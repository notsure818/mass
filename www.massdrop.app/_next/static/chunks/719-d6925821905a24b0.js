(self.webpackChunk_N_E = self.webpackChunk_N_E || []).push([
    [719], {
        90053: function(e, t, r) {
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: !0
            }), t.CosmWasmClient = void 0;
            let n = r(81299),
                o = r(82071),
                i = r(24658),
                a = r(63584),
                s = r(8261),
                d = r(77932),
                c = r(29229),
                l = r(94740);
            class u {
                static async connect(e) {
                    let t = await (0, a.connectComet)(e);
                    return u.create(t)
                }
                static async create(e) {
                    return new u(e)
                }
                constructor(e) {
                    this.codesCache = new Map, e && (this.cometClient = e, this.queryClient = i.QueryClient.withExtensions(e, i.setupAuthExtension, i.setupBankExtension, l.setupWasmExtension, i.setupTxExtension))
                }
                getCometClient() {
                    return this.cometClient
                }
                forceGetCometClient() {
                    if (!this.cometClient) throw Error("Comet client not available. You cannot use online functionality in offline mode.");
                    return this.cometClient
                }
                getQueryClient() {
                    return this.queryClient
                }
                forceGetQueryClient() {
                    if (!this.queryClient) throw Error("Query client not available. You cannot use online functionality in offline mode.");
                    return this.queryClient
                }
                async getChainId() {
                    if (!this.chainId) {
                        let e = (await this.forceGetCometClient().status()).nodeInfo.network;
                        if (!e) throw Error("Chain ID must not be empty");
                        this.chainId = e
                    }
                    return this.chainId
                }
                async getHeight() {
                    return (await this.forceGetCometClient().status()).syncInfo.latestBlockHeight
                }
                async getAccount(e) {
                    try {
                        let t = await this.forceGetQueryClient().auth.account(e);
                        return t ? (0, i.accountFromAny)(t) : null
                    } catch (e) {
                        if (/rpc error: code = NotFound/i.test(e.toString())) return null;
                        throw e
                    }
                }
                async getSequence(e) {
                    let t = await this.getAccount(e);
                    if (!t) throw Error(`Account '${e}' does not exist on chain. Send some tokens there before trying to query sequence.`);
                    return {
                        accountNumber: t.accountNumber,
                        sequence: t.sequence
                    }
                }
                async getBlock(e) {
                    let t = await this.forceGetCometClient().block(e);
                    return {
                        id: (0, n.toHex)(t.blockId.hash).toUpperCase(),
                        header: {
                            version: {
                                block: new o.Uint53(t.block.header.version.block).toString(),
                                app: new o.Uint53(t.block.header.version.app).toString()
                            },
                            height: t.block.header.height,
                            chainId: t.block.header.chainId,
                            time: (0, a.toRfc3339WithNanoseconds)(t.block.header.time)
                        },
                        txs: t.block.txs
                    }
                }
                async getBalance(e, t) {
                    return this.forceGetQueryClient().bank.balance(e, t)
                }
                async getTx(e) {
                    return (await this.txsQuery(`tx.hash='${e}'`))[0] ? ? null
                }
                async searchTx(e) {
                    let t;
                    if ("string" == typeof e) t = e;
                    else if ((0, i.isSearchTxQueryArray)(e)) t = e.map(e => "string" == typeof e.value ? `${e.key}='${e.value}'` : `${e.key}=${e.value}`).join(" AND ");
                    else throw Error("Got unsupported query type. See CosmJS 0.31 CHANGELOG for API breaking changes here.");
                    return this.txsQuery(t)
                }
                disconnect() {
                    this.cometClient && this.cometClient.disconnect()
                }
                async broadcastTx(e, t = 6e4, r = 3e3) {
                    let n = !1,
                        o = setTimeout(() => {
                            n = !0
                        }, t),
                        a = async e => {
                            if (n) throw new i.TimeoutError(`Transaction with ID ${e} was submitted but was not yet found on the chain. You might want to check later. There was a wait of ${t/1e3} seconds.`, e);
                            await (0, s.sleep)(r);
                            let o = await this.getTx(e);
                            return o ? {
                                code: o.code,
                                height: o.height,
                                txIndex: o.txIndex,
                                rawLog: o.rawLog,
                                transactionHash: e,
                                events: o.events,
                                msgResponses: o.msgResponses,
                                gasUsed: o.gasUsed,
                                gasWanted: o.gasWanted
                            } : a(e)
                        },
                        d = await this.broadcastTxSync(e);
                    return new Promise((e, t) => a(d).then(t => {
                        clearTimeout(o), e(t)
                    }, e => {
                        clearTimeout(o), t(e)
                    }))
                }
                async broadcastTxSync(e) {
                    let t = await this.forceGetCometClient().broadcastTxSync({
                        tx: e
                    });
                    return t.code ? Promise.reject(new i.BroadcastTxError(t.code, t.codespace ? ? "", t.log)) : (0, n.toHex)(t.hash).toUpperCase()
                }
                async getCodes() {
                    let e;
                    let t = [];
                    do {
                        let {
                            codeInfos: r,
                            pagination: n
                        } = await this.forceGetQueryClient().wasm.listCodeInfo(e), o = r || [];
                        t.push(...o), e = n ? .nextKey
                    } while (e ? .length !== 0);
                    return t.map(e => ((0, s.assert)(e.creator && e.codeId && e.dataHash, "entry incomplete"), {
                        id: Number(e.codeId),
                        creator: e.creator,
                        checksum: (0, n.toHex)(e.dataHash)
                    }))
                }
                async getCodeDetails(e) {
                    let t = this.codesCache.get(e);
                    if (t) return t;
                    let {
                        codeInfo: r,
                        data: o
                    } = await this.forceGetQueryClient().wasm.getCode(e);
                    (0, s.assert)(r && r.codeId && r.creator && r.dataHash && o, "codeInfo missing or incomplete");
                    let i = {
                        id: Number(r.codeId),
                        creator: r.creator,
                        checksum: (0, n.toHex)(r.dataHash),
                        data: o
                    };
                    return this.codesCache.set(e, i), i
                }
                async getContracts(e) {
                    let t;
                    let r = [];
                    do {
                        let {
                            contracts: n,
                            pagination: o
                        } = await this.forceGetQueryClient().wasm.listContractsByCodeId(e, t);
                        r.push(...n), t = o ? .nextKey
                    } while (t ? .length !== 0 && void 0 !== t);
                    return r
                }
                async getContractsByCreator(e) {
                    let t;
                    let r = [];
                    do {
                        let {
                            contractAddresses: n,
                            pagination: o
                        } = await this.forceGetQueryClient().wasm.listContractsByCreator(e, t);
                        r.push(...n), t = o ? .nextKey
                    } while (t ? .length !== 0 && void 0 !== t);
                    return r
                }
                async getContract(e) {
                    let {
                        address: t,
                        contractInfo: r
                    } = await this.forceGetQueryClient().wasm.getContractInfo(e);
                    if (!r) throw Error(`No contract found at address "${e}"`);
                    return (0, s.assert)(t, "address missing"), (0, s.assert)(r.codeId && r.creator && r.label, "contractInfo incomplete"), {
                        address: t,
                        codeId: Number(r.codeId),
                        creator: r.creator,
                        admin: r.admin || void 0,
                        label: r.label,
                        ibcPortId: r.ibcPortId || void 0
                    }
                }
                async getContractCodeHistory(e) {
                    let t = await this.forceGetQueryClient().wasm.getContractCodeHistory(e);
                    if (!t) throw Error(`No contract history found for address "${e}"`);
                    let r = {
                        [c.ContractCodeHistoryOperationType.CONTRACT_CODE_HISTORY_OPERATION_TYPE_INIT]: "Init",
                        [c.ContractCodeHistoryOperationType.CONTRACT_CODE_HISTORY_OPERATION_TYPE_GENESIS]: "Genesis",
                        [c.ContractCodeHistoryOperationType.CONTRACT_CODE_HISTORY_OPERATION_TYPE_MIGRATE]: "Migrate"
                    };
                    return (t.entries || []).map(e => ((0, s.assert)(e.operation && e.codeId && e.msg), {
                        operation: r[e.operation],
                        codeId: Number(e.codeId),
                        msg: JSON.parse((0, n.fromUtf8)(e.msg))
                    }))
                }
                async queryContractRaw(e, t) {
                    await this.getContract(e);
                    let {
                        data: r
                    } = await this.forceGetQueryClient().wasm.queryContractRaw(e, t);
                    return r ? ? null
                }
                async queryContractSmart(e, t) {
                    try {
                        return await this.forceGetQueryClient().wasm.queryContractSmart(e, t)
                    } catch (t) {
                        if (t instanceof Error && t.message.startsWith("not found: contract")) throw Error(`No contract found at address "${e}"`);
                        throw t
                    }
                }
                async txsQuery(e) {
                    return (await this.forceGetCometClient().txSearchAll({
                        query: e
                    })).txs.map(e => {
                        let t = d.TxMsgData.decode(e.result.data ? ? new Uint8Array);
                        return {
                            height: e.height,
                            txIndex: e.index,
                            hash: (0, n.toHex)(e.hash).toUpperCase(),
                            code: e.result.code,
                            events: e.result.events.map(i.fromTendermintEvent),
                            rawLog: e.result.log || "",
                            tx: e.tx,
                            msgResponses: t.msgResponses,
                            gasUsed: e.result.gasUsed,
                            gasWanted: e.result.gasWanted
                        }
                    })
                }
            }
            t.CosmWasmClient = u
        },
        42854: function(e, t, r) {
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: !0
            }), t.fromBinary = t.toBinary = void 0;
            let n = r(81299);
            t.toBinary = function(e) {
                return (0, n.toBase64)((0, n.toUtf8)(JSON.stringify(e)))
            }, t.fromBinary = function(e) {
                return JSON.parse((0, n.fromUtf8)((0, n.fromBase64)(e)))
            }
        },
        74926: function(e, t, r) {
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: !0
            }), t.SigningCosmWasmClient = t.wasmTypes = t.setupWasmExtension = t.isMsgUpdateAdminEncodeObject = t.isMsgStoreCodeEncodeObject = t.isMsgMigrateEncodeObject = t.isMsgInstantiateContractEncodeObject = t.isMsgInstantiateContract2EncodeObject = t.isMsgExecuteEncodeObject = t.isMsgClearAdminEncodeObject = t.createWasmAminoConverters = t.instantiate2Address = t._instantiate2AddressIntermediate = t.toBinary = t.fromBinary = t.CosmWasmClient = void 0;
            var n = r(90053);
            Object.defineProperty(t, "CosmWasmClient", {
                enumerable: !0,
                get: function() {
                    return n.CosmWasmClient
                }
            });
            var o = r(42854);
            Object.defineProperty(t, "fromBinary", {
                enumerable: !0,
                get: function() {
                    return o.fromBinary
                }
            }), Object.defineProperty(t, "toBinary", {
                enumerable: !0,
                get: function() {
                    return o.toBinary
                }
            });
            var i = r(14497);
            Object.defineProperty(t, "_instantiate2AddressIntermediate", {
                enumerable: !0,
                get: function() {
                    return i._instantiate2AddressIntermediate
                }
            }), Object.defineProperty(t, "instantiate2Address", {
                enumerable: !0,
                get: function() {
                    return i.instantiate2Address
                }
            });
            var a = r(94740);
            Object.defineProperty(t, "createWasmAminoConverters", {
                enumerable: !0,
                get: function() {
                    return a.createWasmAminoConverters
                }
            }), Object.defineProperty(t, "isMsgClearAdminEncodeObject", {
                enumerable: !0,
                get: function() {
                    return a.isMsgClearAdminEncodeObject
                }
            }), Object.defineProperty(t, "isMsgExecuteEncodeObject", {
                enumerable: !0,
                get: function() {
                    return a.isMsgExecuteEncodeObject
                }
            }), Object.defineProperty(t, "isMsgInstantiateContract2EncodeObject", {
                enumerable: !0,
                get: function() {
                    return a.isMsgInstantiateContract2EncodeObject
                }
            }), Object.defineProperty(t, "isMsgInstantiateContractEncodeObject", {
                enumerable: !0,
                get: function() {
                    return a.isMsgInstantiateContractEncodeObject
                }
            }), Object.defineProperty(t, "isMsgMigrateEncodeObject", {
                enumerable: !0,
                get: function() {
                    return a.isMsgMigrateEncodeObject
                }
            }), Object.defineProperty(t, "isMsgStoreCodeEncodeObject", {
                enumerable: !0,
                get: function() {
                    return a.isMsgStoreCodeEncodeObject
                }
            }), Object.defineProperty(t, "isMsgUpdateAdminEncodeObject", {
                enumerable: !0,
                get: function() {
                    return a.isMsgUpdateAdminEncodeObject
                }
            }), Object.defineProperty(t, "setupWasmExtension", {
                enumerable: !0,
                get: function() {
                    return a.setupWasmExtension
                }
            }), Object.defineProperty(t, "wasmTypes", {
                enumerable: !0,
                get: function() {
                    return a.wasmTypes
                }
            });
            var s = r(32994);
            Object.defineProperty(t, "SigningCosmWasmClient", {
                enumerable: !0,
                get: function() {
                    return s.SigningCosmWasmClient
                }
            })
        },
        14497: function(e, t, r) {
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: !0
            }), t.instantiate2Address = t._instantiate2AddressIntermediate = void 0;
            let n = r(46495),
                o = r(81299),
                i = r(82071),
                a = r(8261);

            function s(e) {
                return i.Uint64.fromNumber(e).toBytesBigEndian()
            }

            function d(e, t, r, i, d) {
                (0, a.assert)(32 === e.length);
                let c = (0, o.fromBech32)(t).data,
                    l = "string" == typeof i ? (0, o.toUtf8)(i) : new Uint8Array;
                if (r.length < 1 || r.length > 64) throw Error("Salt must be between 1 and 64 bytes");
                let u = new Uint8Array([...(0, o.toAscii)("wasm"), 0, ...s(e.length), ...e, ...s(c.length), ...c, ...s(r.length), ...r, ...s(l.length), ...l]),
                    p = new n.Sha256((0, n.sha256)((0, o.toAscii)("module"))).update(u).digest(),
                    m = (0, o.toBech32)(d, p);
                return {
                    key: u,
                    addressData: p,
                    address: m
                }
            }
            t._instantiate2AddressIntermediate = d, t.instantiate2Address = function(e, t, r, n) {
                return d(e, t, r, null, n).address
            }
        },
        94740: function(e, t, r) {
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: !0
            }), t.setupWasmExtension = t.wasmTypes = t.isMsgUpdateAdminEncodeObject = t.isMsgStoreCodeEncodeObject = t.isMsgMigrateEncodeObject = t.isMsgInstantiateContractEncodeObject = t.isMsgInstantiateContract2EncodeObject = t.isMsgExecuteEncodeObject = t.isMsgClearAdminEncodeObject = t.createWasmAminoConverters = void 0;
            var n = r(4596);
            Object.defineProperty(t, "createWasmAminoConverters", {
                enumerable: !0,
                get: function() {
                    return n.createWasmAminoConverters
                }
            });
            var o = r(69240);
            Object.defineProperty(t, "isMsgClearAdminEncodeObject", {
                enumerable: !0,
                get: function() {
                    return o.isMsgClearAdminEncodeObject
                }
            }), Object.defineProperty(t, "isMsgExecuteEncodeObject", {
                enumerable: !0,
                get: function() {
                    return o.isMsgExecuteEncodeObject
                }
            }), Object.defineProperty(t, "isMsgInstantiateContract2EncodeObject", {
                enumerable: !0,
                get: function() {
                    return o.isMsgInstantiateContract2EncodeObject
                }
            }), Object.defineProperty(t, "isMsgInstantiateContractEncodeObject", {
                enumerable: !0,
                get: function() {
                    return o.isMsgInstantiateContractEncodeObject
                }
            }), Object.defineProperty(t, "isMsgMigrateEncodeObject", {
                enumerable: !0,
                get: function() {
                    return o.isMsgMigrateEncodeObject
                }
            }), Object.defineProperty(t, "isMsgStoreCodeEncodeObject", {
                enumerable: !0,
                get: function() {
                    return o.isMsgStoreCodeEncodeObject
                }
            }), Object.defineProperty(t, "isMsgUpdateAdminEncodeObject", {
                enumerable: !0,
                get: function() {
                    return o.isMsgUpdateAdminEncodeObject
                }
            }), Object.defineProperty(t, "wasmTypes", {
                enumerable: !0,
                get: function() {
                    return o.wasmTypes
                }
            });
            var i = r(77059);
            Object.defineProperty(t, "setupWasmExtension", {
                enumerable: !0,
                get: function() {
                    return i.setupWasmExtension
                }
            })
        },
        4596: function(e, t, r) {
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: !0
            }), t.createWasmAminoConverters = t.accessTypeToString = t.accessTypeFromString = void 0;
            let n = r(69693),
                o = r(81299),
                i = r(29229);

            function a(e) {
                switch (e) {
                    case "Unspecified":
                        return i.AccessType.ACCESS_TYPE_UNSPECIFIED;
                    case "Nobody":
                        return i.AccessType.ACCESS_TYPE_NOBODY;
                    case "OnlyAddress":
                        return i.AccessType.ACCESS_TYPE_ONLY_ADDRESS;
                    case "Everybody":
                        return i.AccessType.ACCESS_TYPE_EVERYBODY;
                    case "AnyOfAddresses":
                        return i.AccessType.ACCESS_TYPE_ANY_OF_ADDRESSES;
                    default:
                        return i.AccessType.UNRECOGNIZED
                }
            }

            function s(e) {
                switch (e) {
                    case i.AccessType.ACCESS_TYPE_UNSPECIFIED:
                        return "Unspecified";
                    case i.AccessType.ACCESS_TYPE_NOBODY:
                        return "Nobody";
                    case i.AccessType.ACCESS_TYPE_ONLY_ADDRESS:
                        return "OnlyAddress";
                    case i.AccessType.ACCESS_TYPE_EVERYBODY:
                        return "Everybody";
                    case i.AccessType.ACCESS_TYPE_ANY_OF_ADDRESSES:
                        return "AnyOfAddresses";
                    case i.AccessType.UNRECOGNIZED:
                    default:
                        return "UNRECOGNIZED"
                }
            }
            t.accessTypeFromString = a, t.accessTypeToString = s, t.createWasmAminoConverters = function() {
                return {
                    "/cosmwasm.wasm.v1.MsgStoreCode": {
                        aminoType: "wasm/MsgStoreCode",
                        toAmino: ({
                            sender: e,
                            wasmByteCode: t,
                            instantiatePermission: r
                        }) => ({
                            sender: e,
                            wasm_byte_code: (0, o.toBase64)(t),
                            instantiate_permission: r ? {
                                permission: s(r.permission),
                                address: r.address || void 0,
                                addresses: 0 !== r.addresses.length ? r.addresses : void 0
                            } : void 0
                        }),
                        fromAmino: ({
                            sender: e,
                            wasm_byte_code: t,
                            instantiate_permission: r
                        }) => ({
                            sender: e,
                            wasmByteCode: (0, o.fromBase64)(t),
                            instantiatePermission: r ? i.AccessConfig.fromPartial({
                                permission: a(r.permission),
                                address: r.address ? ? "",
                                addresses: r.addresses ? ? []
                            }) : void 0
                        })
                    },
                    "/cosmwasm.wasm.v1.MsgInstantiateContract": {
                        aminoType: "wasm/MsgInstantiateContract",
                        toAmino: ({
                            sender: e,
                            codeId: t,
                            label: r,
                            msg: i,
                            funds: a,
                            admin: s
                        }) => ({
                            sender: e,
                            code_id: t.toString(),
                            label: r,
                            msg: JSON.parse((0, o.fromUtf8)(i)),
                            funds: a,
                            admin: (0, n.omitDefault)(s)
                        }),
                        fromAmino: ({
                            sender: e,
                            code_id: t,
                            label: r,
                            msg: n,
                            funds: i,
                            admin: a
                        }) => ({
                            sender: e,
                            codeId: BigInt(t),
                            label: r,
                            msg: (0, o.toUtf8)(JSON.stringify(n)),
                            funds: [...i],
                            admin: a ? ? ""
                        })
                    },
                    "/cosmwasm.wasm.v1.MsgInstantiateContract2": {
                        aminoType: "wasm/MsgInstantiateContract2",
                        toAmino: ({
                            sender: e,
                            codeId: t,
                            label: r,
                            msg: i,
                            funds: a,
                            admin: s,
                            salt: d,
                            fixMsg: c
                        }) => ({
                            sender: e,
                            code_id: t.toString(),
                            label: r,
                            msg: JSON.parse((0, o.fromUtf8)(i)),
                            funds: a,
                            admin: (0, n.omitDefault)(s),
                            salt: (0, o.toBase64)(d),
                            fix_msg: (0, n.omitDefault)(c)
                        }),
                        fromAmino: ({
                            sender: e,
                            code_id: t,
                            label: r,
                            msg: n,
                            funds: i,
                            admin: a,
                            salt: s,
                            fix_msg: d
                        }) => ({
                            sender: e,
                            codeId: BigInt(t),
                            label: r,
                            msg: (0, o.toUtf8)(JSON.stringify(n)),
                            funds: [...i],
                            admin: a ? ? "",
                            salt: (0, o.fromBase64)(s),
                            fixMsg: d ? ? !1
                        })
                    },
                    "/cosmwasm.wasm.v1.MsgUpdateAdmin": {
                        aminoType: "wasm/MsgUpdateAdmin",
                        toAmino: ({
                            sender: e,
                            newAdmin: t,
                            contract: r
                        }) => ({
                            sender: e,
                            new_admin: t,
                            contract: r
                        }),
                        fromAmino: ({
                            sender: e,
                            new_admin: t,
                            contract: r
                        }) => ({
                            sender: e,
                            newAdmin: t,
                            contract: r
                        })
                    },
                    "/cosmwasm.wasm.v1.MsgClearAdmin": {
                        aminoType: "wasm/MsgClearAdmin",
                        toAmino: ({
                            sender: e,
                            contract: t
                        }) => ({
                            sender: e,
                            contract: t
                        }),
                        fromAmino: ({
                            sender: e,
                            contract: t
                        }) => ({
                            sender: e,
                            contract: t
                        })
                    },
                    "/cosmwasm.wasm.v1.MsgExecuteContract": {
                        aminoType: "wasm/MsgExecuteContract",
                        toAmino: ({
                            sender: e,
                            contract: t,
                            msg: r,
                            funds: n
                        }) => ({
                            sender: e,
                            contract: t,
                            msg: JSON.parse((0, o.fromUtf8)(r)),
                            funds: n
                        }),
                        fromAmino: ({
                            sender: e,
                            contract: t,
                            msg: r,
                            funds: n
                        }) => ({
                            sender: e,
                            contract: t,
                            msg: (0, o.toUtf8)(JSON.stringify(r)),
                            funds: [...n]
                        })
                    },
                    "/cosmwasm.wasm.v1.MsgMigrateContract": {
                        aminoType: "wasm/MsgMigrateContract",
                        toAmino: ({
                            sender: e,
                            contract: t,
                            codeId: r,
                            msg: n
                        }) => ({
                            sender: e,
                            contract: t,
                            code_id: r.toString(),
                            msg: JSON.parse((0, o.fromUtf8)(n))
                        }),
                        fromAmino: ({
                            sender: e,
                            contract: t,
                            code_id: r,
                            msg: n
                        }) => ({
                            sender: e,
                            contract: t,
                            codeId: BigInt(r),
                            msg: (0, o.toUtf8)(JSON.stringify(n))
                        })
                    }
                }
            }
        },
        69240: function(e, t, r) {
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: !0
            }), t.isMsgExecuteEncodeObject = t.isMsgMigrateEncodeObject = t.isMsgClearAdminEncodeObject = t.isMsgUpdateAdminEncodeObject = t.isMsgInstantiateContract2EncodeObject = t.isMsgInstantiateContractEncodeObject = t.isMsgStoreCodeEncodeObject = t.wasmTypes = void 0;
            let n = r(91420);
            t.wasmTypes = [
                ["/cosmwasm.wasm.v1.MsgClearAdmin", n.MsgClearAdmin],
                ["/cosmwasm.wasm.v1.MsgExecuteContract", n.MsgExecuteContract],
                ["/cosmwasm.wasm.v1.MsgMigrateContract", n.MsgMigrateContract],
                ["/cosmwasm.wasm.v1.MsgStoreCode", n.MsgStoreCode],
                ["/cosmwasm.wasm.v1.MsgInstantiateContract", n.MsgInstantiateContract],
                ["/cosmwasm.wasm.v1.MsgInstantiateContract2", n.MsgInstantiateContract2],
                ["/cosmwasm.wasm.v1.MsgUpdateAdmin", n.MsgUpdateAdmin]
            ], t.isMsgStoreCodeEncodeObject = function(e) {
                return "/cosmwasm.wasm.v1.MsgStoreCode" === e.typeUrl
            }, t.isMsgInstantiateContractEncodeObject = function(e) {
                return "/cosmwasm.wasm.v1.MsgInstantiateContract" === e.typeUrl
            }, t.isMsgInstantiateContract2EncodeObject = function(e) {
                return "/cosmwasm.wasm.v1.MsgInstantiateContract2" === e.typeUrl
            }, t.isMsgUpdateAdminEncodeObject = function(e) {
                return "/cosmwasm.wasm.v1.MsgUpdateAdmin" === e.typeUrl
            }, t.isMsgClearAdminEncodeObject = function(e) {
                return "/cosmwasm.wasm.v1.MsgClearAdmin" === e.typeUrl
            }, t.isMsgMigrateEncodeObject = function(e) {
                return "/cosmwasm.wasm.v1.MsgMigrateContract" === e.typeUrl
            }, t.isMsgExecuteEncodeObject = function(e) {
                return "/cosmwasm.wasm.v1.MsgExecuteContract" === e.typeUrl
            }
        },
        77059: function(e, t, r) {
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: !0
            }), t.setupWasmExtension = void 0;
            let n = r(81299),
                o = r(24658),
                i = r(8307);
            t.setupWasmExtension = function(e) {
                let t = (0, o.createProtobufRpcClient)(e),
                    r = new i.QueryClientImpl(t);
                return {
                    wasm: {
                        listCodeInfo: async e => {
                            let t = {
                                pagination: (0, o.createPagination)(e)
                            };
                            return r.Codes(t)
                        },
                        getCode: async e => {
                            let t = i.QueryCodeRequest.fromPartial({
                                codeId: BigInt(e)
                            });
                            return r.Code(t)
                        },
                        listContractsByCodeId: async (e, t) => {
                            let n = i.QueryContractsByCodeRequest.fromPartial({
                                codeId: BigInt(e),
                                pagination: (0, o.createPagination)(t)
                            });
                            return r.ContractsByCode(n)
                        },
                        listContractsByCreator: async (e, t) => {
                            let n = {
                                creatorAddress: e,
                                pagination: (0, o.createPagination)(t)
                            };
                            return r.ContractsByCreator(n)
                        },
                        getContractInfo: async e => r.ContractInfo({
                            address: e
                        }),
                        getContractCodeHistory: async (e, t) => {
                            let n = {
                                address: e,
                                pagination: (0, o.createPagination)(t)
                            };
                            return r.ContractHistory(n)
                        },
                        getAllContractState: async (e, t) => {
                            let n = {
                                address: e,
                                pagination: (0, o.createPagination)(t)
                            };
                            return r.AllContractState(n)
                        },
                        queryContractRaw: async (e, t) => r.RawContractState({
                            address: e,
                            queryData: t
                        }),
                        queryContractSmart: async (e, t) => {
                            let o;
                            let i = {
                                    address: e,
                                    queryData: (0, n.toUtf8)(JSON.stringify(t))
                                },
                                {
                                    data: a
                                } = await r.SmartContractState(i);
                            try {
                                o = (0, n.fromUtf8)(a)
                            } catch (e) {
                                throw Error(`Could not UTF-8 decode smart query response from contract: ${e}`)
                            }
                            try {
                                return JSON.parse(o)
                            } catch (e) {
                                throw Error(`Could not JSON parse smart query response from contract: ${e}`)
                            }
                        }
                    }
                }
            }
        },
        32994: function(e, t, r) {
            "use strict";
            var n = this && this.__importDefault || function(e) {
                return e && e.__esModule ? e : {
                    default: e
                }
            };
            Object.defineProperty(t, "__esModule", {
                value: !0
            }), t.SigningCosmWasmClient = void 0;
            let o = r(69693),
                i = r(46495),
                a = r(81299),
                s = r(82071),
                d = r(44440),
                c = r(24658),
                l = r(63584),
                u = r(8261),
                p = r(13314),
                m = r(31528),
                g = r(63702),
                f = r(9858),
                y = r(91420),
                h = n(r(99591)),
                v = r(90053),
                b = r(94740);

            function S(e) {
                return `Error when broadcasting tx ${e.transactionHash} at height ${e.height}. Code: ${e.code}; Raw log: ${e.rawLog}`
            }
            class k extends v.CosmWasmClient {
                static async connectWithSigner(e, t, r = {}) {
                    let n = await (0, l.connectComet)(e);
                    return k.createWithSigner(n, t, r)
                }
                static async createWithSigner(e, t, r = {}) {
                    return new k(e, t, r)
                }
                static async offline(e, t = {}) {
                    return new k(void 0, e, t)
                }
                constructor(e, t, r) {
                    super(e);
                    let {
                        registry: n = new d.Registry([...c.defaultRegistryTypes, ...b.wasmTypes]),
                        aminoTypes: o = new c.AminoTypes({ ...(0, c.createDefaultAminoConverters)(),
                            ...(0, b.createWasmAminoConverters)()
                        })
                    } = r;
                    this.registry = n, this.aminoTypes = o, this.signer = t, this.broadcastTimeoutMs = r.broadcastTimeoutMs, this.broadcastPollIntervalMs = r.broadcastPollIntervalMs, this.gasPrice = r.gasPrice
                }
                async simulate(e, t, r) {
                    let n = t.map(e => this.registry.encodeAsAny(e)),
                        i = (await this.signer.getAccounts()).find(t => t.address === e);
                    if (!i) throw Error("Failed to retrieve account from signer");
                    let a = (0, o.encodeSecp256k1Pubkey)(i.pubkey),
                        {
                            sequence: d
                        } = await this.getSequence(e),
                        {
                            gasInfo: c
                        } = await this.forceGetQueryClient().tx.simulate(n, r, a, d);
                    return (0, u.assertDefined)(c), s.Uint53.fromString(c.gasUsed.toString()).toNumber()
                }
                async upload(e, t, r, n = "", o) {
                    let s = h.default.gzip(t, {
                            level: 9
                        }),
                        d = {
                            typeUrl: "/cosmwasm.wasm.v1.MsgStoreCode",
                            value: y.MsgStoreCode.fromPartial({
                                sender: e,
                                wasmByteCode: s,
                                instantiatePermission: o
                            })
                        },
                        l = await this.signAndBroadcast(e, [d], "auto" == r ? 1.1 : r, n);
                    if ((0, c.isDeliverTxFailure)(l)) throw Error(S(l));
                    let u = c.logs.parseRawLog(l.rawLog),
                        p = c.logs.findAttribute(u, "store_code", "code_id");
                    return {
                        checksum: (0, a.toHex)((0, i.sha256)(t)),
                        originalSize: t.length,
                        compressedSize: s.length,
                        codeId: Number.parseInt(p.value, 10),
                        logs: u,
                        height: l.height,
                        transactionHash: l.transactionHash,
                        events: l.events,
                        gasWanted: l.gasWanted,
                        gasUsed: l.gasUsed
                    }
                }
                async instantiate(e, t, r, n, o, i = {}) {
                    let d = {
                            typeUrl: "/cosmwasm.wasm.v1.MsgInstantiateContract",
                            value: y.MsgInstantiateContract.fromPartial({
                                sender: e,
                                codeId: BigInt(new s.Uint53(t).toString()),
                                label: n,
                                msg: (0, a.toUtf8)(JSON.stringify(r)),
                                funds: [...i.funds || []],
                                admin: i.admin
                            })
                        },
                        l = await this.signAndBroadcast(e, [d], o, i.memo);
                    if ((0, c.isDeliverTxFailure)(l)) throw Error(S(l));
                    let u = c.logs.parseRawLog(l.rawLog);
                    return {
                        contractAddress: c.logs.findAttribute(u, "instantiate", "_contract_address").value,
                        logs: u,
                        height: l.height,
                        transactionHash: l.transactionHash,
                        events: l.events,
                        gasWanted: l.gasWanted,
                        gasUsed: l.gasUsed
                    }
                }
                async instantiate2(e, t, r, n, o, i, d = {}) {
                    let l = {
                            typeUrl: "/cosmwasm.wasm.v1.MsgInstantiateContract2",
                            value: y.MsgInstantiateContract2.fromPartial({
                                sender: e,
                                codeId: BigInt(new s.Uint53(t).toString()),
                                label: o,
                                msg: (0, a.toUtf8)(JSON.stringify(n)),
                                funds: [...d.funds || []],
                                admin: d.admin,
                                salt: r,
                                fixMsg: !1
                            })
                        },
                        u = await this.signAndBroadcast(e, [l], i, d.memo);
                    if ((0, c.isDeliverTxFailure)(u)) throw Error(S(u));
                    let p = c.logs.parseRawLog(u.rawLog);
                    return {
                        contractAddress: c.logs.findAttribute(p, "instantiate", "_contract_address").value,
                        logs: p,
                        height: u.height,
                        transactionHash: u.transactionHash,
                        events: u.events,
                        gasWanted: u.gasWanted,
                        gasUsed: u.gasUsed
                    }
                }
                async updateAdmin(e, t, r, n, o = "") {
                    let i = {
                            typeUrl: "/cosmwasm.wasm.v1.MsgUpdateAdmin",
                            value: y.MsgUpdateAdmin.fromPartial({
                                sender: e,
                                contract: t,
                                newAdmin: r
                            })
                        },
                        a = await this.signAndBroadcast(e, [i], n, o);
                    if ((0, c.isDeliverTxFailure)(a)) throw Error(S(a));
                    return {
                        logs: c.logs.parseRawLog(a.rawLog),
                        height: a.height,
                        transactionHash: a.transactionHash,
                        events: a.events,
                        gasWanted: a.gasWanted,
                        gasUsed: a.gasUsed
                    }
                }
                async clearAdmin(e, t, r, n = "") {
                    let o = {
                            typeUrl: "/cosmwasm.wasm.v1.MsgClearAdmin",
                            value: y.MsgClearAdmin.fromPartial({
                                sender: e,
                                contract: t
                            })
                        },
                        i = await this.signAndBroadcast(e, [o], r, n);
                    if ((0, c.isDeliverTxFailure)(i)) throw Error(S(i));
                    return {
                        logs: c.logs.parseRawLog(i.rawLog),
                        height: i.height,
                        transactionHash: i.transactionHash,
                        events: i.events,
                        gasWanted: i.gasWanted,
                        gasUsed: i.gasUsed
                    }
                }
                async migrate(e, t, r, n, o, i = "") {
                    let d = {
                            typeUrl: "/cosmwasm.wasm.v1.MsgMigrateContract",
                            value: y.MsgMigrateContract.fromPartial({
                                sender: e,
                                contract: t,
                                codeId: BigInt(new s.Uint53(r).toString()),
                                msg: (0, a.toUtf8)(JSON.stringify(n))
                            })
                        },
                        l = await this.signAndBroadcast(e, [d], o, i);
                    if ((0, c.isDeliverTxFailure)(l)) throw Error(S(l));
                    return {
                        logs: c.logs.parseRawLog(l.rawLog),
                        height: l.height,
                        transactionHash: l.transactionHash,
                        events: l.events,
                        gasWanted: l.gasWanted,
                        gasUsed: l.gasUsed
                    }
                }
                async execute(e, t, r, n, o = "", i) {
                    return this.executeMultiple(e, [{
                        contractAddress: t,
                        msg: r,
                        funds: i
                    }], n, o)
                }
                async executeMultiple(e, t, r, n = "") {
                    let o = t.map(t => ({
                            typeUrl: "/cosmwasm.wasm.v1.MsgExecuteContract",
                            value: y.MsgExecuteContract.fromPartial({
                                sender: e,
                                contract: t.contractAddress,
                                msg: (0, a.toUtf8)(JSON.stringify(t.msg)),
                                funds: [...t.funds || []]
                            })
                        })),
                        i = await this.signAndBroadcast(e, o, r, n);
                    if ((0, c.isDeliverTxFailure)(i)) throw Error(S(i));
                    return {
                        logs: c.logs.parseRawLog(i.rawLog),
                        height: i.height,
                        transactionHash: i.transactionHash,
                        events: i.events,
                        gasWanted: i.gasWanted,
                        gasUsed: i.gasUsed
                    }
                }
                async sendTokens(e, t, r, n, o = "") {
                    let i = {
                        typeUrl: "/cosmos.bank.v1beta1.MsgSend",
                        value: {
                            fromAddress: e,
                            toAddress: t,
                            amount: [...r]
                        }
                    };
                    return this.signAndBroadcast(e, [i], n, o)
                }
                async delegateTokens(e, t, r, n, o = "") {
                    let i = {
                        typeUrl: "/cosmos.staking.v1beta1.MsgDelegate",
                        value: m.MsgDelegate.fromPartial({
                            delegatorAddress: e,
                            validatorAddress: t,
                            amount: r
                        })
                    };
                    return this.signAndBroadcast(e, [i], n, o)
                }
                async undelegateTokens(e, t, r, n, o = "") {
                    let i = {
                        typeUrl: "/cosmos.staking.v1beta1.MsgUndelegate",
                        value: m.MsgUndelegate.fromPartial({
                            delegatorAddress: e,
                            validatorAddress: t,
                            amount: r
                        })
                    };
                    return this.signAndBroadcast(e, [i], n, o)
                }
                async withdrawRewards(e, t, r, n = "") {
                    let o = {
                        typeUrl: "/cosmos.distribution.v1beta1.MsgWithdrawDelegatorReward",
                        value: p.MsgWithdrawDelegatorReward.fromPartial({
                            delegatorAddress: e,
                            validatorAddress: t
                        })
                    };
                    return this.signAndBroadcast(e, [o], r, n)
                }
                async signAndBroadcast(e, t, r, n = "", o) {
                    let i;
                    if ("auto" == r || "number" == typeof r) {
                        (0, u.assertDefined)(this.gasPrice, "Gas price must be set in the client options when auto gas is used.");
                        let o = await this.simulate(e, t, n),
                            a = "number" == typeof r ? r : 1.4;
                        i = (0, c.calculateFee)(Math.round(o * a), this.gasPrice)
                    } else i = r;
                    let a = await this.sign(e, t, i, n, void 0, o),
                        s = f.TxRaw.encode(a).finish();
                    return this.broadcastTx(s, this.broadcastTimeoutMs, this.broadcastPollIntervalMs)
                }
                async signAndBroadcastSync(e, t, r, n = "", o) {
                    let i;
                    if ("auto" == r || "number" == typeof r) {
                        (0, u.assertDefined)(this.gasPrice, "Gas price must be set in the client options when auto gas is used.");
                        let o = await this.simulate(e, t, n),
                            a = "number" == typeof r ? r : 1.3;
                        i = (0, c.calculateFee)(Math.round(o * a), this.gasPrice)
                    } else i = r;
                    let a = await this.sign(e, t, i, n, void 0, o),
                        s = f.TxRaw.encode(a).finish();
                    return this.broadcastTxSync(s)
                }
                async sign(e, t, r, n, o, i) {
                    let a;
                    if (o) a = o;
                    else {
                        let {
                            accountNumber: t,
                            sequence: r
                        } = await this.getSequence(e);
                        a = {
                            accountNumber: t,
                            sequence: r,
                            chainId: await this.getChainId()
                        }
                    }
                    return (0, d.isOfflineDirectSigner)(this.signer) ? this.signDirect(e, t, r, n, a, i) : this.signAmino(e, t, r, n, a, i)
                }
                async signAmino(e, t, r, n, {
                    accountNumber: i,
                    sequence: c,
                    chainId: l
                }, p) {
                    (0, u.assert)(!(0, d.isOfflineDirectSigner)(this.signer));
                    let m = (await this.signer.getAccounts()).find(t => t.address === e);
                    if (!m) throw Error("Failed to retrieve account from signer");
                    let y = (0, d.encodePubkey)((0, o.encodeSecp256k1Pubkey)(m.pubkey)),
                        h = g.SignMode.SIGN_MODE_LEGACY_AMINO_JSON,
                        v = t.map(e => this.aminoTypes.toAmino(e)),
                        b = (0, o.makeSignDoc)(v, r, l, n, i, c, p),
                        {
                            signature: S,
                            signed: k
                        } = await this.signer.signAmino(e, b),
                        P = {
                            typeUrl: "/cosmos.tx.v1beta1.TxBody",
                            value: {
                                messages: k.msgs.map(e => this.aminoTypes.fromAmino(e)),
                                memo: k.memo,
                                timeoutHeight: p
                            }
                        },
                        _ = this.registry.encode(P),
                        B = s.Int53.fromString(k.fee.gas).toNumber(),
                        O = s.Int53.fromString(k.sequence).toNumber(),
                        R = (0, d.makeAuthInfoBytes)([{
                            pubkey: y,
                            sequence: O
                        }], k.fee.amount, B, k.fee.granter, k.fee.payer, h);
                    return f.TxRaw.fromPartial({
                        bodyBytes: _,
                        authInfoBytes: R,
                        signatures: [(0, a.fromBase64)(S.signature)]
                    })
                }
                async signDirect(e, t, r, n, {
                    accountNumber: i,
                    sequence: c,
                    chainId: l
                }, p) {
                    (0, u.assert)((0, d.isOfflineDirectSigner)(this.signer));
                    let m = (await this.signer.getAccounts()).find(t => t.address === e);
                    if (!m) throw Error("Failed to retrieve account from signer");
                    let g = (0, d.encodePubkey)((0, o.encodeSecp256k1Pubkey)(m.pubkey)),
                        y = this.registry.encode({
                            typeUrl: "/cosmos.tx.v1beta1.TxBody",
                            value: {
                                messages: t,
                                memo: n,
                                timeoutHeight: p
                            }
                        }),
                        h = s.Int53.fromString(r.gas).toNumber(),
                        v = (0, d.makeAuthInfoBytes)([{
                            pubkey: g,
                            sequence: c
                        }], r.amount, h, r.granter, r.payer),
                        b = (0, d.makeSignDoc)(y, v, l, i),
                        {
                            signature: S,
                            signed: k
                        } = await this.signer.signDirect(e, b);
                    return f.TxRaw.fromPartial({
                        bodyBytes: k.bodyBytes,
                        authInfoBytes: k.authInfoBytes,
                        signatures: [(0, a.fromBase64)(S.signature)]
                    })
                }
            }
            t.SigningCosmWasmClient = k
        },
        83874: function(e, t, r) {
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: !0
            }), t.pubkeyToAddress = t.pubkeyToRawAddress = t.rawSecp256k1PubkeyToRawAddress = t.rawEd25519PubkeyToRawAddress = void 0;
            let n = r(46495),
                o = r(81299),
                i = r(12810),
                a = r(26320);

            function s(e) {
                if (32 !== e.length) throw Error(`Invalid Ed25519 pubkey length: ${e.length}`);
                return (0, n.sha256)(e).slice(0, 20)
            }

            function d(e) {
                if (33 !== e.length) throw Error(`Invalid Secp256k1 pubkey length (compressed): ${e.length}`);
                return (0, n.ripemd160)((0, n.sha256)(e))
            }

            function c(e) {
                if ((0, a.isSecp256k1Pubkey)(e)) return d((0, o.fromBase64)(e.value));
                if ((0, a.isEd25519Pubkey)(e)) return s((0, o.fromBase64)(e.value));
                if ((0, a.isMultisigThresholdPubkey)(e)) {
                    let t = (0, i.encodeAminoPubkey)(e);
                    return (0, n.sha256)(t).slice(0, 20)
                }
                throw Error("Unsupported public key type")
            }
            t.rawEd25519PubkeyToRawAddress = s, t.rawSecp256k1PubkeyToRawAddress = d, t.pubkeyToRawAddress = c, t.pubkeyToAddress = function(e, t) {
                return (0, o.toBech32)(t, c(e))
            }
        },
        52989: function(e, t, r) {
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: !0
            }), t.addCoins = t.parseCoins = t.coins = t.coin = void 0;
            let n = r(82071);

            function o(e, t) {
                let r;
                if ("number" == typeof e) try {
                    r = new n.Uint53(e).toString()
                } catch (e) {
                    throw Error("Given amount is not a safe integer. Consider using a string instead to overcome the limitations of JS numbers.")
                } else {
                    if (!e.match(/^[0-9]+$/)) throw Error("Invalid unsigned integer string format");
                    r = e.replace(/^0*/, "") || "0"
                }
                return {
                    amount: r,
                    denom: t
                }
            }
            t.coin = o, t.coins = function(e, t) {
                return [o(e, t)]
            }, t.parseCoins = function(e) {
                return e.replace(/\s/g, "").split(",").filter(Boolean).map(e => {
                    let t = e.match(/^([0-9]+)([a-zA-Z]+)/);
                    if (!t) throw Error("Got an invalid coin string");
                    return {
                        amount: t[1].replace(/^0+/, "") || "0",
                        denom: t[2]
                    }
                })
            }, t.addCoins = function(e, t) {
                if (e.denom !== t.denom) throw Error("Trying to add two coins with different denoms");
                return {
                    amount: n.Decimal.fromAtomics(e.amount, 0).plus(n.Decimal.fromAtomics(t.amount, 0)).atomics,
                    denom: e.denom
                }
            }
        },
        12810: function(e, t, r) {
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: !0
            }), t.encodeBech32Pubkey = t.encodeAminoPubkey = t.decodeBech32Pubkey = t.decodeAminoPubkey = t.encodeEd25519Pubkey = t.encodeSecp256k1Pubkey = void 0;
            let n = r(81299),
                o = r(82071),
                i = r(8261),
                a = r(26320);
            t.encodeSecp256k1Pubkey = function(e) {
                if (33 !== e.length || 2 !== e[0] && 3 !== e[0]) throw Error("Public key must be compressed secp256k1, i.e. 33 bytes starting with 0x02 or 0x03");
                return {
                    type: a.pubkeyType.secp256k1,
                    value: (0, n.toBase64)(e)
                }
            }, t.encodeEd25519Pubkey = function(e) {
                if (32 !== e.length) throw Error("Ed25519 public key must be 32 bytes long");
                return {
                    type: a.pubkeyType.ed25519,
                    value: (0, n.toBase64)(e)
                }
            };
            let s = (0, n.fromHex)("eb5ae98721"),
                d = (0, n.fromHex)("1624de6420"),
                c = (0, n.fromHex)("0dfb100520"),
                l = (0, n.fromHex)("22c1f7e2");

            function u(e) {
                if ((0, i.arrayContentStartsWith)(e, s)) {
                    let t = e.slice(s.length);
                    if (33 !== t.length) throw Error("Invalid rest data length. Expected 33 bytes (compressed secp256k1 pubkey).");
                    return {
                        type: a.pubkeyType.secp256k1,
                        value: (0, n.toBase64)(t)
                    }
                }
                if ((0, i.arrayContentStartsWith)(e, d)) {
                    let t = e.slice(d.length);
                    if (32 !== t.length) throw Error("Invalid rest data length. Expected 32 bytes (Ed25519 pubkey).");
                    return {
                        type: a.pubkeyType.ed25519,
                        value: (0, n.toBase64)(t)
                    }
                }
                if ((0, i.arrayContentStartsWith)(e, c)) {
                    let t = e.slice(c.length);
                    if (32 !== t.length) throw Error("Invalid rest data length. Expected 32 bytes (Sr25519 pubkey).");
                    return {
                        type: a.pubkeyType.sr25519,
                        value: (0, n.toBase64)(t)
                    }
                }
                if ((0, i.arrayContentStartsWith)(e, l)) return function(e) {
                    let t = Array.from(e),
                        r = t.splice(0, l.length);
                    if (!(0, i.arrayContentStartsWith)(r, l)) throw Error("Invalid multisig prefix.");
                    if (8 != t.shift()) throw Error("Invalid multisig data. Expecting 0x08 prefix before threshold.");
                    let [n, o] = p(t);
                    t.splice(0, o);
                    let s = [];
                    for (; t.length > 0;) {
                        if (18 != t.shift()) throw Error("Invalid multisig data. Expecting 0x12 prefix before participant pubkey length.");
                        let [e, r] = p(t);
                        if (t.splice(0, r), t.length < e) throw Error("Invalid multisig data length.");
                        let n = t.splice(0, e),
                            o = u(Uint8Array.from(n));
                        s.push(o)
                    }
                    return {
                        type: a.pubkeyType.multisigThreshold,
                        value: {
                            threshold: n.toString(),
                            pubkeys: s
                        }
                    }
                }(e);
                throw Error("Unsupported public key type. Amino data starts with: " + (0, n.toHex)(e.slice(0, 5)))
            }

            function p(e) {
                if (e.length < 1) throw Error("Can't decode varint. EOF");
                if (e[0] > 127) throw Error("Decoding numbers > 127 is not supported here. Please tell those lazy CosmJS maintainers to port the binary.Varint implementation from the Go standard library and write some tests.");
                return [e[0], 1]
            }

            function m(e) {
                let t = o.Uint53.fromString(e.toString()).toNumber();
                if (t > 127) throw Error("Encoding numbers > 127 is not supported here. Please tell those lazy CosmJS maintainers to port the binary.PutUvarint implementation from the Go standard library and write some tests.");
                return [t]
            }

            function g(e) {
                if ((0, a.isMultisigThresholdPubkey)(e)) {
                    let t = Array.from(l);
                    for (let r of (t.push(8), t.push(...m(e.value.threshold)), e.value.pubkeys.map(e => g(e)))) t.push(18), t.push(...m(r.length)), t.push(...r);
                    return new Uint8Array(t)
                }
                if ((0, a.isEd25519Pubkey)(e)) return new Uint8Array([...d, ...(0, n.fromBase64)(e.value)]);
                if ((0, a.isSecp256k1Pubkey)(e)) return new Uint8Array([...s, ...(0, n.fromBase64)(e.value)]);
                throw Error("Unsupported pubkey type")
            }
            t.decodeAminoPubkey = u, t.decodeBech32Pubkey = function(e) {
                let {
                    data: t
                } = (0, n.fromBech32)(e);
                return u(t)
            }, t.encodeAminoPubkey = g, t.encodeBech32Pubkey = function(e, t) {
                return (0, n.toBech32)(t, g(e))
            }
        },
        69693: function(e, t, r) {
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: !0
            }), t.executeKdf = t.makeStdTx = t.isStdTx = t.serializeSignDoc = t.makeSignDoc = t.encodeSecp256k1Signature = t.decodeSignature = t.Secp256k1Wallet = t.Secp256k1HdWallet = t.extractKdfConfiguration = t.pubkeyType = t.isSinglePubkey = t.isSecp256k1Pubkey = t.isMultisigThresholdPubkey = t.isEd25519Pubkey = t.makeCosmoshubPath = t.omitDefault = t.createMultisigThresholdPubkey = t.encodeSecp256k1Pubkey = t.encodeEd25519Pubkey = t.encodeBech32Pubkey = t.encodeAminoPubkey = t.decodeBech32Pubkey = t.decodeAminoPubkey = t.parseCoins = t.coins = t.coin = t.addCoins = t.rawSecp256k1PubkeyToRawAddress = t.rawEd25519PubkeyToRawAddress = t.pubkeyToRawAddress = t.pubkeyToAddress = void 0;
            var n = r(83874);
            Object.defineProperty(t, "pubkeyToAddress", {
                enumerable: !0,
                get: function() {
                    return n.pubkeyToAddress
                }
            }), Object.defineProperty(t, "pubkeyToRawAddress", {
                enumerable: !0,
                get: function() {
                    return n.pubkeyToRawAddress
                }
            }), Object.defineProperty(t, "rawEd25519PubkeyToRawAddress", {
                enumerable: !0,
                get: function() {
                    return n.rawEd25519PubkeyToRawAddress
                }
            }), Object.defineProperty(t, "rawSecp256k1PubkeyToRawAddress", {
                enumerable: !0,
                get: function() {
                    return n.rawSecp256k1PubkeyToRawAddress
                }
            });
            var o = r(52989);
            Object.defineProperty(t, "addCoins", {
                enumerable: !0,
                get: function() {
                    return o.addCoins
                }
            }), Object.defineProperty(t, "coin", {
                enumerable: !0,
                get: function() {
                    return o.coin
                }
            }), Object.defineProperty(t, "coins", {
                enumerable: !0,
                get: function() {
                    return o.coins
                }
            }), Object.defineProperty(t, "parseCoins", {
                enumerable: !0,
                get: function() {
                    return o.parseCoins
                }
            });
            var i = r(12810);
            Object.defineProperty(t, "decodeAminoPubkey", {
                enumerable: !0,
                get: function() {
                    return i.decodeAminoPubkey
                }
            }), Object.defineProperty(t, "decodeBech32Pubkey", {
                enumerable: !0,
                get: function() {
                    return i.decodeBech32Pubkey
                }
            }), Object.defineProperty(t, "encodeAminoPubkey", {
                enumerable: !0,
                get: function() {
                    return i.encodeAminoPubkey
                }
            }), Object.defineProperty(t, "encodeBech32Pubkey", {
                enumerable: !0,
                get: function() {
                    return i.encodeBech32Pubkey
                }
            }), Object.defineProperty(t, "encodeEd25519Pubkey", {
                enumerable: !0,
                get: function() {
                    return i.encodeEd25519Pubkey
                }
            }), Object.defineProperty(t, "encodeSecp256k1Pubkey", {
                enumerable: !0,
                get: function() {
                    return i.encodeSecp256k1Pubkey
                }
            });
            var a = r(24861);
            Object.defineProperty(t, "createMultisigThresholdPubkey", {
                enumerable: !0,
                get: function() {
                    return a.createMultisigThresholdPubkey
                }
            });
            var s = r(93013);
            Object.defineProperty(t, "omitDefault", {
                enumerable: !0,
                get: function() {
                    return s.omitDefault
                }
            });
            var d = r(2237);
            Object.defineProperty(t, "makeCosmoshubPath", {
                enumerable: !0,
                get: function() {
                    return d.makeCosmoshubPath
                }
            });
            var c = r(26320);
            Object.defineProperty(t, "isEd25519Pubkey", {
                enumerable: !0,
                get: function() {
                    return c.isEd25519Pubkey
                }
            }), Object.defineProperty(t, "isMultisigThresholdPubkey", {
                enumerable: !0,
                get: function() {
                    return c.isMultisigThresholdPubkey
                }
            }), Object.defineProperty(t, "isSecp256k1Pubkey", {
                enumerable: !0,
                get: function() {
                    return c.isSecp256k1Pubkey
                }
            }), Object.defineProperty(t, "isSinglePubkey", {
                enumerable: !0,
                get: function() {
                    return c.isSinglePubkey
                }
            }), Object.defineProperty(t, "pubkeyType", {
                enumerable: !0,
                get: function() {
                    return c.pubkeyType
                }
            });
            var l = r(47203);
            Object.defineProperty(t, "extractKdfConfiguration", {
                enumerable: !0,
                get: function() {
                    return l.extractKdfConfiguration
                }
            }), Object.defineProperty(t, "Secp256k1HdWallet", {
                enumerable: !0,
                get: function() {
                    return l.Secp256k1HdWallet
                }
            });
            var u = r(70834);
            Object.defineProperty(t, "Secp256k1Wallet", {
                enumerable: !0,
                get: function() {
                    return u.Secp256k1Wallet
                }
            });
            var p = r(83086);
            Object.defineProperty(t, "decodeSignature", {
                enumerable: !0,
                get: function() {
                    return p.decodeSignature
                }
            }), Object.defineProperty(t, "encodeSecp256k1Signature", {
                enumerable: !0,
                get: function() {
                    return p.encodeSecp256k1Signature
                }
            });
            var m = r(28732);
            Object.defineProperty(t, "makeSignDoc", {
                enumerable: !0,
                get: function() {
                    return m.makeSignDoc
                }
            }), Object.defineProperty(t, "serializeSignDoc", {
                enumerable: !0,
                get: function() {
                    return m.serializeSignDoc
                }
            });
            var g = r(46478);
            Object.defineProperty(t, "isStdTx", {
                enumerable: !0,
                get: function() {
                    return g.isStdTx
                }
            }), Object.defineProperty(t, "makeStdTx", {
                enumerable: !0,
                get: function() {
                    return g.makeStdTx
                }
            });
            var f = r(90187);
            Object.defineProperty(t, "executeKdf", {
                enumerable: !0,
                get: function() {
                    return f.executeKdf
                }
            })
        },
        24861: function(e, t, r) {
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: !0
            }), t.createMultisigThresholdPubkey = t.compareArrays = void 0;
            let n = r(81299),
                o = r(82071),
                i = r(83874);

            function a(e, t) {
                let r = (0, n.toHex)(e),
                    o = (0, n.toHex)(t);
                return r === o ? 0 : r < o ? -1 : 1
            }
            t.compareArrays = a, t.createMultisigThresholdPubkey = function(e, t, r = !1) {
                let n = new o.Uint53(t);
                if (n.toNumber() > e.length) throw Error(`Threshold k = ${n.toNumber()} exceeds number of keys n = ${e.length}`);
                let s = r ? e : Array.from(e).sort((e, t) => a((0, i.pubkeyToRawAddress)(e), (0, i.pubkeyToRawAddress)(t)));
                return {
                    type: "tendermint/PubKeyMultisigThreshold",
                    value: {
                        threshold: n.toString(),
                        pubkeys: s
                    }
                }
            }
        },
        93013: function(e, t) {
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: !0
            }), t.omitDefault = void 0, t.omitDefault = function(e) {
                switch (typeof e) {
                    case "string":
                        return "" === e ? void 0 : e;
                    case "number":
                        return 0 === e ? void 0 : e;
                    case "bigint":
                        return e === BigInt(0) ? void 0 : e;
                    case "boolean":
                        return e || void 0;
                    default:
                        throw Error(`Got unsupported type '${typeof e}'`)
                }
            }
        },
        2237: function(e, t, r) {
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: !0
            }), t.makeCosmoshubPath = void 0;
            let n = r(46495);
            t.makeCosmoshubPath = function(e) {
                return [n.Slip10RawIndex.hardened(44), n.Slip10RawIndex.hardened(118), n.Slip10RawIndex.hardened(0), n.Slip10RawIndex.normal(0), n.Slip10RawIndex.normal(e)]
            }
        },
        26320: function(e, t) {
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: !0
            }), t.isMultisigThresholdPubkey = t.isSinglePubkey = t.pubkeyType = t.isSecp256k1Pubkey = t.isEd25519Pubkey = void 0, t.isEd25519Pubkey = function(e) {
                return "tendermint/PubKeyEd25519" === e.type
            }, t.isSecp256k1Pubkey = function(e) {
                return "tendermint/PubKeySecp256k1" === e.type
            }, t.pubkeyType = {
                secp256k1: "tendermint/PubKeySecp256k1",
                ed25519: "tendermint/PubKeyEd25519",
                sr25519: "tendermint/PubKeySr25519",
                multisigThreshold: "tendermint/PubKeyMultisigThreshold"
            }, t.isSinglePubkey = function(e) {
                return [t.pubkeyType.ed25519, t.pubkeyType.secp256k1, t.pubkeyType.sr25519].includes(e.type)
            }, t.isMultisigThresholdPubkey = function(e) {
                return "tendermint/PubKeyMultisigThreshold" === e.type
            }
        },
        47203: function(e, t, r) {
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: !0
            }), t.Secp256k1HdWallet = t.extractKdfConfiguration = void 0;
            let n = r(46495),
                o = r(81299),
                i = r(8261),
                a = r(83874),
                s = r(2237),
                d = r(83086),
                c = r(28732),
                l = r(90187),
                u = "secp256k1wallet-v1",
                p = {
                    algorithm: "argon2id",
                    params: {
                        outputLength: 32,
                        opsLimit: 24,
                        memLimitKib: 12288
                    }
                };
            t.extractKdfConfiguration = function(e) {
                let t = JSON.parse(e);
                if (!(0, i.isNonNullObject)(t)) throw Error("Root document is not an object.");
                if (t.type === u) return t.kdf;
                throw Error("Unsupported serialization type")
            };
            let m = {
                bip39Password: "",
                hdPaths: [(0, s.makeCosmoshubPath)(0)],
                prefix: "cosmos"
            };
            class g {
                static async fromMnemonic(e, t = {}) {
                    let r = new n.EnglishMnemonic(e),
                        o = await n.Bip39.mnemonicToSeed(r, t.bip39Password);
                    return new g(r, { ...t,
                        seed: o
                    })
                }
                static async generate(e = 12, t = {}) {
                    let r = n.Random.getBytes(4 * Math.floor(11 * e / 33)),
                        o = n.Bip39.encode(r);
                    return g.fromMnemonic(o.toString(), t)
                }
                static async deserialize(e, t) {
                    let r = JSON.parse(e);
                    if (!(0, i.isNonNullObject)(r)) throw Error("Root document is not an object.");
                    if (r.type === u) return g.deserializeTypeV1(e, t);
                    throw Error("Unsupported serialization type")
                }
                static async deserializeWithEncryptionKey(e, t) {
                    let r = JSON.parse(e);
                    if (!(0, i.isNonNullObject)(r)) throw Error("Root document is not an object.");
                    if (r.type === u) {
                        let e = await (0, l.decrypt)((0, o.fromBase64)(r.data), t, r.encryption),
                            {
                                mnemonic: a,
                                accounts: s
                            } = JSON.parse((0, o.fromUtf8)(e));
                        if ((0, i.assert)("string" == typeof a), !Array.isArray(s)) throw Error("Property 'accounts' is not an array");
                        if (!s.every(e => !!(0, i.isNonNullObject)(e) && "string" == typeof e.hdPath && "string" == typeof e.prefix)) throw Error("Account is not in the correct format.");
                        let d = s[0].prefix;
                        if (!s.every(({
                                prefix: e
                            }) => e === d)) throw Error("Accounts do not all have the same prefix");
                        let c = s.map(({
                            hdPath: e
                        }) => (0, n.stringToPath)(e));
                        return g.fromMnemonic(a, {
                            hdPaths: c,
                            prefix: d
                        })
                    }
                    throw Error("Unsupported serialization type")
                }
                static async deserializeTypeV1(e, t) {
                    let r = JSON.parse(e);
                    if (!(0, i.isNonNullObject)(r)) throw Error("Root document is not an object.");
                    let n = await (0, l.executeKdf)(t, r.kdf);
                    return g.deserializeWithEncryptionKey(e, n)
                }
                constructor(e, t) {
                    let r = t.hdPaths ? ? m.hdPaths,
                        n = t.prefix ? ? m.prefix;
                    this.secret = e, this.seed = t.seed, this.accounts = r.map(e => ({
                        hdPath: e,
                        prefix: n
                    }))
                }
                get mnemonic() {
                    return this.secret.toString()
                }
                async getAccounts() {
                    return (await this.getAccountsWithPrivkeys()).map(({
                        algo: e,
                        pubkey: t,
                        address: r
                    }) => ({
                        algo: e,
                        pubkey: t,
                        address: r
                    }))
                }
                async signAmino(e, t) {
                    let r = (await this.getAccountsWithPrivkeys()).find(({
                        address: t
                    }) => t === e);
                    if (void 0 === r) throw Error(`Address ${e} not found in wallet`);
                    let {
                        privkey: o,
                        pubkey: i
                    } = r, a = (0, n.sha256)((0, c.serializeSignDoc)(t)), s = await n.Secp256k1.createSignature(a, o), l = new Uint8Array([...s.r(32), ...s.s(32)]);
                    return {
                        signed: t,
                        signature: (0, d.encodeSecp256k1Signature)(i, l)
                    }
                }
                async serialize(e) {
                    let t = await (0, l.executeKdf)(e, p);
                    return this.serializeWithEncryptionKey(t, p)
                }
                async serializeWithEncryptionKey(e, t) {
                    let r = {
                            mnemonic: this.mnemonic,
                            accounts: this.accounts.map(({
                                hdPath: e,
                                prefix: t
                            }) => ({
                                hdPath: (0, n.pathToString)(e),
                                prefix: t
                            }))
                        },
                        i = (0, o.toUtf8)(JSON.stringify(r)),
                        a = {
                            algorithm: l.supportedAlgorithms.xchacha20poly1305Ietf
                        },
                        s = await (0, l.encrypt)(i, e, a);
                    return JSON.stringify({
                        type: u,
                        kdf: t,
                        encryption: a,
                        data: (0, o.toBase64)(s)
                    })
                }
                async getKeyPair(e) {
                    let {
                        privkey: t
                    } = n.Slip10.derivePath(n.Slip10Curve.Secp256k1, this.seed, e), {
                        pubkey: r
                    } = await n.Secp256k1.makeKeypair(t);
                    return {
                        privkey: t,
                        pubkey: n.Secp256k1.compressPubkey(r)
                    }
                }
                async getAccountsWithPrivkeys() {
                    return Promise.all(this.accounts.map(async ({
                        hdPath: e,
                        prefix: t
                    }) => {
                        let {
                            privkey: r,
                            pubkey: n
                        } = await this.getKeyPair(e), i = (0, o.toBech32)(t, (0, a.rawSecp256k1PubkeyToRawAddress)(n));
                        return {
                            algo: "secp256k1",
                            privkey: r,
                            pubkey: n,
                            address: i
                        }
                    }))
                }
            }
            t.Secp256k1HdWallet = g
        },
        70834: function(e, t, r) {
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: !0
            }), t.Secp256k1Wallet = void 0;
            let n = r(46495),
                o = r(81299),
                i = r(83874),
                a = r(83086),
                s = r(28732);
            class d {
                static async fromKey(e, t = "cosmos") {
                    let r = (await n.Secp256k1.makeKeypair(e)).pubkey;
                    return new d(e, n.Secp256k1.compressPubkey(r), t)
                }
                constructor(e, t, r) {
                    this.privkey = e, this.pubkey = t, this.prefix = r
                }
                get address() {
                    return (0, o.toBech32)(this.prefix, (0, i.rawSecp256k1PubkeyToRawAddress)(this.pubkey))
                }
                async getAccounts() {
                    return [{
                        algo: "secp256k1",
                        address: this.address,
                        pubkey: this.pubkey
                    }]
                }
                async signAmino(e, t) {
                    if (e !== this.address) throw Error(`Address ${e} not found in wallet`);
                    let r = new n.Sha256((0, s.serializeSignDoc)(t)).digest(),
                        o = await n.Secp256k1.createSignature(r, this.privkey),
                        i = new Uint8Array([...o.r(32), ...o.s(32)]);
                    return {
                        signed: t,
                        signature: (0, a.encodeSecp256k1Signature)(this.pubkey, i)
                    }
                }
            }
            t.Secp256k1Wallet = d
        },
        83086: function(e, t, r) {
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: !0
            }), t.decodeSignature = t.encodeSecp256k1Signature = void 0;
            let n = r(81299),
                o = r(12810),
                i = r(26320);
            t.encodeSecp256k1Signature = function(e, t) {
                if (64 !== t.length) throw Error("Signature must be 64 bytes long. Cosmos SDK uses a 2x32 byte fixed length encoding for the secp256k1 signature integers r and s.");
                return {
                    pub_key: (0, o.encodeSecp256k1Pubkey)(e),
                    signature: (0, n.toBase64)(t)
                }
            }, t.decodeSignature = function(e) {
                if (e.pub_key.type === i.pubkeyType.secp256k1) return {
                    pubkey: (0, n.fromBase64)(e.pub_key.value),
                    signature: (0, n.fromBase64)(e.signature)
                };
                throw Error("Unsupported pubkey type")
            }
        },
        28732: function(e, t, r) {
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: !0
            }), t.serializeSignDoc = t.escapeCharacters = t.makeSignDoc = t.sortedJsonStringify = void 0;
            let n = r(81299),
                o = r(82071);

            function i(e) {
                return JSON.stringify(function e(t) {
                    if ("object" != typeof t || null === t) return t;
                    if (Array.isArray(t)) return t.map(e);
                    let r = Object.keys(t).sort(),
                        n = {};
                    return r.forEach(r => {
                        n[r] = e(t[r])
                    }), n
                }(e))
            }

            function a(e) {
                return e.replace(/&/g, "\\u0026").replace(/</g, "\\u003c").replace(/>/g, "\\u003e")
            }
            t.sortedJsonStringify = i, t.makeSignDoc = function(e, t, r, n, i, a, s) {
                return {
                    chain_id: r,
                    account_number: o.Uint53.fromString(i.toString()).toString(),
                    sequence: o.Uint53.fromString(a.toString()).toString(),
                    fee: t,
                    msgs: e,
                    memo: n || "",
                    ...s && {
                        timeout_height: s.toString()
                    }
                }
            }, t.escapeCharacters = a, t.serializeSignDoc = function(e) {
                let t = a(i(e));
                return (0, n.toUtf8)(t)
            }
        },
        46478: function(e, t) {
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: !0
            }), t.makeStdTx = t.isStdTx = void 0, t.isStdTx = function(e) {
                let {
                    memo: t,
                    msg: r,
                    fee: n,
                    signatures: o
                } = e;
                return "string" == typeof t && Array.isArray(r) && "object" == typeof n && Array.isArray(o)
            }, t.makeStdTx = function(e, t) {
                return {
                    msg: e.msgs,
                    fee: e.fee,
                    memo: e.memo,
                    signatures: Array.isArray(t) ? t : [t]
                }
            }
        },
        90187: function(e, t, r) {
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: !0
            }), t.decrypt = t.encrypt = t.supportedAlgorithms = t.executeKdf = t.cosmjsSalt = void 0;
            let n = r(46495),
                o = r(81299);
            async function i(e, r) {
                if ("argon2id" === r.algorithm) {
                    let o = r.params;
                    if (!(0, n.isArgon2idOptions)(o)) throw Error("Invalid format of argon2id params");
                    return n.Argon2id.execute(e, t.cosmjsSalt, o)
                }
                throw Error("Unsupported KDF algorithm")
            }
            async function a(e, r, o) {
                if (o.algorithm === t.supportedAlgorithms.xchacha20poly1305Ietf) {
                    let t = n.Random.getBytes(n.xchacha20NonceLength);
                    return new Uint8Array([...t, ...await n.Xchacha20poly1305Ietf.encrypt(e, r, t)])
                }
                throw Error(`Unsupported encryption algorithm: '${o.algorithm}'`)
            }
            async function s(e, r, o) {
                if (o.algorithm === t.supportedAlgorithms.xchacha20poly1305Ietf) {
                    let t = e.slice(0, n.xchacha20NonceLength);
                    return n.Xchacha20poly1305Ietf.decrypt(e.slice(n.xchacha20NonceLength), r, t)
                }
                throw Error(`Unsupported encryption algorithm: '${o.algorithm}'`)
            }
            t.cosmjsSalt = (0, o.toAscii)("The CosmJS salt."), t.executeKdf = i, t.supportedAlgorithms = {
                xchacha20poly1305Ietf: "xchacha20poly1305-ietf"
            }, t.encrypt = a, t.decrypt = s
        },
        64758: function(e, t, r) {
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: !0
            }), t.Bip39 = t.EnglishMnemonic = t.mnemonicToEntropy = t.entropyToMnemonic = void 0;
            let n = r(81299),
                o = r(78098),
                i = r(51564),
                a = ["abandon", "ability", "able", "about", "above", "absent", "absorb", "abstract", "absurd", "abuse", "access", "accident", "account", "accuse", "achieve", "acid", "acoustic", "acquire", "across", "act", "action", "actor", "actress", "actual", "adapt", "add", "addict", "address", "adjust", "admit", "adult", "advance", "advice", "aerobic", "affair", "afford", "afraid", "again", "age", "agent", "agree", "ahead", "aim", "air", "airport", "aisle", "alarm", "album", "alcohol", "alert", "alien", "all", "alley", "allow", "almost", "alone", "alpha", "already", "also", "alter", "always", "amateur", "amazing", "among", "amount", "amused", "analyst", "anchor", "ancient", "anger", "angle", "angry", "animal", "ankle", "announce", "annual", "another", "answer", "antenna", "antique", "anxiety", "any", "apart", "apology", "appear", "apple", "approve", "april", "arch", "arctic", "area", "arena", "argue", "arm", "armed", "armor", "army", "around", "arrange", "arrest", "arrive", "arrow", "art", "artefact", "artist", "artwork", "ask", "aspect", "assault", "asset", "assist", "assume", "asthma", "athlete", "atom", "attack", "attend", "attitude", "attract", "auction", "audit", "august", "aunt", "author", "auto", "autumn", "average", "avocado", "avoid", "awake", "aware", "away", "awesome", "awful", "awkward", "axis", "baby", "bachelor", "bacon", "badge", "bag", "balance", "balcony", "ball", "bamboo", "banana", "banner", "bar", "barely", "bargain", "barrel", "base", "basic", "basket", "battle", "beach", "bean", "beauty", "because", "become", "beef", "before", "begin", "behave", "behind", "believe", "below", "belt", "bench", "benefit", "best", "betray", "better", "between", "beyond", "bicycle", "bid", "bike", "bind", "biology", "bird", "birth", "bitter", "black", "blade", "blame", "blanket", "blast", "bleak", "bless", "blind", "blood", "blossom", "blouse", "blue", "blur", "blush", "board", "boat", "body", "boil", "bomb", "bone", "bonus", "book", "boost", "border", "boring", "borrow", "boss", "bottom", "bounce", "box", "boy", "bracket", "brain", "brand", "brass", "brave", "bread", "breeze", "brick", "bridge", "brief", "bright", "bring", "brisk", "broccoli", "broken", "bronze", "broom", "brother", "brown", "brush", "bubble", "buddy", "budget", "buffalo", "build", "bulb", "bulk", "bullet", "bundle", "bunker", "burden", "burger", "burst", "bus", "business", "busy", "butter", "buyer", "buzz", "cabbage", "cabin", "cable", "cactus", "cage", "cake", "call", "calm", "camera", "camp", "can", "canal", "cancel", "candy", "cannon", "canoe", "canvas", "canyon", "capable", "capital", "captain", "car", "carbon", "card", "cargo", "carpet", "carry", "cart", "case", "cash", "casino", "castle", "casual", "cat", "catalog", "catch", "category", "cattle", "caught", "cause", "caution", "cave", "ceiling", "celery", "cement", "census", "century", "cereal", "certain", "chair", "chalk", "champion", "change", "chaos", "chapter", "charge", "chase", "chat", "cheap", "check", "cheese", "chef", "cherry", "chest", "chicken", "chief", "child", "chimney", "choice", "choose", "chronic", "chuckle", "chunk", "churn", "cigar", "cinnamon", "circle", "citizen", "city", "civil", "claim", "clap", "clarify", "claw", "clay", "clean", "clerk", "clever", "click", "client", "cliff", "climb", "clinic", "clip", "clock", "clog", "close", "cloth", "cloud", "clown", "club", "clump", "cluster", "clutch", "coach", "coast", "coconut", "code", "coffee", "coil", "coin", "collect", "color", "column", "combine", "come", "comfort", "comic", "common", "company", "concert", "conduct", "confirm", "congress", "connect", "consider", "control", "convince", "cook", "cool", "copper", "copy", "coral", "core", "corn", "correct", "cost", "cotton", "couch", "country", "couple", "course", "cousin", "cover", "coyote", "crack", "cradle", "craft", "cram", "crane", "crash", "crater", "crawl", "crazy", "cream", "credit", "creek", "crew", "cricket", "crime", "crisp", "critic", "crop", "cross", "crouch", "crowd", "crucial", "cruel", "cruise", "crumble", "crunch", "crush", "cry", "crystal", "cube", "culture", "cup", "cupboard", "curious", "current", "curtain", "curve", "cushion", "custom", "cute", "cycle", "dad", "damage", "damp", "dance", "danger", "daring", "dash", "daughter", "dawn", "day", "deal", "debate", "debris", "decade", "december", "decide", "decline", "decorate", "decrease", "deer", "defense", "define", "defy", "degree", "delay", "deliver", "demand", "demise", "denial", "dentist", "deny", "depart", "depend", "deposit", "depth", "deputy", "derive", "describe", "desert", "design", "desk", "despair", "destroy", "detail", "detect", "develop", "device", "devote", "diagram", "dial", "diamond", "diary", "dice", "diesel", "diet", "differ", "digital", "dignity", "dilemma", "dinner", "dinosaur", "direct", "dirt", "disagree", "discover", "disease", "dish", "dismiss", "disorder", "display", "distance", "divert", "divide", "divorce", "dizzy", "doctor", "document", "dog", "doll", "dolphin", "domain", "donate", "donkey", "donor", "door", "dose", "double", "dove", "draft", "dragon", "drama", "drastic", "draw", "dream", "dress", "drift", "drill", "drink", "drip", "drive", "drop", "drum", "dry", "duck", "dumb", "dune", "during", "dust", "dutch", "duty", "dwarf", "dynamic", "eager", "eagle", "early", "earn", "earth", "easily", "east", "easy", "echo", "ecology", "economy", "edge", "edit", "educate", "effort", "egg", "eight", "either", "elbow", "elder", "electric", "elegant", "element", "elephant", "elevator", "elite", "else", "embark", "embody", "embrace", "emerge", "emotion", "employ", "empower", "empty", "enable", "enact", "end", "endless", "endorse", "enemy", "energy", "enforce", "engage", "engine", "enhance", "enjoy", "enlist", "enough", "enrich", "enroll", "ensure", "enter", "entire", "entry", "envelope", "episode", "equal", "equip", "era", "erase", "erode", "erosion", "error", "erupt", "escape", "essay", "essence", "estate", "eternal", "ethics", "evidence", "evil", "evoke", "evolve", "exact", "example", "excess", "exchange", "excite", "exclude", "excuse", "execute", "exercise", "exhaust", "exhibit", "exile", "exist", "exit", "exotic", "expand", "expect", "expire", "explain", "expose", "express", "extend", "extra", "eye", "eyebrow", "fabric", "face", "faculty", "fade", "faint", "faith", "fall", "false", "fame", "family", "famous", "fan", "fancy", "fantasy", "farm", "fashion", "fat", "fatal", "father", "fatigue", "fault", "favorite", "feature", "february", "federal", "fee", "feed", "feel", "female", "fence", "festival", "fetch", "fever", "few", "fiber", "fiction", "field", "figure", "file", "film", "filter", "final", "find", "fine", "finger", "finish", "fire", "firm", "first", "fiscal", "fish", "fit", "fitness", "fix", "flag", "flame", "flash", "flat", "flavor", "flee", "flight", "flip", "float", "flock", "floor", "flower", "fluid", "flush", "fly", "foam", "focus", "fog", "foil", "fold", "follow", "food", "foot", "force", "forest", "forget", "fork", "fortune", "forum", "forward", "fossil", "foster", "found", "fox", "fragile", "frame", "frequent", "fresh", "friend", "fringe", "frog", "front", "frost", "frown", "frozen", "fruit", "fuel", "fun", "funny", "furnace", "fury", "future", "gadget", "gain", "galaxy", "gallery", "game", "gap", "garage", "garbage", "garden", "garlic", "garment", "gas", "gasp", "gate", "gather", "gauge", "gaze", "general", "genius", "genre", "gentle", "genuine", "gesture", "ghost", "giant", "gift", "giggle", "ginger", "giraffe", "girl", "give", "glad", "glance", "glare", "glass", "glide", "glimpse", "globe", "gloom", "glory", "glove", "glow", "glue", "goat", "goddess", "gold", "good", "goose", "gorilla", "gospel", "gossip", "govern", "gown", "grab", "grace", "grain", "grant", "grape", "grass", "gravity", "great", "green", "grid", "grief", "grit", "grocery", "group", "grow", "grunt", "guard", "guess", "guide", "guilt", "guitar", "gun", "gym", "habit", "hair", "half", "hammer", "hamster", "hand", "happy", "harbor", "hard", "harsh", "harvest", "hat", "have", "hawk", "hazard", "head", "health", "heart", "heavy", "hedgehog", "height", "hello", "helmet", "help", "hen", "hero", "hidden", "high", "hill", "hint", "hip", "hire", "history", "hobby", "hockey", "hold", "hole", "holiday", "hollow", "home", "honey", "hood", "hope", "horn", "horror", "horse", "hospital", "host", "hotel", "hour", "hover", "hub", "huge", "human", "humble", "humor", "hundred", "hungry", "hunt", "hurdle", "hurry", "hurt", "husband", "hybrid", "ice", "icon", "idea", "identify", "idle", "ignore", "ill", "illegal", "illness", "image", "imitate", "immense", "immune", "impact", "impose", "improve", "impulse", "inch", "include", "income", "increase", "index", "indicate", "indoor", "industry", "infant", "inflict", "inform", "inhale", "inherit", "initial", "inject", "injury", "inmate", "inner", "innocent", "input", "inquiry", "insane", "insect", "inside", "inspire", "install", "intact", "interest", "into", "invest", "invite", "involve", "iron", "island", "isolate", "issue", "item", "ivory", "jacket", "jaguar", "jar", "jazz", "jealous", "jeans", "jelly", "jewel", "job", "join", "joke", "journey", "joy", "judge", "juice", "jump", "jungle", "junior", "junk", "just", "kangaroo", "keen", "keep", "ketchup", "key", "kick", "kid", "kidney", "kind", "kingdom", "kiss", "kit", "kitchen", "kite", "kitten", "kiwi", "knee", "knife", "knock", "know", "lab", "label", "labor", "ladder", "lady", "lake", "lamp", "language", "laptop", "large", "later", "latin", "laugh", "laundry", "lava", "law", "lawn", "lawsuit", "layer", "lazy", "leader", "leaf", "learn", "leave", "lecture", "left", "leg", "legal", "legend", "leisure", "lemon", "lend", "length", "lens", "leopard", "lesson", "letter", "level", "liar", "liberty", "library", "license", "life", "lift", "light", "like", "limb", "limit", "link", "lion", "liquid", "list", "little", "live", "lizard", "load", "loan", "lobster", "local", "lock", "logic", "lonely", "long", "loop", "lottery", "loud", "lounge", "love", "loyal", "lucky", "luggage", "lumber", "lunar", "lunch", "luxury", "lyrics", "machine", "mad", "magic", "magnet", "maid", "mail", "main", "major", "make", "mammal", "man", "manage", "mandate", "mango", "mansion", "manual", "maple", "marble", "march", "margin", "marine", "market", "marriage", "mask", "mass", "master", "match", "material", "math", "matrix", "matter", "maximum", "maze", "meadow", "mean", "measure", "meat", "mechanic", "medal", "media", "melody", "melt", "member", "memory", "mention", "menu", "mercy", "merge", "merit", "merry", "mesh", "message", "metal", "method", "middle", "midnight", "milk", "million", "mimic", "mind", "minimum", "minor", "minute", "miracle", "mirror", "misery", "miss", "mistake", "mix", "mixed", "mixture", "mobile", "model", "modify", "mom", "moment", "monitor", "monkey", "monster", "month", "moon", "moral", "more", "morning", "mosquito", "mother", "motion", "motor", "mountain", "mouse", "move", "movie", "much", "muffin", "mule", "multiply", "muscle", "museum", "mushroom", "music", "must", "mutual", "myself", "mystery", "myth", "naive", "name", "napkin", "narrow", "nasty", "nation", "nature", "near", "neck", "need", "negative", "neglect", "neither", "nephew", "nerve", "nest", "net", "network", "neutral", "never", "news", "next", "nice", "night", "noble", "noise", "nominee", "noodle", "normal", "north", "nose", "notable", "note", "nothing", "notice", "novel", "now", "nuclear", "number", "nurse", "nut", "oak", "obey", "object", "oblige", "obscure", "observe", "obtain", "obvious", "occur", "ocean", "october", "odor", "off", "offer", "office", "often", "oil", "okay", "old", "olive", "olympic", "omit", "once", "one", "onion", "online", "only", "open", "opera", "opinion", "oppose", "option", "orange", "orbit", "orchard", "order", "ordinary", "organ", "orient", "original", "orphan", "ostrich", "other", "outdoor", "outer", "output", "outside", "oval", "oven", "over", "own", "owner", "oxygen", "oyster", "ozone", "pact", "paddle", "page", "pair", "palace", "palm", "panda", "panel", "panic", "panther", "paper", "parade", "parent", "park", "parrot", "party", "pass", "patch", "path", "patient", "patrol", "pattern", "pause", "pave", "payment", "peace", "peanut", "pear", "peasant", "pelican", "pen", "penalty", "pencil", "people", "pepper", "perfect", "permit", "person", "pet", "phone", "photo", "phrase", "physical", "piano", "picnic", "picture", "piece", "pig", "pigeon", "pill", "pilot", "pink", "pioneer", "pipe", "pistol", "pitch", "pizza", "place", "planet", "plastic", "plate", "play", "please", "pledge", "pluck", "plug", "plunge", "poem", "poet", "point", "polar", "pole", "police", "pond", "pony", "pool", "popular", "portion", "position", "possible", "post", "potato", "pottery", "poverty", "powder", "power", "practice", "praise", "predict", "prefer", "prepare", "present", "pretty", "prevent", "price", "pride", "primary", "print", "priority", "prison", "private", "prize", "problem", "process", "produce", "profit", "program", "project", "promote", "proof", "property", "prosper", "protect", "proud", "provide", "public", "pudding", "pull", "pulp", "pulse", "pumpkin", "punch", "pupil", "puppy", "purchase", "purity", "purpose", "purse", "push", "put", "puzzle", "pyramid", "quality", "quantum", "quarter", "question", "quick", "quit", "quiz", "quote", "rabbit", "raccoon", "race", "rack", "radar", "radio", "rail", "rain", "raise", "rally", "ramp", "ranch", "random", "range", "rapid", "rare", "rate", "rather", "raven", "raw", "razor", "ready", "real", "reason", "rebel", "rebuild", "recall", "receive", "recipe", "record", "recycle", "reduce", "reflect", "reform", "refuse", "region", "regret", "regular", "reject", "relax", "release", "relief", "rely", "remain", "remember", "remind", "remove", "render", "renew", "rent", "reopen", "repair", "repeat", "replace", "report", "require", "rescue", "resemble", "resist", "resource", "response", "result", "retire", "retreat", "return", "reunion", "reveal", "review", "reward", "rhythm", "rib", "ribbon", "rice", "rich", "ride", "ridge", "rifle", "right", "rigid", "ring", "riot", "ripple", "risk", "ritual", "rival", "river", "road", "roast", "robot", "robust", "rocket", "romance", "roof", "rookie", "room", "rose", "rotate", "rough", "round", "route", "royal", "rubber", "rude", "rug", "rule", "run", "runway", "rural", "sad", "saddle", "sadness", "safe", "sail", "salad", "salmon", "salon", "salt", "salute", "same", "sample", "sand", "satisfy", "satoshi", "sauce", "sausage", "save", "say", "scale", "scan", "scare", "scatter", "scene", "scheme", "school", "science", "scissors", "scorpion", "scout", "scrap", "screen", "script", "scrub", "sea", "search", "season", "seat", "second", "secret", "section", "security", "seed", "seek", "segment", "select", "sell", "seminar", "senior", "sense", "sentence", "series", "service", "session", "settle", "setup", "seven", "shadow", "shaft", "shallow", "share", "shed", "shell", "sheriff", "shield", "shift", "shine", "ship", "shiver", "shock", "shoe", "shoot", "shop", "short", "shoulder", "shove", "shrimp", "shrug", "shuffle", "shy", "sibling", "sick", "side", "siege", "sight", "sign", "silent", "silk", "silly", "silver", "similar", "simple", "since", "sing", "siren", "sister", "situate", "six", "size", "skate", "sketch", "ski", "skill", "skin", "skirt", "skull", "slab", "slam", "sleep", "slender", "slice", "slide", "slight", "slim", "slogan", "slot", "slow", "slush", "small", "smart", "smile", "smoke", "smooth", "snack", "snake", "snap", "sniff", "snow", "soap", "soccer", "social", "sock", "soda", "soft", "solar", "soldier", "solid", "solution", "solve", "someone", "song", "soon", "sorry", "sort", "soul", "sound", "soup", "source", "south", "space", "spare", "spatial", "spawn", "speak", "special", "speed", "spell", "spend", "sphere", "spice", "spider", "spike", "spin", "spirit", "split", "spoil", "sponsor", "spoon", "sport", "spot", "spray", "spread", "spring", "spy", "square", "squeeze", "squirrel", "stable", "stadium", "staff", "stage", "stairs", "stamp", "stand", "start", "state", "stay", "steak", "steel", "stem", "step", "stereo", "stick", "still", "sting", "stock", "stomach", "stone", "stool", "story", "stove", "strategy", "street", "strike", "strong", "struggle", "student", "stuff", "stumble", "style", "subject", "submit", "subway", "success", "such", "sudden", "suffer", "sugar", "suggest", "suit", "summer", "sun", "sunny", "sunset", "super", "supply", "supreme", "sure", "surface", "surge", "surprise", "surround", "survey", "suspect", "sustain", "swallow", "swamp", "swap", "swarm", "swear", "sweet", "swift", "swim", "swing", "switch", "sword", "symbol", "symptom", "syrup", "system", "table", "tackle", "tag", "tail", "talent", "talk", "tank", "tape", "target", "task", "taste", "tattoo", "taxi", "teach", "team", "tell", "ten", "tenant", "tennis", "tent", "term", "test", "text", "thank", "that", "theme", "then", "theory", "there", "they", "thing", "this", "thought", "three", "thrive", "throw", "thumb", "thunder", "ticket", "tide", "tiger", "tilt", "timber", "time", "tiny", "tip", "tired", "tissue", "title", "toast", "tobacco", "today", "toddler", "toe", "together", "toilet", "token", "tomato", "tomorrow", "tone", "tongue", "tonight", "tool", "tooth", "top", "topic", "topple", "torch", "tornado", "tortoise", "toss", "total", "tourist", "toward", "tower", "town", "toy", "track", "trade", "traffic", "tragic", "train", "transfer", "trap", "trash", "travel", "tray", "treat", "tree", "trend", "trial", "tribe", "trick", "trigger", "trim", "trip", "trophy", "trouble", "truck", "true", "truly", "trumpet", "trust", "truth", "try", "tube", "tuition", "tumble", "tuna", "tunnel", "turkey", "turn", "turtle", "twelve", "twenty", "twice", "twin", "twist", "two", "type", "typical", "ugly", "umbrella", "unable", "unaware", "uncle", "uncover", "under", "undo", "unfair", "unfold", "unhappy", "uniform", "unique", "unit", "universe", "unknown", "unlock", "until", "unusual", "unveil", "update", "upgrade", "uphold", "upon", "upper", "upset", "urban", "urge", "usage", "use", "used", "useful", "useless", "usual", "utility", "vacant", "vacuum", "vague", "valid", "valley", "valve", "van", "vanish", "vapor", "various", "vast", "vault", "vehicle", "velvet", "vendor", "venture", "venue", "verb", "verify", "version", "very", "vessel", "veteran", "viable", "vibrant", "vicious", "victory", "video", "view", "village", "vintage", "violin", "virtual", "virus", "visa", "visit", "visual", "vital", "vivid", "vocal", "voice", "void", "volcano", "volume", "vote", "voyage", "wage", "wagon", "wait", "walk", "wall", "walnut", "want", "warfare", "warm", "warrior", "wash", "wasp", "waste", "water", "wave", "way", "wealth", "weapon", "wear", "weasel", "weather", "web", "wedding", "weekend", "weird", "welcome", "west", "wet", "whale", "what", "wheat", "wheel", "when", "where", "whip", "whisper", "wide", "width", "wife", "wild", "will", "win", "window", "wine", "wing", "wink", "winner", "winter", "wire", "wisdom", "wise", "wish", "witness", "wolf", "woman", "wonder", "wood", "wool", "word", "work", "world", "worry", "worth", "wrap", "wreck", "wrestle", "wrist", "write", "wrong", "yard", "year", "yellow", "you", "young", "youth", "zebra", "zero", "zone", "zoo"];

            function s(e) {
                return Array.from(e).map(e => e.toString(2).padStart(8, "0")).join("")
            }

            function d(e) {
                let t = 8 * e.length;
                return s((0, i.sha256)(e)).slice(0, t / 32)
            }

            function c(e) {
                return parseInt(e, 2)
            }
            let l = [16, 20, 24, 28, 32],
                u = [12, 15, 18, 21, 24];

            function p(e) {
                if (-1 === l.indexOf(e.length)) throw Error("invalid input length");
                return (s(e) + d(e)).match(/(.{11})/g).map(e => a[c(e)]).join(" ")
            }

            function m(e) {
                return e.normalize("NFKD")
            }

            function g(e) {
                let t = m(e).split(" ");
                if (!u.includes(t.length)) throw Error("Invalid number of words");
                let r = t.map(e => {
                        let t = a.indexOf(e);
                        if (-1 === t) throw Error("Found word that is not in the wordlist");
                        return t.toString(2).padStart(11, "0")
                    }).join(""),
                    n = 32 * Math.floor(r.length / 33),
                    o = r.slice(0, n),
                    i = r.slice(n),
                    s = o.match(/(.{1,8})/g).map(c);
                if (s.length < 16 || s.length > 32 || s.length % 4 != 0) throw Error("Invalid entropy");
                let l = Uint8Array.from(s);
                if (d(l) !== i) throw Error("Invalid mnemonic checksum");
                return l
            }
            t.entropyToMnemonic = p, t.mnemonicToEntropy = g;
            class f {
                constructor(e) {
                    if (!f.mnemonicMatcher.test(e)) throw Error("Invalid mnemonic format");
                    let t = e.split(" "),
                        r = [12, 15, 18, 21, 24];
                    if (-1 === r.indexOf(t.length)) throw Error(`Invalid word count in mnemonic (allowed: ${r} got: ${t.length})`);
                    for (let e of t)
                        if (-1 === f.wordlist.indexOf(e)) throw Error("Mnemonic contains invalid word");
                    g(e), this.data = e
                }
                toString() {
                    return this.data
                }
            }
            t.EnglishMnemonic = f, f.wordlist = a, f.mnemonicMatcher = /^[a-z]+( [a-z]+)*$/;
            class y {
                static encode(e) {
                    return new f(p(e))
                }
                static decode(e) {
                    return g(e.toString())
                }
                static async mnemonicToSeed(e, t) {
                    let r = (0, n.toUtf8)(m(e.toString())),
                        i = "mnemonic" + (t ? m(t) : ""),
                        a = (0, n.toUtf8)(i);
                    return (0, o.pbkdf2Sha512)(r, a, 2048, 64)
                }
            }
            t.Bip39 = y
        },
        14276: function(e, t) {
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: !0
            }), t.Hmac = void 0;
            class r {
                constructor(e, t) {
                    let r = new e().blockSize;
                    this.hash = t => new e().update(t).digest();
                    let n = t;
                    if (n.length > r && (n = this.hash(n)), n.length < r) {
                        let e = new Uint8Array(r - n.length);
                        n = new Uint8Array([...n, ...e])
                    }
                    this.oKeyPad = n.map(e => 92 ^ e), this.iKeyPad = n.map(e => 54 ^ e), this.messageHasher = new e, this.blockSize = r, this.update(this.iKeyPad)
                }
                update(e) {
                    return this.messageHasher.update(e), this
                }
                digest() {
                    let e = this.messageHasher.digest();
                    return this.hash(new Uint8Array([...this.oKeyPad, ...e]))
                }
            }
            t.Hmac = r
        },
        46495: function(e, t, r) {
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: !0
            }), t.stringToPath = t.Slip10RawIndex = t.slip10CurveFromString = t.Slip10Curve = t.Slip10 = t.pathToString = t.sha512 = t.Sha512 = t.sha256 = t.Sha256 = t.Secp256k1Signature = t.ExtendedSecp256k1Signature = t.Secp256k1 = t.ripemd160 = t.Ripemd160 = t.Random = t.Xchacha20poly1305Ietf = t.xchacha20NonceLength = t.isArgon2idOptions = t.Ed25519Keypair = t.Ed25519 = t.Argon2id = t.keccak256 = t.Keccak256 = t.Hmac = t.EnglishMnemonic = t.Bip39 = void 0;
            var n = r(64758);
            Object.defineProperty(t, "Bip39", {
                enumerable: !0,
                get: function() {
                    return n.Bip39
                }
            }), Object.defineProperty(t, "EnglishMnemonic", {
                enumerable: !0,
                get: function() {
                    return n.EnglishMnemonic
                }
            });
            var o = r(14276);
            Object.defineProperty(t, "Hmac", {
                enumerable: !0,
                get: function() {
                    return o.Hmac
                }
            });
            var i = r(80653);
            Object.defineProperty(t, "Keccak256", {
                enumerable: !0,
                get: function() {
                    return i.Keccak256
                }
            }), Object.defineProperty(t, "keccak256", {
                enumerable: !0,
                get: function() {
                    return i.keccak256
                }
            });
            var a = r(18226);
            Object.defineProperty(t, "Argon2id", {
                enumerable: !0,
                get: function() {
                    return a.Argon2id
                }
            }), Object.defineProperty(t, "Ed25519", {
                enumerable: !0,
                get: function() {
                    return a.Ed25519
                }
            }), Object.defineProperty(t, "Ed25519Keypair", {
                enumerable: !0,
                get: function() {
                    return a.Ed25519Keypair
                }
            }), Object.defineProperty(t, "isArgon2idOptions", {
                enumerable: !0,
                get: function() {
                    return a.isArgon2idOptions
                }
            }), Object.defineProperty(t, "xchacha20NonceLength", {
                enumerable: !0,
                get: function() {
                    return a.xchacha20NonceLength
                }
            }), Object.defineProperty(t, "Xchacha20poly1305Ietf", {
                enumerable: !0,
                get: function() {
                    return a.Xchacha20poly1305Ietf
                }
            });
            var s = r(11296);
            Object.defineProperty(t, "Random", {
                enumerable: !0,
                get: function() {
                    return s.Random
                }
            });
            var d = r(30839);
            Object.defineProperty(t, "Ripemd160", {
                enumerable: !0,
                get: function() {
                    return d.Ripemd160
                }
            }), Object.defineProperty(t, "ripemd160", {
                enumerable: !0,
                get: function() {
                    return d.ripemd160
                }
            });
            var c = r(36348);
            Object.defineProperty(t, "Secp256k1", {
                enumerable: !0,
                get: function() {
                    return c.Secp256k1
                }
            });
            var l = r(33885);
            Object.defineProperty(t, "ExtendedSecp256k1Signature", {
                enumerable: !0,
                get: function() {
                    return l.ExtendedSecp256k1Signature
                }
            }), Object.defineProperty(t, "Secp256k1Signature", {
                enumerable: !0,
                get: function() {
                    return l.Secp256k1Signature
                }
            });
            var u = r(51564);
            Object.defineProperty(t, "Sha256", {
                enumerable: !0,
                get: function() {
                    return u.Sha256
                }
            }), Object.defineProperty(t, "sha256", {
                enumerable: !0,
                get: function() {
                    return u.sha256
                }
            }), Object.defineProperty(t, "Sha512", {
                enumerable: !0,
                get: function() {
                    return u.Sha512
                }
            }), Object.defineProperty(t, "sha512", {
                enumerable: !0,
                get: function() {
                    return u.sha512
                }
            });
            var p = r(46920);
            Object.defineProperty(t, "pathToString", {
                enumerable: !0,
                get: function() {
                    return p.pathToString
                }
            }), Object.defineProperty(t, "Slip10", {
                enumerable: !0,
                get: function() {
                    return p.Slip10
                }
            }), Object.defineProperty(t, "Slip10Curve", {
                enumerable: !0,
                get: function() {
                    return p.Slip10Curve
                }
            }), Object.defineProperty(t, "slip10CurveFromString", {
                enumerable: !0,
                get: function() {
                    return p.slip10CurveFromString
                }
            }), Object.defineProperty(t, "Slip10RawIndex", {
                enumerable: !0,
                get: function() {
                    return p.Slip10RawIndex
                }
            }), Object.defineProperty(t, "stringToPath", {
                enumerable: !0,
                get: function() {
                    return p.stringToPath
                }
            })
        },
        80653: function(e, t, r) {
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: !0
            }), t.keccak256 = t.Keccak256 = void 0;
            let n = r(85426),
                o = r(39764);
            class i {
                constructor(e) {
                    this.blockSize = 64, this.impl = n.keccak_256.create(), e && this.update(e)
                }
                update(e) {
                    return this.impl.update((0, o.toRealUint8Array)(e)), this
                }
                digest() {
                    return this.impl.digest()
                }
            }
            t.Keccak256 = i, t.keccak256 = function(e) {
                return new i(e).digest()
            }
        },
        18226: function(e, t, r) {
            "use strict";
            var n = this && this.__importDefault || function(e) {
                return e && e.__esModule ? e : {
                    default: e
                }
            };
            Object.defineProperty(t, "__esModule", {
                value: !0
            }), t.Xchacha20poly1305Ietf = t.xchacha20NonceLength = t.Ed25519 = t.Ed25519Keypair = t.Argon2id = t.isArgon2idOptions = void 0;
            let o = r(8261),
                i = n(r(98948));
            t.isArgon2idOptions = function(e) {
                return !!(0, o.isNonNullObject)(e) && "number" == typeof e.outputLength && "number" == typeof e.opsLimit && "number" == typeof e.memLimitKib
            };
            class a {
                static async execute(e, t, r) {
                    return await i.default.ready, i.default.crypto_pwhash(r.outputLength, e, t, r.opsLimit, 1024 * r.memLimitKib, i.default.crypto_pwhash_ALG_ARGON2ID13)
                }
            }
            t.Argon2id = a;
            class s {
                static fromLibsodiumPrivkey(e) {
                    if (64 !== e.length) throw Error(`Unexpected key length ${e.length}. Must be 64.`);
                    return new s(e.slice(0, 32), e.slice(32, 64))
                }
                constructor(e, t) {
                    this.privkey = e, this.pubkey = t
                }
                toLibsodiumPrivkey() {
                    return new Uint8Array([...this.privkey, ...this.pubkey])
                }
            }
            t.Ed25519Keypair = s;
            class d {
                static async makeKeypair(e) {
                    await i.default.ready;
                    let t = i.default.crypto_sign_seed_keypair(e);
                    return s.fromLibsodiumPrivkey(t.privateKey)
                }
                static async createSignature(e, t) {
                    return await i.default.ready, i.default.crypto_sign_detached(e, t.toLibsodiumPrivkey())
                }
                static async verifySignature(e, t, r) {
                    return await i.default.ready, i.default.crypto_sign_verify_detached(e, t, r)
                }
            }
            t.Ed25519 = d, t.xchacha20NonceLength = 24;
            class c {
                static async encrypt(e, t, r) {
                    return await i.default.ready, i.default.crypto_aead_xchacha20poly1305_ietf_encrypt(e, null, null, r, t)
                }
                static async decrypt(e, t, r) {
                    return await i.default.ready, i.default.crypto_aead_xchacha20poly1305_ietf_decrypt(null, e, null, r, t)
                }
            }
            t.Xchacha20poly1305Ietf = c
        },
        78098: function(e, t, r) {
            "use strict";
            var n = this && this.__createBinding || (Object.create ? function(e, t, r, n) {
                    void 0 === n && (n = r);
                    var o = Object.getOwnPropertyDescriptor(t, r);
                    (!o || ("get" in o ? !t.__esModule : o.writable || o.configurable)) && (o = {
                        enumerable: !0,
                        get: function() {
                            return t[r]
                        }
                    }), Object.defineProperty(e, n, o)
                } : function(e, t, r, n) {
                    void 0 === n && (n = r), e[n] = t[r]
                }),
                o = this && this.__setModuleDefault || (Object.create ? function(e, t) {
                    Object.defineProperty(e, "default", {
                        enumerable: !0,
                        value: t
                    })
                } : function(e, t) {
                    e.default = t
                }),
                i = this && this.__importStar || function(e) {
                    if (e && e.__esModule) return e;
                    var t = {};
                    if (null != e)
                        for (var r in e) "default" !== r && Object.prototype.hasOwnProperty.call(e, r) && n(t, e, r);
                    return o(t, e), t
                };
            Object.defineProperty(t, "__esModule", {
                value: !0
            }), t.pbkdf2Sha512 = t.pbkdf2Sha512Noble = t.pbkdf2Sha512NodeCrypto = t.pbkdf2Sha512Subtle = t.getSubtle = t.getNodeCrypto = void 0;
            let a = r(8261),
                s = r(29023),
                d = r(86262);
            async function c() {
                try {
                    let e = await Promise.resolve().then(() => i(r(42474)));
                    if ("object" == typeof e && Object.keys(e).length <= 1) return;
                    return e
                } catch {
                    return
                }
            }
            async function l() {
                let e = globalThis ? .crypto ? .subtle;
                return e || (e = globalThis ? .crypto ? .webcrypto ? .subtle), e
            }
            async function u(e, t, r, n, o) {
                return (0, a.assert)(e, "Argument subtle is falsy"), (0, a.assert)("object" == typeof e, "Argument subtle is not of type object"), (0, a.assert)("function" == typeof e.importKey, "subtle.importKey is not a function"), (0, a.assert)("function" == typeof e.deriveBits, "subtle.deriveBits is not a function"), e.importKey("raw", t, {
                    name: "PBKDF2"
                }, !1, ["deriveBits"]).then(t => e.deriveBits({
                    name: "PBKDF2",
                    salt: r,
                    iterations: n,
                    hash: {
                        name: "SHA-512"
                    }
                }, t, 8 * o).then(e => new Uint8Array(e)))
            }
            async function p(e, t, r, n, o) {
                return (0, a.assert)(e, "Argument nodeCrypto is falsy"), (0, a.assert)("object" == typeof e, "Argument nodeCrypto is not of type object"), (0, a.assert)("function" == typeof e.pbkdf2, "nodeCrypto.pbkdf2 is not a function"), new Promise((i, a) => {
                    e.pbkdf2(t, r, n, o, "sha512", (e, t) => {
                        e ? a(e) : i(Uint8Array.from(t))
                    })
                })
            }
            async function m(e, t, r, n) {
                return (0, s.pbkdf2Async)(d.sha512, e, t, {
                    c: r,
                    dkLen: n
                })
            }
            async function g(e, t, r, n) {
                let o = await l();
                if (o) return u(o, e, t, r, n); {
                    let o = await c();
                    return o ? p(o, e, t, r, n) : m(e, t, r, n)
                }
            }
            t.getNodeCrypto = c, t.getSubtle = l, t.pbkdf2Sha512Subtle = u, t.pbkdf2Sha512NodeCrypto = p, t.pbkdf2Sha512Noble = m, t.pbkdf2Sha512 = g
        },
        11296: function(e, t, r) {
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: !0
            }), t.Random = void 0;
            class n {
                static getBytes(e) {
                    try {
                        let t = "object" == typeof window ? window : self,
                            r = void 0 !== t.crypto ? t.crypto : t.msCrypto,
                            n = new Uint8Array(e);
                        return r.getRandomValues(n), n
                    } catch {
                        try {
                            let t = r(42474);
                            return new Uint8Array([...t.randomBytes(e)])
                        } catch {
                            throw Error("No secure random number generator found")
                        }
                    }
                }
            }
            t.Random = n
        },
        30839: function(e, t, r) {
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: !0
            }), t.ripemd160 = t.Ripemd160 = void 0;
            let n = r(70830),
                o = r(39764);
            class i {
                constructor(e) {
                    this.blockSize = 64, this.impl = n.ripemd160.create(), e && this.update(e)
                }
                update(e) {
                    return this.impl.update((0, o.toRealUint8Array)(e)), this
                }
                digest() {
                    return this.impl.digest()
                }
            }
            t.Ripemd160 = i, t.ripemd160 = function(e) {
                return new i(e).digest()
            }
        },
        36348: function(e, t, r) {
            "use strict";
            var n = this && this.__importDefault || function(e) {
                return e && e.__esModule ? e : {
                    default: e
                }
            };
            Object.defineProperty(t, "__esModule", {
                value: !0
            }), t.Secp256k1 = void 0;
            let o = r(81299),
                i = n(r(13550)),
                a = n(r(86266)),
                s = r(33885),
                d = new a.default.ec("secp256k1"),
                c = new i.default("FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141", "hex");
            class l {
                static async makeKeypair(e) {
                    if (32 !== e.length) throw Error("input data is not a valid secp256k1 private key");
                    let t = d.keyFromPrivate(e);
                    if (!0 !== t.validate().result || new i.default(e).gte(c)) throw Error("input data is not a valid secp256k1 private key");
                    return {
                        privkey: (0, o.fromHex)(t.getPrivate("hex")),
                        pubkey: Uint8Array.from(t.getPublic("array"))
                    }
                }
                static async createSignature(e, t) {
                    if (0 === e.length) throw Error("Message hash must not be empty");
                    if (e.length > 32) throw Error("Message hash length must not exceed 32 bytes");
                    let {
                        r,
                        s: n,
                        recoveryParam: o
                    } = d.keyFromPrivate(t).sign(e, {
                        canonical: !0
                    });
                    if ("number" != typeof o) throw Error("Recovery param missing");
                    return new s.ExtendedSecp256k1Signature(Uint8Array.from(r.toArray()), Uint8Array.from(n.toArray()), o)
                }
                static async verifySignature(e, t, r) {
                    if (0 === t.length) throw Error("Message hash must not be empty");
                    if (t.length > 32) throw Error("Message hash length must not exceed 32 bytes");
                    let n = d.keyFromPublic(r);
                    try {
                        return n.verify(t, e.toDer())
                    } catch (e) {
                        return !1
                    }
                }
                static recoverPubkey(e, t) {
                    let r = {
                            r: (0, o.toHex)(e.r()),
                            s: (0, o.toHex)(e.s())
                        },
                        n = d.recoverPubKey(t, r, e.recovery),
                        i = d.keyFromPublic(n);
                    return (0, o.fromHex)(i.getPublic(!1, "hex"))
                }
                static compressPubkey(e) {
                    switch (e.length) {
                        case 33:
                            return e;
                        case 65:
                            return Uint8Array.from(d.keyFromPublic(e).getPublic(!0, "array"));
                        default:
                            throw Error("Invalid pubkey length")
                    }
                }
                static uncompressPubkey(e) {
                    switch (e.length) {
                        case 33:
                            return Uint8Array.from(d.keyFromPublic(e).getPublic(!1, "array"));
                        case 65:
                            return e;
                        default:
                            throw Error("Invalid pubkey length")
                    }
                }
                static trimRecoveryByte(e) {
                    switch (e.length) {
                        case 64:
                            return e;
                        case 65:
                            return e.slice(0, 64);
                        default:
                            throw Error("Invalid signature length")
                    }
                }
            }
            t.Secp256k1 = l
        },
        33885: function(e, t) {
            "use strict";

            function r(e) {
                let t = 0;
                for (let r of e)
                    if (0 === r) t++;
                    else break;
                return e.slice(t)
            }
            Object.defineProperty(t, "__esModule", {
                value: !0
            }), t.ExtendedSecp256k1Signature = t.Secp256k1Signature = void 0;
            class n {
                static fromFixedLength(e) {
                    if (64 !== e.length) throw Error(`Got invalid data length: ${e.length}. Expected 2x 32 bytes for the pair (r, s)`);
                    return new n(r(e.slice(0, 32)), r(e.slice(32, 64)))
                }
                static fromDer(e) {
                    let t = 0;
                    if (48 !== e[t++]) throw Error("Prefix 0x30 expected");
                    let o = e[t++];
                    if (e.length - t !== o) throw Error("Data length mismatch detected");
                    if (2 !== e[t++]) throw Error("INTEGER tag expected");
                    let i = e[t++];
                    if (i >= 128) throw Error("Decoding length values above 127 not supported");
                    let a = e.slice(t, t + i);
                    if (t += i, 2 !== e[t++]) throw Error("INTEGER tag expected");
                    let s = e[t++];
                    if (s >= 128) throw Error("Decoding length values above 127 not supported");
                    let d = e.slice(t, t + s);
                    return t += s, new n(r(a), r(d))
                }
                constructor(e, t) {
                    if (e.length > 32 || 0 === e.length || 0 === e[0]) throw Error("Unsigned integer r must be encoded as unpadded big endian.");
                    if (t.length > 32 || 0 === t.length || 0 === t[0]) throw Error("Unsigned integer s must be encoded as unpadded big endian.");
                    this.data = {
                        r: e,
                        s: t
                    }
                }
                r(e) {
                    if (void 0 === e) return this.data.r; {
                        let t = e - this.data.r.length;
                        if (t < 0) throw Error("Length too small to hold parameter r");
                        let r = new Uint8Array(t);
                        return new Uint8Array([...r, ...this.data.r])
                    }
                }
                s(e) {
                    if (void 0 === e) return this.data.s; {
                        let t = e - this.data.s.length;
                        if (t < 0) throw Error("Length too small to hold parameter s");
                        let r = new Uint8Array(t);
                        return new Uint8Array([...r, ...this.data.s])
                    }
                }
                toFixedLength() {
                    return new Uint8Array([...this.r(32), ...this.s(32)])
                }
                toDer() {
                    let e = this.data.r[0] >= 128 ? new Uint8Array([0, ...this.data.r]) : this.data.r,
                        t = this.data.s[0] >= 128 ? new Uint8Array([0, ...this.data.s]) : this.data.s,
                        r = e.length,
                        n = t.length,
                        o = new Uint8Array([2, r, ...e, 2, n, ...t]);
                    return new Uint8Array([48, o.length, ...o])
                }
            }
            t.Secp256k1Signature = n;
            class o extends n {
                static fromFixedLength(e) {
                    if (65 !== e.length) throw Error(`Got invalid data length ${e.length}. Expected 32 + 32 + 1`);
                    return new o(r(e.slice(0, 32)), r(e.slice(32, 64)), e[64])
                }
                constructor(e, t, r) {
                    if (super(e, t), !Number.isInteger(r)) throw Error("The recovery parameter must be an integer.");
                    if (r < 0 || r > 4) throw Error("The recovery parameter must be one of 0, 1, 2, 3.");
                    this.recovery = r
                }
                toFixedLength() {
                    return new Uint8Array([...this.r(32), ...this.s(32), this.recovery])
                }
            }
            t.ExtendedSecp256k1Signature = o
        },
        51564: function(e, t, r) {
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: !0
            }), t.sha512 = t.Sha512 = t.sha256 = t.Sha256 = void 0;
            let n = r(23061),
                o = r(86262),
                i = r(39764);
            class a {
                constructor(e) {
                    this.blockSize = 64, this.impl = n.sha256.create(), e && this.update(e)
                }
                update(e) {
                    return this.impl.update((0, i.toRealUint8Array)(e)), this
                }
                digest() {
                    return this.impl.digest()
                }
            }
            t.Sha256 = a, t.sha256 = function(e) {
                return new a(e).digest()
            };
            class s {
                constructor(e) {
                    this.blockSize = 128, this.impl = o.sha512.create(), e && this.update(e)
                }
                update(e) {
                    return this.impl.update((0, i.toRealUint8Array)(e)), this
                }
                digest() {
                    return this.impl.digest()
                }
            }
            t.Sha512 = s, t.sha512 = function(e) {
                return new s(e).digest()
            }
        },
        46920: function(e, t, r) {
            "use strict";
            var n, o, i = this && this.__importDefault || function(e) {
                return e && e.__esModule ? e : {
                    default: e
                }
            };
            Object.defineProperty(t, "__esModule", {
                value: !0
            }), t.stringToPath = t.pathToString = t.Slip10 = t.Slip10RawIndex = t.slip10CurveFromString = t.Slip10Curve = void 0;
            let a = r(81299),
                s = r(82071),
                d = i(r(13550)),
                c = i(r(86266)),
                l = r(14276),
                u = r(51564);
            (n = o = t.Slip10Curve || (t.Slip10Curve = {})).Secp256k1 = "Bitcoin seed", n.Ed25519 = "ed25519 seed", t.slip10CurveFromString = function(e) {
                switch (e) {
                    case o.Ed25519:
                        return o.Ed25519;
                    case o.Secp256k1:
                        return o.Secp256k1;
                    default:
                        throw Error(`Unknown curve string: '${e}'`)
                }
            };
            class p extends s.Uint32 {
                static hardened(e) {
                    return new p(e + 2147483648)
                }
                static normal(e) {
                    return new p(e)
                }
                isHardened() {
                    return this.data >= 2147483648
                }
            }
            t.Slip10RawIndex = p;
            let m = new c.default.ec("secp256k1");
            class g {
                static derivePath(e, t, r) {
                    let n = this.master(e, t);
                    for (let t of r) n = this.child(e, n.privkey, n.chainCode, t);
                    return n
                }
                static master(e, t) {
                    let r = new l.Hmac(u.Sha512, (0, a.toAscii)(e)).update(t).digest(),
                        n = r.slice(0, 32),
                        i = r.slice(32, 64);
                    return e !== o.Ed25519 && (this.isZero(n) || this.isGteN(e, n)) ? this.master(e, r) : {
                        chainCode: i,
                        privkey: n
                    }
                }
                static child(e, t, r, n) {
                    let i;
                    if (n.isHardened()) {
                        let e = new Uint8Array([0, ...t, ...n.toBytesBigEndian()]);
                        i = new l.Hmac(u.Sha512, r).update(e).digest()
                    } else {
                        if (e === o.Ed25519) throw Error("Normal keys are not allowed with ed25519"); {
                            let o = new Uint8Array([...g.serializedPoint(e, new d.default(t)), ...n.toBytesBigEndian()]);
                            i = new l.Hmac(u.Sha512, r).update(o).digest()
                        }
                    }
                    return this.childImpl(e, t, r, n, i)
                }
                static serializedPoint(e, t) {
                    if (e === o.Secp256k1) return (0, a.fromHex)(m.g.mul(t).encodeCompressed("hex"));
                    throw Error("curve not supported")
                }
                static childImpl(e, t, r, n, i) {
                    let a = i.slice(0, 32),
                        s = i.slice(32, 64);
                    if (e === o.Ed25519) return {
                        chainCode: s,
                        privkey: a
                    };
                    let c = this.n(e),
                        p = new d.default(a).add(new d.default(t)).mod(c),
                        m = Uint8Array.from(p.toArray("be", 32));
                    if (this.isGteN(e, a) || this.isZero(m)) {
                        let o = new l.Hmac(u.Sha512, r).update(new Uint8Array([1, ...s, ...n.toBytesBigEndian()])).digest();
                        return this.childImpl(e, t, r, n, o)
                    }
                    return {
                        chainCode: s,
                        privkey: m
                    }
                }
                static isZero(e) {
                    return e.every(e => 0 === e)
                }
                static isGteN(e, t) {
                    return new d.default(t).gte(this.n(e))
                }
                static n(e) {
                    if (e === o.Secp256k1) return new d.default("FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141", 16);
                    throw Error("curve not supported")
                }
            }
            t.Slip10 = g, t.pathToString = function(e) {
                return e.reduce((e, t) => e + "/" + (t.isHardened() ? `${t.toNumber()-2147483648}'` : t.toString()), "m")
            }, t.stringToPath = function(e) {
                if (!e.startsWith("m")) throw Error("Path string must start with 'm'");
                let t = e.slice(1),
                    r = [];
                for (; t;) {
                    let e = t.match(/^\/([0-9]+)('?)/);
                    if (!e) throw Error("Syntax error while reading path component");
                    let [n, o, i] = e, a = s.Uint53.fromString(o).toNumber();
                    if (a >= 2147483648) throw Error("Component value too high. Must not exceed 2**31-1.");
                    i ? r.push(p.hardened(a)) : r.push(p.normal(a)), t = t.slice(n.length)
                }
                return r
            }
        },
        39764: function(e, t) {
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: !0
            }), t.toRealUint8Array = void 0, t.toRealUint8Array = function(e) {
                return e instanceof Uint8Array ? e : Uint8Array.from(e)
            }
        },
        60480: function(e, t) {
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: !0
            }), t.fromAscii = t.toAscii = void 0, t.toAscii = function(e) {
                return Uint8Array.from(e.split("").map(e => {
                    let t = e.charCodeAt(0);
                    if (t < 32 || t > 126) throw Error("Cannot encode character that is out of printable ASCII range: " + t);
                    return t
                }))
            }, t.fromAscii = function(e) {
                return Array.from(e).map(e => {
                    if (e < 32 || e > 126) throw Error("Cannot decode character that is out of printable ASCII range: " + e);
                    return String.fromCharCode(e)
                }).join("")
            }
        },
        84964: function(e, t, r) {
            "use strict";
            var n = this && this.__createBinding || (Object.create ? function(e, t, r, n) {
                    void 0 === n && (n = r);
                    var o = Object.getOwnPropertyDescriptor(t, r);
                    (!o || ("get" in o ? !t.__esModule : o.writable || o.configurable)) && (o = {
                        enumerable: !0,
                        get: function() {
                            return t[r]
                        }
                    }), Object.defineProperty(e, n, o)
                } : function(e, t, r, n) {
                    void 0 === n && (n = r), e[n] = t[r]
                }),
                o = this && this.__setModuleDefault || (Object.create ? function(e, t) {
                    Object.defineProperty(e, "default", {
                        enumerable: !0,
                        value: t
                    })
                } : function(e, t) {
                    e.default = t
                }),
                i = this && this.__importStar || function(e) {
                    if (e && e.__esModule) return e;
                    var t = {};
                    if (null != e)
                        for (var r in e) "default" !== r && Object.prototype.hasOwnProperty.call(e, r) && n(t, e, r);
                    return o(t, e), t
                };
            Object.defineProperty(t, "__esModule", {
                value: !0
            }), t.fromBase64 = t.toBase64 = void 0;
            let a = i(r(79742));
            t.toBase64 = function(e) {
                return a.fromByteArray(e)
            }, t.fromBase64 = function(e) {
                if (!e.match(/^[a-zA-Z0-9+/]*={0,2}$/)) throw Error("Invalid base64 string format");
                return a.toByteArray(e)
            }
        },
        46582: function(e, t, r) {
            "use strict";
            var n = this && this.__createBinding || (Object.create ? function(e, t, r, n) {
                    void 0 === n && (n = r);
                    var o = Object.getOwnPropertyDescriptor(t, r);
                    (!o || ("get" in o ? !t.__esModule : o.writable || o.configurable)) && (o = {
                        enumerable: !0,
                        get: function() {
                            return t[r]
                        }
                    }), Object.defineProperty(e, n, o)
                } : function(e, t, r, n) {
                    void 0 === n && (n = r), e[n] = t[r]
                }),
                o = this && this.__setModuleDefault || (Object.create ? function(e, t) {
                    Object.defineProperty(e, "default", {
                        enumerable: !0,
                        value: t
                    })
                } : function(e, t) {
                    e.default = t
                }),
                i = this && this.__importStar || function(e) {
                    if (e && e.__esModule) return e;
                    var t = {};
                    if (null != e)
                        for (var r in e) "default" !== r && Object.prototype.hasOwnProperty.call(e, r) && n(t, e, r);
                    return o(t, e), t
                };
            Object.defineProperty(t, "__esModule", {
                value: !0
            }), t.normalizeBech32 = t.fromBech32 = t.toBech32 = void 0;
            let a = i(r(60590));

            function s(e, t, r) {
                return a.encode(e, a.toWords(t), r)
            }

            function d(e, t = 1 / 0) {
                let r = a.decode(e, t);
                return {
                    prefix: r.prefix,
                    data: new Uint8Array(a.fromWords(r.words))
                }
            }
            t.toBech32 = s, t.fromBech32 = d, t.normalizeBech32 = function(e) {
                let {
                    prefix: t,
                    data: r
                } = d(e);
                return s(t, r)
            }
        },
        7859: function(e, t) {
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: !0
            }), t.fromHex = t.toHex = void 0, t.toHex = function(e) {
                let t = "";
                for (let r of e) t += ("0" + r.toString(16)).slice(-2);
                return t
            }, t.fromHex = function(e) {
                if (e.length % 2 != 0) throw Error("hex string length must be a multiple of 2");
                let t = new Uint8Array(e.length / 2);
                for (let r = 0; r < t.length; r++) {
                    let n = 2 * r,
                        o = e.slice(n, n + 2);
                    if (!o.match(/[0-9a-f]{2}/i)) throw Error("hex string contains invalid characters");
                    t[r] = parseInt(o, 16)
                }
                return t
            }
        },
        81299: function(e, t, r) {
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: !0
            }), t.toUtf8 = t.fromUtf8 = t.toRfc3339 = t.fromRfc3339 = t.toHex = t.fromHex = t.toBech32 = t.normalizeBech32 = t.fromBech32 = t.toBase64 = t.fromBase64 = t.toAscii = t.fromAscii = void 0;
            var n = r(60480);
            Object.defineProperty(t, "fromAscii", {
                enumerable: !0,
                get: function() {
                    return n.fromAscii
                }
            }), Object.defineProperty(t, "toAscii", {
                enumerable: !0,
                get: function() {
                    return n.toAscii
                }
            });
            var o = r(84964);
            Object.defineProperty(t, "fromBase64", {
                enumerable: !0,
                get: function() {
                    return o.fromBase64
                }
            }), Object.defineProperty(t, "toBase64", {
                enumerable: !0,
                get: function() {
                    return o.toBase64
                }
            });
            var i = r(46582);
            Object.defineProperty(t, "fromBech32", {
                enumerable: !0,
                get: function() {
                    return i.fromBech32
                }
            }), Object.defineProperty(t, "normalizeBech32", {
                enumerable: !0,
                get: function() {
                    return i.normalizeBech32
                }
            }), Object.defineProperty(t, "toBech32", {
                enumerable: !0,
                get: function() {
                    return i.toBech32
                }
            });
            var a = r(7859);
            Object.defineProperty(t, "fromHex", {
                enumerable: !0,
                get: function() {
                    return a.fromHex
                }
            }), Object.defineProperty(t, "toHex", {
                enumerable: !0,
                get: function() {
                    return a.toHex
                }
            });
            var s = r(3063);
            Object.defineProperty(t, "fromRfc3339", {
                enumerable: !0,
                get: function() {
                    return s.fromRfc3339
                }
            }), Object.defineProperty(t, "toRfc3339", {
                enumerable: !0,
                get: function() {
                    return s.toRfc3339
                }
            });
            var d = r(62518);
            Object.defineProperty(t, "fromUtf8", {
                enumerable: !0,
                get: function() {
                    return d.fromUtf8
                }
            }), Object.defineProperty(t, "toUtf8", {
                enumerable: !0,
                get: function() {
                    return d.toUtf8
                }
            })
        },
        3063: function(e, t) {
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: !0
            }), t.toRfc3339 = t.fromRfc3339 = void 0;
            let r = /^(\d{4})-(\d{2})-(\d{2})[T ](\d{2}):(\d{2}):(\d{2})(\.\d{1,9})?((?:[+-]\d{2}:\d{2})|Z)$/;

            function n(e, t = 2) {
                return e.toString().padStart(t, "0")
            }
            t.fromRfc3339 = function(e) {
                let t, n, o;
                let i = r.exec(e);
                if (!i) throw Error("Date string is not in RFC3339 format");
                let a = +i[1],
                    s = +i[2],
                    d = +i[3],
                    c = +i[4],
                    l = +i[5],
                    u = +i[6],
                    p = i[7] ? Math.floor(1e3 * +i[7]) : 0;
                "Z" === i[8] ? (t = 1, n = 0, o = 0) : (t = "-" === i[8].substring(0, 1) ? -1 : 1, n = +i[8].substring(1, 3), o = +i[8].substring(4, 6));
                let m = t * (60 * n + o) * 60,
                    g = new Date;
                return g.setUTCFullYear(a, s - 1, d), g.setUTCHours(c, l, u, p), new Date(g.getTime() - 1e3 * m)
            }, t.toRfc3339 = function(e) {
                let t = e.getUTCFullYear(),
                    r = n(e.getUTCMonth() + 1),
                    o = n(e.getUTCDate()),
                    i = n(e.getUTCHours()),
                    a = n(e.getUTCMinutes()),
                    s = n(e.getUTCSeconds()),
                    d = n(e.getUTCMilliseconds(), 3);
                return `${t}-${r}-${o}T${i}:${a}:${s}.${d}Z`
            }
        },
        62518: function(e, t) {
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: !0
            }), t.fromUtf8 = t.toUtf8 = void 0, t.toUtf8 = function(e) {
                return new TextEncoder().encode(e)
            }, t.fromUtf8 = function(e, t = !1) {
                return new TextDecoder("utf-8", {
                    fatal: !t
                }).decode(e)
            }
        },
        44969: function(e, t) {
            "use strict";

            function r(e) {
                return !!("string" == typeof e || "number" == typeof e || "boolean" == typeof e || null === e || n(e) || o(e))
            }

            function n(e) {
                if (!Array.isArray(e)) return !1;
                for (let t of e)
                    if (!r(t)) return !1;
                return !0
            }

            function o(e) {
                return "object" == typeof e && null !== e && "[object Object]" === Object.prototype.toString.call(e) && Object.values(e).every(r)
            }
            Object.defineProperty(t, "__esModule", {
                value: !0
            }), t.isJsonCompatibleDictionary = t.isJsonCompatibleArray = t.isJsonCompatibleValue = void 0, t.isJsonCompatibleValue = r, t.isJsonCompatibleArray = n, t.isJsonCompatibleDictionary = o
        },
        26274: function(e, t) {
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: !0
            }), t.makeJsonRpcId = void 0;
            let r = 1e4;
            t.makeJsonRpcId = function() {
                return r += 1
            }
        },
        83348: function(e, t, r) {
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: !0
            }), t.jsonRpcCode = t.isJsonRpcSuccessResponse = t.isJsonRpcErrorResponse = t.parseJsonRpcSuccessResponse = t.parseJsonRpcResponse = t.parseJsonRpcRequest = t.parseJsonRpcId = t.parseJsonRpcErrorResponse = t.JsonRpcClient = t.makeJsonRpcId = void 0;
            var n = r(26274);
            Object.defineProperty(t, "makeJsonRpcId", {
                enumerable: !0,
                get: function() {
                    return n.makeJsonRpcId
                }
            });
            var o = r(4700);
            Object.defineProperty(t, "JsonRpcClient", {
                enumerable: !0,
                get: function() {
                    return o.JsonRpcClient
                }
            });
            var i = r(27551);
            Object.defineProperty(t, "parseJsonRpcErrorResponse", {
                enumerable: !0,
                get: function() {
                    return i.parseJsonRpcErrorResponse
                }
            }), Object.defineProperty(t, "parseJsonRpcId", {
                enumerable: !0,
                get: function() {
                    return i.parseJsonRpcId
                }
            }), Object.defineProperty(t, "parseJsonRpcRequest", {
                enumerable: !0,
                get: function() {
                    return i.parseJsonRpcRequest
                }
            }), Object.defineProperty(t, "parseJsonRpcResponse", {
                enumerable: !0,
                get: function() {
                    return i.parseJsonRpcResponse
                }
            }), Object.defineProperty(t, "parseJsonRpcSuccessResponse", {
                enumerable: !0,
                get: function() {
                    return i.parseJsonRpcSuccessResponse
                }
            });
            var a = r(73121);
            Object.defineProperty(t, "isJsonRpcErrorResponse", {
                enumerable: !0,
                get: function() {
                    return a.isJsonRpcErrorResponse
                }
            }), Object.defineProperty(t, "isJsonRpcSuccessResponse", {
                enumerable: !0,
                get: function() {
                    return a.isJsonRpcSuccessResponse
                }
            }), Object.defineProperty(t, "jsonRpcCode", {
                enumerable: !0,
                get: function() {
                    return a.jsonRpcCode
                }
            })
        },
        4700: function(e, t, r) {
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: !0
            }), t.JsonRpcClient = void 0;
            let n = r(59210),
                o = r(73121);
            class i {
                constructor(e) {
                    this.connection = e
                }
                async run(e) {
                    let t = this.connection.responseStream.filter(t => t.id === e.id),
                        r = (0, n.firstEvent)(t);
                    this.connection.sendRequest(e);
                    let i = await r;
                    if ((0, o.isJsonRpcErrorResponse)(i)) {
                        let e = i.error;
                        throw Error(`JSON RPC error: code=${e.code}; message='${e.message}'`)
                    }
                    return i
                }
            }
            t.JsonRpcClient = i
        },
        27551: function(e, t, r) {
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: !0
            }), t.parseJsonRpcResponse = t.parseJsonRpcSuccessResponse = t.parseJsonRpcErrorResponse = t.parseJsonRpcRequest = t.parseJsonRpcId = void 0;
            let n = r(44969);

            function o(e) {
                if (!(0, n.isJsonCompatibleDictionary)(e)) throw Error("Data must be JSON compatible dictionary");
                let t = e.id;
                return "number" != typeof t && "string" != typeof t ? null : t
            }

            function i(e) {
                if (!(0, n.isJsonCompatibleDictionary)(e)) throw Error("Data must be JSON compatible dictionary");
                if ("2.0" !== e.jsonrpc) throw Error(`Got unexpected jsonrpc version: ${JSON.stringify(e)}`);
                let t = e.id;
                if ("number" != typeof t && "string" != typeof t && null !== t) throw Error("Invalid id field");
                if (void 0 === e.error || !(0, n.isJsonCompatibleDictionary)(e.error)) throw Error("Invalid error field");
                return {
                    jsonrpc: "2.0",
                    id: t,
                    error: function(e) {
                        let t;
                        if ("number" != typeof e.code) throw Error("Error property 'code' is not a number");
                        if ("string" != typeof e.message) throw Error("Error property 'message' is not a string");
                        if (void 0 === e.data) t = void 0;
                        else if ((0, n.isJsonCompatibleValue)(e.data)) t = e.data;
                        else throw Error("Error property 'data' is defined but not a JSON compatible value.");
                        return {
                            code: e.code,
                            message: e.message,
                            ...void 0 !== t ? {
                                data: t
                            } : {}
                        }
                    }(e.error)
                }
            }

            function a(e) {
                if (!(0, n.isJsonCompatibleDictionary)(e)) throw Error("Data must be JSON compatible dictionary");
                if ("2.0" !== e.jsonrpc) throw Error(`Got unexpected jsonrpc version: ${JSON.stringify(e)}`);
                let t = e.id;
                if ("number" != typeof t && "string" != typeof t) throw Error("Invalid id field");
                if (void 0 === e.result) throw Error("Invalid result field");
                return {
                    jsonrpc: "2.0",
                    id: t,
                    result: e.result
                }
            }
            t.parseJsonRpcId = o, t.parseJsonRpcRequest = function(e) {
                if (!(0, n.isJsonCompatibleDictionary)(e)) throw Error("Data must be JSON compatible dictionary");
                if ("2.0" !== e.jsonrpc) throw Error(`Got unexpected jsonrpc version: ${e.jsonrpc}`);
                let t = o(e);
                if (null === t) throw Error("Invalid id field");
                let r = e.method;
                if ("string" != typeof r) throw Error("Invalid method field");
                if (!(0, n.isJsonCompatibleArray)(e.params) && !(0, n.isJsonCompatibleDictionary)(e.params)) throw Error("Invalid params field");
                return {
                    jsonrpc: "2.0",
                    id: t,
                    method: r,
                    params: e.params
                }
            }, t.parseJsonRpcErrorResponse = i, t.parseJsonRpcSuccessResponse = a, t.parseJsonRpcResponse = function(e) {
                let t;
                try {
                    t = i(e)
                } catch (r) {
                    t = a(e)
                }
                return t
            }
        },
        73121: function(e, t) {
            "use strict";

            function r(e) {
                return "object" == typeof e.error
            }
            Object.defineProperty(t, "__esModule", {
                value: !0
            }), t.jsonRpcCode = t.isJsonRpcSuccessResponse = t.isJsonRpcErrorResponse = void 0, t.isJsonRpcErrorResponse = r, t.isJsonRpcSuccessResponse = function(e) {
                return !r(e)
            }, t.jsonRpcCode = {
                parseError: -32700,
                invalidRequest: -32600,
                methodNotFound: -32601,
                invalidParams: -32602,
                internalError: -32603,
                serverError: {
                    default: -32e3
                }
            }
        },
        81835: function(e, t, r) {
            "use strict";
            var n = this && this.__importDefault || function(e) {
                return e && e.__esModule ? e : {
                    default: e
                }
            };
            Object.defineProperty(t, "__esModule", {
                value: !0
            }), t.Decimal = void 0;
            let o = n(r(13550));
            class i {
                static fromUserInput(e, t) {
                    let r, n;
                    i.verifyFractionalDigits(t);
                    let o = e.match(/[^0-9.]/);
                    if (o) throw Error(`Invalid character at position ${o.index+1}`);
                    if ("" === e) r = "0", n = "";
                    else if (-1 === e.search(/\./)) r = e, n = "";
                    else {
                        let t = e.split(".");
                        switch (t.length) {
                            case 0:
                            case 1:
                                throw Error("Fewer than two elements in split result. This must not happen here.");
                            case 2:
                                if (!t[1]) throw Error("Fractional part missing");
                                r = t[0], n = t[1].replace(/0+$/, "");
                                break;
                            default:
                                throw Error("More than one separator found")
                        }
                    }
                    if (n.length > t) throw Error("Got more fractional digits than supported");
                    return new i(`${r}${n.padEnd(t,"0")}`, t)
                }
                static fromAtomics(e, t) {
                    return i.verifyFractionalDigits(t), new i(e, t)
                }
                static zero(e) {
                    return i.verifyFractionalDigits(e), new i("0", e)
                }
                static one(e) {
                    return i.verifyFractionalDigits(e), new i("1" + "0".repeat(e), e)
                }
                static verifyFractionalDigits(e) {
                    if (!Number.isInteger(e)) throw Error("Fractional digits is not an integer");
                    if (e < 0) throw Error("Fractional digits must not be negative");
                    if (e > 100) throw Error("Fractional digits must not exceed 100")
                }
                static compare(e, t) {
                    if (e.fractionalDigits !== t.fractionalDigits) throw Error("Fractional digits do not match");
                    return e.data.atomics.cmp(new o.default(t.atomics))
                }
                get atomics() {
                    return this.data.atomics.toString()
                }
                get fractionalDigits() {
                    return this.data.fractionalDigits
                }
                constructor(e, t) {
                    if (!e.match(/^[0-9]+$/)) throw Error("Invalid string format. Only non-negative integers in decimal representation supported.");
                    this.data = {
                        atomics: new o.default(e),
                        fractionalDigits: t
                    }
                }
                clone() {
                    return new i(this.atomics, this.fractionalDigits)
                }
                floor() {
                    let e = new o.default(10).pow(new o.default(this.data.fractionalDigits)),
                        t = this.data.atomics.div(e);
                    return this.data.atomics.mod(e).isZero() ? this.clone() : i.fromAtomics(t.mul(e).toString(), this.fractionalDigits)
                }
                ceil() {
                    let e = new o.default(10).pow(new o.default(this.data.fractionalDigits)),
                        t = this.data.atomics.div(e);
                    return this.data.atomics.mod(e).isZero() ? this.clone() : i.fromAtomics(t.addn(1).mul(e).toString(), this.fractionalDigits)
                }
                toString() {
                    let e = new o.default(10).pow(new o.default(this.data.fractionalDigits)),
                        t = this.data.atomics.div(e),
                        r = this.data.atomics.mod(e);
                    if (r.isZero()) return t.toString(); {
                        let e = r.toString().padStart(this.data.fractionalDigits, "0").replace(/0+$/, "");
                        return `${t.toString()}.${e}`
                    }
                }
                toFloatApproximation() {
                    let e = Number(this.toString());
                    if (Number.isNaN(e)) throw Error("Conversion to number failed");
                    return e
                }
                plus(e) {
                    if (this.fractionalDigits !== e.fractionalDigits) throw Error("Fractional digits do not match");
                    return new i(this.data.atomics.add(new o.default(e.atomics)).toString(), this.fractionalDigits)
                }
                minus(e) {
                    if (this.fractionalDigits !== e.fractionalDigits) throw Error("Fractional digits do not match");
                    let t = this.data.atomics.sub(new o.default(e.atomics));
                    if (t.ltn(0)) throw Error("Difference must not be negative");
                    return new i(t.toString(), this.fractionalDigits)
                }
                multiply(e) {
                    return new i(this.data.atomics.mul(new o.default(e.toString())).toString(), this.fractionalDigits)
                }
                equals(e) {
                    return 0 === i.compare(this, e)
                }
                isLessThan(e) {
                    return 0 > i.compare(this, e)
                }
                isLessThanOrEqual(e) {
                    return 0 >= i.compare(this, e)
                }
                isGreaterThan(e) {
                    return i.compare(this, e) > 0
                }
                isGreaterThanOrEqual(e) {
                    return i.compare(this, e) >= 0
                }
            }
            t.Decimal = i
        },
        82071: function(e, t, r) {
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: !0
            }), t.Uint64 = t.Uint53 = t.Uint32 = t.Int53 = t.Decimal = void 0;
            var n = r(81835);
            Object.defineProperty(t, "Decimal", {
                enumerable: !0,
                get: function() {
                    return n.Decimal
                }
            });
            var o = r(17703);
            Object.defineProperty(t, "Int53", {
                enumerable: !0,
                get: function() {
                    return o.Int53
                }
            }), Object.defineProperty(t, "Uint32", {
                enumerable: !0,
                get: function() {
                    return o.Uint32
                }
            }), Object.defineProperty(t, "Uint53", {
                enumerable: !0,
                get: function() {
                    return o.Uint53
                }
            }), Object.defineProperty(t, "Uint64", {
                enumerable: !0,
                get: function() {
                    return o.Uint64
                }
            })
        },
        17703: function(e, t, r) {
            "use strict";
            var n = this && this.__importDefault || function(e) {
                return e && e.__esModule ? e : {
                    default: e
                }
            };
            Object.defineProperty(t, "__esModule", {
                value: !0
            }), t.Uint64 = t.Uint53 = t.Int53 = t.Uint32 = void 0;
            let o = n(r(13550)),
                i = new o.default("18446744073709551615", 10, "be");
            class a {
                static fromBigEndianBytes(e) {
                    return a.fromBytes(e)
                }
                static fromBytes(e, t = "be") {
                    if (4 !== e.length) throw Error("Invalid input length. Expected 4 bytes.");
                    for (let t = 0; t < e.length; ++t)
                        if (!Number.isInteger(e[t]) || e[t] > 255 || e[t] < 0) throw Error("Invalid value in byte. Found: " + e[t]);
                    let r = "be" === t ? e : Array.from(e).reverse();
                    return new a(16777216 * r[0] + 65536 * r[1] + 256 * r[2] + r[3])
                }
                static fromString(e) {
                    if (!e.match(/^[0-9]+$/)) throw Error("Invalid string format");
                    return new a(Number.parseInt(e, 10))
                }
                constructor(e) {
                    if (Number.isNaN(e)) throw Error("Input is not a number");
                    if (!Number.isInteger(e)) throw Error("Input is not an integer");
                    if (e < 0 || e > 4294967295) throw Error("Input not in uint32 range: " + e.toString());
                    this.data = e
                }
                toBytesBigEndian() {
                    return new Uint8Array([255 & Math.floor(this.data / 16777216), 255 & Math.floor(this.data / 65536), 255 & Math.floor(this.data / 256), 255 & Math.floor(this.data / 1)])
                }
                toBytesLittleEndian() {
                    return new Uint8Array([255 & Math.floor(this.data / 1), 255 & Math.floor(this.data / 256), 255 & Math.floor(this.data / 65536), 255 & Math.floor(this.data / 16777216)])
                }
                toNumber() {
                    return this.data
                }
                toBigInt() {
                    return BigInt(this.toNumber())
                }
                toString() {
                    return this.data.toString()
                }
            }
            t.Uint32 = a;
            class s {
                static fromString(e) {
                    if (!e.match(/^-?[0-9]+$/)) throw Error("Invalid string format");
                    return new s(Number.parseInt(e, 10))
                }
                constructor(e) {
                    if (Number.isNaN(e)) throw Error("Input is not a number");
                    if (!Number.isInteger(e)) throw Error("Input is not an integer");
                    if (e < Number.MIN_SAFE_INTEGER || e > Number.MAX_SAFE_INTEGER) throw Error("Input not in int53 range: " + e.toString());
                    this.data = e
                }
                toNumber() {
                    return this.data
                }
                toBigInt() {
                    return BigInt(this.toNumber())
                }
                toString() {
                    return this.data.toString()
                }
            }
            t.Int53 = s;
            class d {
                static fromString(e) {
                    return new d(s.fromString(e).toNumber())
                }
                constructor(e) {
                    let t = new s(e);
                    if (0 > t.toNumber()) throw Error("Input is negative");
                    this.data = t
                }
                toNumber() {
                    return this.data.toNumber()
                }
                toBigInt() {
                    return BigInt(this.toNumber())
                }
                toString() {
                    return this.data.toString()
                }
            }
            t.Uint53 = d;
            class c {
                static fromBytesBigEndian(e) {
                    return c.fromBytes(e)
                }
                static fromBytes(e, t = "be") {
                    if (8 !== e.length) throw Error("Invalid input length. Expected 8 bytes.");
                    for (let t = 0; t < e.length; ++t)
                        if (!Number.isInteger(e[t]) || e[t] > 255 || e[t] < 0) throw Error("Invalid value in byte. Found: " + e[t]);
                    let r = "be" === t ? Array.from(e) : Array.from(e).reverse();
                    return new c(new o.default(r))
                }
                static fromString(e) {
                    if (!e.match(/^[0-9]+$/)) throw Error("Invalid string format");
                    return new c(new o.default(e, 10, "be"))
                }
                static fromNumber(e) {
                    let t;
                    if (Number.isNaN(e)) throw Error("Input is not a number");
                    if (!Number.isInteger(e)) throw Error("Input is not an integer");
                    try {
                        t = new o.default(e)
                    } catch {
                        throw Error("Input is not a safe integer")
                    }
                    return new c(t)
                }
                constructor(e) {
                    if (e.isNeg()) throw Error("Input is negative");
                    if (e.gt(i)) throw Error("Input exceeds uint64 range");
                    this.data = e
                }
                toBytesBigEndian() {
                    return Uint8Array.from(this.data.toArray("be", 8))
                }
                toBytesLittleEndian() {
                    return Uint8Array.from(this.data.toArray("le", 8))
                }
                toString() {
                    return this.data.toString(10)
                }
                toBigInt() {
                    return BigInt(this.toString())
                }
                toNumber() {
                    return this.data.toNumber()
                }
            }
            t.Uint64 = c
        },
        32285: function(e, t) {
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: !0
            }), t.parseCoins = void 0, t.parseCoins = function(e) {
                return e.replace(/\s/g, "").split(",").filter(Boolean).map(e => {
                    let t = e.match(/^([0-9]+)([a-zA-Z][a-zA-Z0-9/]{2,127})$/);
                    if (!t) throw Error("Got an invalid coin string");
                    return {
                        amount: t[1].replace(/^0+/, "") || "0",
                        denom: t[2]
                    }
                })
            }
        },
        48692: function(e, t, r) {
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: !0
            }), t.decodeTxRaw = void 0;
            let n = r(9858);
            t.decodeTxRaw = function(e) {
                let t = n.TxRaw.decode(e);
                return {
                    authInfo: n.AuthInfo.decode(t.authInfoBytes),
                    body: n.TxBody.decode(t.bodyBytes),
                    signatures: t.signatures
                }
            }
        },
        85743: function(e, t, r) {
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: !0
            }), t.DirectSecp256k1HdWallet = t.extractKdfConfiguration = void 0;
            let n = r(69693),
                o = r(46495),
                i = r(81299),
                a = r(8261),
                s = r(87076),
                d = r(36405),
                c = "directsecp256k1hdwallet-v1",
                l = {
                    algorithm: "argon2id",
                    params: {
                        outputLength: 32,
                        opsLimit: 24,
                        memLimitKib: 12288
                    }
                };
            t.extractKdfConfiguration = function(e) {
                let t = JSON.parse(e);
                if (!(0, a.isNonNullObject)(t)) throw Error("Root document is not an object.");
                if (t.type === c) return t.kdf;
                throw Error("Unsupported serialization type")
            };
            let u = {
                bip39Password: "",
                hdPaths: [(0, n.makeCosmoshubPath)(0)],
                prefix: "cosmos"
            };
            class p {
                static async fromMnemonic(e, t = {}) {
                    let r = new o.EnglishMnemonic(e),
                        n = await o.Bip39.mnemonicToSeed(r, t.bip39Password);
                    return new p(r, { ...t,
                        seed: n
                    })
                }
                static async generate(e = 12, t = {}) {
                    let r = o.Random.getBytes(4 * Math.floor(11 * e / 33)),
                        n = o.Bip39.encode(r);
                    return p.fromMnemonic(n.toString(), t)
                }
                static async deserialize(e, t) {
                    let r = JSON.parse(e);
                    if (!(0, a.isNonNullObject)(r)) throw Error("Root document is not an object.");
                    if (r.type === c) return p.deserializeTypeV1(e, t);
                    throw Error("Unsupported serialization type")
                }
                static async deserializeWithEncryptionKey(e, t) {
                    let r = JSON.parse(e);
                    if (!(0, a.isNonNullObject)(r)) throw Error("Root document is not an object.");
                    if (r.type === c) {
                        let e = await (0, d.decrypt)((0, i.fromBase64)(r.data), t, r.encryption),
                            {
                                mnemonic: n,
                                accounts: s
                            } = JSON.parse((0, i.fromUtf8)(e));
                        if ((0, a.assert)("string" == typeof n), !Array.isArray(s)) throw Error("Property 'accounts' is not an array");
                        if (!s.every(e => !!(0, a.isNonNullObject)(e) && "string" == typeof e.hdPath && "string" == typeof e.prefix)) throw Error("Account is not in the correct format.");
                        let c = s[0].prefix;
                        if (!s.every(({
                                prefix: e
                            }) => e === c)) throw Error("Accounts do not all have the same prefix");
                        let l = s.map(({
                            hdPath: e
                        }) => (0, o.stringToPath)(e));
                        return p.fromMnemonic(n, {
                            hdPaths: l,
                            prefix: c
                        })
                    }
                    throw Error("Unsupported serialization type")
                }
                static async deserializeTypeV1(e, t) {
                    let r = JSON.parse(e);
                    if (!(0, a.isNonNullObject)(r)) throw Error("Root document is not an object.");
                    let n = await (0, d.executeKdf)(t, r.kdf);
                    return p.deserializeWithEncryptionKey(e, n)
                }
                constructor(e, t) {
                    let r = t.prefix ? ? u.prefix,
                        n = t.hdPaths ? ? u.hdPaths;
                    this.secret = e, this.seed = t.seed, this.accounts = n.map(e => ({
                        hdPath: e,
                        prefix: r
                    }))
                }
                get mnemonic() {
                    return this.secret.toString()
                }
                async getAccounts() {
                    return (await this.getAccountsWithPrivkeys()).map(({
                        algo: e,
                        pubkey: t,
                        address: r
                    }) => ({
                        algo: e,
                        pubkey: t,
                        address: r
                    }))
                }
                async signDirect(e, t) {
                    let r = (await this.getAccountsWithPrivkeys()).find(({
                        address: t
                    }) => t === e);
                    if (void 0 === r) throw Error(`Address ${e} not found in wallet`);
                    let {
                        privkey: i,
                        pubkey: a
                    } = r, d = (0, s.makeSignBytes)(t), c = (0, o.sha256)(d), l = await o.Secp256k1.createSignature(c, i), u = new Uint8Array([...l.r(32), ...l.s(32)]);
                    return {
                        signed: t,
                        signature: (0, n.encodeSecp256k1Signature)(a, u)
                    }
                }
                async serialize(e) {
                    let t = await (0, d.executeKdf)(e, l);
                    return this.serializeWithEncryptionKey(t, l)
                }
                async serializeWithEncryptionKey(e, t) {
                    let r = {
                            mnemonic: this.mnemonic,
                            accounts: this.accounts.map(({
                                hdPath: e,
                                prefix: t
                            }) => ({
                                hdPath: (0, o.pathToString)(e),
                                prefix: t
                            }))
                        },
                        n = (0, i.toUtf8)(JSON.stringify(r)),
                        a = {
                            algorithm: d.supportedAlgorithms.xchacha20poly1305Ietf
                        },
                        s = await (0, d.encrypt)(n, e, a);
                    return JSON.stringify({
                        type: c,
                        kdf: t,
                        encryption: a,
                        data: (0, i.toBase64)(s)
                    })
                }
                async getKeyPair(e) {
                    let {
                        privkey: t
                    } = o.Slip10.derivePath(o.Slip10Curve.Secp256k1, this.seed, e), {
                        pubkey: r
                    } = await o.Secp256k1.makeKeypair(t);
                    return {
                        privkey: t,
                        pubkey: o.Secp256k1.compressPubkey(r)
                    }
                }
                async getAccountsWithPrivkeys() {
                    return Promise.all(this.accounts.map(async ({
                        hdPath: e,
                        prefix: t
                    }) => {
                        let {
                            privkey: r,
                            pubkey: o
                        } = await this.getKeyPair(e), a = (0, i.toBech32)(t, (0, n.rawSecp256k1PubkeyToRawAddress)(o));
                        return {
                            algo: "secp256k1",
                            privkey: r,
                            pubkey: o,
                            address: a
                        }
                    }))
                }
            }
            t.DirectSecp256k1HdWallet = p
        },
        92070: function(e, t, r) {
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: !0
            }), t.DirectSecp256k1Wallet = void 0;
            let n = r(69693),
                o = r(46495),
                i = r(81299),
                a = r(87076);
            class s {
                static async fromKey(e, t = "cosmos") {
                    let r = (await o.Secp256k1.makeKeypair(e)).pubkey;
                    return new s(e, o.Secp256k1.compressPubkey(r), t)
                }
                constructor(e, t, r) {
                    this.privkey = e, this.pubkey = t, this.prefix = r
                }
                get address() {
                    return (0, i.toBech32)(this.prefix, (0, n.rawSecp256k1PubkeyToRawAddress)(this.pubkey))
                }
                async getAccounts() {
                    return [{
                        algo: "secp256k1",
                        address: this.address,
                        pubkey: this.pubkey
                    }]
                }
                async signDirect(e, t) {
                    let r = (0, a.makeSignBytes)(t);
                    if (e !== this.address) throw Error(`Address ${e} not found in wallet`);
                    let i = (0, o.sha256)(r),
                        s = await o.Secp256k1.createSignature(i, this.privkey),
                        d = new Uint8Array([...s.r(32), ...s.s(32)]);
                    return {
                        signed: t,
                        signature: (0, n.encodeSecp256k1Signature)(this.pubkey, d)
                    }
                }
            }
            t.DirectSecp256k1Wallet = s
        },
        44440: function(e, t, r) {
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: !0
            }), t.coins = t.coin = t.executeKdf = t.makeSignDoc = t.makeSignBytes = t.makeAuthInfoBytes = t.isOfflineDirectSigner = t.Registry = t.isTxBodyEncodeObject = t.isTsProtoGeneratedType = t.isPbjsGeneratedType = t.encodePubkey = t.decodePubkey = t.decodeOptionalPubkey = t.anyToSinglePubkey = t.makeCosmoshubPath = t.DirectSecp256k1Wallet = t.extractKdfConfiguration = t.DirectSecp256k1HdWallet = t.decodeTxRaw = t.parseCoins = void 0;
            var n = r(32285);
            Object.defineProperty(t, "parseCoins", {
                enumerable: !0,
                get: function() {
                    return n.parseCoins
                }
            });
            var o = r(48692);
            Object.defineProperty(t, "decodeTxRaw", {
                enumerable: !0,
                get: function() {
                    return o.decodeTxRaw
                }
            });
            var i = r(85743);
            Object.defineProperty(t, "DirectSecp256k1HdWallet", {
                enumerable: !0,
                get: function() {
                    return i.DirectSecp256k1HdWallet
                }
            }), Object.defineProperty(t, "extractKdfConfiguration", {
                enumerable: !0,
                get: function() {
                    return i.extractKdfConfiguration
                }
            });
            var a = r(92070);
            Object.defineProperty(t, "DirectSecp256k1Wallet", {
                enumerable: !0,
                get: function() {
                    return a.DirectSecp256k1Wallet
                }
            });
            var s = r(67924);
            Object.defineProperty(t, "makeCosmoshubPath", {
                enumerable: !0,
                get: function() {
                    return s.makeCosmoshubPath
                }
            });
            var d = r(68501);
            Object.defineProperty(t, "anyToSinglePubkey", {
                enumerable: !0,
                get: function() {
                    return d.anyToSinglePubkey
                }
            }), Object.defineProperty(t, "decodeOptionalPubkey", {
                enumerable: !0,
                get: function() {
                    return d.decodeOptionalPubkey
                }
            }), Object.defineProperty(t, "decodePubkey", {
                enumerable: !0,
                get: function() {
                    return d.decodePubkey
                }
            }), Object.defineProperty(t, "encodePubkey", {
                enumerable: !0,
                get: function() {
                    return d.encodePubkey
                }
            });
            var c = r(85572);
            Object.defineProperty(t, "isPbjsGeneratedType", {
                enumerable: !0,
                get: function() {
                    return c.isPbjsGeneratedType
                }
            }), Object.defineProperty(t, "isTsProtoGeneratedType", {
                enumerable: !0,
                get: function() {
                    return c.isTsProtoGeneratedType
                }
            }), Object.defineProperty(t, "isTxBodyEncodeObject", {
                enumerable: !0,
                get: function() {
                    return c.isTxBodyEncodeObject
                }
            }), Object.defineProperty(t, "Registry", {
                enumerable: !0,
                get: function() {
                    return c.Registry
                }
            });
            var l = r(99530);
            Object.defineProperty(t, "isOfflineDirectSigner", {
                enumerable: !0,
                get: function() {
                    return l.isOfflineDirectSigner
                }
            });
            var u = r(87076);
            Object.defineProperty(t, "makeAuthInfoBytes", {
                enumerable: !0,
                get: function() {
                    return u.makeAuthInfoBytes
                }
            }), Object.defineProperty(t, "makeSignBytes", {
                enumerable: !0,
                get: function() {
                    return u.makeSignBytes
                }
            }), Object.defineProperty(t, "makeSignDoc", {
                enumerable: !0,
                get: function() {
                    return u.makeSignDoc
                }
            });
            var p = r(36405);
            Object.defineProperty(t, "executeKdf", {
                enumerable: !0,
                get: function() {
                    return p.executeKdf
                }
            });
            var m = r(69693);
            Object.defineProperty(t, "coin", {
                enumerable: !0,
                get: function() {
                    return m.coin
                }
            }), Object.defineProperty(t, "coins", {
                enumerable: !0,
                get: function() {
                    return m.coins
                }
            })
        },
        67924: function(e, t, r) {
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: !0
            }), t.makeCosmoshubPath = void 0;
            let n = r(46495);
            t.makeCosmoshubPath = function(e) {
                return [n.Slip10RawIndex.hardened(44), n.Slip10RawIndex.hardened(118), n.Slip10RawIndex.hardened(0), n.Slip10RawIndex.normal(0), n.Slip10RawIndex.normal(e)]
            }
        },
        68501: function(e, t, r) {
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: !0
            }), t.decodeOptionalPubkey = t.decodePubkey = t.anyToSinglePubkey = t.encodePubkey = void 0;
            let n = r(69693),
                o = r(81299),
                i = r(82071),
                a = r(23288),
                s = r(13724),
                d = r(59052),
                c = r(40747);

            function l(e) {
                switch (e.typeUrl) {
                    case "/cosmos.crypto.secp256k1.PubKey":
                        {
                            let {
                                key: t
                            } = d.PubKey.decode(e.value);
                            return (0, n.encodeSecp256k1Pubkey)(t)
                        }
                    case "/cosmos.crypto.ed25519.PubKey":
                        {
                            let {
                                key: t
                            } = a.PubKey.decode(e.value);
                            return (0, n.encodeEd25519Pubkey)(t)
                        }
                    default:
                        throw Error(`Pubkey type_url ${e.typeUrl} not recognized as single public key type`)
                }
            }

            function u(e) {
                switch (e.typeUrl) {
                    case "/cosmos.crypto.secp256k1.PubKey":
                    case "/cosmos.crypto.ed25519.PubKey":
                        return l(e);
                    case "/cosmos.crypto.multisig.LegacyAminoPubKey":
                        {
                            let {
                                threshold: t,
                                publicKeys: r
                            } = s.LegacyAminoPubKey.decode(e.value);
                            return {
                                type: "tendermint/PubKeyMultisigThreshold",
                                value: {
                                    threshold: t.toString(),
                                    pubkeys: r.map(l)
                                }
                            }
                        }
                    default:
                        throw Error(`Pubkey type URL '${e.typeUrl}' not recognized`)
                }
            }
            t.encodePubkey = function e(t) {
                if ((0, n.isSecp256k1Pubkey)(t)) {
                    let e = d.PubKey.fromPartial({
                        key: (0, o.fromBase64)(t.value)
                    });
                    return c.Any.fromPartial({
                        typeUrl: "/cosmos.crypto.secp256k1.PubKey",
                        value: Uint8Array.from(d.PubKey.encode(e).finish())
                    })
                }
                if ((0, n.isEd25519Pubkey)(t)) {
                    let e = a.PubKey.fromPartial({
                        key: (0, o.fromBase64)(t.value)
                    });
                    return c.Any.fromPartial({
                        typeUrl: "/cosmos.crypto.ed25519.PubKey",
                        value: Uint8Array.from(a.PubKey.encode(e).finish())
                    })
                }
                if ((0, n.isMultisigThresholdPubkey)(t)) {
                    let r = s.LegacyAminoPubKey.fromPartial({
                        threshold: i.Uint53.fromString(t.value.threshold).toNumber(),
                        publicKeys: t.value.pubkeys.map(e)
                    });
                    return c.Any.fromPartial({
                        typeUrl: "/cosmos.crypto.multisig.LegacyAminoPubKey",
                        value: Uint8Array.from(s.LegacyAminoPubKey.encode(r).finish())
                    })
                }
                throw Error(`Pubkey type ${t.type} not recognized`)
            }, t.anyToSinglePubkey = l, t.decodePubkey = u, t.decodeOptionalPubkey = function(e) {
                if (!e) return null;
                if (e.typeUrl) {
                    if (e.value.length) return u(e);
                    throw Error(`Pubkey is an Any with type URL '${e.typeUrl}' but an empty value`)
                }
                if (!e.value.length) return null;
                throw Error("Pubkey is an Any with an empty type URL but a value set")
            }
        },
        85572: function(e, t, r) {
            "use strict";
            var n = r(48764).Buffer;
            Object.defineProperty(t, "__esModule", {
                value: !0
            }), t.Registry = t.isTxBodyEncodeObject = t.isPbjsGeneratedType = t.isTsProtoGeneratedType = t.isTelescopeGeneratedType = void 0;
            let o = r(50080),
                i = r(91408),
                a = r(9858),
                s = r(40747);

            function d(e) {
                return "function" == typeof e.fromPartial && "string" == typeof e.typeUrl
            }

            function c(e) {
                return "function" == typeof e.fromPartial
            }
            t.isTelescopeGeneratedType = d, t.isTsProtoGeneratedType = c, t.isPbjsGeneratedType = function(e) {
                return !c(e)
            };
            let l = {
                cosmosCoin: "/cosmos.base.v1beta1.Coin",
                cosmosMsgSend: "/cosmos.bank.v1beta1.MsgSend",
                cosmosTxBody: "/cosmos.tx.v1beta1.TxBody",
                googleAny: "/google.protobuf.Any"
            };

            function u(e) {
                return "/cosmos.tx.v1beta1.TxBody" === e.typeUrl
            }
            t.isTxBodyEncodeObject = u;
            class p {
                constructor(e) {
                    let {
                        cosmosCoin: t,
                        cosmosMsgSend: r
                    } = l;
                    this.types = new Map(e ? [...e] : [
                        [t, i.Coin],
                        [r, o.MsgSend]
                    ])
                }
                register(e, t) {
                    this.types.set(e, t)
                }
                lookupType(e) {
                    return this.types.get(e)
                }
                lookupTypeWithError(e) {
                    let t = this.lookupType(e);
                    if (!t) throw Error(`Unregistered type url: ${e}`);
                    return t
                }
                encode(e) {
                    let {
                        value: t,
                        typeUrl: r
                    } = e;
                    if (u(e)) return this.encodeTxBody(t);
                    let n = this.lookupTypeWithError(r),
                        o = d(n) || c(n) ? n.fromPartial(t) : n.create(t);
                    return n.encode(o).finish()
                }
                encodeAsAny(e) {
                    let t = this.encode(e);
                    return s.Any.fromPartial({
                        typeUrl: e.typeUrl,
                        value: t
                    })
                }
                encodeTxBody(e) {
                    let t = e.messages.map(e => this.encodeAsAny(e)),
                        r = a.TxBody.fromPartial({ ...e,
                            timeoutHeight: BigInt(e.timeoutHeight ? .toString() ? ? "0"),
                            messages: t
                        });
                    return a.TxBody.encode(r).finish()
                }
                decode({
                    typeUrl: e,
                    value: t
                }) {
                    if (e === l.cosmosTxBody) return this.decodeTxBody(t);
                    let r = this.lookupTypeWithError(e).decode(t);
                    return Object.entries(r).forEach(([e, t]) => {
                        void 0 !== n && void 0 !== n.isBuffer && n.isBuffer(t) && (r[e] = Uint8Array.from(t))
                    }), r
                }
                decodeTxBody(e) {
                    let t = a.TxBody.decode(e);
                    return { ...t,
                        messages: t.messages.map(({
                            typeUrl: e,
                            value: t
                        }) => {
                            if (!e) throw Error("Missing type_url in Any");
                            if (!t) throw Error("Missing value in Any");
                            return this.decode({
                                typeUrl: e,
                                value: t
                            })
                        })
                    }
                }
            }
            t.Registry = p
        },
        99530: function(e, t) {
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: !0
            }), t.isOfflineDirectSigner = void 0, t.isOfflineDirectSigner = function(e) {
                return void 0 !== e.signDirect
            }
        },
        87076: function(e, t, r) {
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: !0
            }), t.makeSignBytes = t.makeSignDoc = t.makeAuthInfoBytes = void 0;
            let n = r(8261),
                o = r(63702),
                i = r(9858);
            t.makeAuthInfoBytes = function(e, t, r, a, s, d = o.SignMode.SIGN_MODE_DIRECT) {
                (0, n.assert)(void 0 === a || "string" == typeof a, "feeGranter must be undefined or string"), (0, n.assert)(void 0 === s || "string" == typeof s, "feePayer must be undefined or string");
                let c = i.AuthInfo.fromPartial({
                    signerInfos: e.map(({
                        pubkey: e,
                        sequence: t
                    }) => ({
                        publicKey: e,
                        modeInfo: {
                            single: {
                                mode: d
                            }
                        },
                        sequence: BigInt(t)
                    })),
                    fee: {
                        amount: [...t],
                        gasLimit: BigInt(r),
                        granter: a,
                        payer: s
                    }
                });
                return i.AuthInfo.encode(c).finish()
            }, t.makeSignDoc = function(e, t, r, n) {
                return {
                    bodyBytes: e,
                    authInfoBytes: t,
                    chainId: r,
                    accountNumber: BigInt(n)
                }
            }, t.makeSignBytes = function({
                accountNumber: e,
                authInfoBytes: t,
                bodyBytes: r,
                chainId: n
            }) {
                let o = i.SignDoc.fromPartial({
                    accountNumber: e,
                    authInfoBytes: t,
                    bodyBytes: r,
                    chainId: n
                });
                return i.SignDoc.encode(o).finish()
            }
        },
        36405: function(e, t, r) {
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: !0
            }), t.decrypt = t.encrypt = t.supportedAlgorithms = t.executeKdf = t.cosmjsSalt = void 0;
            let n = r(46495),
                o = r(81299);
            async function i(e, r) {
                if ("argon2id" === r.algorithm) {
                    let o = r.params;
                    if (!(0, n.isArgon2idOptions)(o)) throw Error("Invalid format of argon2id params");
                    return n.Argon2id.execute(e, t.cosmjsSalt, o)
                }
                throw Error("Unsupported KDF algorithm")
            }
            async function a(e, r, o) {
                if (o.algorithm === t.supportedAlgorithms.xchacha20poly1305Ietf) {
                    let t = n.Random.getBytes(n.xchacha20NonceLength);
                    return new Uint8Array([...t, ...await n.Xchacha20poly1305Ietf.encrypt(e, r, t)])
                }
                throw Error(`Unsupported encryption algorithm: '${o.algorithm}'`)
            }
            async function s(e, r, o) {
                if (o.algorithm === t.supportedAlgorithms.xchacha20poly1305Ietf) {
                    let t = e.slice(0, n.xchacha20NonceLength);
                    return n.Xchacha20poly1305Ietf.decrypt(e.slice(n.xchacha20NonceLength), r, t)
                }
                throw Error(`Unsupported encryption algorithm: '${o.algorithm}'`)
            }
            t.cosmjsSalt = (0, o.toAscii)("The CosmJS salt."), t.executeKdf = i, t.supportedAlgorithms = {
                xchacha20poly1305Ietf: "xchacha20poly1305-ietf"
            }, t.encrypt = a, t.decrypt = s
        },
        57678: function(e, t, r) {
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: !0
            }), t.StreamingSocket = t.SocketWrapper = t.ReconnectingSocket = t.QueueingStreamingSocket = t.ConnectionStatus = void 0;
            var n = r(74072);
            Object.defineProperty(t, "ConnectionStatus", {
                enumerable: !0,
                get: function() {
                    return n.ConnectionStatus
                }
            }), Object.defineProperty(t, "QueueingStreamingSocket", {
                enumerable: !0,
                get: function() {
                    return n.QueueingStreamingSocket
                }
            });
            var o = r(67792);
            Object.defineProperty(t, "ReconnectingSocket", {
                enumerable: !0,
                get: function() {
                    return o.ReconnectingSocket
                }
            });
            var i = r(19132);
            Object.defineProperty(t, "SocketWrapper", {
                enumerable: !0,
                get: function() {
                    return i.SocketWrapper
                }
            });
            var a = r(33840);
            Object.defineProperty(t, "StreamingSocket", {
                enumerable: !0,
                get: function() {
                    return a.StreamingSocket
                }
            })
        },
        74072: function(e, t, r) {
            "use strict";
            var n, o;
            Object.defineProperty(t, "__esModule", {
                value: !0
            }), t.QueueingStreamingSocket = t.ConnectionStatus = void 0;
            let i = r(59210),
                a = r(43813),
                s = r(33840);
            (o = n = t.ConnectionStatus || (t.ConnectionStatus = {}))[o.Unconnected = 0] = "Unconnected", o[o.Connecting = 1] = "Connecting", o[o.Connected = 2] = "Connected", o[o.Disconnected = 3] = "Disconnected";
            class d {
                constructor(e, t = 1e4, r) {
                    this.queue = [], this.isProcessingQueue = !1, this.url = e, this.timeout = t, this.reconnectedHandler = r, this.events = a.Stream.create({
                        start: e => this.eventProducerListener = e,
                        stop: () => this.eventProducerListener = void 0
                    }), this.connectionStatusProducer = new i.DefaultValueProducer(n.Unconnected), this.connectionStatus = new i.ValueAndUpdates(this.connectionStatusProducer), this.socket = new s.StreamingSocket(this.url, this.timeout), this.socket.events.subscribe({
                        next: e => {
                            if (!this.eventProducerListener) throw Error("No event producer listener set");
                            this.eventProducerListener.next(e)
                        },
                        error: () => this.connectionStatusProducer.update(n.Disconnected)
                    })
                }
                connect() {
                    this.connectionStatusProducer.update(n.Connecting), this.socket.connected.then(async () => (this.connectionStatusProducer.update(n.Connected), this.processQueue()), () => this.connectionStatusProducer.update(n.Disconnected)), this.socket.connect()
                }
                disconnect() {
                    this.connectionStatusProducer.update(n.Disconnected), this.socket.disconnect()
                }
                reconnect() {
                    this.socket = new s.StreamingSocket(this.url, this.timeout), this.socket.events.subscribe({
                        next: e => {
                            if (!this.eventProducerListener) throw Error("No event producer listener set");
                            this.eventProducerListener.next(e)
                        },
                        error: () => this.connectionStatusProducer.update(n.Disconnected)
                    }), this.socket.connected.then(() => {
                        this.reconnectedHandler && this.reconnectedHandler()
                    }), this.connect()
                }
                getQueueLength() {
                    return this.queue.length
                }
                queueRequest(e) {
                    this.queue.push(e), this.processQueue()
                }
                async processQueue() {
                    let e;
                    if (!this.isProcessingQueue && this.connectionStatus.value === n.Connected)
                        for (this.isProcessingQueue = !0; e = this.queue.shift();) try {
                            await this.socket.send(e), this.isProcessingQueue = !1
                        } catch (t) {
                            this.queue.unshift(e), this.isProcessingQueue = !1;
                            return
                        }
                }
            }
            t.QueueingStreamingSocket = d
        },
        67792: function(e, t, r) {
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: !0
            }), t.ReconnectingSocket = void 0;
            let n = r(43813),
                o = r(74072);
            class i {
                static calculateTimeout(e) {
                    return Math.min(2 ** e * 100, 5e3)
                }
                constructor(e, t = 1e4, r) {
                    this.unconnected = !0, this.disconnected = !1, this.timeoutIndex = 0, this.reconnectTimeout = null, this.events = n.Stream.create({
                        start: e => this.eventProducerListener = e,
                        stop: () => this.eventProducerListener = void 0
                    }), this.socket = new o.QueueingStreamingSocket(e, t, r), this.socket.events.subscribe({
                        next: e => {
                            this.eventProducerListener && this.eventProducerListener.next(e)
                        },
                        error: e => {
                            this.eventProducerListener && this.eventProducerListener.error(e)
                        }
                    }), this.connectionStatus = this.socket.connectionStatus, this.connectionStatus.updates.subscribe({
                        next: e => {
                            e === o.ConnectionStatus.Connected && (this.timeoutIndex = 0), e === o.ConnectionStatus.Disconnected && (this.reconnectTimeout && (clearTimeout(this.reconnectTimeout), this.reconnectTimeout = null), this.reconnectTimeout = setTimeout(() => this.socket.reconnect(), i.calculateTimeout(this.timeoutIndex++)))
                        }
                    })
                }
                connect() {
                    if (!this.unconnected) throw Error("Cannot connect: socket has already connected");
                    this.socket.connect(), this.unconnected = !1
                }
                disconnect() {
                    if (this.unconnected) throw Error("Cannot disconnect: socket has not yet connected");
                    this.socket.disconnect(), this.eventProducerListener && this.eventProducerListener.complete(), this.disconnected = !0
                }
                queueRequest(e) {
                    if (this.disconnected) throw Error("Cannot queue request: socket has disconnected");
                    this.socket.queueRequest(e)
                }
            }
            t.ReconnectingSocket = i
        },
        19132: function(e, t, r) {
            "use strict";
            var n = r(34155),
                o = this && this.__importDefault || function(e) {
                    return e && e.__esModule ? e : {
                        default: e
                    }
                };
            Object.defineProperty(t, "__esModule", {
                value: !0
            }), t.SocketWrapper = void 0;
            let i = o(r(46792));
            class a {
                constructor(e, t, r, n, o, i = 1e4) {
                    this.closed = !1, this.connected = new Promise((e, t) => {
                        this.connectedResolver = e, this.connectedRejecter = t
                    }), this.url = e, this.messageHandler = t, this.errorHandler = r, this.openHandler = n, this.closeHandler = o, this.timeout = i
                }
                connect() {
                    let e = new i.default(this.url);
                    e.onerror = e => {
                        this.clearTimeout(), this.errorHandler && this.errorHandler(e)
                    }, e.onmessage = e => {
                        this.messageHandler({
                            type: e.type,
                            data: e.data
                        })
                    }, e.onopen = e => {
                        this.clearTimeout(), this.connectedResolver(), this.openHandler && this.openHandler()
                    }, e.onclose = e => {
                        this.closed = !0, this.closeHandler && this.closeHandler(e)
                    };
                    let t = Date.now();
                    this.timeoutId = setTimeout(() => {
                        e.onmessage = () => 0, e.onerror = () => 0, e.onopen = () => 0, e.onclose = () => 0, e.close(), this.socket = void 0;
                        let r = Math.floor(Date.now() - t);
                        this.connectedRejecter(`Connection attempt timed out after ${r} ms`)
                    }, this.timeout), this.socket = e
                }
                disconnect() {
                    if (!this.socket) throw Error("Socket undefined. This must be called after connecting.");
                    switch (this.clearTimeout(), this.socket.readyState) {
                        case i.default.OPEN:
                            this.socket.close(1e3);
                            break;
                        case i.default.CLOSED:
                            break;
                        case i.default.CONNECTING:
                            this.socket.onopen = () => 0, this.socket.onclose = () => 0, this.socket.onerror = () => 0, this.socket.onmessage = () => 0, this.socket = void 0, this.closeHandler && this.closeHandler({
                                wasClean: !1,
                                code: 4001
                            });
                            break;
                        case i.default.CLOSING:
                            break;
                        default:
                            throw Error(`Unknown readyState: ${this.socket.readyState}`)
                    }
                }
                async send(e) {
                    return new Promise((t, r) => {
                        if (!this.socket) throw Error("Socket undefined. This must be called after connecting.");
                        if (this.closed) throw Error("Socket was closed, so no data can be sent anymore.");
                        if (this.socket.readyState !== i.default.OPEN) throw Error("Websocket is not open");
                        void 0 !== n && void 0 !== n.versions && void 0 !== n.versions.node ? this.socket.send(e, e => e ? r(e) : t()) : (this.socket.send(e), t())
                    })
                }
                clearTimeout() {
                    if (!this.timeoutId) throw Error("Timeout ID not set. This should not happen and usually means connect() was not called.");
                    clearTimeout(this.timeoutId)
                }
            }
            t.SocketWrapper = a
        },
        33840: function(e, t, r) {
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: !0
            }), t.StreamingSocket = void 0;
            let n = r(43813),
                o = r(19132);
            class i {
                constructor(e, t = 1e4) {
                    this.socket = new o.SocketWrapper(e, e => {
                        this.eventProducerListener && this.eventProducerListener.next(e)
                    }, e => {
                        this.eventProducerListener && this.eventProducerListener.error(e)
                    }, () => {}, e => {
                        this.eventProducerListener && (e.wasClean ? this.eventProducerListener.complete() : this.eventProducerListener.error("Socket was closed unclean"))
                    }, t), this.connected = this.socket.connected, this.events = n.Stream.create({
                        start: e => this.eventProducerListener = e,
                        stop: () => this.eventProducerListener = void 0
                    })
                }
                connect() {
                    this.socket.connect()
                }
                disconnect() {
                    this.socket.disconnect()
                }
                async send(e) {
                    return this.socket.send(e)
                }
            }
            t.StreamingSocket = i
        },
        32485: function(e, t, r) {
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: !0
            }), t.concat = void 0;
            let n = r(43813);
            t.concat = function(...e) {
                let t = [],
                    r = [],
                    o = new Set,
                    i = 0;

                function a() {
                    for (; t.length > 0;) t.shift().unsubscribe();
                    r.length = 0, o.clear(), i = 0
                }
                return n.Stream.create({
                    start: n => {
                        function s(e) {
                            for (;;) {
                                let t = r[e].shift();
                                if (void 0 === t) return;
                                n.next(t)
                            }
                        }

                        function d() {
                            return i >= e.length
                        }
                        if (e.forEach(e => r.push([])), d()) {
                            n.complete();
                            return
                        }
                        e.forEach((e, c) => {
                            t.push(e.subscribe({
                                next: e => {
                                    c === i ? n.next(e) : r[c].push(e)
                                },
                                complete: () => {
                                    for (o.add(c); o.has(i);) s(i), i++;
                                    d() ? n.complete() : s(i)
                                },
                                error: e => {
                                    n.error(e), a()
                                }
                            }))
                        })
                    },
                    stop: () => {
                        a()
                    }
                })
            }
        },
        95622: function(e, t) {
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: !0
            }), t.DefaultValueProducer = void 0;
            class r {
                get value() {
                    return this.internalValue
                }
                constructor(e, t) {
                    this.callbacks = t, this.internalValue = e
                }
                update(e) {
                    this.internalValue = e, this.listener && this.listener.next(e)
                }
                error(e) {
                    this.listener && this.listener.error(e)
                }
                start(e) {
                    this.listener = e, e.next(this.internalValue), this.callbacks && this.callbacks.onStarted()
                }
                stop() {
                    this.callbacks && this.callbacks.onStop(), this.listener = void 0
                }
            }
            t.DefaultValueProducer = r
        },
        82690: function(e, t) {
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: !0
            }), t.dropDuplicates = void 0, t.dropDuplicates = function(e) {
                return t => {
                    let r = new Set;
                    return t.filter(t => !r.has(e(t))).debug(t => r.add(e(t)))
                }
            }
        },
        59210: function(e, t, r) {
            "use strict";
            var n = this && this.__createBinding || (Object.create ? function(e, t, r, n) {
                    void 0 === n && (n = r);
                    var o = Object.getOwnPropertyDescriptor(t, r);
                    (!o || ("get" in o ? !t.__esModule : o.writable || o.configurable)) && (o = {
                        enumerable: !0,
                        get: function() {
                            return t[r]
                        }
                    }), Object.defineProperty(e, n, o)
                } : function(e, t, r, n) {
                    void 0 === n && (n = r), e[n] = t[r]
                }),
                o = this && this.__exportStar || function(e, t) {
                    for (var r in e) "default" === r || Object.prototype.hasOwnProperty.call(t, r) || n(t, e, r)
                };
            Object.defineProperty(t, "__esModule", {
                value: !0
            }), t.ValueAndUpdates = t.toListPromise = t.fromListPromise = t.firstEvent = t.dropDuplicates = t.DefaultValueProducer = t.concat = void 0;
            var i = r(32485);
            Object.defineProperty(t, "concat", {
                enumerable: !0,
                get: function() {
                    return i.concat
                }
            });
            var a = r(95622);
            Object.defineProperty(t, "DefaultValueProducer", {
                enumerable: !0,
                get: function() {
                    return a.DefaultValueProducer
                }
            });
            var s = r(82690);
            Object.defineProperty(t, "dropDuplicates", {
                enumerable: !0,
                get: function() {
                    return s.dropDuplicates
                }
            });
            var d = r(91478);
            Object.defineProperty(t, "firstEvent", {
                enumerable: !0,
                get: function() {
                    return d.firstEvent
                }
            }), Object.defineProperty(t, "fromListPromise", {
                enumerable: !0,
                get: function() {
                    return d.fromListPromise
                }
            }), Object.defineProperty(t, "toListPromise", {
                enumerable: !0,
                get: function() {
                    return d.toListPromise
                }
            }), o(r(33975), t);
            var c = r(15701);
            Object.defineProperty(t, "ValueAndUpdates", {
                enumerable: !0,
                get: function() {
                    return c.ValueAndUpdates
                }
            })
        },
        91478: function(e, t, r) {
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: !0
            }), t.firstEvent = t.toListPromise = t.fromListPromise = void 0;
            let n = r(43813);
            async function o(e, t) {
                return new Promise((r, n) => {
                    if (0 === t) {
                        r([]);
                        return
                    }
                    let o = [];
                    e.take(t).subscribe({
                        next: e => {
                            o.push(e), o.length === t && r(o)
                        },
                        complete: () => {
                            n(`Stream completed before all events could be collected. Collected ${o.length}, expected ${t}`)
                        },
                        error: e => n(e)
                    })
                })
            }
            async function i(e) {
                return (await o(e, 1))[0]
            }
            t.fromListPromise = function(e) {
                return n.Stream.create({
                    start: t => {
                        e.then(e => {
                            for (let r of e) t.next(r);
                            t.complete()
                        }).catch(e => t.error(e))
                    },
                    stop: () => {}
                })
            }, t.toListPromise = o, t.firstEvent = i
        },
        33975: function(e, t) {
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: !0
            }), t.lastValue = t.asArray = t.countStream = t.Reducer = void 0;
            class r {
                constructor(e, t, r) {
                    this.stream = e, this.reducer = t, this.state = r, this.completed = new Promise((e, t) => {
                        let r = this.stream.subscribe({
                            next: e => {
                                this.state = this.reducer(this.state, e)
                            },
                            complete: () => {
                                e(), r.unsubscribe()
                            },
                            error: e => {
                                t(e), r.unsubscribe()
                            }
                        })
                    })
                }
                value() {
                    return this.state
                }
                async finished() {
                    return this.completed
                }
            }

            function n(e, t) {
                return e + 1
            }

            function o(e, t) {
                return [...e, t]
            }

            function i(e, t) {
                return t
            }
            t.Reducer = r, t.countStream = function(e) {
                return new r(e, n, 0)
            }, t.asArray = function(e) {
                return new r(e, o, [])
            }, t.lastValue = function(e) {
                return new r(e, i, void 0)
            }
        },
        15701: function(e, t, r) {
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: !0
            }), t.ValueAndUpdates = void 0;
            let n = r(43813);
            class o {
                get value() {
                    return this.producer.value
                }
                constructor(e) {
                    this.producer = e, this.updates = n.MemoryStream.createWithMemory(this.producer)
                }
                async waitFor(e) {
                    let t = "function" == typeof e ? e : t => t === e;
                    return new Promise((e, r) => {
                        let n = this.updates.subscribe({
                            next: r => {
                                t(r) && (e(r), setTimeout(() => n.unsubscribe(), 0))
                            },
                            complete: () => {
                                n.unsubscribe(), r("Update stream completed without expected value")
                            },
                            error: e => {
                                r(e)
                            }
                        })
                    })
                }
            }
            t.ValueAndUpdates = o
        },
        94984: function(e, t, r) {
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: !0
            }), t.pubkeyToAddress = t.pubkeyToRawAddress = t.rawSecp256k1PubkeyToRawAddress = t.rawEd25519PubkeyToRawAddress = void 0;
            let n = r(46495),
                o = r(81299);

            function i(e) {
                if (32 !== e.length) throw Error(`Invalid Ed25519 pubkey length: ${e.length}`);
                return (0, n.sha256)(e).slice(0, 20)
            }

            function a(e) {
                if (33 !== e.length) throw Error(`Invalid Secp256k1 pubkey length (compressed): ${e.length}`);
                return (0, n.ripemd160)((0, n.sha256)(e))
            }

            function s(e, t) {
                switch (e) {
                    case "ed25519":
                        return i(t);
                    case "secp256k1":
                        return a(t);
                    default:
                        throw Error(`Pubkey type ${e} not supported`)
                }
            }
            t.rawEd25519PubkeyToRawAddress = i, t.rawSecp256k1PubkeyToRawAddress = a, t.pubkeyToRawAddress = s, t.pubkeyToAddress = function(e, t) {
                return (0, o.toHex)(s(e, t)).toUpperCase()
            }
        },
        3096: function(e, t, r) {
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: !0
            }), t.Responses = t.Params = void 0;
            var n = r(25100);
            Object.defineProperty(t, "Params", {
                enumerable: !0,
                get: function() {
                    return n.Params
                }
            });
            var o = r(25558);
            Object.defineProperty(t, "Responses", {
                enumerable: !0,
                get: function() {
                    return o.Responses
                }
            })
        },
        25100: function(e, t, r) {
            "use strict";
            var n = this && this.__createBinding || (Object.create ? function(e, t, r, n) {
                    void 0 === n && (n = r);
                    var o = Object.getOwnPropertyDescriptor(t, r);
                    (!o || ("get" in o ? !t.__esModule : o.writable || o.configurable)) && (o = {
                        enumerable: !0,
                        get: function() {
                            return t[r]
                        }
                    }), Object.defineProperty(e, n, o)
                } : function(e, t, r, n) {
                    void 0 === n && (n = r), e[n] = t[r]
                }),
                o = this && this.__setModuleDefault || (Object.create ? function(e, t) {
                    Object.defineProperty(e, "default", {
                        enumerable: !0,
                        value: t
                    })
                } : function(e, t) {
                    e.default = t
                }),
                i = this && this.__importStar || function(e) {
                    if (e && e.__esModule) return e;
                    var t = {};
                    if (null != e)
                        for (var r in e) "default" !== r && Object.prototype.hasOwnProperty.call(e, r) && n(t, e, r);
                    return o(t, e), t
                };
            Object.defineProperty(t, "__esModule", {
                value: !0
            }), t.Params = void 0;
            let a = r(81299),
                s = r(69581),
                d = r(64484),
                c = r(42677),
                l = i(r(60616));

            function u(e) {
                return {
                    height: (0, c.may)(s.smallIntToApi, e.height)
                }
            }
            class p {
                static encodeAbciInfo(e) {
                    return (0, d.createJsonRpcRequest)(e.method)
                }
                static encodeAbciQuery(e) {
                    var t;
                    return (0, d.createJsonRpcRequest)(e.method, (t = e.params, {
                        path: (0, c.assertNotEmpty)(t.path),
                        data: (0, a.toHex)(t.data),
                        height: (0, c.may)(s.smallIntToApi, t.height),
                        prove: t.prove
                    }))
                }
                static encodeBlock(e) {
                    return (0, d.createJsonRpcRequest)(e.method, u(e.params))
                }
                static encodeBlockchain(e) {
                    var t;
                    return (0, d.createJsonRpcRequest)(e.method, (t = e.params, {
                        minHeight: (0, c.may)(s.smallIntToApi, t.minHeight),
                        maxHeight: (0, c.may)(s.smallIntToApi, t.maxHeight)
                    }))
                }
                static encodeBlockResults(e) {
                    return (0, d.createJsonRpcRequest)(e.method, u(e.params))
                }
                static encodeBlockSearch(e) {
                    var t;
                    return (0, d.createJsonRpcRequest)(e.method, {
                        query: (t = e.params).query,
                        page: (0, c.may)(s.smallIntToApi, t.page),
                        per_page: (0, c.may)(s.smallIntToApi, t.per_page),
                        order_by: t.order_by
                    })
                }
                static encodeBroadcastTx(e) {
                    var t;
                    return (0, d.createJsonRpcRequest)(e.method, (t = e.params, {
                        tx: (0, a.toBase64)((0, c.assertNotEmpty)(t.tx))
                    }))
                }
                static encodeCommit(e) {
                    return (0, d.createJsonRpcRequest)(e.method, u(e.params))
                }
                static encodeGenesis(e) {
                    return (0, d.createJsonRpcRequest)(e.method)
                }
                static encodeHealth(e) {
                    return (0, d.createJsonRpcRequest)(e.method)
                }
                static encodeNumUnconfirmedTxs(e) {
                    return (0, d.createJsonRpcRequest)(e.method)
                }
                static encodeStatus(e) {
                    return (0, d.createJsonRpcRequest)(e.method)
                }
                static encodeSubscribe(e) {
                    let t = {
                            key: "tm.event",
                            value: e.query.type
                        },
                        r = l.buildQuery({
                            tags: [t],
                            raw: e.query.raw
                        });
                    return (0, d.createJsonRpcRequest)("subscribe", {
                        query: r
                    })
                }
                static encodeTx(e) {
                    var t;
                    return (0, d.createJsonRpcRequest)(e.method, (t = e.params, {
                        hash: (0, a.toBase64)((0, c.assertNotEmpty)(t.hash)),
                        prove: t.prove
                    }))
                }
                static encodeTxSearch(e) {
                    var t;
                    return (0, d.createJsonRpcRequest)(e.method, {
                        query: (t = e.params).query,
                        prove: t.prove,
                        page: (0, c.may)(s.smallIntToApi, t.page),
                        per_page: (0, c.may)(s.smallIntToApi, t.per_page),
                        order_by: t.order_by
                    })
                }
                static encodeValidators(e) {
                    var t;
                    return (0, d.createJsonRpcRequest)(e.method, (t = e.params, {
                        height: (0, c.may)(s.smallIntToApi, t.height),
                        page: (0, c.may)(s.smallIntToApi, t.page),
                        per_page: (0, c.may)(s.smallIntToApi, t.per_page)
                    }))
                }
            }
            t.Params = p
        },
        25558: function(e, t, r) {
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: !0
            }), t.Responses = t.decodeValidatorInfo = t.decodeValidatorGenesis = t.decodeValidatorUpdate = t.decodeEvent = void 0;
            let n = r(81299),
                o = r(8261),
                i = r(65932),
                a = r(69581),
                s = r(5347),
                d = r(42677),
                c = r(44531);

            function l(e) {
                return {
                    ops: e.ops.map(e => ({
                        type: e.type,
                        key: (0, n.fromBase64)(e.key),
                        data: (0, n.fromBase64)(e.data)
                    }))
                }
            }

            function u(e) {
                return {
                    key: (0, d.assertNotEmpty)(e.key),
                    value: e.value ? ? ""
                }
            }

            function p(e) {
                var t;
                return {
                    type: e.type,
                    attributes: e.attributes ? (t = e.attributes, (0, d.assertArray)(t).map(u)) : []
                }
            }

            function m(e) {
                return (0, d.assertArray)(e).map(p)
            }

            function g(e) {
                return {
                    code: (0, a.apiToSmallInt)((0, d.assertNumber)(e.code ? ? 0)),
                    codespace: e.codespace,
                    log: e.log,
                    data: (0, d.may)(n.fromBase64, e.data),
                    events: e.events ? m(e.events) : [],
                    gasWanted: (0, a.apiToBigInt)(e.gas_wanted ? ? "0"),
                    gasUsed: (0, a.apiToBigInt)(e.gas_used ? ? "0")
                }
            }

            function f(e) {
                if ("Sum" in e) {
                    let [
                        [t, r]
                    ] = Object.entries(e.Sum.value);
                    return (0, o.assert)("ed25519" === t || "secp256k1" === t, `unknown pubkey type: ${t}`), {
                        algorithm: t,
                        data: (0, n.fromBase64)((0, d.assertNotEmpty)(r))
                    }
                }
                switch (e.type) {
                    case "tendermint/PubKeyEd25519":
                        return {
                            algorithm: "ed25519",
                            data: (0, n.fromBase64)((0, d.assertNotEmpty)(e.value))
                        };
                    case "tendermint/PubKeySecp256k1":
                        return {
                            algorithm: "secp256k1",
                            data: (0, n.fromBase64)((0, d.assertNotEmpty)(e.value))
                        };
                    default:
                        throw Error(`unknown pubkey type: ${e.type}`)
                }
            }

            function y(e) {
                var t, r;
                return {
                    block: (t = (0, d.assertObject)(e.block), {
                        maxBytes: (0, a.apiToSmallInt)((0, d.assertNotEmpty)(t.max_bytes)),
                        maxGas: (0, a.apiToSmallInt)((0, d.assertNotEmpty)(t.max_gas))
                    }),
                    evidence: (r = (0, d.assertObject)(e.evidence), {
                        maxAgeNumBlocks: (0, a.apiToSmallInt)((0, d.assertNotEmpty)(r.max_age_num_blocks)),
                        maxAgeDuration: (0, a.apiToSmallInt)((0, d.assertNotEmpty)(r.max_age_duration))
                    })
                }
            }

            function h(e) {
                return {
                    pubkey: f((0, d.assertObject)(e.pub_key)),
                    votingPower: (0, a.apiToBigInt)(e.power ? ? "0")
                }
            }

            function v(e) {
                return {
                    hash: (0, n.fromHex)((0, d.assertNotEmpty)(e.hash)),
                    parts: {
                        total: (0, d.assertNotEmpty)(e.parts.total),
                        hash: (0, n.fromHex)((0, d.assertNotEmpty)(e.parts.hash))
                    }
                }
            }

            function b(e) {
                var t;
                return {
                    version: (t = e.version, {
                        block: (0, a.apiToSmallInt)(t.block),
                        app: (0, a.apiToSmallInt)(t.app ? ? 0)
                    }),
                    chainId: (0, d.assertNotEmpty)(e.chain_id),
                    height: (0, a.apiToSmallInt)((0, d.assertNotEmpty)(e.height)),
                    time: (0, i.fromRfc3339WithNanoseconds)((0, d.assertNotEmpty)(e.time)),
                    lastBlockId: e.last_block_id.hash ? v(e.last_block_id) : null,
                    lastCommitHash: (0, n.fromHex)((0, d.assertSet)(e.last_commit_hash)),
                    dataHash: (0, n.fromHex)((0, d.assertSet)(e.data_hash)),
                    validatorsHash: (0, n.fromHex)((0, d.assertSet)(e.validators_hash)),
                    nextValidatorsHash: (0, n.fromHex)((0, d.assertSet)(e.next_validators_hash)),
                    consensusHash: (0, n.fromHex)((0, d.assertSet)(e.consensus_hash)),
                    appHash: (0, n.fromHex)((0, d.assertSet)(e.app_hash)),
                    lastResultsHash: (0, n.fromHex)((0, d.assertSet)(e.last_results_hash)),
                    evidenceHash: (0, n.fromHex)((0, d.assertSet)(e.evidence_hash)),
                    proposerAddress: (0, n.fromHex)((0, d.assertNotEmpty)(e.proposer_address))
                }
            }

            function S(e) {
                return {
                    blockId: v(e.block_id),
                    blockSize: (0, a.apiToSmallInt)((0, d.assertNotEmpty)(e.block_size)),
                    header: b(e.header),
                    numTxs: (0, a.apiToSmallInt)((0, d.assertNotEmpty)(e.num_txs))
                }
            }

            function k(e) {
                var t;
                return {
                    blockIdFlag: (t = e.block_id_flag, (0, o.assert)(t in s.BlockIdFlag), t),
                    validatorAddress: e.validator_address ? (0, n.fromHex)(e.validator_address) : void 0,
                    timestamp: e.timestamp ? (0, i.fromRfc3339WithNanoseconds)(e.timestamp) : void 0,
                    signature: e.signature ? (0, n.fromBase64)(e.signature) : void 0
                }
            }

            function P(e) {
                return {
                    blockId: v((0, d.assertObject)(e.block_id)),
                    height: (0, a.apiToSmallInt)((0, d.assertNotEmpty)(e.height)),
                    round: (0, a.apiToSmallInt)(e.round),
                    signatures: (0, d.assertArray)(e.signatures).map(k)
                }
            }

            function _(e) {
                return {
                    address: (0, n.fromHex)((0, d.assertNotEmpty)(e.address)),
                    pubkey: f((0, d.assertObject)(e.pub_key)),
                    votingPower: (0, a.apiToBigInt)((0, d.assertNotEmpty)(e.power))
                }
            }

            function B(e) {
                return {
                    pubkey: f((0, d.assertObject)(e.pub_key)),
                    votingPower: (0, a.apiToBigInt)((0, d.assertNotEmpty)(e.voting_power)),
                    address: (0, n.fromHex)((0, d.assertNotEmpty)(e.address)),
                    proposerPriority: e.proposer_priority ? (0, a.apiToSmallInt)(e.proposer_priority) : void 0
                }
            }

            function O(e) {
                return {
                    data: (0, n.fromBase64)((0, d.assertNotEmpty)(e.data)),
                    rootHash: (0, n.fromHex)((0, d.assertNotEmpty)(e.root_hash)),
                    proof: {
                        total: (0, a.apiToSmallInt)((0, d.assertNotEmpty)(e.proof.total)),
                        index: (0, a.apiToSmallInt)((0, d.assertNotEmpty)(e.proof.index)),
                        leafHash: (0, n.fromBase64)((0, d.assertNotEmpty)(e.proof.leaf_hash)),
                        aunts: (0, d.assertArray)(e.proof.aunts).map(n.fromBase64)
                    }
                }
            }

            function R(e) {
                return {
                    tx: (0, n.fromBase64)((0, d.assertNotEmpty)(e.tx)),
                    result: g((0, d.assertObject)(e.tx_result)),
                    height: (0, a.apiToSmallInt)((0, d.assertNotEmpty)(e.height)),
                    index: (0, a.apiToSmallInt)((0, d.assertNumber)(e.index)),
                    hash: (0, n.fromHex)((0, d.assertNotEmpty)(e.hash)),
                    proof: (0, d.may)(O, e.proof)
                }
            }

            function A(e) {
                return {
                    header: b((0, d.assertObject)(e.header)),
                    lastCommit: e.last_commit.block_id.hash ? P((0, d.assertObject)(e.last_commit)) : null,
                    txs: e.data.txs ? (0, d.assertArray)(e.data.txs).map(n.fromBase64) : [],
                    evidence: e.evidence ? .evidence ? ? []
                }
            }

            function I(e) {
                return {
                    blockId: v(e.block_id),
                    block: A(e.block)
                }
            }
            t.decodeEvent = p, t.decodeValidatorUpdate = h, t.decodeValidatorGenesis = _, t.decodeValidatorInfo = B;
            class w {
                static decodeAbciInfo(e) {
                    var t;
                    return {
                        data: (t = (0, d.assertObject)(e.result.response)).data,
                        lastBlockHeight: (0, d.may)(a.apiToSmallInt, t.last_block_height),
                        lastBlockAppHash: (0, d.may)(n.fromBase64, t.last_block_app_hash)
                    }
                }
                static decodeAbciQuery(e) {
                    var t;
                    return t = (0, d.assertObject)(e.result.response), {
                        key: (0, n.fromBase64)((0, d.assertString)(t.key ? ? "")),
                        value: (0, n.fromBase64)((0, d.assertString)(t.value ? ? "")),
                        proof: (0, d.may)(l, t.proofOps),
                        height: (0, d.may)(a.apiToSmallInt, t.height),
                        code: (0, d.may)(a.apiToSmallInt, t.code),
                        codespace: (0, d.assertString)(t.codespace ? ? ""),
                        index: (0, d.may)(a.apiToSmallInt, t.index),
                        log: t.log,
                        info: (0, d.assertString)(t.info ? ? "")
                    }
                }
                static decodeBlock(e) {
                    return I(e.result)
                }
                static decodeBlockResults(e) {
                    var t;
                    return t = e.result, {
                        height: (0, a.apiToSmallInt)((0, d.assertNotEmpty)(t.height)),
                        results: (t.txs_results || []).map(g),
                        validatorUpdates: (t.validator_updates || []).map(h),
                        consensusUpdates: (0, d.may)(y, t.consensus_param_updates),
                        beginBlockEvents: m(t.begin_block_events || []),
                        endBlockEvents: m(t.end_block_events || [])
                    }
                }
                static decodeBlockSearch(e) {
                    var t;
                    return t = e.result, {
                        totalCount: (0, a.apiToSmallInt)((0, d.assertNotEmpty)(t.total_count)),
                        blocks: (0, d.assertArray)(t.blocks).map(I)
                    }
                }
                static decodeBlockchain(e) {
                    var t;
                    return t = e.result, {
                        lastHeight: (0, a.apiToSmallInt)((0, d.assertNotEmpty)(t.last_height)),
                        blockMetas: (0, d.assertArray)(t.block_metas).map(S)
                    }
                }
                static decodeBroadcastTxSync(e) {
                    var t;
                    return { ...g(t = e.result),
                        hash: (0, n.fromHex)((0, d.assertNotEmpty)(t.hash))
                    }
                }
                static decodeBroadcastTxAsync(e) {
                    return w.decodeBroadcastTxSync(e)
                }
                static decodeBroadcastTxCommit(e) {
                    return function(e) {
                        let t = e.tx_result ? g(e.tx_result) : void 0;
                        return {
                            height: (0, a.apiToSmallInt)(e.height),
                            hash: (0, n.fromHex)((0, d.assertNotEmpty)(e.hash)),
                            checkTx: g((0, d.assertObject)(e.check_tx)),
                            deliverTx: t,
                            txResult: t
                        }
                    }(e.result)
                }
                static decodeCommit(e) {
                    var t;
                    return t = e.result, {
                        canonical: (0, d.assertBoolean)(t.canonical),
                        header: b(t.signed_header.header),
                        commit: P(t.signed_header.commit)
                    }
                }
                static decodeGenesis(e) {
                    var t;
                    return t = (0, d.assertObject)(e.result.genesis), {
                        genesisTime: (0, i.fromRfc3339WithNanoseconds)((0, d.assertNotEmpty)(t.genesis_time)),
                        chainId: (0, d.assertNotEmpty)(t.chain_id),
                        consensusParams: y(t.consensus_params),
                        validators: t.validators ? (0, d.assertArray)(t.validators).map(_) : [],
                        appHash: (0, n.fromHex)((0, d.assertSet)(t.app_hash)),
                        appState: t.app_state
                    }
                }
                static decodeHealth() {
                    return null
                }
                static decodeNumUnconfirmedTxs(e) {
                    var t;
                    return t = e.result, {
                        total: (0, a.apiToSmallInt)((0, d.assertNotEmpty)(t.total)),
                        totalBytes: (0, a.apiToSmallInt)((0, d.assertNotEmpty)(t.total_bytes))
                    }
                }
                static decodeStatus(e) {
                    var t, r;
                    return {
                        nodeInfo: (r = (t = e.result).node_info, {
                            id: (0, n.fromHex)((0, d.assertNotEmpty)(r.id)),
                            listenAddr: (0, d.assertNotEmpty)(r.listen_addr),
                            network: (0, d.assertNotEmpty)(r.network),
                            version: (0, d.assertString)(r.version),
                            channels: (0, d.assertNotEmpty)(r.channels),
                            moniker: (0, d.assertNotEmpty)(r.moniker),
                            other: (0, d.dictionaryToStringMap)(r.other),
                            protocolVersion: {
                                app: (0, a.apiToSmallInt)((0, d.assertNotEmpty)(r.protocol_version.app)),
                                block: (0, a.apiToSmallInt)((0, d.assertNotEmpty)(r.protocol_version.block)),
                                p2p: (0, a.apiToSmallInt)((0, d.assertNotEmpty)(r.protocol_version.p2p))
                            }
                        }),
                        syncInfo: function(e) {
                            let t = e.earliest_block_height ? (0, a.apiToSmallInt)(e.earliest_block_height) : void 0,
                                r = e.earliest_block_time ? (0, i.fromRfc3339WithNanoseconds)(e.earliest_block_time) : void 0;
                            return {
                                earliestAppHash: e.earliest_app_hash ? (0, n.fromHex)(e.earliest_app_hash) : void 0,
                                earliestBlockHash: e.earliest_block_hash ? (0, n.fromHex)(e.earliest_block_hash) : void 0,
                                earliestBlockHeight: t || void 0,
                                earliestBlockTime: r ? .getTime() ? r : void 0,
                                latestBlockHash: (0, n.fromHex)((0, d.assertNotEmpty)(e.latest_block_hash)),
                                latestAppHash: (0, n.fromHex)((0, d.assertNotEmpty)(e.latest_app_hash)),
                                latestBlockTime: (0, i.fromRfc3339WithNanoseconds)((0, d.assertNotEmpty)(e.latest_block_time)),
                                latestBlockHeight: (0, a.apiToSmallInt)((0, d.assertNotEmpty)(e.latest_block_height)),
                                catchingUp: (0, d.assertBoolean)(e.catching_up)
                            }
                        }(t.sync_info),
                        validatorInfo: B(t.validator_info)
                    }
                }
                static decodeNewBlockEvent(e) {
                    return A(e.data.value.block)
                }
                static decodeNewBlockHeaderEvent(e) {
                    return b(e.data.value.header)
                }
                static decodeTxEvent(e) {
                    return function(e) {
                        let t = (0, n.fromBase64)((0, d.assertNotEmpty)(e.tx));
                        return {
                            tx: t,
                            hash: (0, c.hashTx)(t),
                            result: g(e.result),
                            height: (0, a.apiToSmallInt)((0, d.assertNotEmpty)(e.height))
                        }
                    }(e.data.value.TxResult)
                }
                static decodeTx(e) {
                    return R(e.result)
                }
                static decodeTxSearch(e) {
                    var t;
                    return t = e.result, {
                        totalCount: (0, a.apiToSmallInt)((0, d.assertNotEmpty)(t.total_count)),
                        txs: (0, d.assertArray)(t.txs).map(R)
                    }
                }
                static decodeValidators(e) {
                    var t;
                    return t = e.result, {
                        blockHeight: (0, a.apiToSmallInt)((0, d.assertNotEmpty)(t.block_height)),
                        validators: (0, d.assertArray)(t.validators).map(B),
                        count: (0, a.apiToSmallInt)((0, d.assertNotEmpty)(t.count)),
                        total: (0, a.apiToSmallInt)((0, d.assertNotEmpty)(t.total))
                    }
                }
            }
            t.Responses = w
        },
        70536: function(e, t, r) {
            "use strict";
            var n = this && this.__createBinding || (Object.create ? function(e, t, r, n) {
                    void 0 === n && (n = r);
                    var o = Object.getOwnPropertyDescriptor(t, r);
                    (!o || ("get" in o ? !t.__esModule : o.writable || o.configurable)) && (o = {
                        enumerable: !0,
                        get: function() {
                            return t[r]
                        }
                    }), Object.defineProperty(e, n, o)
                } : function(e, t, r, n) {
                    void 0 === n && (n = r), e[n] = t[r]
                }),
                o = this && this.__setModuleDefault || (Object.create ? function(e, t) {
                    Object.defineProperty(e, "default", {
                        enumerable: !0,
                        value: t
                    })
                } : function(e, t) {
                    e.default = t
                }),
                i = this && this.__importStar || function(e) {
                    if (e && e.__esModule) return e;
                    var t = {};
                    if (null != e)
                        for (var r in e) "default" !== r && Object.prototype.hasOwnProperty.call(e, r) && n(t, e, r);
                    return o(t, e), t
                };
            Object.defineProperty(t, "__esModule", {
                value: !0
            }), t.Comet38Client = void 0;
            let a = r(64484),
                s = r(24528),
                d = r(3096),
                c = i(r(60616));
            class l {
                static async connect(e) {
                    let t;
                    return t = "object" == typeof e ? new s.HttpClient(e) : e.startsWith("http://") || e.startsWith("https://") ? new s.HttpClient(e) : new s.WebsocketClient(e), await this.detectVersion(t), l.create(t)
                }
                static async create(e) {
                    return new l(e)
                }
                static async detectVersion(e) {
                    let t = (0, a.createJsonRpcRequest)(c.Method.Status),
                        r = (await e.execute(t)).result;
                    if (!r || !r.node_info) throw Error("Unrecognized format for status response");
                    let n = r.node_info.version;
                    if ("string" != typeof n) throw Error("Unrecognized version format: must be string");
                    return n
                }
                constructor(e) {
                    this.client = e
                }
                disconnect() {
                    this.client.disconnect()
                }
                async abciInfo() {
                    let e = {
                        method: c.Method.AbciInfo
                    };
                    return this.doCall(e, d.Params.encodeAbciInfo, d.Responses.decodeAbciInfo)
                }
                async abciQuery(e) {
                    let t = {
                        params: e,
                        method: c.Method.AbciQuery
                    };
                    return this.doCall(t, d.Params.encodeAbciQuery, d.Responses.decodeAbciQuery)
                }
                async block(e) {
                    let t = {
                        method: c.Method.Block,
                        params: {
                            height: e
                        }
                    };
                    return this.doCall(t, d.Params.encodeBlock, d.Responses.decodeBlock)
                }
                async blockResults(e) {
                    let t = {
                        method: c.Method.BlockResults,
                        params: {
                            height: e
                        }
                    };
                    return this.doCall(t, d.Params.encodeBlockResults, d.Responses.decodeBlockResults)
                }
                async blockSearch(e) {
                    let t = {
                            params: e,
                            method: c.Method.BlockSearch
                        },
                        r = await this.doCall(t, d.Params.encodeBlockSearch, d.Responses.decodeBlockSearch);
                    return { ...r,
                        blocks: [...r.blocks].sort((e, t) => e.block.header.height - t.block.header.height)
                    }
                }
                async blockSearchAll(e) {
                    let t = e.page || 1,
                        r = [],
                        n = !1;
                    for (; !n;) {
                        let o = await this.blockSearch({ ...e,
                            page: t
                        });
                        r.push(...o.blocks), r.length < o.totalCount ? t++ : n = !0
                    }
                    return r.sort((e, t) => e.block.header.height - t.block.header.height), {
                        totalCount: r.length,
                        blocks: r
                    }
                }
                async blockchain(e, t) {
                    let r = {
                        method: c.Method.Blockchain,
                        params: {
                            minHeight: e,
                            maxHeight: t
                        }
                    };
                    return this.doCall(r, d.Params.encodeBlockchain, d.Responses.decodeBlockchain)
                }
                async broadcastTxSync(e) {
                    let t = {
                        params: e,
                        method: c.Method.BroadcastTxSync
                    };
                    return this.doCall(t, d.Params.encodeBroadcastTx, d.Responses.decodeBroadcastTxSync)
                }
                async broadcastTxAsync(e) {
                    let t = {
                        params: e,
                        method: c.Method.BroadcastTxAsync
                    };
                    return this.doCall(t, d.Params.encodeBroadcastTx, d.Responses.decodeBroadcastTxAsync)
                }
                async broadcastTxCommit(e) {
                    let t = {
                        params: e,
                        method: c.Method.BroadcastTxCommit
                    };
                    return this.doCall(t, d.Params.encodeBroadcastTx, d.Responses.decodeBroadcastTxCommit)
                }
                async commit(e) {
                    let t = {
                        method: c.Method.Commit,
                        params: {
                            height: e
                        }
                    };
                    return this.doCall(t, d.Params.encodeCommit, d.Responses.decodeCommit)
                }
                async genesis() {
                    let e = {
                        method: c.Method.Genesis
                    };
                    return this.doCall(e, d.Params.encodeGenesis, d.Responses.decodeGenesis)
                }
                async health() {
                    let e = {
                        method: c.Method.Health
                    };
                    return this.doCall(e, d.Params.encodeHealth, d.Responses.decodeHealth)
                }
                async numUnconfirmedTxs() {
                    let e = {
                        method: c.Method.NumUnconfirmedTxs
                    };
                    return this.doCall(e, d.Params.encodeNumUnconfirmedTxs, d.Responses.decodeNumUnconfirmedTxs)
                }
                async status() {
                    let e = {
                        method: c.Method.Status
                    };
                    return this.doCall(e, d.Params.encodeStatus, d.Responses.decodeStatus)
                }
                subscribeNewBlock() {
                    let e = {
                        method: c.Method.Subscribe,
                        query: {
                            type: c.SubscriptionEventType.NewBlock
                        }
                    };
                    return this.subscribe(e, d.Responses.decodeNewBlockEvent)
                }
                subscribeNewBlockHeader() {
                    let e = {
                        method: c.Method.Subscribe,
                        query: {
                            type: c.SubscriptionEventType.NewBlockHeader
                        }
                    };
                    return this.subscribe(e, d.Responses.decodeNewBlockHeaderEvent)
                }
                subscribeTx(e) {
                    let t = {
                        method: c.Method.Subscribe,
                        query: {
                            type: c.SubscriptionEventType.Tx,
                            raw: e
                        }
                    };
                    return this.subscribe(t, d.Responses.decodeTxEvent)
                }
                async tx(e) {
                    let t = {
                        params: e,
                        method: c.Method.Tx
                    };
                    return this.doCall(t, d.Params.encodeTx, d.Responses.decodeTx)
                }
                async txSearch(e) {
                    let t = {
                        params: e,
                        method: c.Method.TxSearch
                    };
                    return this.doCall(t, d.Params.encodeTxSearch, d.Responses.decodeTxSearch)
                }
                async txSearchAll(e) {
                    let t = e.page || 1,
                        r = [],
                        n = !1;
                    for (; !n;) {
                        let o = await this.txSearch({ ...e,
                            page: t
                        });
                        r.push(...o.txs), r.length < o.totalCount ? t++ : n = !0
                    }
                    return {
                        totalCount: r.length,
                        txs: r
                    }
                }
                async validators(e) {
                    let t = {
                        method: c.Method.Validators,
                        params: e
                    };
                    return this.doCall(t, d.Params.encodeValidators, d.Responses.decodeValidators)
                }
                async validatorsAll(e) {
                    let t = [],
                        r = 1,
                        n = !1,
                        o = e;
                    for (; !n;) {
                        let e = await this.validators({
                            per_page: 50,
                            height: o,
                            page: r
                        });
                        t.push(...e.validators), o = o || e.blockHeight, t.length < e.total ? r++ : n = !0
                    }
                    return {
                        blockHeight: o ? ? 0,
                        count: t.length,
                        total: t.length,
                        validators: t
                    }
                }
                async doCall(e, t, r) {
                    let n = t(e);
                    return r(await this.client.execute(n))
                }
                subscribe(e, t) {
                    if (!(0, s.instanceOfRpcStreamingClient)(this.client)) throw Error("This RPC client type cannot subscribe to events");
                    let r = d.Params.encodeSubscribe(e);
                    return this.client.listen(r).map(e => t(e))
                }
            }
            t.Comet38Client = l
        },
        42677: function(e, t, r) {
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: !0
            }), t.encodeBlockId = t.encodeVersion = t.encodeBytes = t.encodeTime = t.encodeUvarint = t.encodeString = t.dictionaryToStringMap = t.may = t.assertNotEmpty = t.assertObject = t.assertArray = t.assertNumber = t.assertString = t.assertBoolean = t.assertSet = void 0;
            let n = r(81299);

            function o(e) {
                if (void 0 === e) throw Error("Value must not be undefined");
                if (null === e) throw Error("Value must not be null");
                return e
            }

            function i(e) {
                return e >= 128 ? Uint8Array.from([255 & e | 128, ...i(e >> 7)]) : Uint8Array.from([255 & e])
            }
            t.assertSet = o, t.assertBoolean = function(e) {
                if (o(e), "boolean" != typeof e) throw Error("Value must be a boolean");
                return e
            }, t.assertString = function(e) {
                if (o(e), "string" != typeof e) throw Error("Value must be a string");
                return e
            }, t.assertNumber = function(e) {
                if (o(e), "number" != typeof e) throw Error("Value must be a number");
                return e
            }, t.assertArray = function(e) {
                if (o(e), !Array.isArray(e)) throw Error("Value must be a an array");
                return e
            }, t.assertObject = function(e) {
                if (o(e), "object" != typeof e) throw Error("Value must be an object");
                if ("[object Object]" !== Object.prototype.toString.call(e)) throw Error("Value must be a simple object");
                return e
            }, t.assertNotEmpty = function(e) {
                if (o(e), "number" == typeof e && 0 === e) throw Error("must provide a non-zero value");
                if (0 === e.length) throw Error("must provide a non-empty value");
                return e
            }, t.may = function(e, t) {
                return null == t ? void 0 : e(t)
            }, t.dictionaryToStringMap = function(e) {
                let t = new Map;
                for (let r of Object.keys(e)) {
                    let n = e[r];
                    if ("string" != typeof n) throw Error("Found dictionary value of type other than string");
                    t.set(r, n)
                }
                return t
            }, t.encodeString = function(e) {
                let t = (0, n.toUtf8)(e);
                return Uint8Array.from([t.length, ...t])
            }, t.encodeUvarint = i, t.encodeTime = function(e) {
                let t = e.getTime(),
                    r = Math.floor(t / 1e3),
                    n = r ? [8, ...i(r)] : new Uint8Array,
                    o = (e.nanoseconds || 0) + t % 1e3 * 1e6,
                    a = o ? [16, ...i(o)] : new Uint8Array;
                return Uint8Array.from([...n, ...a])
            }, t.encodeBytes = function(e) {
                if (e.length >= 128) throw Error("Not implemented for byte arrays of length 128 or more");
                return e.length ? Uint8Array.from([e.length, ...e]) : new Uint8Array
            }, t.encodeVersion = function(e) {
                let t = e.block ? Uint8Array.from([8, ...i(e.block)]) : new Uint8Array,
                    r = e.app ? Uint8Array.from([16, ...i(e.app)]) : new Uint8Array;
                return Uint8Array.from([...t, ...r])
            }, t.encodeBlockId = function(e) {
                return Uint8Array.from([10, e.hash.length, ...e.hash, 18, e.parts.hash.length + 4, 8, e.parts.total, 18, e.parts.hash.length, ...e.parts.hash])
            }
        },
        44531: function(e, t, r) {
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: !0
            }), t.hashBlock = t.hashTx = void 0;
            let n = r(46495),
                o = r(42677);
            t.hashTx = function(e) {
                return (0, n.sha256)(e)
            }, t.hashBlock = function(e) {
                if (!e.lastBlockId) throw Error("Hashing a block header with no last block ID (i.e. header at height 1) is not supported. If you need this, contributions are welcome. Please add documentation and test vectors for this case.");
                return function e(t) {
                    switch (t.length) {
                        case 0:
                            throw Error("Cannot hash empty tree");
                        case 1:
                            return function(e) {
                                let t = new n.Sha256(Uint8Array.from([0]));
                                return t.update(e), t.digest()
                            }(t[0]);
                        default:
                            {
                                let r = function(e) {
                                    if (e < 1) throw Error("Cannot split an empty tree");
                                    let t = 2 ** Math.floor(Math.log2(e));
                                    return t < e ? t : t / 2
                                }(t.length);
                                return function(e, t) {
                                    let r = new n.Sha256(Uint8Array.from([1]));
                                    return r.update(e), r.update(t), r.digest()
                                }(e(t.slice(0, r)), e(t.slice(r)))
                            }
                    }
                }([(0, o.encodeVersion)(e.version), (0, o.encodeString)(e.chainId), (0, o.encodeUvarint)(e.height), (0, o.encodeTime)(e.time), (0, o.encodeBlockId)(e.lastBlockId), (0, o.encodeBytes)(e.lastCommitHash), (0, o.encodeBytes)(e.dataHash), (0, o.encodeBytes)(e.validatorsHash), (0, o.encodeBytes)(e.nextValidatorsHash), (0, o.encodeBytes)(e.consensusHash), (0, o.encodeBytes)(e.appHash), (0, o.encodeBytes)(e.lastResultsHash), (0, o.encodeBytes)(e.evidenceHash), (0, o.encodeBytes)(e.proposerAddress)])
            }
        },
        64355: function(e, t, r) {
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: !0
            }), t.VoteType = t.broadcastTxSyncSuccess = t.broadcastTxCommitSuccess = t.SubscriptionEventType = t.Method = t.Comet38Client = void 0;
            var n = r(70536);
            Object.defineProperty(t, "Comet38Client", {
                enumerable: !0,
                get: function() {
                    return n.Comet38Client
                }
            });
            var o = r(60616);
            Object.defineProperty(t, "Method", {
                enumerable: !0,
                get: function() {
                    return o.Method
                }
            }), Object.defineProperty(t, "SubscriptionEventType", {
                enumerable: !0,
                get: function() {
                    return o.SubscriptionEventType
                }
            });
            var i = r(98456);
            Object.defineProperty(t, "broadcastTxCommitSuccess", {
                enumerable: !0,
                get: function() {
                    return i.broadcastTxCommitSuccess
                }
            }), Object.defineProperty(t, "broadcastTxSyncSuccess", {
                enumerable: !0,
                get: function() {
                    return i.broadcastTxSyncSuccess
                }
            }), Object.defineProperty(t, "VoteType", {
                enumerable: !0,
                get: function() {
                    return i.VoteType
                }
            })
        },
        60616: function(e, t) {
            "use strict";
            var r, n;
            Object.defineProperty(t, "__esModule", {
                value: !0
            }), t.buildQuery = t.SubscriptionEventType = t.Method = void 0, (r = t.Method || (t.Method = {})).AbciInfo = "abci_info", r.AbciQuery = "abci_query", r.Block = "block", r.Blockchain = "blockchain", r.BlockResults = "block_results", r.BlockSearch = "block_search", r.BroadcastTxAsync = "broadcast_tx_async", r.BroadcastTxSync = "broadcast_tx_sync", r.BroadcastTxCommit = "broadcast_tx_commit", r.Commit = "commit", r.Genesis = "genesis", r.Health = "health", r.NumUnconfirmedTxs = "num_unconfirmed_txs", r.Status = "status", r.Subscribe = "subscribe", r.Tx = "tx", r.TxSearch = "tx_search", r.Validators = "validators", r.Unsubscribe = "unsubscribe", (n = t.SubscriptionEventType || (t.SubscriptionEventType = {})).NewBlock = "NewBlock", n.NewBlockHeader = "NewBlockHeader", n.Tx = "Tx", t.buildQuery = function(e) {
                return [...(e.tags ? e.tags : []).map(e => `${e.key}='${e.value}'`), ...e.raw ? [e.raw] : []].join(" AND ")
            }
        },
        98456: function(e, t) {
            "use strict";
            var r;
            Object.defineProperty(t, "__esModule", {
                value: !0
            }), t.VoteType = t.broadcastTxCommitSuccess = t.broadcastTxSyncSuccess = void 0, t.broadcastTxSyncSuccess = function(e) {
                return 0 === e.code
            }, t.broadcastTxCommitSuccess = function(e) {
                return 0 === e.checkTx.code && !!e.deliverTx && 0 === e.deliverTx.code
            }, (r = t.VoteType || (t.VoteType = {}))[r.PreVote = 1] = "PreVote", r[r.PreCommit = 2] = "PreCommit"
        },
        65932: function(e, t, r) {
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: !0
            }), t.DateTime = t.toSeconds = t.fromSeconds = t.toRfc3339WithNanoseconds = t.fromRfc3339WithNanoseconds = void 0;
            let n = r(81299),
                o = r(82071);

            function i(e) {
                let t = (0, n.fromRfc3339)(e),
                    r = e.match(/\.(\d+)Z$/),
                    o = r ? r[1].slice(3) : "";
                return t.nanoseconds = parseInt(o.padEnd(6, "0"), 10), t
            }

            function a(e) {
                let t = e.toISOString(),
                    r = e.nanoseconds ? .toString() ? ? "";
                return `${t.slice(0,-1)}${r.padStart(6,"0")}Z`
            }
            t.fromRfc3339WithNanoseconds = i, t.toRfc3339WithNanoseconds = a, t.fromSeconds = function(e, t = 0) {
                let r = new o.Uint32(t).toNumber();
                if (r > 999999999) throw Error("Nano seconds must not exceed 999999999");
                let n = new Date(1e3 * e + Math.floor(r / 1e6));
                return n.nanoseconds = r % 1e6, n
            }, t.toSeconds = function(e) {
                return {
                    seconds: Math.floor(e.getTime() / 1e3),
                    nanos: e.getTime() % 1e3 * 1e6 + (e.nanoseconds ? ? 0)
                }
            };
            class s {
                static decode(e) {
                    return i(e)
                }
                static encode(e) {
                    return a(e)
                }
            }
            t.DateTime = s
        },
        63584: function(e, t, r) {
            "use strict";
            var n = this && this.__createBinding || (Object.create ? function(e, t, r, n) {
                    void 0 === n && (n = r);
                    var o = Object.getOwnPropertyDescriptor(t, r);
                    (!o || ("get" in o ? !t.__esModule : o.writable || o.configurable)) && (o = {
                        enumerable: !0,
                        get: function() {
                            return t[r]
                        }
                    }), Object.defineProperty(e, n, o)
                } : function(e, t, r, n) {
                    void 0 === n && (n = r), e[n] = t[r]
                }),
                o = this && this.__setModuleDefault || (Object.create ? function(e, t) {
                    Object.defineProperty(e, "default", {
                        enumerable: !0,
                        value: t
                    })
                } : function(e, t) {
                    e.default = t
                }),
                i = this && this.__importStar || function(e) {
                    if (e && e.__esModule) return e;
                    var t = {};
                    if (null != e)
                        for (var r in e) "default" !== r && Object.prototype.hasOwnProperty.call(e, r) && n(t, e, r);
                    return o(t, e), t
                };
            Object.defineProperty(t, "__esModule", {
                value: !0
            }), t.BlockIdFlag = t.isTendermint37Client = t.isTendermint34Client = t.isComet38Client = t.connectComet = t.Tendermint37Client = t.tendermint37 = t.Tendermint34Client = t.tendermint34 = t.VoteType = t.SubscriptionEventType = t.Method = t.broadcastTxSyncSuccess = t.broadcastTxCommitSuccess = t.WebsocketClient = t.HttpClient = t.HttpBatchClient = t.Comet38Client = t.comet38 = t.toSeconds = t.toRfc3339WithNanoseconds = t.fromSeconds = t.fromRfc3339WithNanoseconds = t.DateTime = t.rawSecp256k1PubkeyToRawAddress = t.rawEd25519PubkeyToRawAddress = t.pubkeyToRawAddress = t.pubkeyToAddress = void 0;
            var a = r(94984);
            Object.defineProperty(t, "pubkeyToAddress", {
                enumerable: !0,
                get: function() {
                    return a.pubkeyToAddress
                }
            }), Object.defineProperty(t, "pubkeyToRawAddress", {
                enumerable: !0,
                get: function() {
                    return a.pubkeyToRawAddress
                }
            }), Object.defineProperty(t, "rawEd25519PubkeyToRawAddress", {
                enumerable: !0,
                get: function() {
                    return a.rawEd25519PubkeyToRawAddress
                }
            }), Object.defineProperty(t, "rawSecp256k1PubkeyToRawAddress", {
                enumerable: !0,
                get: function() {
                    return a.rawSecp256k1PubkeyToRawAddress
                }
            });
            var s = r(65932);
            Object.defineProperty(t, "DateTime", {
                enumerable: !0,
                get: function() {
                    return s.DateTime
                }
            }), Object.defineProperty(t, "fromRfc3339WithNanoseconds", {
                enumerable: !0,
                get: function() {
                    return s.fromRfc3339WithNanoseconds
                }
            }), Object.defineProperty(t, "fromSeconds", {
                enumerable: !0,
                get: function() {
                    return s.fromSeconds
                }
            }), Object.defineProperty(t, "toRfc3339WithNanoseconds", {
                enumerable: !0,
                get: function() {
                    return s.toRfc3339WithNanoseconds
                }
            }), Object.defineProperty(t, "toSeconds", {
                enumerable: !0,
                get: function() {
                    return s.toSeconds
                }
            }), t.comet38 = i(r(64355));
            var d = r(64355);
            Object.defineProperty(t, "Comet38Client", {
                enumerable: !0,
                get: function() {
                    return d.Comet38Client
                }
            });
            var c = r(24528);
            Object.defineProperty(t, "HttpBatchClient", {
                enumerable: !0,
                get: function() {
                    return c.HttpBatchClient
                }
            }), Object.defineProperty(t, "HttpClient", {
                enumerable: !0,
                get: function() {
                    return c.HttpClient
                }
            }), Object.defineProperty(t, "WebsocketClient", {
                enumerable: !0,
                get: function() {
                    return c.WebsocketClient
                }
            });
            var l = r(90716);
            Object.defineProperty(t, "broadcastTxCommitSuccess", {
                enumerable: !0,
                get: function() {
                    return l.broadcastTxCommitSuccess
                }
            }), Object.defineProperty(t, "broadcastTxSyncSuccess", {
                enumerable: !0,
                get: function() {
                    return l.broadcastTxSyncSuccess
                }
            }), Object.defineProperty(t, "Method", {
                enumerable: !0,
                get: function() {
                    return l.Method
                }
            }), Object.defineProperty(t, "SubscriptionEventType", {
                enumerable: !0,
                get: function() {
                    return l.SubscriptionEventType
                }
            }), Object.defineProperty(t, "VoteType", {
                enumerable: !0,
                get: function() {
                    return l.VoteType
                }
            }), t.tendermint34 = i(r(90716));
            var u = r(90716);
            Object.defineProperty(t, "Tendermint34Client", {
                enumerable: !0,
                get: function() {
                    return u.Tendermint34Client
                }
            }), t.tendermint37 = i(r(79158));
            var p = r(79158);
            Object.defineProperty(t, "Tendermint37Client", {
                enumerable: !0,
                get: function() {
                    return p.Tendermint37Client
                }
            });
            var m = r(74108);
            Object.defineProperty(t, "connectComet", {
                enumerable: !0,
                get: function() {
                    return m.connectComet
                }
            }), Object.defineProperty(t, "isComet38Client", {
                enumerable: !0,
                get: function() {
                    return m.isComet38Client
                }
            }), Object.defineProperty(t, "isTendermint34Client", {
                enumerable: !0,
                get: function() {
                    return m.isTendermint34Client
                }
            }), Object.defineProperty(t, "isTendermint37Client", {
                enumerable: !0,
                get: function() {
                    return m.isTendermint37Client
                }
            });
            var g = r(5347);
            Object.defineProperty(t, "BlockIdFlag", {
                enumerable: !0,
                get: function() {
                    return g.BlockIdFlag
                }
            })
        },
        69581: function(e, t, r) {
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: !0
            }), t.smallIntToApi = t.apiToBigInt = t.apiToSmallInt = void 0;
            let n = r(82071),
                o = r(57009);
            t.apiToSmallInt = function(e) {
                return ("number" == typeof e ? new n.Int53(e) : n.Int53.fromString(e)).toNumber()
            }, t.apiToBigInt = function(e) {
                if ((0, o.assertString)(e), !e.match(/^-?[0-9]+$/)) throw Error("Invalid string format");
                return BigInt(e)
            }, t.smallIntToApi = function(e) {
                return new n.Int53(e).toString()
            }
        },
        64484: function(e, t) {
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: !0
            }), t.createJsonRpcRequest = void 0;
            let r = "123456789";
            t.createJsonRpcRequest = function(e, t) {
                let n = t ? { ...t
                } : {};
                return {
                    jsonrpc: "2.0",
                    id: parseInt(Array.from({
                        length: 12
                    }).map(() => r[Math.floor(Math.random() * r.length)]).join(""), 10),
                    method: e,
                    params: n
                }
            }
        },
        44390: function(e, t, r) {
            "use strict";
            var n = this && this.__importDefault || function(e) {
                return e && e.__esModule ? e : {
                    default: e
                }
            };
            Object.defineProperty(t, "__esModule", {
                value: !0
            }), t.http = void 0;
            let o = n(r(48772));

            function i(e) {
                if (e.status >= 400) throw Error(`Bad status on response: ${e.status}`);
                return e
            }
            async function a(e, t, r, n) {
                if ("function" != typeof fetch || fetch.toString().includes("emitExperimentalWarning")) return o.default.request({
                    url: t,
                    method: e,
                    data: n,
                    headers: r
                }).then(e => e.data); {
                    let o = {
                        method: e,
                        body: n ? JSON.stringify(n) : void 0,
                        headers: {
                            "Content-Type": "application/json",
                            ...r
                        }
                    };
                    return fetch(t, o).then(i).then(e => e.json())
                }
            }
            t.http = a
        },
        24027: function(e, t, r) {
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: !0
            }), t.HttpBatchClient = void 0;
            let n = r(83348),
                o = r(44390),
                i = r(29848),
                a = {
                    dispatchInterval: 20,
                    batchSizeLimit: 20
                };
            class s {
                constructor(e, t = {}) {
                    if (this.queue = [], this.options = {
                            batchSizeLimit: t.batchSizeLimit ? ? a.batchSizeLimit,
                            dispatchInterval: t.dispatchInterval ? ? a.dispatchInterval
                        }, "string" == typeof e) {
                        if (!(0, i.hasProtocol)(e)) throw Error("Endpoint URL is missing a protocol. Expected 'https://' or 'http://'.");
                        this.url = e
                    } else this.url = e.url, this.headers = e.headers;
                    this.timer = setInterval(() => this.tick(), t.dispatchInterval), this.validate()
                }
                disconnect() {
                    this.timer && clearInterval(this.timer), this.timer = void 0
                }
                async execute(e) {
                    return new Promise((t, r) => {
                        this.queue.push({
                            request: e,
                            resolve: t,
                            reject: r
                        }), this.queue.length >= this.options.batchSizeLimit && this.tick()
                    })
                }
                validate() {
                    if (!this.options.batchSizeLimit || !Number.isSafeInteger(this.options.batchSizeLimit) || this.options.batchSizeLimit < 1) throw Error("batchSizeLimit must be a safe integer >= 1")
                }
                tick() {
                    let e = this.queue.splice(0, this.options.batchSizeLimit);
                    if (!e.length) return;
                    let t = e.map(e => e.request),
                        r = t.map(e => e.id);
                    (0, o.http)("POST", this.url, this.headers, t).then(t => {
                        (Array.isArray(t) ? t : [t]).forEach(t => {
                            let r = e.find(e => e.request.id === t.id);
                            if (!r) return;
                            let {
                                reject: o,
                                resolve: i
                            } = r, a = (0, n.parseJsonRpcResponse)(t);
                            (0, n.isJsonRpcErrorResponse)(a) ? o(Error(JSON.stringify(a.error))): i(a)
                        })
                    }, t => {
                        for (let n of r) {
                            let r = e.find(e => e.request.id === n);
                            if (!r) return;
                            r.reject(t)
                        }
                    })
                }
            }
            t.HttpBatchClient = s
        },
        83536: function(e, t, r) {
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: !0
            }), t.HttpClient = void 0;
            let n = r(83348),
                o = r(44390),
                i = r(29848);
            class a {
                constructor(e) {
                    if ("string" == typeof e) {
                        if (!(0, i.hasProtocol)(e)) throw Error("Endpoint URL is missing a protocol. Expected 'https://' or 'http://'.");
                        this.url = e
                    } else this.url = e.url, this.headers = e.headers
                }
                disconnect() {}
                async execute(e) {
                    let t = (0, n.parseJsonRpcResponse)(await (0, o.http)("POST", this.url, this.headers, e));
                    if ((0, n.isJsonRpcErrorResponse)(t)) throw Error(JSON.stringify(t.error));
                    return t
                }
            }
            t.HttpClient = a
        },
        24528: function(e, t, r) {
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: !0
            }), t.WebsocketClient = t.instanceOfRpcStreamingClient = t.HttpClient = t.HttpBatchClient = void 0;
            var n = r(24027);
            Object.defineProperty(t, "HttpBatchClient", {
                enumerable: !0,
                get: function() {
                    return n.HttpBatchClient
                }
            });
            var o = r(83536);
            Object.defineProperty(t, "HttpClient", {
                enumerable: !0,
                get: function() {
                    return o.HttpClient
                }
            });
            var i = r(29848);
            Object.defineProperty(t, "instanceOfRpcStreamingClient", {
                enumerable: !0,
                get: function() {
                    return i.instanceOfRpcStreamingClient
                }
            });
            var a = r(98668);
            Object.defineProperty(t, "WebsocketClient", {
                enumerable: !0,
                get: function() {
                    return a.WebsocketClient
                }
            })
        },
        29848: function(e, t) {
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: !0
            }), t.hasProtocol = t.instanceOfRpcStreamingClient = void 0, t.instanceOfRpcStreamingClient = function(e) {
                return "function" == typeof e.listen
            }, t.hasProtocol = function(e) {
                return -1 !== e.search("://")
            }
        },
        98668: function(e, t, r) {
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: !0
            }), t.WebsocketClient = void 0;
            let n = r(83348),
                o = r(57678),
                i = r(59210),
                a = r(43813),
                s = r(29848);

            function d(e) {
                throw e
            }

            function c(e) {
                if ("message" !== e.type) throw Error(`Unexcepted message type on websocket: ${e.type}`);
                return (0, n.parseJsonRpcResponse)(JSON.parse(e.data))
            }
            class l {
                constructor(e, t) {
                    this.running = !1, this.subscriptions = [], this.request = e, this.socket = t
                }
                start(e) {
                    if (this.running) throw Error("Already started. Please stop first before restarting.");
                    this.running = !0, this.connectToClient(e), this.socket.queueRequest(JSON.stringify(this.request))
                }
                stop() {
                    this.running = !1;
                    let e = { ...this.request,
                        method: "unsubscribe"
                    };
                    try {
                        this.socket.queueRequest(JSON.stringify(e))
                    } catch (e) {
                        if (e instanceof Error && e.message.match(/socket has disconnected/i));
                        else throw e
                    }
                }
                connectToClient(e) {
                    let t = this.socket.events.map(c),
                        r = t.filter(e => e.id === this.request.id).subscribe({
                            next: t => {
                                (0, n.isJsonRpcErrorResponse)(t) && (this.closeSubscriptions(), e.error(JSON.stringify(t.error))), r.unsubscribe()
                            }
                        }),
                        o = t.filter(e => e.id === this.request.id).subscribe({
                            next: t => {
                                (0, n.isJsonRpcErrorResponse)(t) ? (this.closeSubscriptions(), e.error(JSON.stringify(t.error))) : e.next(t.result)
                            }
                        }),
                        i = t.subscribe({
                            error: t => {
                                this.closeSubscriptions(), e.error(t)
                            },
                            complete: () => {
                                this.closeSubscriptions(), e.complete()
                            }
                        });
                    this.subscriptions.push(r, o, i)
                }
                closeSubscriptions() {
                    for (let e of this.subscriptions) e.unsubscribe();
                    this.subscriptions = []
                }
            }
            class u {
                constructor(e, t = d) {
                    if (this.subscriptionStreams = new Map, !(0, s.hasProtocol)(e)) throw Error("Base URL is missing a protocol. Expected 'ws://' or 'wss://'.");
                    let r = e.endsWith("/") ? "websocket" : "/websocket";
                    this.url = e + r, this.socket = new o.ReconnectingSocket(this.url);
                    let n = this.socket.events.subscribe({
                        error: e => {
                            t(e), n.unsubscribe()
                        }
                    });
                    this.jsonRpcResponseStream = this.socket.events.map(c), this.socket.connect()
                }
                async execute(e) {
                    let t = this.responseForRequestId(e.id);
                    this.socket.queueRequest(JSON.stringify(e));
                    let r = await t;
                    if ((0, n.isJsonRpcErrorResponse)(r)) throw Error(JSON.stringify(r.error));
                    return r
                }
                listen(e) {
                    if ("subscribe" !== e.method) throw Error('Request method must be "subscribe" to start event listening');
                    let t = e.params.query;
                    if ("string" != typeof t) throw Error("request.params.query must be a string");
                    if (!this.subscriptionStreams.has(t)) {
                        let r = new l(e, this.socket),
                            n = a.Stream.create(r);
                        this.subscriptionStreams.set(t, n)
                    }
                    return this.subscriptionStreams.get(t).filter(e => void 0 !== e.query)
                }
                async connected() {
                    await this.socket.connectionStatus.waitFor(o.ConnectionStatus.Connected)
                }
                disconnect() {
                    this.socket.disconnect()
                }
                async responseForRequestId(e) {
                    return (0, i.firstEvent)(this.jsonRpcResponseStream.filter(t => t.id === e))
                }
            }
            t.WebsocketClient = u
        },
        27547: function(e, t, r) {
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: !0
            }), t.Responses = t.Params = void 0;
            var n = r(87284);
            Object.defineProperty(t, "Params", {
                enumerable: !0,
                get: function() {
                    return n.Params
                }
            });
            var o = r(87298);
            Object.defineProperty(t, "Responses", {
                enumerable: !0,
                get: function() {
                    return o.Responses
                }
            })
        },
        87284: function(e, t, r) {
            "use strict";
            var n = this && this.__createBinding || (Object.create ? function(e, t, r, n) {
                    void 0 === n && (n = r);
                    var o = Object.getOwnPropertyDescriptor(t, r);
                    (!o || ("get" in o ? !t.__esModule : o.writable || o.configurable)) && (o = {
                        enumerable: !0,
                        get: function() {
                            return t[r]
                        }
                    }), Object.defineProperty(e, n, o)
                } : function(e, t, r, n) {
                    void 0 === n && (n = r), e[n] = t[r]
                }),
                o = this && this.__setModuleDefault || (Object.create ? function(e, t) {
                    Object.defineProperty(e, "default", {
                        enumerable: !0,
                        value: t
                    })
                } : function(e, t) {
                    e.default = t
                }),
                i = this && this.__importStar || function(e) {
                    if (e && e.__esModule) return e;
                    var t = {};
                    if (null != e)
                        for (var r in e) "default" !== r && Object.prototype.hasOwnProperty.call(e, r) && n(t, e, r);
                    return o(t, e), t
                };
            Object.defineProperty(t, "__esModule", {
                value: !0
            }), t.Params = void 0;
            let a = r(81299),
                s = r(69581),
                d = r(64484),
                c = r(57009),
                l = i(r(66712));

            function u(e) {
                return {
                    height: (0, c.may)(s.smallIntToApi, e.height)
                }
            }
            class p {
                static encodeAbciInfo(e) {
                    return (0, d.createJsonRpcRequest)(e.method)
                }
                static encodeAbciQuery(e) {
                    var t;
                    return (0, d.createJsonRpcRequest)(e.method, (t = e.params, {
                        path: (0, c.assertNotEmpty)(t.path),
                        data: (0, a.toHex)(t.data),
                        height: (0, c.may)(s.smallIntToApi, t.height),
                        prove: t.prove
                    }))
                }
                static encodeBlock(e) {
                    return (0, d.createJsonRpcRequest)(e.method, u(e.params))
                }
                static encodeBlockchain(e) {
                    var t;
                    return (0, d.createJsonRpcRequest)(e.method, (t = e.params, {
                        minHeight: (0, c.may)(s.smallIntToApi, t.minHeight),
                        maxHeight: (0, c.may)(s.smallIntToApi, t.maxHeight)
                    }))
                }
                static encodeBlockResults(e) {
                    return (0, d.createJsonRpcRequest)(e.method, u(e.params))
                }
                static encodeBlockSearch(e) {
                    var t;
                    return (0, d.createJsonRpcRequest)(e.method, {
                        query: (t = e.params).query,
                        page: (0, c.may)(s.smallIntToApi, t.page),
                        per_page: (0, c.may)(s.smallIntToApi, t.per_page),
                        order_by: t.order_by
                    })
                }
                static encodeBroadcastTx(e) {
                    var t;
                    return (0, d.createJsonRpcRequest)(e.method, (t = e.params, {
                        tx: (0, a.toBase64)((0, c.assertNotEmpty)(t.tx))
                    }))
                }
                static encodeCommit(e) {
                    return (0, d.createJsonRpcRequest)(e.method, u(e.params))
                }
                static encodeGenesis(e) {
                    return (0, d.createJsonRpcRequest)(e.method)
                }
                static encodeHealth(e) {
                    return (0, d.createJsonRpcRequest)(e.method)
                }
                static encodeNumUnconfirmedTxs(e) {
                    return (0, d.createJsonRpcRequest)(e.method)
                }
                static encodeStatus(e) {
                    return (0, d.createJsonRpcRequest)(e.method)
                }
                static encodeSubscribe(e) {
                    let t = {
                            key: "tm.event",
                            value: e.query.type
                        },
                        r = l.buildQuery({
                            tags: [t],
                            raw: e.query.raw
                        });
                    return (0, d.createJsonRpcRequest)("subscribe", {
                        query: r
                    })
                }
                static encodeTx(e) {
                    var t;
                    return (0, d.createJsonRpcRequest)(e.method, (t = e.params, {
                        hash: (0, a.toBase64)((0, c.assertNotEmpty)(t.hash)),
                        prove: t.prove
                    }))
                }
                static encodeTxSearch(e) {
                    var t;
                    return (0, d.createJsonRpcRequest)(e.method, {
                        query: (t = e.params).query,
                        prove: t.prove,
                        page: (0, c.may)(s.smallIntToApi, t.page),
                        per_page: (0, c.may)(s.smallIntToApi, t.per_page),
                        order_by: t.order_by
                    })
                }
                static encodeValidators(e) {
                    var t;
                    return (0, d.createJsonRpcRequest)(e.method, (t = e.params, {
                        height: (0, c.may)(s.smallIntToApi, t.height),
                        page: (0, c.may)(s.smallIntToApi, t.page),
                        per_page: (0, c.may)(s.smallIntToApi, t.per_page)
                    }))
                }
            }
            t.Params = p
        },
        87298: function(e, t, r) {
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: !0
            }), t.Responses = t.decodeValidatorInfo = t.decodeValidatorGenesis = t.decodeValidatorUpdate = t.decodeEvent = void 0;
            let n = r(81299),
                o = r(8261),
                i = r(65932),
                a = r(69581),
                s = r(5347),
                d = r(57009),
                c = r(47777);

            function l(e) {
                return {
                    ops: e.ops.map(e => ({
                        type: e.type,
                        key: (0, n.fromBase64)(e.key),
                        data: (0, n.fromBase64)(e.data)
                    }))
                }
            }

            function u(e) {
                return {
                    key: (0, n.fromBase64)((0, d.assertNotEmpty)(e.key)),
                    value: (0, n.fromBase64)((0, d.assertString)(e.value ? ? ""))
                }
            }

            function p(e) {
                var t;
                return {
                    type: e.type,
                    attributes: e.attributes ? (t = e.attributes, (0, d.assertArray)(t).map(u)) : []
                }
            }

            function m(e) {
                return (0, d.assertArray)(e).map(p)
            }

            function g(e) {
                return {
                    code: (0, a.apiToSmallInt)((0, d.assertNumber)(e.code ? ? 0)),
                    codespace: e.codespace,
                    log: e.log,
                    data: (0, d.may)(n.fromBase64, e.data),
                    events: e.events ? m(e.events) : [],
                    gasWanted: (0, a.apiToBigInt)(e.gas_wanted ? ? "0"),
                    gasUsed: (0, a.apiToBigInt)(e.gas_used ? ? "0")
                }
            }

            function f(e) {
                if ("Sum" in e) {
                    let [
                        [t, r]
                    ] = Object.entries(e.Sum.value);
                    return (0, o.assert)("ed25519" === t || "secp256k1" === t, `unknown pubkey type: ${t}`), {
                        algorithm: t,
                        data: (0, n.fromBase64)((0, d.assertNotEmpty)(r))
                    }
                }
                switch (e.type) {
                    case "tendermint/PubKeyEd25519":
                        return {
                            algorithm: "ed25519",
                            data: (0, n.fromBase64)((0, d.assertNotEmpty)(e.value))
                        };
                    case "tendermint/PubKeySecp256k1":
                        return {
                            algorithm: "secp256k1",
                            data: (0, n.fromBase64)((0, d.assertNotEmpty)(e.value))
                        };
                    default:
                        throw Error(`unknown pubkey type: ${e.type}`)
                }
            }

            function y(e) {
                var t, r;
                return {
                    block: (t = (0, d.assertObject)(e.block), {
                        maxBytes: (0, a.apiToSmallInt)((0, d.assertNotEmpty)(t.max_bytes)),
                        maxGas: (0, a.apiToSmallInt)((0, d.assertNotEmpty)(t.max_gas))
                    }),
                    evidence: (r = (0, d.assertObject)(e.evidence), {
                        maxAgeNumBlocks: (0, a.apiToSmallInt)((0, d.assertNotEmpty)(r.max_age_num_blocks)),
                        maxAgeDuration: (0, a.apiToSmallInt)((0, d.assertNotEmpty)(r.max_age_duration))
                    })
                }
            }

            function h(e) {
                return {
                    pubkey: f((0, d.assertObject)(e.pub_key)),
                    votingPower: (0, a.apiToBigInt)(e.power ? ? "0")
                }
            }

            function v(e) {
                return {
                    hash: (0, n.fromHex)((0, d.assertNotEmpty)(e.hash)),
                    parts: {
                        total: (0, d.assertNotEmpty)(e.parts.total),
                        hash: (0, n.fromHex)((0, d.assertNotEmpty)(e.parts.hash))
                    }
                }
            }

            function b(e) {
                var t;
                return {
                    version: (t = e.version, {
                        block: (0, a.apiToSmallInt)(t.block),
                        app: (0, a.apiToSmallInt)(t.app ? ? 0)
                    }),
                    chainId: (0, d.assertNotEmpty)(e.chain_id),
                    height: (0, a.apiToSmallInt)((0, d.assertNotEmpty)(e.height)),
                    time: (0, i.fromRfc3339WithNanoseconds)((0, d.assertNotEmpty)(e.time)),
                    lastBlockId: e.last_block_id.hash ? v(e.last_block_id) : null,
                    lastCommitHash: (0, n.fromHex)((0, d.assertSet)(e.last_commit_hash)),
                    dataHash: (0, n.fromHex)((0, d.assertSet)(e.data_hash)),
                    validatorsHash: (0, n.fromHex)((0, d.assertSet)(e.validators_hash)),
                    nextValidatorsHash: (0, n.fromHex)((0, d.assertSet)(e.next_validators_hash)),
                    consensusHash: (0, n.fromHex)((0, d.assertSet)(e.consensus_hash)),
                    appHash: (0, n.fromHex)((0, d.assertSet)(e.app_hash)),
                    lastResultsHash: (0, n.fromHex)((0, d.assertSet)(e.last_results_hash)),
                    evidenceHash: (0, n.fromHex)((0, d.assertSet)(e.evidence_hash)),
                    proposerAddress: (0, n.fromHex)((0, d.assertNotEmpty)(e.proposer_address))
                }
            }

            function S(e) {
                return {
                    blockId: v(e.block_id),
                    blockSize: (0, a.apiToSmallInt)((0, d.assertNotEmpty)(e.block_size)),
                    header: b(e.header),
                    numTxs: (0, a.apiToSmallInt)((0, d.assertNotEmpty)(e.num_txs))
                }
            }

            function k(e) {
                var t;
                return {
                    blockIdFlag: (t = e.block_id_flag, (0, o.assert)(t in s.BlockIdFlag), t),
                    validatorAddress: e.validator_address ? (0, n.fromHex)(e.validator_address) : void 0,
                    timestamp: e.timestamp ? (0, i.fromRfc3339WithNanoseconds)(e.timestamp) : void 0,
                    signature: e.signature ? (0, n.fromBase64)(e.signature) : void 0
                }
            }

            function P(e) {
                return {
                    blockId: v((0, d.assertObject)(e.block_id)),
                    height: (0, a.apiToSmallInt)((0, d.assertNotEmpty)(e.height)),
                    round: (0, a.apiToSmallInt)(e.round),
                    signatures: (0, d.assertArray)(e.signatures).map(k)
                }
            }

            function _(e) {
                return {
                    address: (0, n.fromHex)((0, d.assertNotEmpty)(e.address)),
                    pubkey: f((0, d.assertObject)(e.pub_key)),
                    votingPower: (0, a.apiToBigInt)((0, d.assertNotEmpty)(e.power))
                }
            }

            function B(e) {
                return {
                    pubkey: f((0, d.assertObject)(e.pub_key)),
                    votingPower: (0, a.apiToBigInt)((0, d.assertNotEmpty)(e.voting_power)),
                    address: (0, n.fromHex)((0, d.assertNotEmpty)(e.address)),
                    proposerPriority: e.proposer_priority ? (0, a.apiToSmallInt)(e.proposer_priority) : void 0
                }
            }

            function O(e) {
                return {
                    data: (0, n.fromBase64)((0, d.assertNotEmpty)(e.data)),
                    rootHash: (0, n.fromHex)((0, d.assertNotEmpty)(e.root_hash)),
                    proof: {
                        total: (0, a.apiToSmallInt)((0, d.assertNotEmpty)(e.proof.total)),
                        index: (0, a.apiToSmallInt)((0, d.assertNotEmpty)(e.proof.index)),
                        leafHash: (0, n.fromBase64)((0, d.assertNotEmpty)(e.proof.leaf_hash)),
                        aunts: (0, d.assertArray)(e.proof.aunts).map(n.fromBase64)
                    }
                }
            }

            function R(e) {
                return {
                    tx: (0, n.fromBase64)((0, d.assertNotEmpty)(e.tx)),
                    result: g((0, d.assertObject)(e.tx_result)),
                    height: (0, a.apiToSmallInt)((0, d.assertNotEmpty)(e.height)),
                    index: (0, a.apiToSmallInt)((0, d.assertNumber)(e.index)),
                    hash: (0, n.fromHex)((0, d.assertNotEmpty)(e.hash)),
                    proof: (0, d.may)(O, e.proof)
                }
            }

            function A(e) {
                return {
                    header: b((0, d.assertObject)(e.header)),
                    lastCommit: e.last_commit.block_id.hash ? P((0, d.assertObject)(e.last_commit)) : null,
                    txs: e.data.txs ? (0, d.assertArray)(e.data.txs).map(n.fromBase64) : [],
                    evidence: e.evidence ? .evidence ? ? []
                }
            }

            function I(e) {
                return {
                    blockId: v(e.block_id),
                    block: A(e.block)
                }
            }
            t.decodeEvent = p, t.decodeValidatorUpdate = h, t.decodeValidatorGenesis = _, t.decodeValidatorInfo = B;
            class w {
                static decodeAbciInfo(e) {
                    var t;
                    return {
                        data: (t = (0, d.assertObject)(e.result.response)).data,
                        lastBlockHeight: (0, d.may)(a.apiToSmallInt, t.last_block_height),
                        lastBlockAppHash: (0, d.may)(n.fromBase64, t.last_block_app_hash)
                    }
                }
                static decodeAbciQuery(e) {
                    var t;
                    return t = (0, d.assertObject)(e.result.response), {
                        key: (0, n.fromBase64)((0, d.assertString)(t.key ? ? "")),
                        value: (0, n.fromBase64)((0, d.assertString)(t.value ? ? "")),
                        proof: (0, d.may)(l, t.proofOps),
                        height: (0, d.may)(a.apiToSmallInt, t.height),
                        code: (0, d.may)(a.apiToSmallInt, t.code),
                        codespace: (0, d.assertString)(t.codespace ? ? ""),
                        index: (0, d.may)(a.apiToSmallInt, t.index),
                        log: t.log,
                        info: (0, d.assertString)(t.info ? ? "")
                    }
                }
                static decodeBlock(e) {
                    return I(e.result)
                }
                static decodeBlockResults(e) {
                    var t;
                    return t = e.result, {
                        height: (0, a.apiToSmallInt)((0, d.assertNotEmpty)(t.height)),
                        results: (t.txs_results || []).map(g),
                        validatorUpdates: (t.validator_updates || []).map(h),
                        consensusUpdates: (0, d.may)(y, t.consensus_param_updates),
                        beginBlockEvents: m(t.begin_block_events || []),
                        endBlockEvents: m(t.end_block_events || [])
                    }
                }
                static decodeBlockSearch(e) {
                    var t;
                    return t = e.result, {
                        totalCount: (0, a.apiToSmallInt)((0, d.assertNotEmpty)(t.total_count)),
                        blocks: (0, d.assertArray)(t.blocks).map(I)
                    }
                }
                static decodeBlockchain(e) {
                    var t;
                    return t = e.result, {
                        lastHeight: (0, a.apiToSmallInt)((0, d.assertNotEmpty)(t.last_height)),
                        blockMetas: (0, d.assertArray)(t.block_metas).map(S)
                    }
                }
                static decodeBroadcastTxSync(e) {
                    var t;
                    return { ...g(t = e.result),
                        hash: (0, n.fromHex)((0, d.assertNotEmpty)(t.hash))
                    }
                }
                static decodeBroadcastTxAsync(e) {
                    return w.decodeBroadcastTxSync(e)
                }
                static decodeBroadcastTxCommit(e) {
                    var t;
                    return t = e.result, {
                        height: (0, a.apiToSmallInt)(t.height),
                        hash: (0, n.fromHex)((0, d.assertNotEmpty)(t.hash)),
                        checkTx: g((0, d.assertObject)(t.check_tx)),
                        deliverTx: (0, d.may)(g, t.deliver_tx)
                    }
                }
                static decodeCommit(e) {
                    var t;
                    return t = e.result, {
                        canonical: (0, d.assertBoolean)(t.canonical),
                        header: b(t.signed_header.header),
                        commit: P(t.signed_header.commit)
                    }
                }
                static decodeGenesis(e) {
                    var t;
                    return t = (0, d.assertObject)(e.result.genesis), {
                        genesisTime: (0, i.fromRfc3339WithNanoseconds)((0, d.assertNotEmpty)(t.genesis_time)),
                        chainId: (0, d.assertNotEmpty)(t.chain_id),
                        consensusParams: y(t.consensus_params),
                        validators: t.validators ? (0, d.assertArray)(t.validators).map(_) : [],
                        appHash: (0, n.fromHex)((0, d.assertSet)(t.app_hash)),
                        appState: t.app_state
                    }
                }
                static decodeHealth() {
                    return null
                }
                static decodeNumUnconfirmedTxs(e) {
                    var t;
                    return t = e.result, {
                        total: (0, a.apiToSmallInt)((0, d.assertNotEmpty)(t.total)),
                        totalBytes: (0, a.apiToSmallInt)((0, d.assertNotEmpty)(t.total_bytes))
                    }
                }
                static decodeStatus(e) {
                    var t, r;
                    return {
                        nodeInfo: (r = (t = e.result).node_info, {
                            id: (0, n.fromHex)((0, d.assertNotEmpty)(r.id)),
                            listenAddr: (0, d.assertNotEmpty)(r.listen_addr),
                            network: (0, d.assertNotEmpty)(r.network),
                            version: (0, d.assertString)(r.version),
                            channels: (0, d.assertNotEmpty)(r.channels),
                            moniker: (0, d.assertNotEmpty)(r.moniker),
                            other: (0, d.dictionaryToStringMap)(r.other),
                            protocolVersion: {
                                app: (0, a.apiToSmallInt)((0, d.assertNotEmpty)(r.protocol_version.app)),
                                block: (0, a.apiToSmallInt)((0, d.assertNotEmpty)(r.protocol_version.block)),
                                p2p: (0, a.apiToSmallInt)((0, d.assertNotEmpty)(r.protocol_version.p2p))
                            }
                        }),
                        syncInfo: function(e) {
                            let t = e.earliest_block_height ? (0, a.apiToSmallInt)(e.earliest_block_height) : void 0,
                                r = e.earliest_block_time ? (0, i.fromRfc3339WithNanoseconds)(e.earliest_block_time) : void 0;
                            return {
                                earliestAppHash: e.earliest_app_hash ? (0, n.fromHex)(e.earliest_app_hash) : void 0,
                                earliestBlockHash: e.earliest_block_hash ? (0, n.fromHex)(e.earliest_block_hash) : void 0,
                                earliestBlockHeight: t || void 0,
                                earliestBlockTime: r ? .getTime() ? r : void 0,
                                latestBlockHash: (0, n.fromHex)((0, d.assertNotEmpty)(e.latest_block_hash)),
                                latestAppHash: (0, n.fromHex)((0, d.assertNotEmpty)(e.latest_app_hash)),
                                latestBlockTime: (0, i.fromRfc3339WithNanoseconds)((0, d.assertNotEmpty)(e.latest_block_time)),
                                latestBlockHeight: (0, a.apiToSmallInt)((0, d.assertNotEmpty)(e.latest_block_height)),
                                catchingUp: (0, d.assertBoolean)(e.catching_up)
                            }
                        }(t.sync_info),
                        validatorInfo: B(t.validator_info)
                    }
                }
                static decodeNewBlockEvent(e) {
                    return A(e.data.value.block)
                }
                static decodeNewBlockHeaderEvent(e) {
                    return b(e.data.value.header)
                }
                static decodeTxEvent(e) {
                    return function(e) {
                        let t = (0, n.fromBase64)((0, d.assertNotEmpty)(e.tx));
                        return {
                            tx: t,
                            hash: (0, c.hashTx)(t),
                            result: g(e.result),
                            height: (0, a.apiToSmallInt)((0, d.assertNotEmpty)(e.height))
                        }
                    }(e.data.value.TxResult)
                }
                static decodeTx(e) {
                    return R(e.result)
                }
                static decodeTxSearch(e) {
                    var t;
                    return t = e.result, {
                        totalCount: (0, a.apiToSmallInt)((0, d.assertNotEmpty)(t.total_count)),
                        txs: (0, d.assertArray)(t.txs).map(R)
                    }
                }
                static decodeValidators(e) {
                    var t;
                    return t = e.result, {
                        blockHeight: (0, a.apiToSmallInt)((0, d.assertNotEmpty)(t.block_height)),
                        validators: (0, d.assertArray)(t.validators).map(B),
                        count: (0, a.apiToSmallInt)((0, d.assertNotEmpty)(t.count)),
                        total: (0, a.apiToSmallInt)((0, d.assertNotEmpty)(t.total))
                    }
                }
            }
            t.Responses = w
        },
        57009: function(e, t, r) {
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: !0
            }), t.encodeBlockId = t.encodeVersion = t.encodeBytes = t.encodeTime = t.encodeUvarint = t.encodeString = t.dictionaryToStringMap = t.may = t.assertNotEmpty = t.assertObject = t.assertArray = t.assertNumber = t.assertString = t.assertBoolean = t.assertSet = void 0;
            let n = r(81299);

            function o(e) {
                if (void 0 === e) throw Error("Value must not be undefined");
                if (null === e) throw Error("Value must not be null");
                return e
            }

            function i(e) {
                return e >= 128 ? Uint8Array.from([255 & e | 128, ...i(e >> 7)]) : Uint8Array.from([255 & e])
            }
            t.assertSet = o, t.assertBoolean = function(e) {
                if (o(e), "boolean" != typeof e) throw Error("Value must be a boolean");
                return e
            }, t.assertString = function(e) {
                if (o(e), "string" != typeof e) throw Error("Value must be a string");
                return e
            }, t.assertNumber = function(e) {
                if (o(e), "number" != typeof e) throw Error("Value must be a number");
                return e
            }, t.assertArray = function(e) {
                if (o(e), !Array.isArray(e)) throw Error("Value must be a an array");
                return e
            }, t.assertObject = function(e) {
                if (o(e), "object" != typeof e) throw Error("Value must be an object");
                if ("[object Object]" !== Object.prototype.toString.call(e)) throw Error("Value must be a simple object");
                return e
            }, t.assertNotEmpty = function(e) {
                if (o(e), "number" == typeof e && 0 === e) throw Error("must provide a non-zero value");
                if (0 === e.length) throw Error("must provide a non-empty value");
                return e
            }, t.may = function(e, t) {
                return null == t ? void 0 : e(t)
            }, t.dictionaryToStringMap = function(e) {
                let t = new Map;
                for (let r of Object.keys(e)) {
                    let n = e[r];
                    if ("string" != typeof n) throw Error("Found dictionary value of type other than string");
                    t.set(r, n)
                }
                return t
            }, t.encodeString = function(e) {
                let t = (0, n.toUtf8)(e);
                return Uint8Array.from([t.length, ...t])
            }, t.encodeUvarint = i, t.encodeTime = function(e) {
                let t = e.getTime(),
                    r = Math.floor(t / 1e3),
                    n = r ? [8, ...i(r)] : new Uint8Array,
                    o = (e.nanoseconds || 0) + t % 1e3 * 1e6,
                    a = o ? [16, ...i(o)] : new Uint8Array;
                return Uint8Array.from([...n, ...a])
            }, t.encodeBytes = function(e) {
                if (e.length >= 128) throw Error("Not implemented for byte arrays of length 128 or more");
                return e.length ? Uint8Array.from([e.length, ...e]) : new Uint8Array
            }, t.encodeVersion = function(e) {
                let t = e.block ? Uint8Array.from([8, ...i(e.block)]) : new Uint8Array,
                    r = e.app ? Uint8Array.from([16, ...i(e.app)]) : new Uint8Array;
                return Uint8Array.from([...t, ...r])
            }, t.encodeBlockId = function(e) {
                return Uint8Array.from([10, e.hash.length, ...e.hash, 18, e.parts.hash.length + 4, 8, e.parts.total, 18, e.parts.hash.length, ...e.parts.hash])
            }
        },
        47777: function(e, t, r) {
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: !0
            }), t.hashBlock = t.hashTx = void 0;
            let n = r(46495),
                o = r(57009);
            t.hashTx = function(e) {
                return (0, n.sha256)(e)
            }, t.hashBlock = function(e) {
                if (!e.lastBlockId) throw Error("Hashing a block header with no last block ID (i.e. header at height 1) is not supported. If you need this, contributions are welcome. Please add documentation and test vectors for this case.");
                return function e(t) {
                    switch (t.length) {
                        case 0:
                            throw Error("Cannot hash empty tree");
                        case 1:
                            return function(e) {
                                let t = new n.Sha256(Uint8Array.from([0]));
                                return t.update(e), t.digest()
                            }(t[0]);
                        default:
                            {
                                let r = function(e) {
                                    if (e < 1) throw Error("Cannot split an empty tree");
                                    let t = 2 ** Math.floor(Math.log2(e));
                                    return t < e ? t : t / 2
                                }(t.length);
                                return function(e, t) {
                                    let r = new n.Sha256(Uint8Array.from([1]));
                                    return r.update(e), r.update(t), r.digest()
                                }(e(t.slice(0, r)), e(t.slice(r)))
                            }
                    }
                }([(0, o.encodeVersion)(e.version), (0, o.encodeString)(e.chainId), (0, o.encodeUvarint)(e.height), (0, o.encodeTime)(e.time), (0, o.encodeBlockId)(e.lastBlockId), (0, o.encodeBytes)(e.lastCommitHash), (0, o.encodeBytes)(e.dataHash), (0, o.encodeBytes)(e.validatorsHash), (0, o.encodeBytes)(e.nextValidatorsHash), (0, o.encodeBytes)(e.consensusHash), (0, o.encodeBytes)(e.appHash), (0, o.encodeBytes)(e.lastResultsHash), (0, o.encodeBytes)(e.evidenceHash), (0, o.encodeBytes)(e.proposerAddress)])
            }
        },
        90716: function(e, t, r) {
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: !0
            }), t.Tendermint34Client = t.VoteType = t.broadcastTxSyncSuccess = t.broadcastTxCommitSuccess = t.SubscriptionEventType = t.Method = void 0;
            var n = r(66712);
            Object.defineProperty(t, "Method", {
                enumerable: !0,
                get: function() {
                    return n.Method
                }
            }), Object.defineProperty(t, "SubscriptionEventType", {
                enumerable: !0,
                get: function() {
                    return n.SubscriptionEventType
                }
            });
            var o = r(70701);
            Object.defineProperty(t, "broadcastTxCommitSuccess", {
                enumerable: !0,
                get: function() {
                    return o.broadcastTxCommitSuccess
                }
            }), Object.defineProperty(t, "broadcastTxSyncSuccess", {
                enumerable: !0,
                get: function() {
                    return o.broadcastTxSyncSuccess
                }
            }), Object.defineProperty(t, "VoteType", {
                enumerable: !0,
                get: function() {
                    return o.VoteType
                }
            });
            var i = r(98713);
            Object.defineProperty(t, "Tendermint34Client", {
                enumerable: !0,
                get: function() {
                    return i.Tendermint34Client
                }
            })
        },
        66712: function(e, t) {
            "use strict";
            var r, n;
            Object.defineProperty(t, "__esModule", {
                value: !0
            }), t.buildQuery = t.SubscriptionEventType = t.Method = void 0, (r = t.Method || (t.Method = {})).AbciInfo = "abci_info", r.AbciQuery = "abci_query", r.Block = "block", r.Blockchain = "blockchain", r.BlockResults = "block_results", r.BlockSearch = "block_search", r.BroadcastTxAsync = "broadcast_tx_async", r.BroadcastTxSync = "broadcast_tx_sync", r.BroadcastTxCommit = "broadcast_tx_commit", r.Commit = "commit", r.Genesis = "genesis", r.Health = "health", r.NumUnconfirmedTxs = "num_unconfirmed_txs", r.Status = "status", r.Subscribe = "subscribe", r.Tx = "tx", r.TxSearch = "tx_search", r.Validators = "validators", r.Unsubscribe = "unsubscribe", (n = t.SubscriptionEventType || (t.SubscriptionEventType = {})).NewBlock = "NewBlock", n.NewBlockHeader = "NewBlockHeader", n.Tx = "Tx", t.buildQuery = function(e) {
                return [...(e.tags ? e.tags : []).map(e => `${e.key}='${e.value}'`), ...e.raw ? [e.raw] : []].join(" AND ")
            }
        },
        70701: function(e, t) {
            "use strict";
            var r;
            Object.defineProperty(t, "__esModule", {
                value: !0
            }), t.VoteType = t.broadcastTxCommitSuccess = t.broadcastTxSyncSuccess = void 0, t.broadcastTxSyncSuccess = function(e) {
                return 0 === e.code
            }, t.broadcastTxCommitSuccess = function(e) {
                return 0 === e.checkTx.code && !!e.deliverTx && 0 === e.deliverTx.code
            }, (r = t.VoteType || (t.VoteType = {}))[r.PreVote = 1] = "PreVote", r[r.PreCommit = 2] = "PreCommit"
        },
        98713: function(e, t, r) {
            "use strict";
            var n = this && this.__createBinding || (Object.create ? function(e, t, r, n) {
                    void 0 === n && (n = r);
                    var o = Object.getOwnPropertyDescriptor(t, r);
                    (!o || ("get" in o ? !t.__esModule : o.writable || o.configurable)) && (o = {
                        enumerable: !0,
                        get: function() {
                            return t[r]
                        }
                    }), Object.defineProperty(e, n, o)
                } : function(e, t, r, n) {
                    void 0 === n && (n = r), e[n] = t[r]
                }),
                o = this && this.__setModuleDefault || (Object.create ? function(e, t) {
                    Object.defineProperty(e, "default", {
                        enumerable: !0,
                        value: t
                    })
                } : function(e, t) {
                    e.default = t
                }),
                i = this && this.__importStar || function(e) {
                    if (e && e.__esModule) return e;
                    var t = {};
                    if (null != e)
                        for (var r in e) "default" !== r && Object.prototype.hasOwnProperty.call(e, r) && n(t, e, r);
                    return o(t, e), t
                };
            Object.defineProperty(t, "__esModule", {
                value: !0
            }), t.Tendermint34Client = void 0;
            let a = r(64484),
                s = r(24528),
                d = r(27547),
                c = i(r(66712));
            class l {
                static async connect(e) {
                    let t;
                    return t = "object" == typeof e ? new s.HttpClient(e) : e.startsWith("http://") || e.startsWith("https://") ? new s.HttpClient(e) : new s.WebsocketClient(e), await this.detectVersion(t), l.create(t)
                }
                static async create(e) {
                    return new l(e)
                }
                static async detectVersion(e) {
                    let t = (0, a.createJsonRpcRequest)(c.Method.Status),
                        r = (await e.execute(t)).result;
                    if (!r || !r.node_info) throw Error("Unrecognized format for status response");
                    let n = r.node_info.version;
                    if ("string" != typeof n) throw Error("Unrecognized version format: must be string");
                    return n
                }
                constructor(e) {
                    this.client = e
                }
                disconnect() {
                    this.client.disconnect()
                }
                async abciInfo() {
                    let e = {
                        method: c.Method.AbciInfo
                    };
                    return this.doCall(e, d.Params.encodeAbciInfo, d.Responses.decodeAbciInfo)
                }
                async abciQuery(e) {
                    let t = {
                        params: e,
                        method: c.Method.AbciQuery
                    };
                    return this.doCall(t, d.Params.encodeAbciQuery, d.Responses.decodeAbciQuery)
                }
                async block(e) {
                    let t = {
                        method: c.Method.Block,
                        params: {
                            height: e
                        }
                    };
                    return this.doCall(t, d.Params.encodeBlock, d.Responses.decodeBlock)
                }
                async blockResults(e) {
                    let t = {
                        method: c.Method.BlockResults,
                        params: {
                            height: e
                        }
                    };
                    return this.doCall(t, d.Params.encodeBlockResults, d.Responses.decodeBlockResults)
                }
                async blockSearch(e) {
                    let t = {
                            params: e,
                            method: c.Method.BlockSearch
                        },
                        r = await this.doCall(t, d.Params.encodeBlockSearch, d.Responses.decodeBlockSearch);
                    return { ...r,
                        blocks: [...r.blocks].sort((e, t) => e.block.header.height - t.block.header.height)
                    }
                }
                async blockSearchAll(e) {
                    let t = e.page || 1,
                        r = [],
                        n = !1;
                    for (; !n;) {
                        let o = await this.blockSearch({ ...e,
                            page: t
                        });
                        r.push(...o.blocks), r.length < o.totalCount ? t++ : n = !0
                    }
                    return r.sort((e, t) => e.block.header.height - t.block.header.height), {
                        totalCount: r.length,
                        blocks: r
                    }
                }
                async blockchain(e, t) {
                    let r = {
                        method: c.Method.Blockchain,
                        params: {
                            minHeight: e,
                            maxHeight: t
                        }
                    };
                    return this.doCall(r, d.Params.encodeBlockchain, d.Responses.decodeBlockchain)
                }
                async broadcastTxSync(e) {
                    let t = {
                        params: e,
                        method: c.Method.BroadcastTxSync
                    };
                    return this.doCall(t, d.Params.encodeBroadcastTx, d.Responses.decodeBroadcastTxSync)
                }
                async broadcastTxAsync(e) {
                    let t = {
                        params: e,
                        method: c.Method.BroadcastTxAsync
                    };
                    return this.doCall(t, d.Params.encodeBroadcastTx, d.Responses.decodeBroadcastTxAsync)
                }
                async broadcastTxCommit(e) {
                    let t = {
                        params: e,
                        method: c.Method.BroadcastTxCommit
                    };
                    return this.doCall(t, d.Params.encodeBroadcastTx, d.Responses.decodeBroadcastTxCommit)
                }
                async commit(e) {
                    let t = {
                        method: c.Method.Commit,
                        params: {
                            height: e
                        }
                    };
                    return this.doCall(t, d.Params.encodeCommit, d.Responses.decodeCommit)
                }
                async genesis() {
                    let e = {
                        method: c.Method.Genesis
                    };
                    return this.doCall(e, d.Params.encodeGenesis, d.Responses.decodeGenesis)
                }
                async health() {
                    let e = {
                        method: c.Method.Health
                    };
                    return this.doCall(e, d.Params.encodeHealth, d.Responses.decodeHealth)
                }
                async numUnconfirmedTxs() {
                    let e = {
                        method: c.Method.NumUnconfirmedTxs
                    };
                    return this.doCall(e, d.Params.encodeNumUnconfirmedTxs, d.Responses.decodeNumUnconfirmedTxs)
                }
                async status() {
                    let e = {
                        method: c.Method.Status
                    };
                    return this.doCall(e, d.Params.encodeStatus, d.Responses.decodeStatus)
                }
                subscribeNewBlock() {
                    let e = {
                        method: c.Method.Subscribe,
                        query: {
                            type: c.SubscriptionEventType.NewBlock
                        }
                    };
                    return this.subscribe(e, d.Responses.decodeNewBlockEvent)
                }
                subscribeNewBlockHeader() {
                    let e = {
                        method: c.Method.Subscribe,
                        query: {
                            type: c.SubscriptionEventType.NewBlockHeader
                        }
                    };
                    return this.subscribe(e, d.Responses.decodeNewBlockHeaderEvent)
                }
                subscribeTx(e) {
                    let t = {
                        method: c.Method.Subscribe,
                        query: {
                            type: c.SubscriptionEventType.Tx,
                            raw: e
                        }
                    };
                    return this.subscribe(t, d.Responses.decodeTxEvent)
                }
                async tx(e) {
                    let t = {
                        params: e,
                        method: c.Method.Tx
                    };
                    return this.doCall(t, d.Params.encodeTx, d.Responses.decodeTx)
                }
                async txSearch(e) {
                    let t = {
                        params: e,
                        method: c.Method.TxSearch
                    };
                    return this.doCall(t, d.Params.encodeTxSearch, d.Responses.decodeTxSearch)
                }
                async txSearchAll(e) {
                    let t = e.page || 1,
                        r = [],
                        n = !1;
                    for (; !n;) {
                        let o = await this.txSearch({ ...e,
                            page: t
                        });
                        r.push(...o.txs), r.length < o.totalCount ? t++ : n = !0
                    }
                    return {
                        totalCount: r.length,
                        txs: r
                    }
                }
                async validators(e) {
                    let t = {
                        method: c.Method.Validators,
                        params: e
                    };
                    return this.doCall(t, d.Params.encodeValidators, d.Responses.decodeValidators)
                }
                async validatorsAll(e) {
                    let t = [],
                        r = 1,
                        n = !1,
                        o = e;
                    for (; !n;) {
                        let e = await this.validators({
                            per_page: 50,
                            height: o,
                            page: r
                        });
                        t.push(...e.validators), o = o || e.blockHeight, t.length < e.total ? r++ : n = !0
                    }
                    return {
                        blockHeight: o ? ? 0,
                        count: t.length,
                        total: t.length,
                        validators: t
                    }
                }
                async doCall(e, t, r) {
                    let n = t(e);
                    return r(await this.client.execute(n))
                }
                subscribe(e, t) {
                    if (!(0, s.instanceOfRpcStreamingClient)(this.client)) throw Error("This RPC client type cannot subscribe to events");
                    let r = d.Params.encodeSubscribe(e);
                    return this.client.listen(r).map(e => t(e))
                }
            }
            t.Tendermint34Client = l
        },
        18059: function(e, t, r) {
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: !0
            }), t.Responses = t.Params = void 0;
            var n = r(85722);
            Object.defineProperty(t, "Params", {
                enumerable: !0,
                get: function() {
                    return n.Params
                }
            });
            var o = r(68472);
            Object.defineProperty(t, "Responses", {
                enumerable: !0,
                get: function() {
                    return o.Responses
                }
            })
        },
        85722: function(e, t, r) {
            "use strict";
            var n = this && this.__createBinding || (Object.create ? function(e, t, r, n) {
                    void 0 === n && (n = r);
                    var o = Object.getOwnPropertyDescriptor(t, r);
                    (!o || ("get" in o ? !t.__esModule : o.writable || o.configurable)) && (o = {
                        enumerable: !0,
                        get: function() {
                            return t[r]
                        }
                    }), Object.defineProperty(e, n, o)
                } : function(e, t, r, n) {
                    void 0 === n && (n = r), e[n] = t[r]
                }),
                o = this && this.__setModuleDefault || (Object.create ? function(e, t) {
                    Object.defineProperty(e, "default", {
                        enumerable: !0,
                        value: t
                    })
                } : function(e, t) {
                    e.default = t
                }),
                i = this && this.__importStar || function(e) {
                    if (e && e.__esModule) return e;
                    var t = {};
                    if (null != e)
                        for (var r in e) "default" !== r && Object.prototype.hasOwnProperty.call(e, r) && n(t, e, r);
                    return o(t, e), t
                };
            Object.defineProperty(t, "__esModule", {
                value: !0
            }), t.Params = void 0;
            let a = r(81299),
                s = r(69581),
                d = r(64484),
                c = r(44844),
                l = i(r(48266));

            function u(e) {
                return {
                    height: (0, c.may)(s.smallIntToApi, e.height)
                }
            }
            class p {
                static encodeAbciInfo(e) {
                    return (0, d.createJsonRpcRequest)(e.method)
                }
                static encodeAbciQuery(e) {
                    var t;
                    return (0, d.createJsonRpcRequest)(e.method, (t = e.params, {
                        path: (0, c.assertNotEmpty)(t.path),
                        data: (0, a.toHex)(t.data),
                        height: (0, c.may)(s.smallIntToApi, t.height),
                        prove: t.prove
                    }))
                }
                static encodeBlock(e) {
                    return (0, d.createJsonRpcRequest)(e.method, u(e.params))
                }
                static encodeBlockchain(e) {
                    var t;
                    return (0, d.createJsonRpcRequest)(e.method, (t = e.params, {
                        minHeight: (0, c.may)(s.smallIntToApi, t.minHeight),
                        maxHeight: (0, c.may)(s.smallIntToApi, t.maxHeight)
                    }))
                }
                static encodeBlockResults(e) {
                    return (0, d.createJsonRpcRequest)(e.method, u(e.params))
                }
                static encodeBlockSearch(e) {
                    var t;
                    return (0, d.createJsonRpcRequest)(e.method, {
                        query: (t = e.params).query,
                        page: (0, c.may)(s.smallIntToApi, t.page),
                        per_page: (0, c.may)(s.smallIntToApi, t.per_page),
                        order_by: t.order_by
                    })
                }
                static encodeBroadcastTx(e) {
                    var t;
                    return (0, d.createJsonRpcRequest)(e.method, (t = e.params, {
                        tx: (0, a.toBase64)((0, c.assertNotEmpty)(t.tx))
                    }))
                }
                static encodeCommit(e) {
                    return (0, d.createJsonRpcRequest)(e.method, u(e.params))
                }
                static encodeGenesis(e) {
                    return (0, d.createJsonRpcRequest)(e.method)
                }
                static encodeHealth(e) {
                    return (0, d.createJsonRpcRequest)(e.method)
                }
                static encodeNumUnconfirmedTxs(e) {
                    return (0, d.createJsonRpcRequest)(e.method)
                }
                static encodeStatus(e) {
                    return (0, d.createJsonRpcRequest)(e.method)
                }
                static encodeSubscribe(e) {
                    let t = {
                            key: "tm.event",
                            value: e.query.type
                        },
                        r = l.buildQuery({
                            tags: [t],
                            raw: e.query.raw
                        });
                    return (0, d.createJsonRpcRequest)("subscribe", {
                        query: r
                    })
                }
                static encodeTx(e) {
                    var t;
                    return (0, d.createJsonRpcRequest)(e.method, (t = e.params, {
                        hash: (0, a.toBase64)((0, c.assertNotEmpty)(t.hash)),
                        prove: t.prove
                    }))
                }
                static encodeTxSearch(e) {
                    var t;
                    return (0, d.createJsonRpcRequest)(e.method, {
                        query: (t = e.params).query,
                        prove: t.prove,
                        page: (0, c.may)(s.smallIntToApi, t.page),
                        per_page: (0, c.may)(s.smallIntToApi, t.per_page),
                        order_by: t.order_by
                    })
                }
                static encodeValidators(e) {
                    var t;
                    return (0, d.createJsonRpcRequest)(e.method, (t = e.params, {
                        height: (0, c.may)(s.smallIntToApi, t.height),
                        page: (0, c.may)(s.smallIntToApi, t.page),
                        per_page: (0, c.may)(s.smallIntToApi, t.per_page)
                    }))
                }
            }
            t.Params = p
        },
        68472: function(e, t, r) {
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: !0
            }), t.Responses = t.decodeValidatorInfo = t.decodeValidatorGenesis = t.decodeValidatorUpdate = t.decodeEvent = void 0;
            let n = r(81299),
                o = r(8261),
                i = r(65932),
                a = r(69581),
                s = r(5347),
                d = r(44844),
                c = r(42738);

            function l(e) {
                return {
                    ops: e.ops.map(e => ({
                        type: e.type,
                        key: (0, n.fromBase64)(e.key),
                        data: (0, n.fromBase64)(e.data)
                    }))
                }
            }

            function u(e) {
                return {
                    key: (0, d.assertNotEmpty)(e.key),
                    value: e.value ? ? ""
                }
            }

            function p(e) {
                var t;
                return {
                    type: e.type,
                    attributes: e.attributes ? (t = e.attributes, (0, d.assertArray)(t).map(u)) : []
                }
            }

            function m(e) {
                return (0, d.assertArray)(e).map(p)
            }

            function g(e) {
                return {
                    code: (0, a.apiToSmallInt)((0, d.assertNumber)(e.code ? ? 0)),
                    codespace: e.codespace,
                    log: e.log,
                    data: (0, d.may)(n.fromBase64, e.data),
                    events: e.events ? m(e.events) : [],
                    gasWanted: (0, a.apiToBigInt)(e.gas_wanted ? ? "0"),
                    gasUsed: (0, a.apiToBigInt)(e.gas_used ? ? "0")
                }
            }

            function f(e) {
                if ("Sum" in e) {
                    let [
                        [t, r]
                    ] = Object.entries(e.Sum.value);
                    return (0, o.assert)("ed25519" === t || "secp256k1" === t, `unknown pubkey type: ${t}`), {
                        algorithm: t,
                        data: (0, n.fromBase64)((0, d.assertNotEmpty)(r))
                    }
                }
                switch (e.type) {
                    case "tendermint/PubKeyEd25519":
                        return {
                            algorithm: "ed25519",
                            data: (0, n.fromBase64)((0, d.assertNotEmpty)(e.value))
                        };
                    case "tendermint/PubKeySecp256k1":
                        return {
                            algorithm: "secp256k1",
                            data: (0, n.fromBase64)((0, d.assertNotEmpty)(e.value))
                        };
                    default:
                        throw Error(`unknown pubkey type: ${e.type}`)
                }
            }

            function y(e) {
                var t, r;
                return {
                    block: (t = (0, d.assertObject)(e.block), {
                        maxBytes: (0, a.apiToSmallInt)((0, d.assertNotEmpty)(t.max_bytes)),
                        maxGas: (0, a.apiToSmallInt)((0, d.assertNotEmpty)(t.max_gas))
                    }),
                    evidence: (r = (0, d.assertObject)(e.evidence), {
                        maxAgeNumBlocks: (0, a.apiToSmallInt)((0, d.assertNotEmpty)(r.max_age_num_blocks)),
                        maxAgeDuration: (0, a.apiToSmallInt)((0, d.assertNotEmpty)(r.max_age_duration))
                    })
                }
            }

            function h(e) {
                return {
                    pubkey: f((0, d.assertObject)(e.pub_key)),
                    votingPower: (0, a.apiToBigInt)(e.power ? ? "0")
                }
            }

            function v(e) {
                return {
                    hash: (0, n.fromHex)((0, d.assertNotEmpty)(e.hash)),
                    parts: {
                        total: (0, d.assertNotEmpty)(e.parts.total),
                        hash: (0, n.fromHex)((0, d.assertNotEmpty)(e.parts.hash))
                    }
                }
            }

            function b(e) {
                var t;
                return {
                    version: (t = e.version, {
                        block: (0, a.apiToSmallInt)(t.block),
                        app: (0, a.apiToSmallInt)(t.app ? ? 0)
                    }),
                    chainId: (0, d.assertNotEmpty)(e.chain_id),
                    height: (0, a.apiToSmallInt)((0, d.assertNotEmpty)(e.height)),
                    time: (0, i.fromRfc3339WithNanoseconds)((0, d.assertNotEmpty)(e.time)),
                    lastBlockId: e.last_block_id.hash ? v(e.last_block_id) : null,
                    lastCommitHash: (0, n.fromHex)((0, d.assertSet)(e.last_commit_hash)),
                    dataHash: (0, n.fromHex)((0, d.assertSet)(e.data_hash)),
                    validatorsHash: (0, n.fromHex)((0, d.assertSet)(e.validators_hash)),
                    nextValidatorsHash: (0, n.fromHex)((0, d.assertSet)(e.next_validators_hash)),
                    consensusHash: (0, n.fromHex)((0, d.assertSet)(e.consensus_hash)),
                    appHash: (0, n.fromHex)((0, d.assertSet)(e.app_hash)),
                    lastResultsHash: (0, n.fromHex)((0, d.assertSet)(e.last_results_hash)),
                    evidenceHash: (0, n.fromHex)((0, d.assertSet)(e.evidence_hash)),
                    proposerAddress: (0, n.fromHex)((0, d.assertNotEmpty)(e.proposer_address))
                }
            }

            function S(e) {
                return {
                    blockId: v(e.block_id),
                    blockSize: (0, a.apiToSmallInt)((0, d.assertNotEmpty)(e.block_size)),
                    header: b(e.header),
                    numTxs: (0, a.apiToSmallInt)((0, d.assertNotEmpty)(e.num_txs))
                }
            }

            function k(e) {
                var t;
                return {
                    blockIdFlag: (t = e.block_id_flag, (0, o.assert)(t in s.BlockIdFlag), t),
                    validatorAddress: e.validator_address ? (0, n.fromHex)(e.validator_address) : void 0,
                    timestamp: e.timestamp ? (0, i.fromRfc3339WithNanoseconds)(e.timestamp) : void 0,
                    signature: e.signature ? (0, n.fromBase64)(e.signature) : void 0
                }
            }

            function P(e) {
                return {
                    blockId: v((0, d.assertObject)(e.block_id)),
                    height: (0, a.apiToSmallInt)((0, d.assertNotEmpty)(e.height)),
                    round: (0, a.apiToSmallInt)(e.round),
                    signatures: (0, d.assertArray)(e.signatures).map(k)
                }
            }

            function _(e) {
                return {
                    address: (0, n.fromHex)((0, d.assertNotEmpty)(e.address)),
                    pubkey: f((0, d.assertObject)(e.pub_key)),
                    votingPower: (0, a.apiToBigInt)((0, d.assertNotEmpty)(e.power))
                }
            }

            function B(e) {
                return {
                    pubkey: f((0, d.assertObject)(e.pub_key)),
                    votingPower: (0, a.apiToBigInt)((0, d.assertNotEmpty)(e.voting_power)),
                    address: (0, n.fromHex)((0, d.assertNotEmpty)(e.address)),
                    proposerPriority: e.proposer_priority ? (0, a.apiToSmallInt)(e.proposer_priority) : void 0
                }
            }

            function O(e) {
                return {
                    data: (0, n.fromBase64)((0, d.assertNotEmpty)(e.data)),
                    rootHash: (0, n.fromHex)((0, d.assertNotEmpty)(e.root_hash)),
                    proof: {
                        total: (0, a.apiToSmallInt)((0, d.assertNotEmpty)(e.proof.total)),
                        index: (0, a.apiToSmallInt)((0, d.assertNotEmpty)(e.proof.index)),
                        leafHash: (0, n.fromBase64)((0, d.assertNotEmpty)(e.proof.leaf_hash)),
                        aunts: (0, d.assertArray)(e.proof.aunts).map(n.fromBase64)
                    }
                }
            }

            function R(e) {
                return {
                    tx: (0, n.fromBase64)((0, d.assertNotEmpty)(e.tx)),
                    result: g((0, d.assertObject)(e.tx_result)),
                    height: (0, a.apiToSmallInt)((0, d.assertNotEmpty)(e.height)),
                    index: (0, a.apiToSmallInt)((0, d.assertNumber)(e.index)),
                    hash: (0, n.fromHex)((0, d.assertNotEmpty)(e.hash)),
                    proof: (0, d.may)(O, e.proof)
                }
            }

            function A(e) {
                return {
                    header: b((0, d.assertObject)(e.header)),
                    lastCommit: e.last_commit.block_id.hash ? P((0, d.assertObject)(e.last_commit)) : null,
                    txs: e.data.txs ? (0, d.assertArray)(e.data.txs).map(n.fromBase64) : [],
                    evidence: e.evidence ? .evidence ? ? []
                }
            }

            function I(e) {
                return {
                    blockId: v(e.block_id),
                    block: A(e.block)
                }
            }
            t.decodeEvent = p, t.decodeValidatorUpdate = h, t.decodeValidatorGenesis = _, t.decodeValidatorInfo = B;
            class w {
                static decodeAbciInfo(e) {
                    var t;
                    return {
                        data: (t = (0, d.assertObject)(e.result.response)).data,
                        lastBlockHeight: (0, d.may)(a.apiToSmallInt, t.last_block_height),
                        lastBlockAppHash: (0, d.may)(n.fromBase64, t.last_block_app_hash)
                    }
                }
                static decodeAbciQuery(e) {
                    var t;
                    return t = (0, d.assertObject)(e.result.response), {
                        key: (0, n.fromBase64)((0, d.assertString)(t.key ? ? "")),
                        value: (0, n.fromBase64)((0, d.assertString)(t.value ? ? "")),
                        proof: (0, d.may)(l, t.proofOps),
                        height: (0, d.may)(a.apiToSmallInt, t.height),
                        code: (0, d.may)(a.apiToSmallInt, t.code),
                        codespace: (0, d.assertString)(t.codespace ? ? ""),
                        index: (0, d.may)(a.apiToSmallInt, t.index),
                        log: t.log,
                        info: (0, d.assertString)(t.info ? ? "")
                    }
                }
                static decodeBlock(e) {
                    return I(e.result)
                }
                static decodeBlockResults(e) {
                    var t;
                    return t = e.result, {
                        height: (0, a.apiToSmallInt)((0, d.assertNotEmpty)(t.height)),
                        results: (t.txs_results || []).map(g),
                        validatorUpdates: (t.validator_updates || []).map(h),
                        consensusUpdates: (0, d.may)(y, t.consensus_param_updates),
                        beginBlockEvents: m(t.begin_block_events || []),
                        endBlockEvents: m(t.end_block_events || [])
                    }
                }
                static decodeBlockSearch(e) {
                    var t;
                    return t = e.result, {
                        totalCount: (0, a.apiToSmallInt)((0, d.assertNotEmpty)(t.total_count)),
                        blocks: (0, d.assertArray)(t.blocks).map(I)
                    }
                }
                static decodeBlockchain(e) {
                    var t;
                    return t = e.result, {
                        lastHeight: (0, a.apiToSmallInt)((0, d.assertNotEmpty)(t.last_height)),
                        blockMetas: (0, d.assertArray)(t.block_metas).map(S)
                    }
                }
                static decodeBroadcastTxSync(e) {
                    var t;
                    return { ...g(t = e.result),
                        hash: (0, n.fromHex)((0, d.assertNotEmpty)(t.hash))
                    }
                }
                static decodeBroadcastTxAsync(e) {
                    return w.decodeBroadcastTxSync(e)
                }
                static decodeBroadcastTxCommit(e) {
                    var t;
                    return t = e.result, {
                        height: (0, a.apiToSmallInt)(t.height),
                        hash: (0, n.fromHex)((0, d.assertNotEmpty)(t.hash)),
                        checkTx: g((0, d.assertObject)(t.check_tx)),
                        deliverTx: (0, d.may)(g, t.deliver_tx)
                    }
                }
                static decodeCommit(e) {
                    var t;
                    return t = e.result, {
                        canonical: (0, d.assertBoolean)(t.canonical),
                        header: b(t.signed_header.header),
                        commit: P(t.signed_header.commit)
                    }
                }
                static decodeGenesis(e) {
                    var t;
                    return t = (0, d.assertObject)(e.result.genesis), {
                        genesisTime: (0, i.fromRfc3339WithNanoseconds)((0, d.assertNotEmpty)(t.genesis_time)),
                        chainId: (0, d.assertNotEmpty)(t.chain_id),
                        consensusParams: y(t.consensus_params),
                        validators: t.validators ? (0, d.assertArray)(t.validators).map(_) : [],
                        appHash: (0, n.fromHex)((0, d.assertSet)(t.app_hash)),
                        appState: t.app_state
                    }
                }
                static decodeHealth() {
                    return null
                }
                static decodeNumUnconfirmedTxs(e) {
                    var t;
                    return t = e.result, {
                        total: (0, a.apiToSmallInt)((0, d.assertNotEmpty)(t.total)),
                        totalBytes: (0, a.apiToSmallInt)((0, d.assertNotEmpty)(t.total_bytes))
                    }
                }
                static decodeStatus(e) {
                    var t, r;
                    return {
                        nodeInfo: (r = (t = e.result).node_info, {
                            id: (0, n.fromHex)((0, d.assertNotEmpty)(r.id)),
                            listenAddr: (0, d.assertNotEmpty)(r.listen_addr),
                            network: (0, d.assertNotEmpty)(r.network),
                            version: (0, d.assertString)(r.version),
                            channels: (0, d.assertNotEmpty)(r.channels),
                            moniker: (0, d.assertNotEmpty)(r.moniker),
                            other: (0, d.dictionaryToStringMap)(r.other),
                            protocolVersion: {
                                app: (0, a.apiToSmallInt)((0, d.assertNotEmpty)(r.protocol_version.app)),
                                block: (0, a.apiToSmallInt)((0, d.assertNotEmpty)(r.protocol_version.block)),
                                p2p: (0, a.apiToSmallInt)((0, d.assertNotEmpty)(r.protocol_version.p2p))
                            }
                        }),
                        syncInfo: function(e) {
                            let t = e.earliest_block_height ? (0, a.apiToSmallInt)(e.earliest_block_height) : void 0,
                                r = e.earliest_block_time ? (0, i.fromRfc3339WithNanoseconds)(e.earliest_block_time) : void 0;
                            return {
                                earliestAppHash: e.earliest_app_hash ? (0, n.fromHex)(e.earliest_app_hash) : void 0,
                                earliestBlockHash: e.earliest_block_hash ? (0, n.fromHex)(e.earliest_block_hash) : void 0,
                                earliestBlockHeight: t || void 0,
                                earliestBlockTime: r ? .getTime() ? r : void 0,
                                latestBlockHash: (0, n.fromHex)((0, d.assertNotEmpty)(e.latest_block_hash)),
                                latestAppHash: (0, n.fromHex)((0, d.assertNotEmpty)(e.latest_app_hash)),
                                latestBlockTime: (0, i.fromRfc3339WithNanoseconds)((0, d.assertNotEmpty)(e.latest_block_time)),
                                latestBlockHeight: (0, a.apiToSmallInt)((0, d.assertNotEmpty)(e.latest_block_height)),
                                catchingUp: (0, d.assertBoolean)(e.catching_up)
                            }
                        }(t.sync_info),
                        validatorInfo: B(t.validator_info)
                    }
                }
                static decodeNewBlockEvent(e) {
                    return A(e.data.value.block)
                }
                static decodeNewBlockHeaderEvent(e) {
                    return b(e.data.value.header)
                }
                static decodeTxEvent(e) {
                    return function(e) {
                        let t = (0, n.fromBase64)((0, d.assertNotEmpty)(e.tx));
                        return {
                            tx: t,
                            hash: (0, c.hashTx)(t),
                            result: g(e.result),
                            height: (0, a.apiToSmallInt)((0, d.assertNotEmpty)(e.height))
                        }
                    }(e.data.value.TxResult)
                }
                static decodeTx(e) {
                    return R(e.result)
                }
                static decodeTxSearch(e) {
                    var t;
                    return t = e.result, {
                        totalCount: (0, a.apiToSmallInt)((0, d.assertNotEmpty)(t.total_count)),
                        txs: (0, d.assertArray)(t.txs).map(R)
                    }
                }
                static decodeValidators(e) {
                    var t;
                    return t = e.result, {
                        blockHeight: (0, a.apiToSmallInt)((0, d.assertNotEmpty)(t.block_height)),
                        validators: (0, d.assertArray)(t.validators).map(B),
                        count: (0, a.apiToSmallInt)((0, d.assertNotEmpty)(t.count)),
                        total: (0, a.apiToSmallInt)((0, d.assertNotEmpty)(t.total))
                    }
                }
            }
            t.Responses = w
        },
        44844: function(e, t, r) {
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: !0
            }), t.encodeBlockId = t.encodeVersion = t.encodeBytes = t.encodeTime = t.encodeUvarint = t.encodeString = t.dictionaryToStringMap = t.may = t.assertNotEmpty = t.assertObject = t.assertArray = t.assertNumber = t.assertString = t.assertBoolean = t.assertSet = void 0;
            let n = r(81299);

            function o(e) {
                if (void 0 === e) throw Error("Value must not be undefined");
                if (null === e) throw Error("Value must not be null");
                return e
            }

            function i(e) {
                return e >= 128 ? Uint8Array.from([255 & e | 128, ...i(e >> 7)]) : Uint8Array.from([255 & e])
            }
            t.assertSet = o, t.assertBoolean = function(e) {
                if (o(e), "boolean" != typeof e) throw Error("Value must be a boolean");
                return e
            }, t.assertString = function(e) {
                if (o(e), "string" != typeof e) throw Error("Value must be a string");
                return e
            }, t.assertNumber = function(e) {
                if (o(e), "number" != typeof e) throw Error("Value must be a number");
                return e
            }, t.assertArray = function(e) {
                if (o(e), !Array.isArray(e)) throw Error("Value must be a an array");
                return e
            }, t.assertObject = function(e) {
                if (o(e), "object" != typeof e) throw Error("Value must be an object");
                if ("[object Object]" !== Object.prototype.toString.call(e)) throw Error("Value must be a simple object");
                return e
            }, t.assertNotEmpty = function(e) {
                if (o(e), "number" == typeof e && 0 === e) throw Error("must provide a non-zero value");
                if (0 === e.length) throw Error("must provide a non-empty value");
                return e
            }, t.may = function(e, t) {
                return null == t ? void 0 : e(t)
            }, t.dictionaryToStringMap = function(e) {
                let t = new Map;
                for (let r of Object.keys(e)) {
                    let n = e[r];
                    if ("string" != typeof n) throw Error("Found dictionary value of type other than string");
                    t.set(r, n)
                }
                return t
            }, t.encodeString = function(e) {
                let t = (0, n.toUtf8)(e);
                return Uint8Array.from([t.length, ...t])
            }, t.encodeUvarint = i, t.encodeTime = function(e) {
                let t = e.getTime(),
                    r = Math.floor(t / 1e3),
                    n = r ? [8, ...i(r)] : new Uint8Array,
                    o = (e.nanoseconds || 0) + t % 1e3 * 1e6,
                    a = o ? [16, ...i(o)] : new Uint8Array;
                return Uint8Array.from([...n, ...a])
            }, t.encodeBytes = function(e) {
                if (e.length >= 128) throw Error("Not implemented for byte arrays of length 128 or more");
                return e.length ? Uint8Array.from([e.length, ...e]) : new Uint8Array
            }, t.encodeVersion = function(e) {
                let t = e.block ? Uint8Array.from([8, ...i(e.block)]) : new Uint8Array,
                    r = e.app ? Uint8Array.from([16, ...i(e.app)]) : new Uint8Array;
                return Uint8Array.from([...t, ...r])
            }, t.encodeBlockId = function(e) {
                return Uint8Array.from([10, e.hash.length, ...e.hash, 18, e.parts.hash.length + 4, 8, e.parts.total, 18, e.parts.hash.length, ...e.parts.hash])
            }
        },
        42738: function(e, t, r) {
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: !0
            }), t.hashBlock = t.hashTx = void 0;
            let n = r(46495),
                o = r(44844);
            t.hashTx = function(e) {
                return (0, n.sha256)(e)
            }, t.hashBlock = function(e) {
                if (!e.lastBlockId) throw Error("Hashing a block header with no last block ID (i.e. header at height 1) is not supported. If you need this, contributions are welcome. Please add documentation and test vectors for this case.");
                return function e(t) {
                    switch (t.length) {
                        case 0:
                            throw Error("Cannot hash empty tree");
                        case 1:
                            return function(e) {
                                let t = new n.Sha256(Uint8Array.from([0]));
                                return t.update(e), t.digest()
                            }(t[0]);
                        default:
                            {
                                let r = function(e) {
                                    if (e < 1) throw Error("Cannot split an empty tree");
                                    let t = 2 ** Math.floor(Math.log2(e));
                                    return t < e ? t : t / 2
                                }(t.length);
                                return function(e, t) {
                                    let r = new n.Sha256(Uint8Array.from([1]));
                                    return r.update(e), r.update(t), r.digest()
                                }(e(t.slice(0, r)), e(t.slice(r)))
                            }
                    }
                }([(0, o.encodeVersion)(e.version), (0, o.encodeString)(e.chainId), (0, o.encodeUvarint)(e.height), (0, o.encodeTime)(e.time), (0, o.encodeBlockId)(e.lastBlockId), (0, o.encodeBytes)(e.lastCommitHash), (0, o.encodeBytes)(e.dataHash), (0, o.encodeBytes)(e.validatorsHash), (0, o.encodeBytes)(e.nextValidatorsHash), (0, o.encodeBytes)(e.consensusHash), (0, o.encodeBytes)(e.appHash), (0, o.encodeBytes)(e.lastResultsHash), (0, o.encodeBytes)(e.evidenceHash), (0, o.encodeBytes)(e.proposerAddress)])
            }
        },
        79158: function(e, t, r) {
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: !0
            }), t.Tendermint37Client = t.VoteType = t.broadcastTxSyncSuccess = t.broadcastTxCommitSuccess = t.SubscriptionEventType = t.Method = void 0;
            var n = r(48266);
            Object.defineProperty(t, "Method", {
                enumerable: !0,
                get: function() {
                    return n.Method
                }
            }), Object.defineProperty(t, "SubscriptionEventType", {
                enumerable: !0,
                get: function() {
                    return n.SubscriptionEventType
                }
            });
            var o = r(30526);
            Object.defineProperty(t, "broadcastTxCommitSuccess", {
                enumerable: !0,
                get: function() {
                    return o.broadcastTxCommitSuccess
                }
            }), Object.defineProperty(t, "broadcastTxSyncSuccess", {
                enumerable: !0,
                get: function() {
                    return o.broadcastTxSyncSuccess
                }
            }), Object.defineProperty(t, "VoteType", {
                enumerable: !0,
                get: function() {
                    return o.VoteType
                }
            });
            var i = r(47719);
            Object.defineProperty(t, "Tendermint37Client", {
                enumerable: !0,
                get: function() {
                    return i.Tendermint37Client
                }
            })
        },
        48266: function(e, t) {
            "use strict";
            var r, n;
            Object.defineProperty(t, "__esModule", {
                value: !0
            }), t.buildQuery = t.SubscriptionEventType = t.Method = void 0, (r = t.Method || (t.Method = {})).AbciInfo = "abci_info", r.AbciQuery = "abci_query", r.Block = "block", r.Blockchain = "blockchain", r.BlockResults = "block_results", r.BlockSearch = "block_search", r.BroadcastTxAsync = "broadcast_tx_async", r.BroadcastTxSync = "broadcast_tx_sync", r.BroadcastTxCommit = "broadcast_tx_commit", r.Commit = "commit", r.Genesis = "genesis", r.Health = "health", r.NumUnconfirmedTxs = "num_unconfirmed_txs", r.Status = "status", r.Subscribe = "subscribe", r.Tx = "tx", r.TxSearch = "tx_search", r.Validators = "validators", r.Unsubscribe = "unsubscribe", (n = t.SubscriptionEventType || (t.SubscriptionEventType = {})).NewBlock = "NewBlock", n.NewBlockHeader = "NewBlockHeader", n.Tx = "Tx", t.buildQuery = function(e) {
                return [...(e.tags ? e.tags : []).map(e => `${e.key}='${e.value}'`), ...e.raw ? [e.raw] : []].join(" AND ")
            }
        },
        30526: function(e, t) {
            "use strict";
            var r;
            Object.defineProperty(t, "__esModule", {
                value: !0
            }), t.VoteType = t.broadcastTxCommitSuccess = t.broadcastTxSyncSuccess = void 0, t.broadcastTxSyncSuccess = function(e) {
                return 0 === e.code
            }, t.broadcastTxCommitSuccess = function(e) {
                return 0 === e.checkTx.code && !!e.deliverTx && 0 === e.deliverTx.code
            }, (r = t.VoteType || (t.VoteType = {}))[r.PreVote = 1] = "PreVote", r[r.PreCommit = 2] = "PreCommit"
        },
        47719: function(e, t, r) {
            "use strict";
            var n = this && this.__createBinding || (Object.create ? function(e, t, r, n) {
                    void 0 === n && (n = r);
                    var o = Object.getOwnPropertyDescriptor(t, r);
                    (!o || ("get" in o ? !t.__esModule : o.writable || o.configurable)) && (o = {
                        enumerable: !0,
                        get: function() {
                            return t[r]
                        }
                    }), Object.defineProperty(e, n, o)
                } : function(e, t, r, n) {
                    void 0 === n && (n = r), e[n] = t[r]
                }),
                o = this && this.__setModuleDefault || (Object.create ? function(e, t) {
                    Object.defineProperty(e, "default", {
                        enumerable: !0,
                        value: t
                    })
                } : function(e, t) {
                    e.default = t
                }),
                i = this && this.__importStar || function(e) {
                    if (e && e.__esModule) return e;
                    var t = {};
                    if (null != e)
                        for (var r in e) "default" !== r && Object.prototype.hasOwnProperty.call(e, r) && n(t, e, r);
                    return o(t, e), t
                };
            Object.defineProperty(t, "__esModule", {
                value: !0
            }), t.Tendermint37Client = void 0;
            let a = r(64484),
                s = r(24528),
                d = r(18059),
                c = i(r(48266));
            class l {
                static async connect(e) {
                    let t;
                    return t = "object" == typeof e ? new s.HttpClient(e) : e.startsWith("http://") || e.startsWith("https://") ? new s.HttpClient(e) : new s.WebsocketClient(e), await this.detectVersion(t), l.create(t)
                }
                static async create(e) {
                    return new l(e)
                }
                static async detectVersion(e) {
                    let t = (0, a.createJsonRpcRequest)(c.Method.Status),
                        r = (await e.execute(t)).result;
                    if (!r || !r.node_info) throw Error("Unrecognized format for status response");
                    let n = r.node_info.version;
                    if ("string" != typeof n) throw Error("Unrecognized version format: must be string");
                    return n
                }
                constructor(e) {
                    this.client = e
                }
                disconnect() {
                    this.client.disconnect()
                }
                async abciInfo() {
                    let e = {
                        method: c.Method.AbciInfo
                    };
                    return this.doCall(e, d.Params.encodeAbciInfo, d.Responses.decodeAbciInfo)
                }
                async abciQuery(e) {
                    let t = {
                        params: e,
                        method: c.Method.AbciQuery
                    };
                    return this.doCall(t, d.Params.encodeAbciQuery, d.Responses.decodeAbciQuery)
                }
                async block(e) {
                    let t = {
                        method: c.Method.Block,
                        params: {
                            height: e
                        }
                    };
                    return this.doCall(t, d.Params.encodeBlock, d.Responses.decodeBlock)
                }
                async blockResults(e) {
                    let t = {
                        method: c.Method.BlockResults,
                        params: {
                            height: e
                        }
                    };
                    return this.doCall(t, d.Params.encodeBlockResults, d.Responses.decodeBlockResults)
                }
                async blockSearch(e) {
                    let t = {
                            params: e,
                            method: c.Method.BlockSearch
                        },
                        r = await this.doCall(t, d.Params.encodeBlockSearch, d.Responses.decodeBlockSearch);
                    return { ...r,
                        blocks: [...r.blocks].sort((e, t) => e.block.header.height - t.block.header.height)
                    }
                }
                async blockSearchAll(e) {
                    let t = e.page || 1,
                        r = [],
                        n = !1;
                    for (; !n;) {
                        let o = await this.blockSearch({ ...e,
                            page: t
                        });
                        r.push(...o.blocks), r.length < o.totalCount ? t++ : n = !0
                    }
                    return r.sort((e, t) => e.block.header.height - t.block.header.height), {
                        totalCount: r.length,
                        blocks: r
                    }
                }
                async blockchain(e, t) {
                    let r = {
                        method: c.Method.Blockchain,
                        params: {
                            minHeight: e,
                            maxHeight: t
                        }
                    };
                    return this.doCall(r, d.Params.encodeBlockchain, d.Responses.decodeBlockchain)
                }
                async broadcastTxSync(e) {
                    let t = {
                        params: e,
                        method: c.Method.BroadcastTxSync
                    };
                    return this.doCall(t, d.Params.encodeBroadcastTx, d.Responses.decodeBroadcastTxSync)
                }
                async broadcastTxAsync(e) {
                    let t = {
                        params: e,
                        method: c.Method.BroadcastTxAsync
                    };
                    return this.doCall(t, d.Params.encodeBroadcastTx, d.Responses.decodeBroadcastTxAsync)
                }
                async broadcastTxCommit(e) {
                    let t = {
                        params: e,
                        method: c.Method.BroadcastTxCommit
                    };
                    return this.doCall(t, d.Params.encodeBroadcastTx, d.Responses.decodeBroadcastTxCommit)
                }
                async commit(e) {
                    let t = {
                        method: c.Method.Commit,
                        params: {
                            height: e
                        }
                    };
                    return this.doCall(t, d.Params.encodeCommit, d.Responses.decodeCommit)
                }
                async genesis() {
                    let e = {
                        method: c.Method.Genesis
                    };
                    return this.doCall(e, d.Params.encodeGenesis, d.Responses.decodeGenesis)
                }
                async health() {
                    let e = {
                        method: c.Method.Health
                    };
                    return this.doCall(e, d.Params.encodeHealth, d.Responses.decodeHealth)
                }
                async numUnconfirmedTxs() {
                    let e = {
                        method: c.Method.NumUnconfirmedTxs
                    };
                    return this.doCall(e, d.Params.encodeNumUnconfirmedTxs, d.Responses.decodeNumUnconfirmedTxs)
                }
                async status() {
                    let e = {
                        method: c.Method.Status
                    };
                    return this.doCall(e, d.Params.encodeStatus, d.Responses.decodeStatus)
                }
                subscribeNewBlock() {
                    let e = {
                        method: c.Method.Subscribe,
                        query: {
                            type: c.SubscriptionEventType.NewBlock
                        }
                    };
                    return this.subscribe(e, d.Responses.decodeNewBlockEvent)
                }
                subscribeNewBlockHeader() {
                    let e = {
                        method: c.Method.Subscribe,
                        query: {
                            type: c.SubscriptionEventType.NewBlockHeader
                        }
                    };
                    return this.subscribe(e, d.Responses.decodeNewBlockHeaderEvent)
                }
                subscribeTx(e) {
                    let t = {
                        method: c.Method.Subscribe,
                        query: {
                            type: c.SubscriptionEventType.Tx,
                            raw: e
                        }
                    };
                    return this.subscribe(t, d.Responses.decodeTxEvent)
                }
                async tx(e) {
                    let t = {
                        params: e,
                        method: c.Method.Tx
                    };
                    return this.doCall(t, d.Params.encodeTx, d.Responses.decodeTx)
                }
                async txSearch(e) {
                    let t = {
                        params: e,
                        method: c.Method.TxSearch
                    };
                    return this.doCall(t, d.Params.encodeTxSearch, d.Responses.decodeTxSearch)
                }
                async txSearchAll(e) {
                    let t = e.page || 1,
                        r = [],
                        n = !1;
                    for (; !n;) {
                        let o = await this.txSearch({ ...e,
                            page: t
                        });
                        r.push(...o.txs), r.length < o.totalCount ? t++ : n = !0
                    }
                    return {
                        totalCount: r.length,
                        txs: r
                    }
                }
                async validators(e) {
                    let t = {
                        method: c.Method.Validators,
                        params: e
                    };
                    return this.doCall(t, d.Params.encodeValidators, d.Responses.decodeValidators)
                }
                async validatorsAll(e) {
                    let t = [],
                        r = 1,
                        n = !1,
                        o = e;
                    for (; !n;) {
                        let e = await this.validators({
                            per_page: 50,
                            height: o,
                            page: r
                        });
                        t.push(...e.validators), o = o || e.blockHeight, t.length < e.total ? r++ : n = !0
                    }
                    return {
                        blockHeight: o ? ? 0,
                        count: t.length,
                        total: t.length,
                        validators: t
                    }
                }
                async doCall(e, t, r) {
                    let n = t(e);
                    return r(await this.client.execute(n))
                }
                subscribe(e, t) {
                    if (!(0, s.instanceOfRpcStreamingClient)(this.client)) throw Error("This RPC client type cannot subscribe to events");
                    let r = d.Params.encodeSubscribe(e);
                    return this.client.listen(r).map(e => t(e))
                }
            }
            t.Tendermint37Client = l
        },
        74108: function(e, t, r) {
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: !0
            }), t.connectComet = t.isComet38Client = t.isTendermint37Client = t.isTendermint34Client = void 0;
            let n = r(64355),
                o = r(90716),
                i = r(79158);
            async function a(e) {
                let t;
                let r = await i.Tendermint37Client.connect(e),
                    a = (await r.status()).nodeInfo.version;
                return a.startsWith("0.37.") ? t = r : a.startsWith("0.38.") ? (r.disconnect(), t = await n.Comet38Client.connect(e)) : (r.disconnect(), t = await o.Tendermint34Client.connect(e)), t
            }
            t.isTendermint34Client = function(e) {
                return e instanceof o.Tendermint34Client
            }, t.isTendermint37Client = function(e) {
                return e instanceof i.Tendermint37Client
            }, t.isComet38Client = function(e) {
                return e instanceof n.Comet38Client
            }, t.connectComet = a
        },
        5347: function(e, t) {
            "use strict";
            var r;
            Object.defineProperty(t, "__esModule", {
                value: !0
            }), t.BlockIdFlag = void 0, (r = t.BlockIdFlag || (t.BlockIdFlag = {}))[r.Unknown = 0] = "Unknown", r[r.Absent = 1] = "Absent", r[r.Commit = 2] = "Commit", r[r.Nil = 3] = "Nil", r[r.Unrecognized = -1] = "Unrecognized"
        },
        30537: function(e, t) {
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: !0
            }), t.arrayContentStartsWith = t.arrayContentEquals = void 0, t.arrayContentEquals = function(e, t) {
                if (e.length !== t.length) return !1;
                for (let r = 0; r < e.length; ++r)
                    if (e[r] !== t[r]) return !1;
                return !0
            }, t.arrayContentStartsWith = function(e, t) {
                if (e.length < t.length) return !1;
                for (let r = 0; r < t.length; ++r)
                    if (e[r] !== t[r]) return !1;
                return !0
            }
        },
        42263: function(e, t) {
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: !0
            }), t.assertDefinedAndNotNull = t.assertDefined = t.assert = void 0, t.assert = function(e, t) {
                if (!e) throw Error(t || "condition is not truthy")
            }, t.assertDefined = function(e, t) {
                if (void 0 === e) throw Error(t ? ? "value is undefined")
            }, t.assertDefinedAndNotNull = function(e, t) {
                if (null == e) throw Error(t ? ? "value is undefined or null")
            }
        },
        8261: function(e, t, r) {
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: !0
            }), t.isUint8Array = t.isNonNullObject = t.isDefined = t.sleep = t.assertDefinedAndNotNull = t.assertDefined = t.assert = t.arrayContentStartsWith = t.arrayContentEquals = void 0;
            var n = r(30537);
            Object.defineProperty(t, "arrayContentEquals", {
                enumerable: !0,
                get: function() {
                    return n.arrayContentEquals
                }
            }), Object.defineProperty(t, "arrayContentStartsWith", {
                enumerable: !0,
                get: function() {
                    return n.arrayContentStartsWith
                }
            });
            var o = r(42263);
            Object.defineProperty(t, "assert", {
                enumerable: !0,
                get: function() {
                    return o.assert
                }
            }), Object.defineProperty(t, "assertDefined", {
                enumerable: !0,
                get: function() {
                    return o.assertDefined
                }
            }), Object.defineProperty(t, "assertDefinedAndNotNull", {
                enumerable: !0,
                get: function() {
                    return o.assertDefinedAndNotNull
                }
            });
            var i = r(42409);
            Object.defineProperty(t, "sleep", {
                enumerable: !0,
                get: function() {
                    return i.sleep
                }
            });
            var a = r(23607);
            Object.defineProperty(t, "isDefined", {
                enumerable: !0,
                get: function() {
                    return a.isDefined
                }
            }), Object.defineProperty(t, "isNonNullObject", {
                enumerable: !0,
                get: function() {
                    return a.isNonNullObject
                }
            }), Object.defineProperty(t, "isUint8Array", {
                enumerable: !0,
                get: function() {
                    return a.isUint8Array
                }
            })
        },
        42409: function(e, t) {
            "use strict";
            async function r(e) {
                return new Promise(t => setTimeout(t, e))
            }
            Object.defineProperty(t, "__esModule", {
                value: !0
            }), t.sleep = void 0, t.sleep = r
        },
        23607: function(e, t, r) {
            "use strict";
            var n = r(48764).Buffer;

            function o(e) {
                return "object" == typeof e && null !== e
            }
            Object.defineProperty(t, "__esModule", {
                value: !0
            }), t.isDefined = t.isUint8Array = t.isNonNullObject = void 0, t.isNonNullObject = o, t.isUint8Array = function(e) {
                return !(!o(e) || "[object Uint8Array]" !== Object.prototype.toString.call(e) || void 0 !== n && void 0 !== n.isBuffer && n.isBuffer(e))
            }, t.isDefined = function(e) {
                return void 0 !== e
            }
        },
        60590: function(e) {
            "use strict";
            for (var t = "qpzry9x8gf2tvdw0s3jn54khce6mua7l", r = {}, n = 0; n < t.length; n++) {
                var o = t.charAt(n);
                if (void 0 !== r[o]) throw TypeError(o + " is ambiguous");
                r[o] = n
            }

            function i(e) {
                var t = e >> 25;
                return (33554431 & e) << 5 ^ 996825010 & -(t >> 0 & 1) ^ 642813549 & -(t >> 1 & 1) ^ 513874426 & -(t >> 2 & 1) ^ 1027748829 & -(t >> 3 & 1) ^ 705979059 & -(t >> 4 & 1)
            }

            function a(e) {
                for (var t = 1, r = 0; r < e.length; ++r) {
                    var n = e.charCodeAt(r);
                    if (n < 33 || n > 126) return "Invalid prefix (" + e + ")";
                    t = i(t) ^ n >> 5
                }
                for (r = 0, t = i(t); r < e.length; ++r) {
                    var o = e.charCodeAt(r);
                    t = i(t) ^ 31 & o
                }
                return t
            }

            function s(e, t) {
                if (t = t || 90, e.length < 8) return e + " too short";
                if (e.length > t) return "Exceeds length limit";
                var n = e.toLowerCase(),
                    o = e.toUpperCase();
                if (e !== n && e !== o) return "Mixed-case string " + e;
                var s = (e = n).lastIndexOf("1");
                if (-1 === s) return "No separator character for " + e;
                if (0 === s) return "Missing prefix for " + e;
                var d = e.slice(0, s),
                    c = e.slice(s + 1);
                if (c.length < 6) return "Data too short";
                var l = a(d);
                if ("string" == typeof l) return l;
                for (var u = [], p = 0; p < c.length; ++p) {
                    var m = c.charAt(p),
                        g = r[m];
                    if (void 0 === g) return "Unknown character " + m;
                    l = i(l) ^ g, p + 6 >= c.length || u.push(g)
                }
                return 1 !== l ? "Invalid checksum for " + e : {
                    prefix: d,
                    words: u
                }
            }

            function d(e, t, r, n) {
                for (var o = 0, i = 0, a = (1 << r) - 1, s = [], d = 0; d < e.length; ++d)
                    for (o = o << t | e[d], i += t; i >= r;) s.push(o >> (i -= r) & a);
                if (n) i > 0 && s.push(o << r - i & a);
                else {
                    if (i >= t) return "Excess padding";
                    if (o << r - i & a) return "Non-zero padding"
                }
                return s
            }
            e.exports = {
                decodeUnsafe: function() {
                    var e = s.apply(null, arguments);
                    if ("object" == typeof e) return e
                },
                decode: function(e) {
                    var t = s.apply(null, arguments);
                    if ("object" == typeof t) return t;
                    throw Error(t)
                },
                encode: function(e, r, n) {
                    if (n = n || 90, e.length + 7 + r.length > n) throw TypeError("Exceeds length limit");
                    var o = a(e = e.toLowerCase());
                    if ("string" == typeof o) throw Error(o);
                    for (var s = e + "1", d = 0; d < r.length; ++d) {
                        var c = r[d];
                        if (c >> 5 != 0) throw Error("Non 5-bit word");
                        o = i(o) ^ c, s += t.charAt(c)
                    }
                    for (d = 0; d < 6; ++d) o = i(o);
                    for (o ^= 1, d = 0; d < 6; ++d) {
                        var l = o >> (5 - d) * 5 & 31;
                        s += t.charAt(l)
                    }
                    return s
                },
                toWordsUnsafe: function(e) {
                    var t = d(e, 8, 5, !0);
                    if (Array.isArray(t)) return t
                },
                toWords: function(e) {
                    var t = d(e, 8, 5, !0);
                    if (Array.isArray(t)) return t;
                    throw Error(t)
                },
                fromWordsUnsafe: function(e) {
                    var t = d(e, 5, 8, !1);
                    if (Array.isArray(t)) return t
                },
                fromWords: function(e) {
                    var t = d(e, 5, 8, !1);
                    if (Array.isArray(t)) return t;
                    throw Error(t)
                }
            }
        },
        23795: function(e, t, r) {
            "use strict";
            var n, o;
            Object.defineProperty(t, "__esModule", {
                value: !0
            }), t.BinaryWriter = t.BinaryReader = t.WireType = void 0;
            let i = r(82208),
                a = r(73238);
            (o = n || (t.WireType = n = {}))[o.Varint = 0] = "Varint", o[o.Fixed64 = 1] = "Fixed64", o[o.Bytes = 2] = "Bytes", o[o.Fixed32 = 5] = "Fixed32";
            class s {
                assertBounds() {
                    if (this.pos > this.len) throw RangeError("premature EOF")
                }
                constructor(e) {
                    this.buf = new Uint8Array(e || 0), this.pos = 0, this.type = 0, this.len = this.buf.length
                }
                tag() {
                    let e = this.uint32(),
                        t = e >>> 3,
                        r = 7 & e;
                    if (t <= 0 || r < 0 || r > 5) throw Error("illegal tag: field no " + t + " wire type " + r);
                    return [t, r, e]
                }
                skip(e) {
                    if ("number" == typeof e) {
                        if (this.pos + e > this.len) throw p(this, e);
                        this.pos += e
                    } else
                        do
                            if (this.pos >= this.len) throw p(this); while (128 & this.buf[this.pos++]);
                    return this
                }
                skipType(e) {
                    switch (e) {
                        case n.Varint:
                            this.skip();
                            break;
                        case n.Fixed64:
                            this.skip(8);
                            break;
                        case n.Bytes:
                            this.skip(this.uint32());
                            break;
                        case 3:
                            for (; 4 != (e = 7 & this.uint32());) this.skipType(e);
                            break;
                        case n.Fixed32:
                            this.skip(4);
                            break;
                        default:
                            throw Error("invalid wire type " + e + " at offset " + this.pos)
                    }
                    return this
                }
                uint32() {
                    return a.varint32read.bind(this)()
                }
                int32() {
                    return 0 | this.uint32()
                }
                sint32() {
                    let e = this.uint32();
                    return e % 2 == 1 ? -((e + 1) / 2) : e / 2
                }
                fixed32() {
                    let e = (0, a.readUInt32)(this.buf, this.pos);
                    return this.pos += 4, e
                }
                sfixed32() {
                    let e = (0, a.readInt32)(this.buf, this.pos);
                    return this.pos += 4, e
                }
                int64() {
                    let [e, t] = a.varint64read.bind(this)();
                    return BigInt((0, a.int64ToString)(e, t))
                }
                uint64() {
                    let [e, t] = a.varint64read.bind(this)();
                    return BigInt((0, a.uInt64ToString)(e, t))
                }
                sint64() {
                    let [e, t] = a.varint64read.bind(this)();
                    return [e, t] = (0, a.zzDecode)(e, t), BigInt((0, a.int64ToString)(e, t))
                }
                fixed64() {
                    let e = this.sfixed32(),
                        t = this.sfixed32();
                    return BigInt((0, a.uInt64ToString)(e, t))
                }
                sfixed64() {
                    let e = this.sfixed32(),
                        t = this.sfixed32();
                    return BigInt((0, a.int64ToString)(e, t))
                }
                float() {
                    throw Error("float not supported")
                }
                double() {
                    throw Error("double not supported")
                }
                bool() {
                    let [e, t] = a.varint64read.bind(this)();
                    return 0 !== e || 0 !== t
                }
                bytes() {
                    let e = this.uint32(),
                        t = this.pos;
                    return this.pos += e, this.assertBounds(), this.buf.subarray(t, t + e)
                }
                string() {
                    let e = this.bytes();
                    return (0, i.utf8Read)(e, 0, e.length)
                }
            }
            t.BinaryReader = s;
            class d {
                constructor(e, t, r) {
                    this.fn = e, this.len = t, this.val = r
                }
                proceed(e, t) {
                    this.fn && this.fn(this.val, e, t)
                }
            }
            class c {
                constructor(e) {
                    this.head = e.head, this.tail = e.tail, this.len = e.len, this.next = e.states
                }
            }
            class l {
                constructor() {
                    this.len = 0, this.uint64 = l.prototype.int64, this.sfixed64 = l.prototype.fixed64, this.sfixed32 = l.prototype.fixed32, this.head = new d(null, 0, 0), this.tail = this.head, this.states = null
                }
                static create() {
                    return new l
                }
                static alloc(e) {
                    return "undefined" != typeof Uint8Array ? (function(e, t, r) {
                        let n = 4096,
                            o = null,
                            i = 8192;
                        return function(r) {
                            if (r < 1 || r > n) return e(r);
                            i + r > 8192 && (o = e(8192), i = 0);
                            let a = t.call(o, i, i += r);
                            return 7 & i && (i = (7 | i) + 1), a
                        }
                    })(e => new Uint8Array(e), Uint8Array.prototype.subarray)(e) : Array(e)
                }
                _push(e, t, r) {
                    return this.tail = this.tail.next = new d(e, t, r), this.len += t, this
                }
                finish() {
                    let e = this.head.next,
                        t = 0,
                        r = l.alloc(this.len);
                    for (; e;) e.proceed(r, t), t += e.len, e = e.next;
                    return r
                }
                fork() {
                    return this.states = new c(this), this.head = this.tail = new d(null, 0, 0), this.len = 0, this
                }
                reset() {
                    return this.states ? (this.head = this.states.head, this.tail = this.states.tail, this.len = this.states.len, this.states = this.states.next) : (this.head = this.tail = new d(null, 0, 0), this.len = 0), this
                }
                ldelim() {
                    let e = this.head,
                        t = this.tail,
                        r = this.len;
                    return this.reset().uint32(r), r && (this.tail.next = e.next, this.tail = t, this.len += r), this
                }
                tag(e, t) {
                    return this.uint32((e << 3 | t) >>> 0)
                }
                uint32(e) {
                    return this.len += (this.tail = this.tail.next = new d(a.writeVarint32, (e >>>= 0) < 128 ? 1 : e < 16384 ? 2 : e < 2097152 ? 3 : e < 268435456 ? 4 : 5, e)).len, this
                }
                int32(e) {
                    return e < 0 ? this._push(a.writeVarint64, 10, (0, a.int64FromString)(e.toString())) : this.uint32(e)
                }
                sint32(e) {
                    return this.uint32((e << 1 ^ e >> 31) >>> 0)
                }
                int64(e) {
                    let {
                        lo: t,
                        hi: r
                    } = (0, a.int64FromString)(e.toString());
                    return this._push(a.writeVarint64, (0, a.int64Length)(t, r), {
                        lo: t,
                        hi: r
                    })
                }
                sint64(e) {
                    let {
                        lo: t,
                        hi: r
                    } = (0, a.int64FromString)(e.toString());
                    return [t, r] = (0, a.zzEncode)(t, r), this._push(a.writeVarint64, (0, a.int64Length)(t, r), {
                        lo: t,
                        hi: r
                    })
                }
                fixed64(e) {
                    let {
                        lo: t,
                        hi: r
                    } = (0, a.int64FromString)(e.toString());
                    return this._push(a.writeFixed32, 4, t)._push(a.writeFixed32, 4, r)
                }
                bool(e) {
                    return this._push(a.writeByte, 1, e ? 1 : 0)
                }
                fixed32(e) {
                    return this._push(a.writeFixed32, 4, e >>> 0)
                }
                float(e) {
                    throw Error("float not supported" + e)
                }
                double(e) {
                    throw Error("double not supported" + e)
                }
                bytes(e) {
                    let t = e.length >>> 0;
                    return t ? this.uint32(t)._push(u, t, e) : this._push(a.writeByte, 1, 0)
                }
                string(e) {
                    let t = (0, i.utf8Length)(e);
                    return t ? this.uint32(t)._push(i.utf8Write, t, e) : this._push(a.writeByte, 1, 0)
                }
            }

            function u(e, t, r) {
                if ("undefined" != typeof Uint8Array) t.set(e, r);
                else
                    for (let n = 0; n < e.length; ++n) t[r + n] = e[n]
            }

            function p(e, t) {
                return RangeError("index out of range: " + e.pos + " + " + (t || 1) + " > " + e.len)
            }
            t.BinaryWriter = l
        },
        71836: function(e, t, r) {
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: !0
            }), t.Metadata = t.DenomUnit = t.Supply = t.Output = t.Input = t.SendEnabled = t.Params = t.protobufPackage = void 0;
            let n = r(91408),
                o = r(23795),
                i = r(96987);

            function a() {
                return {
                    sendEnabled: [],
                    defaultSendEnabled: !1
                }
            }

            function s() {
                return {
                    denom: "",
                    enabled: !1
                }
            }

            function d() {
                return {
                    address: "",
                    coins: []
                }
            }

            function c() {
                return {
                    address: "",
                    coins: []
                }
            }

            function l() {
                return {
                    total: []
                }
            }

            function u() {
                return {
                    denom: "",
                    exponent: 0,
                    aliases: []
                }
            }

            function p() {
                return {
                    description: "",
                    denomUnits: [],
                    base: "",
                    display: "",
                    name: "",
                    symbol: "",
                    uri: "",
                    uriHash: ""
                }
            }
            t.protobufPackage = "cosmos.bank.v1beta1", t.Params = {
                typeUrl: "/cosmos.bank.v1beta1.Params",
                encode(e, r = o.BinaryWriter.create()) {
                    for (let n of e.sendEnabled) t.SendEnabled.encode(n, r.uint32(10).fork()).ldelim();
                    return !0 === e.defaultSendEnabled && r.uint32(16).bool(e.defaultSendEnabled), r
                },
                decode(e, r) {
                    let n = e instanceof o.BinaryReader ? e : new o.BinaryReader(e),
                        i = void 0 === r ? n.len : n.pos + r,
                        s = a();
                    for (; n.pos < i;) {
                        let e = n.uint32();
                        switch (e >>> 3) {
                            case 1:
                                s.sendEnabled.push(t.SendEnabled.decode(n, n.uint32()));
                                break;
                            case 2:
                                s.defaultSendEnabled = n.bool();
                                break;
                            default:
                                n.skipType(7 & e)
                        }
                    }
                    return s
                },
                fromJSON(e) {
                    let r = a();
                    return Array.isArray(e ? .sendEnabled) && (r.sendEnabled = e.sendEnabled.map(e => t.SendEnabled.fromJSON(e))), (0, i.isSet)(e.defaultSendEnabled) && (r.defaultSendEnabled = !!e.defaultSendEnabled), r
                },
                toJSON(e) {
                    let r = {};
                    return e.sendEnabled ? r.sendEnabled = e.sendEnabled.map(e => e ? t.SendEnabled.toJSON(e) : void 0) : r.sendEnabled = [], void 0 !== e.defaultSendEnabled && (r.defaultSendEnabled = e.defaultSendEnabled), r
                },
                fromPartial(e) {
                    let r = a();
                    return r.sendEnabled = e.sendEnabled ? .map(e => t.SendEnabled.fromPartial(e)) || [], r.defaultSendEnabled = e.defaultSendEnabled ? ? !1, r
                }
            }, t.SendEnabled = {
                typeUrl: "/cosmos.bank.v1beta1.SendEnabled",
                encode: (e, t = o.BinaryWriter.create()) => ("" !== e.denom && t.uint32(10).string(e.denom), !0 === e.enabled && t.uint32(16).bool(e.enabled), t),
                decode(e, t) {
                    let r = e instanceof o.BinaryReader ? e : new o.BinaryReader(e),
                        n = void 0 === t ? r.len : r.pos + t,
                        i = s();
                    for (; r.pos < n;) {
                        let e = r.uint32();
                        switch (e >>> 3) {
                            case 1:
                                i.denom = r.string();
                                break;
                            case 2:
                                i.enabled = r.bool();
                                break;
                            default:
                                r.skipType(7 & e)
                        }
                    }
                    return i
                },
                fromJSON(e) {
                    let t = s();
                    return (0, i.isSet)(e.denom) && (t.denom = String(e.denom)), (0, i.isSet)(e.enabled) && (t.enabled = !!e.enabled), t
                },
                toJSON(e) {
                    let t = {};
                    return void 0 !== e.denom && (t.denom = e.denom), void 0 !== e.enabled && (t.enabled = e.enabled), t
                },
                fromPartial(e) {
                    let t = s();
                    return t.denom = e.denom ? ? "", t.enabled = e.enabled ? ? !1, t
                }
            }, t.Input = {
                typeUrl: "/cosmos.bank.v1beta1.Input",
                encode(e, t = o.BinaryWriter.create()) {
                    for (let r of ("" !== e.address && t.uint32(10).string(e.address), e.coins)) n.Coin.encode(r, t.uint32(18).fork()).ldelim();
                    return t
                },
                decode(e, t) {
                    let r = e instanceof o.BinaryReader ? e : new o.BinaryReader(e),
                        i = void 0 === t ? r.len : r.pos + t,
                        a = d();
                    for (; r.pos < i;) {
                        let e = r.uint32();
                        switch (e >>> 3) {
                            case 1:
                                a.address = r.string();
                                break;
                            case 2:
                                a.coins.push(n.Coin.decode(r, r.uint32()));
                                break;
                            default:
                                r.skipType(7 & e)
                        }
                    }
                    return a
                },
                fromJSON(e) {
                    let t = d();
                    return (0, i.isSet)(e.address) && (t.address = String(e.address)), Array.isArray(e ? .coins) && (t.coins = e.coins.map(e => n.Coin.fromJSON(e))), t
                },
                toJSON(e) {
                    let t = {};
                    return void 0 !== e.address && (t.address = e.address), e.coins ? t.coins = e.coins.map(e => e ? n.Coin.toJSON(e) : void 0) : t.coins = [], t
                },
                fromPartial(e) {
                    let t = d();
                    return t.address = e.address ? ? "", t.coins = e.coins ? .map(e => n.Coin.fromPartial(e)) || [], t
                }
            }, t.Output = {
                typeUrl: "/cosmos.bank.v1beta1.Output",
                encode(e, t = o.BinaryWriter.create()) {
                    for (let r of ("" !== e.address && t.uint32(10).string(e.address), e.coins)) n.Coin.encode(r, t.uint32(18).fork()).ldelim();
                    return t
                },
                decode(e, t) {
                    let r = e instanceof o.BinaryReader ? e : new o.BinaryReader(e),
                        i = void 0 === t ? r.len : r.pos + t,
                        a = c();
                    for (; r.pos < i;) {
                        let e = r.uint32();
                        switch (e >>> 3) {
                            case 1:
                                a.address = r.string();
                                break;
                            case 2:
                                a.coins.push(n.Coin.decode(r, r.uint32()));
                                break;
                            default:
                                r.skipType(7 & e)
                        }
                    }
                    return a
                },
                fromJSON(e) {
                    let t = c();
                    return (0, i.isSet)(e.address) && (t.address = String(e.address)), Array.isArray(e ? .coins) && (t.coins = e.coins.map(e => n.Coin.fromJSON(e))), t
                },
                toJSON(e) {
                    let t = {};
                    return void 0 !== e.address && (t.address = e.address), e.coins ? t.coins = e.coins.map(e => e ? n.Coin.toJSON(e) : void 0) : t.coins = [], t
                },
                fromPartial(e) {
                    let t = c();
                    return t.address = e.address ? ? "", t.coins = e.coins ? .map(e => n.Coin.fromPartial(e)) || [], t
                }
            }, t.Supply = {
                typeUrl: "/cosmos.bank.v1beta1.Supply",
                encode(e, t = o.BinaryWriter.create()) {
                    for (let r of e.total) n.Coin.encode(r, t.uint32(10).fork()).ldelim();
                    return t
                },
                decode(e, t) {
                    let r = e instanceof o.BinaryReader ? e : new o.BinaryReader(e),
                        i = void 0 === t ? r.len : r.pos + t,
                        a = l();
                    for (; r.pos < i;) {
                        let e = r.uint32();
                        e >>> 3 == 1 ? a.total.push(n.Coin.decode(r, r.uint32())) : r.skipType(7 & e)
                    }
                    return a
                },
                fromJSON(e) {
                    let t = l();
                    return Array.isArray(e ? .total) && (t.total = e.total.map(e => n.Coin.fromJSON(e))), t
                },
                toJSON(e) {
                    let t = {};
                    return e.total ? t.total = e.total.map(e => e ? n.Coin.toJSON(e) : void 0) : t.total = [], t
                },
                fromPartial(e) {
                    let t = l();
                    return t.total = e.total ? .map(e => n.Coin.fromPartial(e)) || [], t
                }
            }, t.DenomUnit = {
                typeUrl: "/cosmos.bank.v1beta1.DenomUnit",
                encode(e, t = o.BinaryWriter.create()) {
                    for (let r of ("" !== e.denom && t.uint32(10).string(e.denom), 0 !== e.exponent && t.uint32(16).uint32(e.exponent), e.aliases)) t.uint32(26).string(r);
                    return t
                },
                decode(e, t) {
                    let r = e instanceof o.BinaryReader ? e : new o.BinaryReader(e),
                        n = void 0 === t ? r.len : r.pos + t,
                        i = u();
                    for (; r.pos < n;) {
                        let e = r.uint32();
                        switch (e >>> 3) {
                            case 1:
                                i.denom = r.string();
                                break;
                            case 2:
                                i.exponent = r.uint32();
                                break;
                            case 3:
                                i.aliases.push(r.string());
                                break;
                            default:
                                r.skipType(7 & e)
                        }
                    }
                    return i
                },
                fromJSON(e) {
                    let t = u();
                    return (0, i.isSet)(e.denom) && (t.denom = String(e.denom)), (0, i.isSet)(e.exponent) && (t.exponent = Number(e.exponent)), Array.isArray(e ? .aliases) && (t.aliases = e.aliases.map(e => String(e))), t
                },
                toJSON(e) {
                    let t = {};
                    return void 0 !== e.denom && (t.denom = e.denom), void 0 !== e.exponent && (t.exponent = Math.round(e.exponent)), e.aliases ? t.aliases = e.aliases.map(e => e) : t.aliases = [], t
                },
                fromPartial(e) {
                    let t = u();
                    return t.denom = e.denom ? ? "", t.exponent = e.exponent ? ? 0, t.aliases = e.aliases ? .map(e => e) || [], t
                }
            }, t.Metadata = {
                typeUrl: "/cosmos.bank.v1beta1.Metadata",
                encode(e, r = o.BinaryWriter.create()) {
                    for (let n of ("" !== e.description && r.uint32(10).string(e.description), e.denomUnits)) t.DenomUnit.encode(n, r.uint32(18).fork()).ldelim();
                    return "" !== e.base && r.uint32(26).string(e.base), "" !== e.display && r.uint32(34).string(e.display), "" !== e.name && r.uint32(42).string(e.name), "" !== e.symbol && r.uint32(50).string(e.symbol), "" !== e.uri && r.uint32(58).string(e.uri), "" !== e.uriHash && r.uint32(66).string(e.uriHash), r
                },
                decode(e, r) {
                    let n = e instanceof o.BinaryReader ? e : new o.BinaryReader(e),
                        i = void 0 === r ? n.len : n.pos + r,
                        a = p();
                    for (; n.pos < i;) {
                        let e = n.uint32();
                        switch (e >>> 3) {
                            case 1:
                                a.description = n.string();
                                break;
                            case 2:
                                a.denomUnits.push(t.DenomUnit.decode(n, n.uint32()));
                                break;
                            case 3:
                                a.base = n.string();
                                break;
                            case 4:
                                a.display = n.string();
                                break;
                            case 5:
                                a.name = n.string();
                                break;
                            case 6:
                                a.symbol = n.string();
                                break;
                            case 7:
                                a.uri = n.string();
                                break;
                            case 8:
                                a.uriHash = n.string();
                                break;
                            default:
                                n.skipType(7 & e)
                        }
                    }
                    return a
                },
                fromJSON(e) {
                    let r = p();
                    return (0, i.isSet)(e.description) && (r.description = String(e.description)), Array.isArray(e ? .denomUnits) && (r.denomUnits = e.denomUnits.map(e => t.DenomUnit.fromJSON(e))), (0, i.isSet)(e.base) && (r.base = String(e.base)), (0, i.isSet)(e.display) && (r.display = String(e.display)), (0, i.isSet)(e.name) && (r.name = String(e.name)), (0, i.isSet)(e.symbol) && (r.symbol = String(e.symbol)), (0, i.isSet)(e.uri) && (r.uri = String(e.uri)), (0, i.isSet)(e.uriHash) && (r.uriHash = String(e.uriHash)), r
                },
                toJSON(e) {
                    let r = {};
                    return void 0 !== e.description && (r.description = e.description), e.denomUnits ? r.denomUnits = e.denomUnits.map(e => e ? t.DenomUnit.toJSON(e) : void 0) : r.denomUnits = [], void 0 !== e.base && (r.base = e.base), void 0 !== e.display && (r.display = e.display), void 0 !== e.name && (r.name = e.name), void 0 !== e.symbol && (r.symbol = e.symbol), void 0 !== e.uri && (r.uri = e.uri), void 0 !== e.uriHash && (r.uriHash = e.uriHash), r
                },
                fromPartial(e) {
                    let r = p();
                    return r.description = e.description ? ? "", r.denomUnits = e.denomUnits ? .map(e => t.DenomUnit.fromPartial(e)) || [], r.base = e.base ? ? "", r.display = e.display ? ? "", r.name = e.name ? ? "", r.symbol = e.symbol ? ? "", r.uri = e.uri ? ? "", r.uriHash = e.uriHash ? ? "", r
                }
            }
        },
        50080: function(e, t, r) {
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: !0
            }), t.MsgClientImpl = t.MsgSetSendEnabledResponse = t.MsgSetSendEnabled = t.MsgUpdateParamsResponse = t.MsgUpdateParams = t.MsgMultiSendResponse = t.MsgMultiSend = t.MsgSendResponse = t.MsgSend = t.protobufPackage = void 0;
            let n = r(91408),
                o = r(71836),
                i = r(23795),
                a = r(96987);

            function s() {
                return {
                    fromAddress: "",
                    toAddress: "",
                    amount: []
                }
            }

            function d() {
                return {
                    inputs: [],
                    outputs: []
                }
            }

            function c() {
                return {
                    authority: "",
                    params: o.Params.fromPartial({})
                }
            }

            function l() {
                return {
                    authority: "",
                    sendEnabled: [],
                    useDefaultFor: []
                }
            }
            t.protobufPackage = "cosmos.bank.v1beta1", t.MsgSend = {
                typeUrl: "/cosmos.bank.v1beta1.MsgSend",
                encode(e, t = i.BinaryWriter.create()) {
                    for (let r of ("" !== e.fromAddress && t.uint32(10).string(e.fromAddress), "" !== e.toAddress && t.uint32(18).string(e.toAddress), e.amount)) n.Coin.encode(r, t.uint32(26).fork()).ldelim();
                    return t
                },
                decode(e, t) {
                    let r = e instanceof i.BinaryReader ? e : new i.BinaryReader(e),
                        o = void 0 === t ? r.len : r.pos + t,
                        a = s();
                    for (; r.pos < o;) {
                        let e = r.uint32();
                        switch (e >>> 3) {
                            case 1:
                                a.fromAddress = r.string();
                                break;
                            case 2:
                                a.toAddress = r.string();
                                break;
                            case 3:
                                a.amount.push(n.Coin.decode(r, r.uint32()));
                                break;
                            default:
                                r.skipType(7 & e)
                        }
                    }
                    return a
                },
                fromJSON(e) {
                    let t = s();
                    return (0, a.isSet)(e.fromAddress) && (t.fromAddress = String(e.fromAddress)), (0, a.isSet)(e.toAddress) && (t.toAddress = String(e.toAddress)), Array.isArray(e ? .amount) && (t.amount = e.amount.map(e => n.Coin.fromJSON(e))), t
                },
                toJSON(e) {
                    let t = {};
                    return void 0 !== e.fromAddress && (t.fromAddress = e.fromAddress), void 0 !== e.toAddress && (t.toAddress = e.toAddress), e.amount ? t.amount = e.amount.map(e => e ? n.Coin.toJSON(e) : void 0) : t.amount = [], t
                },
                fromPartial(e) {
                    let t = s();
                    return t.fromAddress = e.fromAddress ? ? "", t.toAddress = e.toAddress ? ? "", t.amount = e.amount ? .map(e => n.Coin.fromPartial(e)) || [], t
                }
            }, t.MsgSendResponse = {
                typeUrl: "/cosmos.bank.v1beta1.MsgSendResponse",
                encode: (e, t = i.BinaryWriter.create()) => t,
                decode(e, t) {
                    let r = e instanceof i.BinaryReader ? e : new i.BinaryReader(e),
                        n = void 0 === t ? r.len : r.pos + t;
                    for (; r.pos < n;) {
                        let e = r.uint32();
                        r.skipType(7 & e)
                    }
                    return {}
                },
                fromJSON: e => ({}),
                toJSON: e => ({}),
                fromPartial: e => ({})
            }, t.MsgMultiSend = {
                typeUrl: "/cosmos.bank.v1beta1.MsgMultiSend",
                encode(e, t = i.BinaryWriter.create()) {
                    for (let r of e.inputs) o.Input.encode(r, t.uint32(10).fork()).ldelim();
                    for (let r of e.outputs) o.Output.encode(r, t.uint32(18).fork()).ldelim();
                    return t
                },
                decode(e, t) {
                    let r = e instanceof i.BinaryReader ? e : new i.BinaryReader(e),
                        n = void 0 === t ? r.len : r.pos + t,
                        a = d();
                    for (; r.pos < n;) {
                        let e = r.uint32();
                        switch (e >>> 3) {
                            case 1:
                                a.inputs.push(o.Input.decode(r, r.uint32()));
                                break;
                            case 2:
                                a.outputs.push(o.Output.decode(r, r.uint32()));
                                break;
                            default:
                                r.skipType(7 & e)
                        }
                    }
                    return a
                },
                fromJSON(e) {
                    let t = d();
                    return Array.isArray(e ? .inputs) && (t.inputs = e.inputs.map(e => o.Input.fromJSON(e))), Array.isArray(e ? .outputs) && (t.outputs = e.outputs.map(e => o.Output.fromJSON(e))), t
                },
                toJSON(e) {
                    let t = {};
                    return e.inputs ? t.inputs = e.inputs.map(e => e ? o.Input.toJSON(e) : void 0) : t.inputs = [], e.outputs ? t.outputs = e.outputs.map(e => e ? o.Output.toJSON(e) : void 0) : t.outputs = [], t
                },
                fromPartial(e) {
                    let t = d();
                    return t.inputs = e.inputs ? .map(e => o.Input.fromPartial(e)) || [], t.outputs = e.outputs ? .map(e => o.Output.fromPartial(e)) || [], t
                }
            }, t.MsgMultiSendResponse = {
                typeUrl: "/cosmos.bank.v1beta1.MsgMultiSendResponse",
                encode: (e, t = i.BinaryWriter.create()) => t,
                decode(e, t) {
                    let r = e instanceof i.BinaryReader ? e : new i.BinaryReader(e),
                        n = void 0 === t ? r.len : r.pos + t;
                    for (; r.pos < n;) {
                        let e = r.uint32();
                        r.skipType(7 & e)
                    }
                    return {}
                },
                fromJSON: e => ({}),
                toJSON: e => ({}),
                fromPartial: e => ({})
            }, t.MsgUpdateParams = {
                typeUrl: "/cosmos.bank.v1beta1.MsgUpdateParams",
                encode: (e, t = i.BinaryWriter.create()) => ("" !== e.authority && t.uint32(10).string(e.authority), void 0 !== e.params && o.Params.encode(e.params, t.uint32(18).fork()).ldelim(), t),
                decode(e, t) {
                    let r = e instanceof i.BinaryReader ? e : new i.BinaryReader(e),
                        n = void 0 === t ? r.len : r.pos + t,
                        a = c();
                    for (; r.pos < n;) {
                        let e = r.uint32();
                        switch (e >>> 3) {
                            case 1:
                                a.authority = r.string();
                                break;
                            case 2:
                                a.params = o.Params.decode(r, r.uint32());
                                break;
                            default:
                                r.skipType(7 & e)
                        }
                    }
                    return a
                },
                fromJSON(e) {
                    let t = c();
                    return (0, a.isSet)(e.authority) && (t.authority = String(e.authority)), (0, a.isSet)(e.params) && (t.params = o.Params.fromJSON(e.params)), t
                },
                toJSON(e) {
                    let t = {};
                    return void 0 !== e.authority && (t.authority = e.authority), void 0 !== e.params && (t.params = e.params ? o.Params.toJSON(e.params) : void 0), t
                },
                fromPartial(e) {
                    let t = c();
                    return t.authority = e.authority ? ? "", void 0 !== e.params && null !== e.params && (t.params = o.Params.fromPartial(e.params)), t
                }
            }, t.MsgUpdateParamsResponse = {
                typeUrl: "/cosmos.bank.v1beta1.MsgUpdateParamsResponse",
                encode: (e, t = i.BinaryWriter.create()) => t,
                decode(e, t) {
                    let r = e instanceof i.BinaryReader ? e : new i.BinaryReader(e),
                        n = void 0 === t ? r.len : r.pos + t;
                    for (; r.pos < n;) {
                        let e = r.uint32();
                        r.skipType(7 & e)
                    }
                    return {}
                },
                fromJSON: e => ({}),
                toJSON: e => ({}),
                fromPartial: e => ({})
            }, t.MsgSetSendEnabled = {
                typeUrl: "/cosmos.bank.v1beta1.MsgSetSendEnabled",
                encode(e, t = i.BinaryWriter.create()) {
                    for (let r of ("" !== e.authority && t.uint32(10).string(e.authority), e.sendEnabled)) o.SendEnabled.encode(r, t.uint32(18).fork()).ldelim();
                    for (let r of e.useDefaultFor) t.uint32(26).string(r);
                    return t
                },
                decode(e, t) {
                    let r = e instanceof i.BinaryReader ? e : new i.BinaryReader(e),
                        n = void 0 === t ? r.len : r.pos + t,
                        a = l();
                    for (; r.pos < n;) {
                        let e = r.uint32();
                        switch (e >>> 3) {
                            case 1:
                                a.authority = r.string();
                                break;
                            case 2:
                                a.sendEnabled.push(o.SendEnabled.decode(r, r.uint32()));
                                break;
                            case 3:
                                a.useDefaultFor.push(r.string());
                                break;
                            default:
                                r.skipType(7 & e)
                        }
                    }
                    return a
                },
                fromJSON(e) {
                    let t = l();
                    return (0, a.isSet)(e.authority) && (t.authority = String(e.authority)), Array.isArray(e ? .sendEnabled) && (t.sendEnabled = e.sendEnabled.map(e => o.SendEnabled.fromJSON(e))), Array.isArray(e ? .useDefaultFor) && (t.useDefaultFor = e.useDefaultFor.map(e => String(e))), t
                },
                toJSON(e) {
                    let t = {};
                    return void 0 !== e.authority && (t.authority = e.authority), e.sendEnabled ? t.sendEnabled = e.sendEnabled.map(e => e ? o.SendEnabled.toJSON(e) : void 0) : t.sendEnabled = [], e.useDefaultFor ? t.useDefaultFor = e.useDefaultFor.map(e => e) : t.useDefaultFor = [], t
                },
                fromPartial(e) {
                    let t = l();
                    return t.authority = e.authority ? ? "", t.sendEnabled = e.sendEnabled ? .map(e => o.SendEnabled.fromPartial(e)) || [], t.useDefaultFor = e.useDefaultFor ? .map(e => e) || [], t
                }
            }, t.MsgSetSendEnabledResponse = {
                typeUrl: "/cosmos.bank.v1beta1.MsgSetSendEnabledResponse",
                encode: (e, t = i.BinaryWriter.create()) => t,
                decode(e, t) {
                    let r = e instanceof i.BinaryReader ? e : new i.BinaryReader(e),
                        n = void 0 === t ? r.len : r.pos + t;
                    for (; r.pos < n;) {
                        let e = r.uint32();
                        r.skipType(7 & e)
                    }
                    return {}
                },
                fromJSON: e => ({}),
                toJSON: e => ({}),
                fromPartial: e => ({})
            };
            class u {
                constructor(e) {
                    this.rpc = e, this.Send = this.Send.bind(this), this.MultiSend = this.MultiSend.bind(this), this.UpdateParams = this.UpdateParams.bind(this), this.SetSendEnabled = this.SetSendEnabled.bind(this)
                }
                Send(e) {
                    let r = t.MsgSend.encode(e).finish();
                    return this.rpc.request("cosmos.bank.v1beta1.Msg", "Send", r).then(e => t.MsgSendResponse.decode(new i.BinaryReader(e)))
                }
                MultiSend(e) {
                    let r = t.MsgMultiSend.encode(e).finish();
                    return this.rpc.request("cosmos.bank.v1beta1.Msg", "MultiSend", r).then(e => t.MsgMultiSendResponse.decode(new i.BinaryReader(e)))
                }
                UpdateParams(e) {
                    let r = t.MsgUpdateParams.encode(e).finish();
                    return this.rpc.request("cosmos.bank.v1beta1.Msg", "UpdateParams", r).then(e => t.MsgUpdateParamsResponse.decode(new i.BinaryReader(e)))
                }
                SetSendEnabled(e) {
                    let r = t.MsgSetSendEnabled.encode(e).finish();
                    return this.rpc.request("cosmos.bank.v1beta1.Msg", "SetSendEnabled", r).then(e => t.MsgSetSendEnabledResponse.decode(new i.BinaryReader(e)))
                }
            }
            t.MsgClientImpl = u
        },
        77932: function(e, t, r) {
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: !0
            }), t.SearchTxsResult = t.TxMsgData = t.MsgData = t.SimulationResponse = t.Result = t.GasInfo = t.Attribute = t.StringEvent = t.ABCIMessageLog = t.TxResponse = t.protobufPackage = void 0;
            let n = r(40747),
                o = r(88854),
                i = r(23795),
                a = r(96987);

            function s() {
                return {
                    height: BigInt(0),
                    txhash: "",
                    codespace: "",
                    code: 0,
                    data: "",
                    rawLog: "",
                    logs: [],
                    info: "",
                    gasWanted: BigInt(0),
                    gasUsed: BigInt(0),
                    tx: void 0,
                    timestamp: "",
                    events: []
                }
            }

            function d() {
                return {
                    msgIndex: 0,
                    log: "",
                    events: []
                }
            }

            function c() {
                return {
                    type: "",
                    attributes: []
                }
            }

            function l() {
                return {
                    key: "",
                    value: ""
                }
            }

            function u() {
                return {
                    gasWanted: BigInt(0),
                    gasUsed: BigInt(0)
                }
            }

            function p() {
                return {
                    data: new Uint8Array,
                    log: "",
                    events: [],
                    msgResponses: []
                }
            }

            function m() {
                return {
                    gasInfo: t.GasInfo.fromPartial({}),
                    result: void 0
                }
            }

            function g() {
                return {
                    msgType: "",
                    data: new Uint8Array
                }
            }

            function f() {
                return {
                    data: [],
                    msgResponses: []
                }
            }

            function y() {
                return {
                    totalCount: BigInt(0),
                    count: BigInt(0),
                    pageNumber: BigInt(0),
                    pageTotal: BigInt(0),
                    limit: BigInt(0),
                    txs: []
                }
            }
            t.protobufPackage = "cosmos.base.abci.v1beta1", t.TxResponse = {
                typeUrl: "/cosmos.base.abci.v1beta1.TxResponse",
                encode(e, r = i.BinaryWriter.create()) {
                    for (let n of (e.height !== BigInt(0) && r.uint32(8).int64(e.height), "" !== e.txhash && r.uint32(18).string(e.txhash), "" !== e.codespace && r.uint32(26).string(e.codespace), 0 !== e.code && r.uint32(32).uint32(e.code), "" !== e.data && r.uint32(42).string(e.data), "" !== e.rawLog && r.uint32(50).string(e.rawLog), e.logs)) t.ABCIMessageLog.encode(n, r.uint32(58).fork()).ldelim();
                    for (let t of ("" !== e.info && r.uint32(66).string(e.info), e.gasWanted !== BigInt(0) && r.uint32(72).int64(e.gasWanted), e.gasUsed !== BigInt(0) && r.uint32(80).int64(e.gasUsed), void 0 !== e.tx && n.Any.encode(e.tx, r.uint32(90).fork()).ldelim(), "" !== e.timestamp && r.uint32(98).string(e.timestamp), e.events)) o.Event.encode(t, r.uint32(106).fork()).ldelim();
                    return r
                },
                decode(e, r) {
                    let a = e instanceof i.BinaryReader ? e : new i.BinaryReader(e),
                        d = void 0 === r ? a.len : a.pos + r,
                        c = s();
                    for (; a.pos < d;) {
                        let e = a.uint32();
                        switch (e >>> 3) {
                            case 1:
                                c.height = a.int64();
                                break;
                            case 2:
                                c.txhash = a.string();
                                break;
                            case 3:
                                c.codespace = a.string();
                                break;
                            case 4:
                                c.code = a.uint32();
                                break;
                            case 5:
                                c.data = a.string();
                                break;
                            case 6:
                                c.rawLog = a.string();
                                break;
                            case 7:
                                c.logs.push(t.ABCIMessageLog.decode(a, a.uint32()));
                                break;
                            case 8:
                                c.info = a.string();
                                break;
                            case 9:
                                c.gasWanted = a.int64();
                                break;
                            case 10:
                                c.gasUsed = a.int64();
                                break;
                            case 11:
                                c.tx = n.Any.decode(a, a.uint32());
                                break;
                            case 12:
                                c.timestamp = a.string();
                                break;
                            case 13:
                                c.events.push(o.Event.decode(a, a.uint32()));
                                break;
                            default:
                                a.skipType(7 & e)
                        }
                    }
                    return c
                },
                fromJSON(e) {
                    let r = s();
                    return (0, a.isSet)(e.height) && (r.height = BigInt(e.height.toString())), (0, a.isSet)(e.txhash) && (r.txhash = String(e.txhash)), (0, a.isSet)(e.codespace) && (r.codespace = String(e.codespace)), (0, a.isSet)(e.code) && (r.code = Number(e.code)), (0, a.isSet)(e.data) && (r.data = String(e.data)), (0, a.isSet)(e.rawLog) && (r.rawLog = String(e.rawLog)), Array.isArray(e ? .logs) && (r.logs = e.logs.map(e => t.ABCIMessageLog.fromJSON(e))), (0, a.isSet)(e.info) && (r.info = String(e.info)), (0, a.isSet)(e.gasWanted) && (r.gasWanted = BigInt(e.gasWanted.toString())), (0, a.isSet)(e.gasUsed) && (r.gasUsed = BigInt(e.gasUsed.toString())), (0, a.isSet)(e.tx) && (r.tx = n.Any.fromJSON(e.tx)), (0, a.isSet)(e.timestamp) && (r.timestamp = String(e.timestamp)), Array.isArray(e ? .events) && (r.events = e.events.map(e => o.Event.fromJSON(e))), r
                },
                toJSON(e) {
                    let r = {};
                    return void 0 !== e.height && (r.height = (e.height || BigInt(0)).toString()), void 0 !== e.txhash && (r.txhash = e.txhash), void 0 !== e.codespace && (r.codespace = e.codespace), void 0 !== e.code && (r.code = Math.round(e.code)), void 0 !== e.data && (r.data = e.data), void 0 !== e.rawLog && (r.rawLog = e.rawLog), e.logs ? r.logs = e.logs.map(e => e ? t.ABCIMessageLog.toJSON(e) : void 0) : r.logs = [], void 0 !== e.info && (r.info = e.info), void 0 !== e.gasWanted && (r.gasWanted = (e.gasWanted || BigInt(0)).toString()), void 0 !== e.gasUsed && (r.gasUsed = (e.gasUsed || BigInt(0)).toString()), void 0 !== e.tx && (r.tx = e.tx ? n.Any.toJSON(e.tx) : void 0), void 0 !== e.timestamp && (r.timestamp = e.timestamp), e.events ? r.events = e.events.map(e => e ? o.Event.toJSON(e) : void 0) : r.events = [], r
                },
                fromPartial(e) {
                    let r = s();
                    return void 0 !== e.height && null !== e.height && (r.height = BigInt(e.height.toString())), r.txhash = e.txhash ? ? "", r.codespace = e.codespace ? ? "", r.code = e.code ? ? 0, r.data = e.data ? ? "", r.rawLog = e.rawLog ? ? "", r.logs = e.logs ? .map(e => t.ABCIMessageLog.fromPartial(e)) || [], r.info = e.info ? ? "", void 0 !== e.gasWanted && null !== e.gasWanted && (r.gasWanted = BigInt(e.gasWanted.toString())), void 0 !== e.gasUsed && null !== e.gasUsed && (r.gasUsed = BigInt(e.gasUsed.toString())), void 0 !== e.tx && null !== e.tx && (r.tx = n.Any.fromPartial(e.tx)), r.timestamp = e.timestamp ? ? "", r.events = e.events ? .map(e => o.Event.fromPartial(e)) || [], r
                }
            }, t.ABCIMessageLog = {
                typeUrl: "/cosmos.base.abci.v1beta1.ABCIMessageLog",
                encode(e, r = i.BinaryWriter.create()) {
                    for (let n of (0 !== e.msgIndex && r.uint32(8).uint32(e.msgIndex), "" !== e.log && r.uint32(18).string(e.log), e.events)) t.StringEvent.encode(n, r.uint32(26).fork()).ldelim();
                    return r
                },
                decode(e, r) {
                    let n = e instanceof i.BinaryReader ? e : new i.BinaryReader(e),
                        o = void 0 === r ? n.len : n.pos + r,
                        a = d();
                    for (; n.pos < o;) {
                        let e = n.uint32();
                        switch (e >>> 3) {
                            case 1:
                                a.msgIndex = n.uint32();
                                break;
                            case 2:
                                a.log = n.string();
                                break;
                            case 3:
                                a.events.push(t.StringEvent.decode(n, n.uint32()));
                                break;
                            default:
                                n.skipType(7 & e)
                        }
                    }
                    return a
                },
                fromJSON(e) {
                    let r = d();
                    return (0, a.isSet)(e.msgIndex) && (r.msgIndex = Number(e.msgIndex)), (0, a.isSet)(e.log) && (r.log = String(e.log)), Array.isArray(e ? .events) && (r.events = e.events.map(e => t.StringEvent.fromJSON(e))), r
                },
                toJSON(e) {
                    let r = {};
                    return void 0 !== e.msgIndex && (r.msgIndex = Math.round(e.msgIndex)), void 0 !== e.log && (r.log = e.log), e.events ? r.events = e.events.map(e => e ? t.StringEvent.toJSON(e) : void 0) : r.events = [], r
                },
                fromPartial(e) {
                    let r = d();
                    return r.msgIndex = e.msgIndex ? ? 0, r.log = e.log ? ? "", r.events = e.events ? .map(e => t.StringEvent.fromPartial(e)) || [], r
                }
            }, t.StringEvent = {
                typeUrl: "/cosmos.base.abci.v1beta1.StringEvent",
                encode(e, r = i.BinaryWriter.create()) {
                    for (let n of ("" !== e.type && r.uint32(10).string(e.type), e.attributes)) t.Attribute.encode(n, r.uint32(18).fork()).ldelim();
                    return r
                },
                decode(e, r) {
                    let n = e instanceof i.BinaryReader ? e : new i.BinaryReader(e),
                        o = void 0 === r ? n.len : n.pos + r,
                        a = c();
                    for (; n.pos < o;) {
                        let e = n.uint32();
                        switch (e >>> 3) {
                            case 1:
                                a.type = n.string();
                                break;
                            case 2:
                                a.attributes.push(t.Attribute.decode(n, n.uint32()));
                                break;
                            default:
                                n.skipType(7 & e)
                        }
                    }
                    return a
                },
                fromJSON(e) {
                    let r = c();
                    return (0, a.isSet)(e.type) && (r.type = String(e.type)), Array.isArray(e ? .attributes) && (r.attributes = e.attributes.map(e => t.Attribute.fromJSON(e))), r
                },
                toJSON(e) {
                    let r = {};
                    return void 0 !== e.type && (r.type = e.type), e.attributes ? r.attributes = e.attributes.map(e => e ? t.Attribute.toJSON(e) : void 0) : r.attributes = [], r
                },
                fromPartial(e) {
                    let r = c();
                    return r.type = e.type ? ? "", r.attributes = e.attributes ? .map(e => t.Attribute.fromPartial(e)) || [], r
                }
            }, t.Attribute = {
                typeUrl: "/cosmos.base.abci.v1beta1.Attribute",
                encode: (e, t = i.BinaryWriter.create()) => ("" !== e.key && t.uint32(10).string(e.key), "" !== e.value && t.uint32(18).string(e.value), t),
                decode(e, t) {
                    let r = e instanceof i.BinaryReader ? e : new i.BinaryReader(e),
                        n = void 0 === t ? r.len : r.pos + t,
                        o = l();
                    for (; r.pos < n;) {
                        let e = r.uint32();
                        switch (e >>> 3) {
                            case 1:
                                o.key = r.string();
                                break;
                            case 2:
                                o.value = r.string();
                                break;
                            default:
                                r.skipType(7 & e)
                        }
                    }
                    return o
                },
                fromJSON(e) {
                    let t = l();
                    return (0, a.isSet)(e.key) && (t.key = String(e.key)), (0, a.isSet)(e.value) && (t.value = String(e.value)), t
                },
                toJSON(e) {
                    let t = {};
                    return void 0 !== e.key && (t.key = e.key), void 0 !== e.value && (t.value = e.value), t
                },
                fromPartial(e) {
                    let t = l();
                    return t.key = e.key ? ? "", t.value = e.value ? ? "", t
                }
            }, t.GasInfo = {
                typeUrl: "/cosmos.base.abci.v1beta1.GasInfo",
                encode: (e, t = i.BinaryWriter.create()) => (e.gasWanted !== BigInt(0) && t.uint32(8).uint64(e.gasWanted), e.gasUsed !== BigInt(0) && t.uint32(16).uint64(e.gasUsed), t),
                decode(e, t) {
                    let r = e instanceof i.BinaryReader ? e : new i.BinaryReader(e),
                        n = void 0 === t ? r.len : r.pos + t,
                        o = u();
                    for (; r.pos < n;) {
                        let e = r.uint32();
                        switch (e >>> 3) {
                            case 1:
                                o.gasWanted = r.uint64();
                                break;
                            case 2:
                                o.gasUsed = r.uint64();
                                break;
                            default:
                                r.skipType(7 & e)
                        }
                    }
                    return o
                },
                fromJSON(e) {
                    let t = u();
                    return (0, a.isSet)(e.gasWanted) && (t.gasWanted = BigInt(e.gasWanted.toString())), (0, a.isSet)(e.gasUsed) && (t.gasUsed = BigInt(e.gasUsed.toString())), t
                },
                toJSON(e) {
                    let t = {};
                    return void 0 !== e.gasWanted && (t.gasWanted = (e.gasWanted || BigInt(0)).toString()), void 0 !== e.gasUsed && (t.gasUsed = (e.gasUsed || BigInt(0)).toString()), t
                },
                fromPartial(e) {
                    let t = u();
                    return void 0 !== e.gasWanted && null !== e.gasWanted && (t.gasWanted = BigInt(e.gasWanted.toString())), void 0 !== e.gasUsed && null !== e.gasUsed && (t.gasUsed = BigInt(e.gasUsed.toString())), t
                }
            }, t.Result = {
                typeUrl: "/cosmos.base.abci.v1beta1.Result",
                encode(e, t = i.BinaryWriter.create()) {
                    for (let r of (0 !== e.data.length && t.uint32(10).bytes(e.data), "" !== e.log && t.uint32(18).string(e.log), e.events)) o.Event.encode(r, t.uint32(26).fork()).ldelim();
                    for (let r of e.msgResponses) n.Any.encode(r, t.uint32(34).fork()).ldelim();
                    return t
                },
                decode(e, t) {
                    let r = e instanceof i.BinaryReader ? e : new i.BinaryReader(e),
                        a = void 0 === t ? r.len : r.pos + t,
                        s = p();
                    for (; r.pos < a;) {
                        let e = r.uint32();
                        switch (e >>> 3) {
                            case 1:
                                s.data = r.bytes();
                                break;
                            case 2:
                                s.log = r.string();
                                break;
                            case 3:
                                s.events.push(o.Event.decode(r, r.uint32()));
                                break;
                            case 4:
                                s.msgResponses.push(n.Any.decode(r, r.uint32()));
                                break;
                            default:
                                r.skipType(7 & e)
                        }
                    }
                    return s
                },
                fromJSON(e) {
                    let t = p();
                    return (0, a.isSet)(e.data) && (t.data = (0, a.bytesFromBase64)(e.data)), (0, a.isSet)(e.log) && (t.log = String(e.log)), Array.isArray(e ? .events) && (t.events = e.events.map(e => o.Event.fromJSON(e))), Array.isArray(e ? .msgResponses) && (t.msgResponses = e.msgResponses.map(e => n.Any.fromJSON(e))), t
                },
                toJSON(e) {
                    let t = {};
                    return void 0 !== e.data && (t.data = (0, a.base64FromBytes)(void 0 !== e.data ? e.data : new Uint8Array)), void 0 !== e.log && (t.log = e.log), e.events ? t.events = e.events.map(e => e ? o.Event.toJSON(e) : void 0) : t.events = [], e.msgResponses ? t.msgResponses = e.msgResponses.map(e => e ? n.Any.toJSON(e) : void 0) : t.msgResponses = [], t
                },
                fromPartial(e) {
                    let t = p();
                    return t.data = e.data ? ? new Uint8Array, t.log = e.log ? ? "", t.events = e.events ? .map(e => o.Event.fromPartial(e)) || [], t.msgResponses = e.msgResponses ? .map(e => n.Any.fromPartial(e)) || [], t
                }
            }, t.SimulationResponse = {
                typeUrl: "/cosmos.base.abci.v1beta1.SimulationResponse",
                encode: (e, r = i.BinaryWriter.create()) => (void 0 !== e.gasInfo && t.GasInfo.encode(e.gasInfo, r.uint32(10).fork()).ldelim(), void 0 !== e.result && t.Result.encode(e.result, r.uint32(18).fork()).ldelim(), r),
                decode(e, r) {
                    let n = e instanceof i.BinaryReader ? e : new i.BinaryReader(e),
                        o = void 0 === r ? n.len : n.pos + r,
                        a = m();
                    for (; n.pos < o;) {
                        let e = n.uint32();
                        switch (e >>> 3) {
                            case 1:
                                a.gasInfo = t.GasInfo.decode(n, n.uint32());
                                break;
                            case 2:
                                a.result = t.Result.decode(n, n.uint32());
                                break;
                            default:
                                n.skipType(7 & e)
                        }
                    }
                    return a
                },
                fromJSON(e) {
                    let r = m();
                    return (0, a.isSet)(e.gasInfo) && (r.gasInfo = t.GasInfo.fromJSON(e.gasInfo)), (0, a.isSet)(e.result) && (r.result = t.Result.fromJSON(e.result)), r
                },
                toJSON(e) {
                    let r = {};
                    return void 0 !== e.gasInfo && (r.gasInfo = e.gasInfo ? t.GasInfo.toJSON(e.gasInfo) : void 0), void 0 !== e.result && (r.result = e.result ? t.Result.toJSON(e.result) : void 0), r
                },
                fromPartial(e) {
                    let r = m();
                    return void 0 !== e.gasInfo && null !== e.gasInfo && (r.gasInfo = t.GasInfo.fromPartial(e.gasInfo)), void 0 !== e.result && null !== e.result && (r.result = t.Result.fromPartial(e.result)), r
                }
            }, t.MsgData = {
                typeUrl: "/cosmos.base.abci.v1beta1.MsgData",
                encode: (e, t = i.BinaryWriter.create()) => ("" !== e.msgType && t.uint32(10).string(e.msgType), 0 !== e.data.length && t.uint32(18).bytes(e.data), t),
                decode(e, t) {
                    let r = e instanceof i.BinaryReader ? e : new i.BinaryReader(e),
                        n = void 0 === t ? r.len : r.pos + t,
                        o = g();
                    for (; r.pos < n;) {
                        let e = r.uint32();
                        switch (e >>> 3) {
                            case 1:
                                o.msgType = r.string();
                                break;
                            case 2:
                                o.data = r.bytes();
                                break;
                            default:
                                r.skipType(7 & e)
                        }
                    }
                    return o
                },
                fromJSON(e) {
                    let t = g();
                    return (0, a.isSet)(e.msgType) && (t.msgType = String(e.msgType)), (0, a.isSet)(e.data) && (t.data = (0, a.bytesFromBase64)(e.data)), t
                },
                toJSON(e) {
                    let t = {};
                    return void 0 !== e.msgType && (t.msgType = e.msgType), void 0 !== e.data && (t.data = (0, a.base64FromBytes)(void 0 !== e.data ? e.data : new Uint8Array)), t
                },
                fromPartial(e) {
                    let t = g();
                    return t.msgType = e.msgType ? ? "", t.data = e.data ? ? new Uint8Array, t
                }
            }, t.TxMsgData = {
                typeUrl: "/cosmos.base.abci.v1beta1.TxMsgData",
                encode(e, r = i.BinaryWriter.create()) {
                    for (let n of e.data) t.MsgData.encode(n, r.uint32(10).fork()).ldelim();
                    for (let t of e.msgResponses) n.Any.encode(t, r.uint32(18).fork()).ldelim();
                    return r
                },
                decode(e, r) {
                    let o = e instanceof i.BinaryReader ? e : new i.BinaryReader(e),
                        a = void 0 === r ? o.len : o.pos + r,
                        s = f();
                    for (; o.pos < a;) {
                        let e = o.uint32();
                        switch (e >>> 3) {
                            case 1:
                                s.data.push(t.MsgData.decode(o, o.uint32()));
                                break;
                            case 2:
                                s.msgResponses.push(n.Any.decode(o, o.uint32()));
                                break;
                            default:
                                o.skipType(7 & e)
                        }
                    }
                    return s
                },
                fromJSON(e) {
                    let r = f();
                    return Array.isArray(e ? .data) && (r.data = e.data.map(e => t.MsgData.fromJSON(e))), Array.isArray(e ? .msgResponses) && (r.msgResponses = e.msgResponses.map(e => n.Any.fromJSON(e))), r
                },
                toJSON(e) {
                    let r = {};
                    return e.data ? r.data = e.data.map(e => e ? t.MsgData.toJSON(e) : void 0) : r.data = [], e.msgResponses ? r.msgResponses = e.msgResponses.map(e => e ? n.Any.toJSON(e) : void 0) : r.msgResponses = [], r
                },
                fromPartial(e) {
                    let r = f();
                    return r.data = e.data ? .map(e => t.MsgData.fromPartial(e)) || [], r.msgResponses = e.msgResponses ? .map(e => n.Any.fromPartial(e)) || [], r
                }
            }, t.SearchTxsResult = {
                typeUrl: "/cosmos.base.abci.v1beta1.SearchTxsResult",
                encode(e, r = i.BinaryWriter.create()) {
                    for (let n of (e.totalCount !== BigInt(0) && r.uint32(8).uint64(e.totalCount), e.count !== BigInt(0) && r.uint32(16).uint64(e.count), e.pageNumber !== BigInt(0) && r.uint32(24).uint64(e.pageNumber), e.pageTotal !== BigInt(0) && r.uint32(32).uint64(e.pageTotal), e.limit !== BigInt(0) && r.uint32(40).uint64(e.limit), e.txs)) t.TxResponse.encode(n, r.uint32(50).fork()).ldelim();
                    return r
                },
                decode(e, r) {
                    let n = e instanceof i.BinaryReader ? e : new i.BinaryReader(e),
                        o = void 0 === r ? n.len : n.pos + r,
                        a = y();
                    for (; n.pos < o;) {
                        let e = n.uint32();
                        switch (e >>> 3) {
                            case 1:
                                a.totalCount = n.uint64();
                                break;
                            case 2:
                                a.count = n.uint64();
                                break;
                            case 3:
                                a.pageNumber = n.uint64();
                                break;
                            case 4:
                                a.pageTotal = n.uint64();
                                break;
                            case 5:
                                a.limit = n.uint64();
                                break;
                            case 6:
                                a.txs.push(t.TxResponse.decode(n, n.uint32()));
                                break;
                            default:
                                n.skipType(7 & e)
                        }
                    }
                    return a
                },
                fromJSON(e) {
                    let r = y();
                    return (0, a.isSet)(e.totalCount) && (r.totalCount = BigInt(e.totalCount.toString())), (0, a.isSet)(e.count) && (r.count = BigInt(e.count.toString())), (0, a.isSet)(e.pageNumber) && (r.pageNumber = BigInt(e.pageNumber.toString())), (0, a.isSet)(e.pageTotal) && (r.pageTotal = BigInt(e.pageTotal.toString())), (0, a.isSet)(e.limit) && (r.limit = BigInt(e.limit.toString())), Array.isArray(e ? .txs) && (r.txs = e.txs.map(e => t.TxResponse.fromJSON(e))), r
                },
                toJSON(e) {
                    let r = {};
                    return void 0 !== e.totalCount && (r.totalCount = (e.totalCount || BigInt(0)).toString()), void 0 !== e.count && (r.count = (e.count || BigInt(0)).toString()), void 0 !== e.pageNumber && (r.pageNumber = (e.pageNumber || BigInt(0)).toString()), void 0 !== e.pageTotal && (r.pageTotal = (e.pageTotal || BigInt(0)).toString()), void 0 !== e.limit && (r.limit = (e.limit || BigInt(0)).toString()), e.txs ? r.txs = e.txs.map(e => e ? t.TxResponse.toJSON(e) : void 0) : r.txs = [], r
                },
                fromPartial(e) {
                    let r = y();
                    return void 0 !== e.totalCount && null !== e.totalCount && (r.totalCount = BigInt(e.totalCount.toString())), void 0 !== e.count && null !== e.count && (r.count = BigInt(e.count.toString())), void 0 !== e.pageNumber && null !== e.pageNumber && (r.pageNumber = BigInt(e.pageNumber.toString())), void 0 !== e.pageTotal && null !== e.pageTotal && (r.pageTotal = BigInt(e.pageTotal.toString())), void 0 !== e.limit && null !== e.limit && (r.limit = BigInt(e.limit.toString())), r.txs = e.txs ? .map(e => t.TxResponse.fromPartial(e)) || [], r
                }
            }
        },
        40425: function(e, t, r) {
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: !0
            }), t.PageResponse = t.PageRequest = t.protobufPackage = void 0;
            let n = r(23795),
                o = r(96987);

            function i() {
                return {
                    key: new Uint8Array,
                    offset: BigInt(0),
                    limit: BigInt(0),
                    countTotal: !1,
                    reverse: !1
                }
            }

            function a() {
                return {
                    nextKey: new Uint8Array,
                    total: BigInt(0)
                }
            }
            t.protobufPackage = "cosmos.base.query.v1beta1", t.PageRequest = {
                typeUrl: "/cosmos.base.query.v1beta1.PageRequest",
                encode: (e, t = n.BinaryWriter.create()) => (0 !== e.key.length && t.uint32(10).bytes(e.key), e.offset !== BigInt(0) && t.uint32(16).uint64(e.offset), e.limit !== BigInt(0) && t.uint32(24).uint64(e.limit), !0 === e.countTotal && t.uint32(32).bool(e.countTotal), !0 === e.reverse && t.uint32(40).bool(e.reverse), t),
                decode(e, t) {
                    let r = e instanceof n.BinaryReader ? e : new n.BinaryReader(e),
                        o = void 0 === t ? r.len : r.pos + t,
                        a = i();
                    for (; r.pos < o;) {
                        let e = r.uint32();
                        switch (e >>> 3) {
                            case 1:
                                a.key = r.bytes();
                                break;
                            case 2:
                                a.offset = r.uint64();
                                break;
                            case 3:
                                a.limit = r.uint64();
                                break;
                            case 4:
                                a.countTotal = r.bool();
                                break;
                            case 5:
                                a.reverse = r.bool();
                                break;
                            default:
                                r.skipType(7 & e)
                        }
                    }
                    return a
                },
                fromJSON(e) {
                    let t = i();
                    return (0, o.isSet)(e.key) && (t.key = (0, o.bytesFromBase64)(e.key)), (0, o.isSet)(e.offset) && (t.offset = BigInt(e.offset.toString())), (0, o.isSet)(e.limit) && (t.limit = BigInt(e.limit.toString())), (0, o.isSet)(e.countTotal) && (t.countTotal = !!e.countTotal), (0, o.isSet)(e.reverse) && (t.reverse = !!e.reverse), t
                },
                toJSON(e) {
                    let t = {};
                    return void 0 !== e.key && (t.key = (0, o.base64FromBytes)(void 0 !== e.key ? e.key : new Uint8Array)), void 0 !== e.offset && (t.offset = (e.offset || BigInt(0)).toString()), void 0 !== e.limit && (t.limit = (e.limit || BigInt(0)).toString()), void 0 !== e.countTotal && (t.countTotal = e.countTotal), void 0 !== e.reverse && (t.reverse = e.reverse), t
                },
                fromPartial(e) {
                    let t = i();
                    return t.key = e.key ? ? new Uint8Array, void 0 !== e.offset && null !== e.offset && (t.offset = BigInt(e.offset.toString())), void 0 !== e.limit && null !== e.limit && (t.limit = BigInt(e.limit.toString())), t.countTotal = e.countTotal ? ? !1, t.reverse = e.reverse ? ? !1, t
                }
            }, t.PageResponse = {
                typeUrl: "/cosmos.base.query.v1beta1.PageResponse",
                encode: (e, t = n.BinaryWriter.create()) => (0 !== e.nextKey.length && t.uint32(10).bytes(e.nextKey), e.total !== BigInt(0) && t.uint32(16).uint64(e.total), t),
                decode(e, t) {
                    let r = e instanceof n.BinaryReader ? e : new n.BinaryReader(e),
                        o = void 0 === t ? r.len : r.pos + t,
                        i = a();
                    for (; r.pos < o;) {
                        let e = r.uint32();
                        switch (e >>> 3) {
                            case 1:
                                i.nextKey = r.bytes();
                                break;
                            case 2:
                                i.total = r.uint64();
                                break;
                            default:
                                r.skipType(7 & e)
                        }
                    }
                    return i
                },
                fromJSON(e) {
                    let t = a();
                    return (0, o.isSet)(e.nextKey) && (t.nextKey = (0, o.bytesFromBase64)(e.nextKey)), (0, o.isSet)(e.total) && (t.total = BigInt(e.total.toString())), t
                },
                toJSON(e) {
                    let t = {};
                    return void 0 !== e.nextKey && (t.nextKey = (0, o.base64FromBytes)(void 0 !== e.nextKey ? e.nextKey : new Uint8Array)), void 0 !== e.total && (t.total = (e.total || BigInt(0)).toString()), t
                },
                fromPartial(e) {
                    let t = a();
                    return t.nextKey = e.nextKey ? ? new Uint8Array, void 0 !== e.total && null !== e.total && (t.total = BigInt(e.total.toString())), t
                }
            }
        },
        91408: function(e, t, r) {
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: !0
            }), t.DecProto = t.IntProto = t.DecCoin = t.Coin = t.protobufPackage = void 0;
            let n = r(23795),
                o = r(96987);

            function i() {
                return {
                    denom: "",
                    amount: ""
                }
            }

            function a() {
                return {
                    denom: "",
                    amount: ""
                }
            }

            function s() {
                return {
                    int: ""
                }
            }

            function d() {
                return {
                    dec: ""
                }
            }
            t.protobufPackage = "cosmos.base.v1beta1", t.Coin = {
                typeUrl: "/cosmos.base.v1beta1.Coin",
                encode: (e, t = n.BinaryWriter.create()) => ("" !== e.denom && t.uint32(10).string(e.denom), "" !== e.amount && t.uint32(18).string(e.amount), t),
                decode(e, t) {
                    let r = e instanceof n.BinaryReader ? e : new n.BinaryReader(e),
                        o = void 0 === t ? r.len : r.pos + t,
                        a = i();
                    for (; r.pos < o;) {
                        let e = r.uint32();
                        switch (e >>> 3) {
                            case 1:
                                a.denom = r.string();
                                break;
                            case 2:
                                a.amount = r.string();
                                break;
                            default:
                                r.skipType(7 & e)
                        }
                    }
                    return a
                },
                fromJSON(e) {
                    let t = i();
                    return (0, o.isSet)(e.denom) && (t.denom = String(e.denom)), (0, o.isSet)(e.amount) && (t.amount = String(e.amount)), t
                },
                toJSON(e) {
                    let t = {};
                    return void 0 !== e.denom && (t.denom = e.denom), void 0 !== e.amount && (t.amount = e.amount), t
                },
                fromPartial(e) {
                    let t = i();
                    return t.denom = e.denom ? ? "", t.amount = e.amount ? ? "", t
                }
            }, t.DecCoin = {
                typeUrl: "/cosmos.base.v1beta1.DecCoin",
                encode: (e, t = n.BinaryWriter.create()) => ("" !== e.denom && t.uint32(10).string(e.denom), "" !== e.amount && t.uint32(18).string(e.amount), t),
                decode(e, t) {
                    let r = e instanceof n.BinaryReader ? e : new n.BinaryReader(e),
                        o = void 0 === t ? r.len : r.pos + t,
                        i = a();
                    for (; r.pos < o;) {
                        let e = r.uint32();
                        switch (e >>> 3) {
                            case 1:
                                i.denom = r.string();
                                break;
                            case 2:
                                i.amount = r.string();
                                break;
                            default:
                                r.skipType(7 & e)
                        }
                    }
                    return i
                },
                fromJSON(e) {
                    let t = a();
                    return (0, o.isSet)(e.denom) && (t.denom = String(e.denom)), (0, o.isSet)(e.amount) && (t.amount = String(e.amount)), t
                },
                toJSON(e) {
                    let t = {};
                    return void 0 !== e.denom && (t.denom = e.denom), void 0 !== e.amount && (t.amount = e.amount), t
                },
                fromPartial(e) {
                    let t = a();
                    return t.denom = e.denom ? ? "", t.amount = e.amount ? ? "", t
                }
            }, t.IntProto = {
                typeUrl: "/cosmos.base.v1beta1.IntProto",
                encode: (e, t = n.BinaryWriter.create()) => ("" !== e.int && t.uint32(10).string(e.int), t),
                decode(e, t) {
                    let r = e instanceof n.BinaryReader ? e : new n.BinaryReader(e),
                        o = void 0 === t ? r.len : r.pos + t,
                        i = s();
                    for (; r.pos < o;) {
                        let e = r.uint32();
                        e >>> 3 == 1 ? i.int = r.string() : r.skipType(7 & e)
                    }
                    return i
                },
                fromJSON(e) {
                    let t = s();
                    return (0, o.isSet)(e.int) && (t.int = String(e.int)), t
                },
                toJSON(e) {
                    let t = {};
                    return void 0 !== e.int && (t.int = e.int), t
                },
                fromPartial(e) {
                    let t = s();
                    return t.int = e.int ? ? "", t
                }
            }, t.DecProto = {
                typeUrl: "/cosmos.base.v1beta1.DecProto",
                encode: (e, t = n.BinaryWriter.create()) => ("" !== e.dec && t.uint32(10).string(e.dec), t),
                decode(e, t) {
                    let r = e instanceof n.BinaryReader ? e : new n.BinaryReader(e),
                        o = void 0 === t ? r.len : r.pos + t,
                        i = d();
                    for (; r.pos < o;) {
                        let e = r.uint32();
                        e >>> 3 == 1 ? i.dec = r.string() : r.skipType(7 & e)
                    }
                    return i
                },
                fromJSON(e) {
                    let t = d();
                    return (0, o.isSet)(e.dec) && (t.dec = String(e.dec)), t
                },
                toJSON(e) {
                    let t = {};
                    return void 0 !== e.dec && (t.dec = e.dec), t
                },
                fromPartial(e) {
                    let t = d();
                    return t.dec = e.dec ? ? "", t
                }
            }
        },
        23288: function(e, t, r) {
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: !0
            }), t.PrivKey = t.PubKey = t.protobufPackage = void 0;
            let n = r(23795),
                o = r(96987);

            function i() {
                return {
                    key: new Uint8Array
                }
            }

            function a() {
                return {
                    key: new Uint8Array
                }
            }
            t.protobufPackage = "cosmos.crypto.ed25519", t.PubKey = {
                typeUrl: "/cosmos.crypto.ed25519.PubKey",
                encode: (e, t = n.BinaryWriter.create()) => (0 !== e.key.length && t.uint32(10).bytes(e.key), t),
                decode(e, t) {
                    let r = e instanceof n.BinaryReader ? e : new n.BinaryReader(e),
                        o = void 0 === t ? r.len : r.pos + t,
                        a = i();
                    for (; r.pos < o;) {
                        let e = r.uint32();
                        e >>> 3 == 1 ? a.key = r.bytes() : r.skipType(7 & e)
                    }
                    return a
                },
                fromJSON(e) {
                    let t = i();
                    return (0, o.isSet)(e.key) && (t.key = (0, o.bytesFromBase64)(e.key)), t
                },
                toJSON(e) {
                    let t = {};
                    return void 0 !== e.key && (t.key = (0, o.base64FromBytes)(void 0 !== e.key ? e.key : new Uint8Array)), t
                },
                fromPartial(e) {
                    let t = i();
                    return t.key = e.key ? ? new Uint8Array, t
                }
            }, t.PrivKey = {
                typeUrl: "/cosmos.crypto.ed25519.PrivKey",
                encode: (e, t = n.BinaryWriter.create()) => (0 !== e.key.length && t.uint32(10).bytes(e.key), t),
                decode(e, t) {
                    let r = e instanceof n.BinaryReader ? e : new n.BinaryReader(e),
                        o = void 0 === t ? r.len : r.pos + t,
                        i = a();
                    for (; r.pos < o;) {
                        let e = r.uint32();
                        e >>> 3 == 1 ? i.key = r.bytes() : r.skipType(7 & e)
                    }
                    return i
                },
                fromJSON(e) {
                    let t = a();
                    return (0, o.isSet)(e.key) && (t.key = (0, o.bytesFromBase64)(e.key)), t
                },
                toJSON(e) {
                    let t = {};
                    return void 0 !== e.key && (t.key = (0, o.base64FromBytes)(void 0 !== e.key ? e.key : new Uint8Array)), t
                },
                fromPartial(e) {
                    let t = a();
                    return t.key = e.key ? ? new Uint8Array, t
                }
            }
        },
        13724: function(e, t, r) {
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: !0
            }), t.LegacyAminoPubKey = t.protobufPackage = void 0;
            let n = r(40747),
                o = r(23795),
                i = r(96987);

            function a() {
                return {
                    threshold: 0,
                    publicKeys: []
                }
            }
            t.protobufPackage = "cosmos.crypto.multisig", t.LegacyAminoPubKey = {
                typeUrl: "/cosmos.crypto.multisig.LegacyAminoPubKey",
                encode(e, t = o.BinaryWriter.create()) {
                    for (let r of (0 !== e.threshold && t.uint32(8).uint32(e.threshold), e.publicKeys)) n.Any.encode(r, t.uint32(18).fork()).ldelim();
                    return t
                },
                decode(e, t) {
                    let r = e instanceof o.BinaryReader ? e : new o.BinaryReader(e),
                        i = void 0 === t ? r.len : r.pos + t,
                        s = a();
                    for (; r.pos < i;) {
                        let e = r.uint32();
                        switch (e >>> 3) {
                            case 1:
                                s.threshold = r.uint32();
                                break;
                            case 2:
                                s.publicKeys.push(n.Any.decode(r, r.uint32()));
                                break;
                            default:
                                r.skipType(7 & e)
                        }
                    }
                    return s
                },
                fromJSON(e) {
                    let t = a();
                    return (0, i.isSet)(e.threshold) && (t.threshold = Number(e.threshold)), Array.isArray(e ? .publicKeys) && (t.publicKeys = e.publicKeys.map(e => n.Any.fromJSON(e))), t
                },
                toJSON(e) {
                    let t = {};
                    return void 0 !== e.threshold && (t.threshold = Math.round(e.threshold)), e.publicKeys ? t.publicKeys = e.publicKeys.map(e => e ? n.Any.toJSON(e) : void 0) : t.publicKeys = [], t
                },
                fromPartial(e) {
                    let t = a();
                    return t.threshold = e.threshold ? ? 0, t.publicKeys = e.publicKeys ? .map(e => n.Any.fromPartial(e)) || [], t
                }
            }
        },
        80758: function(e, t, r) {
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: !0
            }), t.CompactBitArray = t.MultiSignature = t.protobufPackage = void 0;
            let n = r(23795),
                o = r(96987);

            function i() {
                return {
                    signatures: []
                }
            }

            function a() {
                return {
                    extraBitsStored: 0,
                    elems: new Uint8Array
                }
            }
            t.protobufPackage = "cosmos.crypto.multisig.v1beta1", t.MultiSignature = {
                typeUrl: "/cosmos.crypto.multisig.v1beta1.MultiSignature",
                encode(e, t = n.BinaryWriter.create()) {
                    for (let r of e.signatures) t.uint32(10).bytes(r);
                    return t
                },
                decode(e, t) {
                    let r = e instanceof n.BinaryReader ? e : new n.BinaryReader(e),
                        o = void 0 === t ? r.len : r.pos + t,
                        a = i();
                    for (; r.pos < o;) {
                        let e = r.uint32();
                        e >>> 3 == 1 ? a.signatures.push(r.bytes()) : r.skipType(7 & e)
                    }
                    return a
                },
                fromJSON(e) {
                    let t = i();
                    return Array.isArray(e ? .signatures) && (t.signatures = e.signatures.map(e => (0, o.bytesFromBase64)(e))), t
                },
                toJSON(e) {
                    let t = {};
                    return e.signatures ? t.signatures = e.signatures.map(e => (0, o.base64FromBytes)(void 0 !== e ? e : new Uint8Array)) : t.signatures = [], t
                },
                fromPartial(e) {
                    let t = i();
                    return t.signatures = e.signatures ? .map(e => e) || [], t
                }
            }, t.CompactBitArray = {
                typeUrl: "/cosmos.crypto.multisig.v1beta1.CompactBitArray",
                encode: (e, t = n.BinaryWriter.create()) => (0 !== e.extraBitsStored && t.uint32(8).uint32(e.extraBitsStored), 0 !== e.elems.length && t.uint32(18).bytes(e.elems), t),
                decode(e, t) {
                    let r = e instanceof n.BinaryReader ? e : new n.BinaryReader(e),
                        o = void 0 === t ? r.len : r.pos + t,
                        i = a();
                    for (; r.pos < o;) {
                        let e = r.uint32();
                        switch (e >>> 3) {
                            case 1:
                                i.extraBitsStored = r.uint32();
                                break;
                            case 2:
                                i.elems = r.bytes();
                                break;
                            default:
                                r.skipType(7 & e)
                        }
                    }
                    return i
                },
                fromJSON(e) {
                    let t = a();
                    return (0, o.isSet)(e.extraBitsStored) && (t.extraBitsStored = Number(e.extraBitsStored)), (0, o.isSet)(e.elems) && (t.elems = (0, o.bytesFromBase64)(e.elems)), t
                },
                toJSON(e) {
                    let t = {};
                    return void 0 !== e.extraBitsStored && (t.extraBitsStored = Math.round(e.extraBitsStored)), void 0 !== e.elems && (t.elems = (0, o.base64FromBytes)(void 0 !== e.elems ? e.elems : new Uint8Array)), t
                },
                fromPartial(e) {
                    let t = a();
                    return t.extraBitsStored = e.extraBitsStored ? ? 0, t.elems = e.elems ? ? new Uint8Array, t
                }
            }
        },
        59052: function(e, t, r) {
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: !0
            }), t.PrivKey = t.PubKey = t.protobufPackage = void 0;
            let n = r(23795),
                o = r(96987);

            function i() {
                return {
                    key: new Uint8Array
                }
            }

            function a() {
                return {
                    key: new Uint8Array
                }
            }
            t.protobufPackage = "cosmos.crypto.secp256k1", t.PubKey = {
                typeUrl: "/cosmos.crypto.secp256k1.PubKey",
                encode: (e, t = n.BinaryWriter.create()) => (0 !== e.key.length && t.uint32(10).bytes(e.key), t),
                decode(e, t) {
                    let r = e instanceof n.BinaryReader ? e : new n.BinaryReader(e),
                        o = void 0 === t ? r.len : r.pos + t,
                        a = i();
                    for (; r.pos < o;) {
                        let e = r.uint32();
                        e >>> 3 == 1 ? a.key = r.bytes() : r.skipType(7 & e)
                    }
                    return a
                },
                fromJSON(e) {
                    let t = i();
                    return (0, o.isSet)(e.key) && (t.key = (0, o.bytesFromBase64)(e.key)), t
                },
                toJSON(e) {
                    let t = {};
                    return void 0 !== e.key && (t.key = (0, o.base64FromBytes)(void 0 !== e.key ? e.key : new Uint8Array)), t
                },
                fromPartial(e) {
                    let t = i();
                    return t.key = e.key ? ? new Uint8Array, t
                }
            }, t.PrivKey = {
                typeUrl: "/cosmos.crypto.secp256k1.PrivKey",
                encode: (e, t = n.BinaryWriter.create()) => (0 !== e.key.length && t.uint32(10).bytes(e.key), t),
                decode(e, t) {
                    let r = e instanceof n.BinaryReader ? e : new n.BinaryReader(e),
                        o = void 0 === t ? r.len : r.pos + t,
                        i = a();
                    for (; r.pos < o;) {
                        let e = r.uint32();
                        e >>> 3 == 1 ? i.key = r.bytes() : r.skipType(7 & e)
                    }
                    return i
                },
                fromJSON(e) {
                    let t = a();
                    return (0, o.isSet)(e.key) && (t.key = (0, o.bytesFromBase64)(e.key)), t
                },
                toJSON(e) {
                    let t = {};
                    return void 0 !== e.key && (t.key = (0, o.base64FromBytes)(void 0 !== e.key ? e.key : new Uint8Array)), t
                },
                fromPartial(e) {
                    let t = a();
                    return t.key = e.key ? ? new Uint8Array, t
                }
            }
        },
        76893: function(e, t, r) {
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: !0
            }), t.CommunityPoolSpendProposalWithDeposit = t.DelegationDelegatorReward = t.DelegatorStartingInfo = t.CommunityPoolSpendProposal = t.FeePool = t.ValidatorSlashEvents = t.ValidatorSlashEvent = t.ValidatorOutstandingRewards = t.ValidatorAccumulatedCommission = t.ValidatorCurrentRewards = t.ValidatorHistoricalRewards = t.Params = t.protobufPackage = void 0;
            let n = r(91408),
                o = r(23795),
                i = r(96987);

            function a() {
                return {
                    communityTax: "",
                    baseProposerReward: "",
                    bonusProposerReward: "",
                    withdrawAddrEnabled: !1
                }
            }

            function s() {
                return {
                    cumulativeRewardRatio: [],
                    referenceCount: 0
                }
            }

            function d() {
                return {
                    rewards: [],
                    period: BigInt(0)
                }
            }

            function c() {
                return {
                    commission: []
                }
            }

            function l() {
                return {
                    rewards: []
                }
            }

            function u() {
                return {
                    validatorPeriod: BigInt(0),
                    fraction: ""
                }
            }

            function p() {
                return {
                    validatorSlashEvents: []
                }
            }

            function m() {
                return {
                    communityPool: []
                }
            }

            function g() {
                return {
                    title: "",
                    description: "",
                    recipient: "",
                    amount: []
                }
            }

            function f() {
                return {
                    previousPeriod: BigInt(0),
                    stake: "",
                    height: BigInt(0)
                }
            }

            function y() {
                return {
                    validatorAddress: "",
                    reward: []
                }
            }

            function h() {
                return {
                    title: "",
                    description: "",
                    recipient: "",
                    amount: "",
                    deposit: ""
                }
            }
            t.protobufPackage = "cosmos.distribution.v1beta1", t.Params = {
                typeUrl: "/cosmos.distribution.v1beta1.Params",
                encode: (e, t = o.BinaryWriter.create()) => ("" !== e.communityTax && t.uint32(10).string(e.communityTax), "" !== e.baseProposerReward && t.uint32(18).string(e.baseProposerReward), "" !== e.bonusProposerReward && t.uint32(26).string(e.bonusProposerReward), !0 === e.withdrawAddrEnabled && t.uint32(32).bool(e.withdrawAddrEnabled), t),
                decode(e, t) {
                    let r = e instanceof o.BinaryReader ? e : new o.BinaryReader(e),
                        n = void 0 === t ? r.len : r.pos + t,
                        i = a();
                    for (; r.pos < n;) {
                        let e = r.uint32();
                        switch (e >>> 3) {
                            case 1:
                                i.communityTax = r.string();
                                break;
                            case 2:
                                i.baseProposerReward = r.string();
                                break;
                            case 3:
                                i.bonusProposerReward = r.string();
                                break;
                            case 4:
                                i.withdrawAddrEnabled = r.bool();
                                break;
                            default:
                                r.skipType(7 & e)
                        }
                    }
                    return i
                },
                fromJSON(e) {
                    let t = a();
                    return (0, i.isSet)(e.communityTax) && (t.communityTax = String(e.communityTax)), (0, i.isSet)(e.baseProposerReward) && (t.baseProposerReward = String(e.baseProposerReward)), (0, i.isSet)(e.bonusProposerReward) && (t.bonusProposerReward = String(e.bonusProposerReward)), (0, i.isSet)(e.withdrawAddrEnabled) && (t.withdrawAddrEnabled = !!e.withdrawAddrEnabled), t
                },
                toJSON(e) {
                    let t = {};
                    return void 0 !== e.communityTax && (t.communityTax = e.communityTax), void 0 !== e.baseProposerReward && (t.baseProposerReward = e.baseProposerReward), void 0 !== e.bonusProposerReward && (t.bonusProposerReward = e.bonusProposerReward), void 0 !== e.withdrawAddrEnabled && (t.withdrawAddrEnabled = e.withdrawAddrEnabled), t
                },
                fromPartial(e) {
                    let t = a();
                    return t.communityTax = e.communityTax ? ? "", t.baseProposerReward = e.baseProposerReward ? ? "", t.bonusProposerReward = e.bonusProposerReward ? ? "", t.withdrawAddrEnabled = e.withdrawAddrEnabled ? ? !1, t
                }
            }, t.ValidatorHistoricalRewards = {
                typeUrl: "/cosmos.distribution.v1beta1.ValidatorHistoricalRewards",
                encode(e, t = o.BinaryWriter.create()) {
                    for (let r of e.cumulativeRewardRatio) n.DecCoin.encode(r, t.uint32(10).fork()).ldelim();
                    return 0 !== e.referenceCount && t.uint32(16).uint32(e.referenceCount), t
                },
                decode(e, t) {
                    let r = e instanceof o.BinaryReader ? e : new o.BinaryReader(e),
                        i = void 0 === t ? r.len : r.pos + t,
                        a = s();
                    for (; r.pos < i;) {
                        let e = r.uint32();
                        switch (e >>> 3) {
                            case 1:
                                a.cumulativeRewardRatio.push(n.DecCoin.decode(r, r.uint32()));
                                break;
                            case 2:
                                a.referenceCount = r.uint32();
                                break;
                            default:
                                r.skipType(7 & e)
                        }
                    }
                    return a
                },
                fromJSON(e) {
                    let t = s();
                    return Array.isArray(e ? .cumulativeRewardRatio) && (t.cumulativeRewardRatio = e.cumulativeRewardRatio.map(e => n.DecCoin.fromJSON(e))), (0, i.isSet)(e.referenceCount) && (t.referenceCount = Number(e.referenceCount)), t
                },
                toJSON(e) {
                    let t = {};
                    return e.cumulativeRewardRatio ? t.cumulativeRewardRatio = e.cumulativeRewardRatio.map(e => e ? n.DecCoin.toJSON(e) : void 0) : t.cumulativeRewardRatio = [], void 0 !== e.referenceCount && (t.referenceCount = Math.round(e.referenceCount)), t
                },
                fromPartial(e) {
                    let t = s();
                    return t.cumulativeRewardRatio = e.cumulativeRewardRatio ? .map(e => n.DecCoin.fromPartial(e)) || [], t.referenceCount = e.referenceCount ? ? 0, t
                }
            }, t.ValidatorCurrentRewards = {
                typeUrl: "/cosmos.distribution.v1beta1.ValidatorCurrentRewards",
                encode(e, t = o.BinaryWriter.create()) {
                    for (let r of e.rewards) n.DecCoin.encode(r, t.uint32(10).fork()).ldelim();
                    return e.period !== BigInt(0) && t.uint32(16).uint64(e.period), t
                },
                decode(e, t) {
                    let r = e instanceof o.BinaryReader ? e : new o.BinaryReader(e),
                        i = void 0 === t ? r.len : r.pos + t,
                        a = d();
                    for (; r.pos < i;) {
                        let e = r.uint32();
                        switch (e >>> 3) {
                            case 1:
                                a.rewards.push(n.DecCoin.decode(r, r.uint32()));
                                break;
                            case 2:
                                a.period = r.uint64();
                                break;
                            default:
                                r.skipType(7 & e)
                        }
                    }
                    return a
                },
                fromJSON(e) {
                    let t = d();
                    return Array.isArray(e ? .rewards) && (t.rewards = e.rewards.map(e => n.DecCoin.fromJSON(e))), (0, i.isSet)(e.period) && (t.period = BigInt(e.period.toString())), t
                },
                toJSON(e) {
                    let t = {};
                    return e.rewards ? t.rewards = e.rewards.map(e => e ? n.DecCoin.toJSON(e) : void 0) : t.rewards = [], void 0 !== e.period && (t.period = (e.period || BigInt(0)).toString()), t
                },
                fromPartial(e) {
                    let t = d();
                    return t.rewards = e.rewards ? .map(e => n.DecCoin.fromPartial(e)) || [], void 0 !== e.period && null !== e.period && (t.period = BigInt(e.period.toString())), t
                }
            }, t.ValidatorAccumulatedCommission = {
                typeUrl: "/cosmos.distribution.v1beta1.ValidatorAccumulatedCommission",
                encode(e, t = o.BinaryWriter.create()) {
                    for (let r of e.commission) n.DecCoin.encode(r, t.uint32(10).fork()).ldelim();
                    return t
                },
                decode(e, t) {
                    let r = e instanceof o.BinaryReader ? e : new o.BinaryReader(e),
                        i = void 0 === t ? r.len : r.pos + t,
                        a = c();
                    for (; r.pos < i;) {
                        let e = r.uint32();
                        e >>> 3 == 1 ? a.commission.push(n.DecCoin.decode(r, r.uint32())) : r.skipType(7 & e)
                    }
                    return a
                },
                fromJSON(e) {
                    let t = c();
                    return Array.isArray(e ? .commission) && (t.commission = e.commission.map(e => n.DecCoin.fromJSON(e))), t
                },
                toJSON(e) {
                    let t = {};
                    return e.commission ? t.commission = e.commission.map(e => e ? n.DecCoin.toJSON(e) : void 0) : t.commission = [], t
                },
                fromPartial(e) {
                    let t = c();
                    return t.commission = e.commission ? .map(e => n.DecCoin.fromPartial(e)) || [], t
                }
            }, t.ValidatorOutstandingRewards = {
                typeUrl: "/cosmos.distribution.v1beta1.ValidatorOutstandingRewards",
                encode(e, t = o.BinaryWriter.create()) {
                    for (let r of e.rewards) n.DecCoin.encode(r, t.uint32(10).fork()).ldelim();
                    return t
                },
                decode(e, t) {
                    let r = e instanceof o.BinaryReader ? e : new o.BinaryReader(e),
                        i = void 0 === t ? r.len : r.pos + t,
                        a = l();
                    for (; r.pos < i;) {
                        let e = r.uint32();
                        e >>> 3 == 1 ? a.rewards.push(n.DecCoin.decode(r, r.uint32())) : r.skipType(7 & e)
                    }
                    return a
                },
                fromJSON(e) {
                    let t = l();
                    return Array.isArray(e ? .rewards) && (t.rewards = e.rewards.map(e => n.DecCoin.fromJSON(e))), t
                },
                toJSON(e) {
                    let t = {};
                    return e.rewards ? t.rewards = e.rewards.map(e => e ? n.DecCoin.toJSON(e) : void 0) : t.rewards = [], t
                },
                fromPartial(e) {
                    let t = l();
                    return t.rewards = e.rewards ? .map(e => n.DecCoin.fromPartial(e)) || [], t
                }
            }, t.ValidatorSlashEvent = {
                typeUrl: "/cosmos.distribution.v1beta1.ValidatorSlashEvent",
                encode: (e, t = o.BinaryWriter.create()) => (e.validatorPeriod !== BigInt(0) && t.uint32(8).uint64(e.validatorPeriod), "" !== e.fraction && t.uint32(18).string(e.fraction), t),
                decode(e, t) {
                    let r = e instanceof o.BinaryReader ? e : new o.BinaryReader(e),
                        n = void 0 === t ? r.len : r.pos + t,
                        i = u();
                    for (; r.pos < n;) {
                        let e = r.uint32();
                        switch (e >>> 3) {
                            case 1:
                                i.validatorPeriod = r.uint64();
                                break;
                            case 2:
                                i.fraction = r.string();
                                break;
                            default:
                                r.skipType(7 & e)
                        }
                    }
                    return i
                },
                fromJSON(e) {
                    let t = u();
                    return (0, i.isSet)(e.validatorPeriod) && (t.validatorPeriod = BigInt(e.validatorPeriod.toString())), (0, i.isSet)(e.fraction) && (t.fraction = String(e.fraction)), t
                },
                toJSON(e) {
                    let t = {};
                    return void 0 !== e.validatorPeriod && (t.validatorPeriod = (e.validatorPeriod || BigInt(0)).toString()), void 0 !== e.fraction && (t.fraction = e.fraction), t
                },
                fromPartial(e) {
                    let t = u();
                    return void 0 !== e.validatorPeriod && null !== e.validatorPeriod && (t.validatorPeriod = BigInt(e.validatorPeriod.toString())), t.fraction = e.fraction ? ? "", t
                }
            }, t.ValidatorSlashEvents = {
                typeUrl: "/cosmos.distribution.v1beta1.ValidatorSlashEvents",
                encode(e, r = o.BinaryWriter.create()) {
                    for (let n of e.validatorSlashEvents) t.ValidatorSlashEvent.encode(n, r.uint32(10).fork()).ldelim();
                    return r
                },
                decode(e, r) {
                    let n = e instanceof o.BinaryReader ? e : new o.BinaryReader(e),
                        i = void 0 === r ? n.len : n.pos + r,
                        a = p();
                    for (; n.pos < i;) {
                        let e = n.uint32();
                        e >>> 3 == 1 ? a.validatorSlashEvents.push(t.ValidatorSlashEvent.decode(n, n.uint32())) : n.skipType(7 & e)
                    }
                    return a
                },
                fromJSON(e) {
                    let r = p();
                    return Array.isArray(e ? .validatorSlashEvents) && (r.validatorSlashEvents = e.validatorSlashEvents.map(e => t.ValidatorSlashEvent.fromJSON(e))), r
                },
                toJSON(e) {
                    let r = {};
                    return e.validatorSlashEvents ? r.validatorSlashEvents = e.validatorSlashEvents.map(e => e ? t.ValidatorSlashEvent.toJSON(e) : void 0) : r.validatorSlashEvents = [], r
                },
                fromPartial(e) {
                    let r = p();
                    return r.validatorSlashEvents = e.validatorSlashEvents ? .map(e => t.ValidatorSlashEvent.fromPartial(e)) || [], r
                }
            }, t.FeePool = {
                typeUrl: "/cosmos.distribution.v1beta1.FeePool",
                encode(e, t = o.BinaryWriter.create()) {
                    for (let r of e.communityPool) n.DecCoin.encode(r, t.uint32(10).fork()).ldelim();
                    return t
                },
                decode(e, t) {
                    let r = e instanceof o.BinaryReader ? e : new o.BinaryReader(e),
                        i = void 0 === t ? r.len : r.pos + t,
                        a = m();
                    for (; r.pos < i;) {
                        let e = r.uint32();
                        e >>> 3 == 1 ? a.communityPool.push(n.DecCoin.decode(r, r.uint32())) : r.skipType(7 & e)
                    }
                    return a
                },
                fromJSON(e) {
                    let t = m();
                    return Array.isArray(e ? .communityPool) && (t.communityPool = e.communityPool.map(e => n.DecCoin.fromJSON(e))), t
                },
                toJSON(e) {
                    let t = {};
                    return e.communityPool ? t.communityPool = e.communityPool.map(e => e ? n.DecCoin.toJSON(e) : void 0) : t.communityPool = [], t
                },
                fromPartial(e) {
                    let t = m();
                    return t.communityPool = e.communityPool ? .map(e => n.DecCoin.fromPartial(e)) || [], t
                }
            }, t.CommunityPoolSpendProposal = {
                typeUrl: "/cosmos.distribution.v1beta1.CommunityPoolSpendProposal",
                encode(e, t = o.BinaryWriter.create()) {
                    for (let r of ("" !== e.title && t.uint32(10).string(e.title), "" !== e.description && t.uint32(18).string(e.description), "" !== e.recipient && t.uint32(26).string(e.recipient), e.amount)) n.Coin.encode(r, t.uint32(34).fork()).ldelim();
                    return t
                },
                decode(e, t) {
                    let r = e instanceof o.BinaryReader ? e : new o.BinaryReader(e),
                        i = void 0 === t ? r.len : r.pos + t,
                        a = g();
                    for (; r.pos < i;) {
                        let e = r.uint32();
                        switch (e >>> 3) {
                            case 1:
                                a.title = r.string();
                                break;
                            case 2:
                                a.description = r.string();
                                break;
                            case 3:
                                a.recipient = r.string();
                                break;
                            case 4:
                                a.amount.push(n.Coin.decode(r, r.uint32()));
                                break;
                            default:
                                r.skipType(7 & e)
                        }
                    }
                    return a
                },
                fromJSON(e) {
                    let t = g();
                    return (0, i.isSet)(e.title) && (t.title = String(e.title)), (0, i.isSet)(e.description) && (t.description = String(e.description)), (0, i.isSet)(e.recipient) && (t.recipient = String(e.recipient)), Array.isArray(e ? .amount) && (t.amount = e.amount.map(e => n.Coin.fromJSON(e))), t
                },
                toJSON(e) {
                    let t = {};
                    return void 0 !== e.title && (t.title = e.title), void 0 !== e.description && (t.description = e.description), void 0 !== e.recipient && (t.recipient = e.recipient), e.amount ? t.amount = e.amount.map(e => e ? n.Coin.toJSON(e) : void 0) : t.amount = [], t
                },
                fromPartial(e) {
                    let t = g();
                    return t.title = e.title ? ? "", t.description = e.description ? ? "", t.recipient = e.recipient ? ? "", t.amount = e.amount ? .map(e => n.Coin.fromPartial(e)) || [], t
                }
            }, t.DelegatorStartingInfo = {
                typeUrl: "/cosmos.distribution.v1beta1.DelegatorStartingInfo",
                encode: (e, t = o.BinaryWriter.create()) => (e.previousPeriod !== BigInt(0) && t.uint32(8).uint64(e.previousPeriod), "" !== e.stake && t.uint32(18).string(e.stake), e.height !== BigInt(0) && t.uint32(24).uint64(e.height), t),
                decode(e, t) {
                    let r = e instanceof o.BinaryReader ? e : new o.BinaryReader(e),
                        n = void 0 === t ? r.len : r.pos + t,
                        i = f();
                    for (; r.pos < n;) {
                        let e = r.uint32();
                        switch (e >>> 3) {
                            case 1:
                                i.previousPeriod = r.uint64();
                                break;
                            case 2:
                                i.stake = r.string();
                                break;
                            case 3:
                                i.height = r.uint64();
                                break;
                            default:
                                r.skipType(7 & e)
                        }
                    }
                    return i
                },
                fromJSON(e) {
                    let t = f();
                    return (0, i.isSet)(e.previousPeriod) && (t.previousPeriod = BigInt(e.previousPeriod.toString())), (0, i.isSet)(e.stake) && (t.stake = String(e.stake)), (0, i.isSet)(e.height) && (t.height = BigInt(e.height.toString())), t
                },
                toJSON(e) {
                    let t = {};
                    return void 0 !== e.previousPeriod && (t.previousPeriod = (e.previousPeriod || BigInt(0)).toString()), void 0 !== e.stake && (t.stake = e.stake), void 0 !== e.height && (t.height = (e.height || BigInt(0)).toString()), t
                },
                fromPartial(e) {
                    let t = f();
                    return void 0 !== e.previousPeriod && null !== e.previousPeriod && (t.previousPeriod = BigInt(e.previousPeriod.toString())), t.stake = e.stake ? ? "", void 0 !== e.height && null !== e.height && (t.height = BigInt(e.height.toString())), t
                }
            }, t.DelegationDelegatorReward = {
                typeUrl: "/cosmos.distribution.v1beta1.DelegationDelegatorReward",
                encode(e, t = o.BinaryWriter.create()) {
                    for (let r of ("" !== e.validatorAddress && t.uint32(10).string(e.validatorAddress), e.reward)) n.DecCoin.encode(r, t.uint32(18).fork()).ldelim();
                    return t
                },
                decode(e, t) {
                    let r = e instanceof o.BinaryReader ? e : new o.BinaryReader(e),
                        i = void 0 === t ? r.len : r.pos + t,
                        a = y();
                    for (; r.pos < i;) {
                        let e = r.uint32();
                        switch (e >>> 3) {
                            case 1:
                                a.validatorAddress = r.string();
                                break;
                            case 2:
                                a.reward.push(n.DecCoin.decode(r, r.uint32()));
                                break;
                            default:
                                r.skipType(7 & e)
                        }
                    }
                    return a
                },
                fromJSON(e) {
                    let t = y();
                    return (0, i.isSet)(e.validatorAddress) && (t.validatorAddress = String(e.validatorAddress)), Array.isArray(e ? .reward) && (t.reward = e.reward.map(e => n.DecCoin.fromJSON(e))), t
                },
                toJSON(e) {
                    let t = {};
                    return void 0 !== e.validatorAddress && (t.validatorAddress = e.validatorAddress), e.reward ? t.reward = e.reward.map(e => e ? n.DecCoin.toJSON(e) : void 0) : t.reward = [], t
                },
                fromPartial(e) {
                    let t = y();
                    return t.validatorAddress = e.validatorAddress ? ? "", t.reward = e.reward ? .map(e => n.DecCoin.fromPartial(e)) || [], t
                }
            }, t.CommunityPoolSpendProposalWithDeposit = {
                typeUrl: "/cosmos.distribution.v1beta1.CommunityPoolSpendProposalWithDeposit",
                encode: (e, t = o.BinaryWriter.create()) => ("" !== e.title && t.uint32(10).string(e.title), "" !== e.description && t.uint32(18).string(e.description), "" !== e.recipient && t.uint32(26).string(e.recipient), "" !== e.amount && t.uint32(34).string(e.amount), "" !== e.deposit && t.uint32(42).string(e.deposit), t),
                decode(e, t) {
                    let r = e instanceof o.BinaryReader ? e : new o.BinaryReader(e),
                        n = void 0 === t ? r.len : r.pos + t,
                        i = h();
                    for (; r.pos < n;) {
                        let e = r.uint32();
                        switch (e >>> 3) {
                            case 1:
                                i.title = r.string();
                                break;
                            case 2:
                                i.description = r.string();
                                break;
                            case 3:
                                i.recipient = r.string();
                                break;
                            case 4:
                                i.amount = r.string();
                                break;
                            case 5:
                                i.deposit = r.string();
                                break;
                            default:
                                r.skipType(7 & e)
                        }
                    }
                    return i
                },
                fromJSON(e) {
                    let t = h();
                    return (0, i.isSet)(e.title) && (t.title = String(e.title)), (0, i.isSet)(e.description) && (t.description = String(e.description)), (0, i.isSet)(e.recipient) && (t.recipient = String(e.recipient)), (0, i.isSet)(e.amount) && (t.amount = String(e.amount)), (0, i.isSet)(e.deposit) && (t.deposit = String(e.deposit)), t
                },
                toJSON(e) {
                    let t = {};
                    return void 0 !== e.title && (t.title = e.title), void 0 !== e.description && (t.description = e.description), void 0 !== e.recipient && (t.recipient = e.recipient), void 0 !== e.amount && (t.amount = e.amount), void 0 !== e.deposit && (t.deposit = e.deposit), t
                },
                fromPartial(e) {
                    let t = h();
                    return t.title = e.title ? ? "", t.description = e.description ? ? "", t.recipient = e.recipient ? ? "", t.amount = e.amount ? ? "", t.deposit = e.deposit ? ? "", t
                }
            }
        },
        13314: function(e, t, r) {
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: !0
            }), t.MsgClientImpl = t.MsgCommunityPoolSpendResponse = t.MsgCommunityPoolSpend = t.MsgUpdateParamsResponse = t.MsgUpdateParams = t.MsgFundCommunityPoolResponse = t.MsgFundCommunityPool = t.MsgWithdrawValidatorCommissionResponse = t.MsgWithdrawValidatorCommission = t.MsgWithdrawDelegatorRewardResponse = t.MsgWithdrawDelegatorReward = t.MsgSetWithdrawAddressResponse = t.MsgSetWithdrawAddress = t.protobufPackage = void 0;
            let n = r(91408),
                o = r(76893),
                i = r(23795),
                a = r(96987);

            function s() {
                return {
                    delegatorAddress: "",
                    withdrawAddress: ""
                }
            }

            function d() {
                return {
                    delegatorAddress: "",
                    validatorAddress: ""
                }
            }

            function c() {
                return {
                    amount: []
                }
            }

            function l() {
                return {
                    validatorAddress: ""
                }
            }

            function u() {
                return {
                    amount: []
                }
            }

            function p() {
                return {
                    amount: [],
                    depositor: ""
                }
            }

            function m() {
                return {
                    authority: "",
                    params: o.Params.fromPartial({})
                }
            }

            function g() {
                return {
                    authority: "",
                    recipient: "",
                    amount: []
                }
            }
            t.protobufPackage = "cosmos.distribution.v1beta1", t.MsgSetWithdrawAddress = {
                typeUrl: "/cosmos.distribution.v1beta1.MsgSetWithdrawAddress",
                encode: (e, t = i.BinaryWriter.create()) => ("" !== e.delegatorAddress && t.uint32(10).string(e.delegatorAddress), "" !== e.withdrawAddress && t.uint32(18).string(e.withdrawAddress), t),
                decode(e, t) {
                    let r = e instanceof i.BinaryReader ? e : new i.BinaryReader(e),
                        n = void 0 === t ? r.len : r.pos + t,
                        o = s();
                    for (; r.pos < n;) {
                        let e = r.uint32();
                        switch (e >>> 3) {
                            case 1:
                                o.delegatorAddress = r.string();
                                break;
                            case 2:
                                o.withdrawAddress = r.string();
                                break;
                            default:
                                r.skipType(7 & e)
                        }
                    }
                    return o
                },
                fromJSON(e) {
                    let t = s();
                    return (0, a.isSet)(e.delegatorAddress) && (t.delegatorAddress = String(e.delegatorAddress)), (0, a.isSet)(e.withdrawAddress) && (t.withdrawAddress = String(e.withdrawAddress)), t
                },
                toJSON(e) {
                    let t = {};
                    return void 0 !== e.delegatorAddress && (t.delegatorAddress = e.delegatorAddress), void 0 !== e.withdrawAddress && (t.withdrawAddress = e.withdrawAddress), t
                },
                fromPartial(e) {
                    let t = s();
                    return t.delegatorAddress = e.delegatorAddress ? ? "", t.withdrawAddress = e.withdrawAddress ? ? "", t
                }
            }, t.MsgSetWithdrawAddressResponse = {
                typeUrl: "/cosmos.distribution.v1beta1.MsgSetWithdrawAddressResponse",
                encode: (e, t = i.BinaryWriter.create()) => t,
                decode(e, t) {
                    let r = e instanceof i.BinaryReader ? e : new i.BinaryReader(e),
                        n = void 0 === t ? r.len : r.pos + t;
                    for (; r.pos < n;) {
                        let e = r.uint32();
                        r.skipType(7 & e)
                    }
                    return {}
                },
                fromJSON: e => ({}),
                toJSON: e => ({}),
                fromPartial: e => ({})
            }, t.MsgWithdrawDelegatorReward = {
                typeUrl: "/cosmos.distribution.v1beta1.MsgWithdrawDelegatorReward",
                encode: (e, t = i.BinaryWriter.create()) => ("" !== e.delegatorAddress && t.uint32(10).string(e.delegatorAddress), "" !== e.validatorAddress && t.uint32(18).string(e.validatorAddress), t),
                decode(e, t) {
                    let r = e instanceof i.BinaryReader ? e : new i.BinaryReader(e),
                        n = void 0 === t ? r.len : r.pos + t,
                        o = d();
                    for (; r.pos < n;) {
                        let e = r.uint32();
                        switch (e >>> 3) {
                            case 1:
                                o.delegatorAddress = r.string();
                                break;
                            case 2:
                                o.validatorAddress = r.string();
                                break;
                            default:
                                r.skipType(7 & e)
                        }
                    }
                    return o
                },
                fromJSON(e) {
                    let t = d();
                    return (0, a.isSet)(e.delegatorAddress) && (t.delegatorAddress = String(e.delegatorAddress)), (0, a.isSet)(e.validatorAddress) && (t.validatorAddress = String(e.validatorAddress)), t
                },
                toJSON(e) {
                    let t = {};
                    return void 0 !== e.delegatorAddress && (t.delegatorAddress = e.delegatorAddress), void 0 !== e.validatorAddress && (t.validatorAddress = e.validatorAddress), t
                },
                fromPartial(e) {
                    let t = d();
                    return t.delegatorAddress = e.delegatorAddress ? ? "", t.validatorAddress = e.validatorAddress ? ? "", t
                }
            }, t.MsgWithdrawDelegatorRewardResponse = {
                typeUrl: "/cosmos.distribution.v1beta1.MsgWithdrawDelegatorRewardResponse",
                encode(e, t = i.BinaryWriter.create()) {
                    for (let r of e.amount) n.Coin.encode(r, t.uint32(10).fork()).ldelim();
                    return t
                },
                decode(e, t) {
                    let r = e instanceof i.BinaryReader ? e : new i.BinaryReader(e),
                        o = void 0 === t ? r.len : r.pos + t,
                        a = c();
                    for (; r.pos < o;) {
                        let e = r.uint32();
                        e >>> 3 == 1 ? a.amount.push(n.Coin.decode(r, r.uint32())) : r.skipType(7 & e)
                    }
                    return a
                },
                fromJSON(e) {
                    let t = c();
                    return Array.isArray(e ? .amount) && (t.amount = e.amount.map(e => n.Coin.fromJSON(e))), t
                },
                toJSON(e) {
                    let t = {};
                    return e.amount ? t.amount = e.amount.map(e => e ? n.Coin.toJSON(e) : void 0) : t.amount = [], t
                },
                fromPartial(e) {
                    let t = c();
                    return t.amount = e.amount ? .map(e => n.Coin.fromPartial(e)) || [], t
                }
            }, t.MsgWithdrawValidatorCommission = {
                typeUrl: "/cosmos.distribution.v1beta1.MsgWithdrawValidatorCommission",
                encode: (e, t = i.BinaryWriter.create()) => ("" !== e.validatorAddress && t.uint32(10).string(e.validatorAddress), t),
                decode(e, t) {
                    let r = e instanceof i.BinaryReader ? e : new i.BinaryReader(e),
                        n = void 0 === t ? r.len : r.pos + t,
                        o = l();
                    for (; r.pos < n;) {
                        let e = r.uint32();
                        e >>> 3 == 1 ? o.validatorAddress = r.string() : r.skipType(7 & e)
                    }
                    return o
                },
                fromJSON(e) {
                    let t = l();
                    return (0, a.isSet)(e.validatorAddress) && (t.validatorAddress = String(e.validatorAddress)), t
                },
                toJSON(e) {
                    let t = {};
                    return void 0 !== e.validatorAddress && (t.validatorAddress = e.validatorAddress), t
                },
                fromPartial(e) {
                    let t = l();
                    return t.validatorAddress = e.validatorAddress ? ? "", t
                }
            }, t.MsgWithdrawValidatorCommissionResponse = {
                typeUrl: "/cosmos.distribution.v1beta1.MsgWithdrawValidatorCommissionResponse",
                encode(e, t = i.BinaryWriter.create()) {
                    for (let r of e.amount) n.Coin.encode(r, t.uint32(10).fork()).ldelim();
                    return t
                },
                decode(e, t) {
                    let r = e instanceof i.BinaryReader ? e : new i.BinaryReader(e),
                        o = void 0 === t ? r.len : r.pos + t,
                        a = u();
                    for (; r.pos < o;) {
                        let e = r.uint32();
                        e >>> 3 == 1 ? a.amount.push(n.Coin.decode(r, r.uint32())) : r.skipType(7 & e)
                    }
                    return a
                },
                fromJSON(e) {
                    let t = u();
                    return Array.isArray(e ? .amount) && (t.amount = e.amount.map(e => n.Coin.fromJSON(e))), t
                },
                toJSON(e) {
                    let t = {};
                    return e.amount ? t.amount = e.amount.map(e => e ? n.Coin.toJSON(e) : void 0) : t.amount = [], t
                },
                fromPartial(e) {
                    let t = u();
                    return t.amount = e.amount ? .map(e => n.Coin.fromPartial(e)) || [], t
                }
            }, t.MsgFundCommunityPool = {
                typeUrl: "/cosmos.distribution.v1beta1.MsgFundCommunityPool",
                encode(e, t = i.BinaryWriter.create()) {
                    for (let r of e.amount) n.Coin.encode(r, t.uint32(10).fork()).ldelim();
                    return "" !== e.depositor && t.uint32(18).string(e.depositor), t
                },
                decode(e, t) {
                    let r = e instanceof i.BinaryReader ? e : new i.BinaryReader(e),
                        o = void 0 === t ? r.len : r.pos + t,
                        a = p();
                    for (; r.pos < o;) {
                        let e = r.uint32();
                        switch (e >>> 3) {
                            case 1:
                                a.amount.push(n.Coin.decode(r, r.uint32()));
                                break;
                            case 2:
                                a.depositor = r.string();
                                break;
                            default:
                                r.skipType(7 & e)
                        }
                    }
                    return a
                },
                fromJSON(e) {
                    let t = p();
                    return Array.isArray(e ? .amount) && (t.amount = e.amount.map(e => n.Coin.fromJSON(e))), (0, a.isSet)(e.depositor) && (t.depositor = String(e.depositor)), t
                },
                toJSON(e) {
                    let t = {};
                    return e.amount ? t.amount = e.amount.map(e => e ? n.Coin.toJSON(e) : void 0) : t.amount = [], void 0 !== e.depositor && (t.depositor = e.depositor), t
                },
                fromPartial(e) {
                    let t = p();
                    return t.amount = e.amount ? .map(e => n.Coin.fromPartial(e)) || [], t.depositor = e.depositor ? ? "", t
                }
            }, t.MsgFundCommunityPoolResponse = {
                typeUrl: "/cosmos.distribution.v1beta1.MsgFundCommunityPoolResponse",
                encode: (e, t = i.BinaryWriter.create()) => t,
                decode(e, t) {
                    let r = e instanceof i.BinaryReader ? e : new i.BinaryReader(e),
                        n = void 0 === t ? r.len : r.pos + t;
                    for (; r.pos < n;) {
                        let e = r.uint32();
                        r.skipType(7 & e)
                    }
                    return {}
                },
                fromJSON: e => ({}),
                toJSON: e => ({}),
                fromPartial: e => ({})
            }, t.MsgUpdateParams = {
                typeUrl: "/cosmos.distribution.v1beta1.MsgUpdateParams",
                encode: (e, t = i.BinaryWriter.create()) => ("" !== e.authority && t.uint32(10).string(e.authority), void 0 !== e.params && o.Params.encode(e.params, t.uint32(18).fork()).ldelim(), t),
                decode(e, t) {
                    let r = e instanceof i.BinaryReader ? e : new i.BinaryReader(e),
                        n = void 0 === t ? r.len : r.pos + t,
                        a = m();
                    for (; r.pos < n;) {
                        let e = r.uint32();
                        switch (e >>> 3) {
                            case 1:
                                a.authority = r.string();
                                break;
                            case 2:
                                a.params = o.Params.decode(r, r.uint32());
                                break;
                            default:
                                r.skipType(7 & e)
                        }
                    }
                    return a
                },
                fromJSON(e) {
                    let t = m();
                    return (0, a.isSet)(e.authority) && (t.authority = String(e.authority)), (0, a.isSet)(e.params) && (t.params = o.Params.fromJSON(e.params)), t
                },
                toJSON(e) {
                    let t = {};
                    return void 0 !== e.authority && (t.authority = e.authority), void 0 !== e.params && (t.params = e.params ? o.Params.toJSON(e.params) : void 0), t
                },
                fromPartial(e) {
                    let t = m();
                    return t.authority = e.authority ? ? "", void 0 !== e.params && null !== e.params && (t.params = o.Params.fromPartial(e.params)), t
                }
            }, t.MsgUpdateParamsResponse = {
                typeUrl: "/cosmos.distribution.v1beta1.MsgUpdateParamsResponse",
                encode: (e, t = i.BinaryWriter.create()) => t,
                decode(e, t) {
                    let r = e instanceof i.BinaryReader ? e : new i.BinaryReader(e),
                        n = void 0 === t ? r.len : r.pos + t;
                    for (; r.pos < n;) {
                        let e = r.uint32();
                        r.skipType(7 & e)
                    }
                    return {}
                },
                fromJSON: e => ({}),
                toJSON: e => ({}),
                fromPartial: e => ({})
            }, t.MsgCommunityPoolSpend = {
                typeUrl: "/cosmos.distribution.v1beta1.MsgCommunityPoolSpend",
                encode(e, t = i.BinaryWriter.create()) {
                    for (let r of ("" !== e.authority && t.uint32(10).string(e.authority), "" !== e.recipient && t.uint32(18).string(e.recipient), e.amount)) n.Coin.encode(r, t.uint32(26).fork()).ldelim();
                    return t
                },
                decode(e, t) {
                    let r = e instanceof i.BinaryReader ? e : new i.BinaryReader(e),
                        o = void 0 === t ? r.len : r.pos + t,
                        a = g();
                    for (; r.pos < o;) {
                        let e = r.uint32();
                        switch (e >>> 3) {
                            case 1:
                                a.authority = r.string();
                                break;
                            case 2:
                                a.recipient = r.string();
                                break;
                            case 3:
                                a.amount.push(n.Coin.decode(r, r.uint32()));
                                break;
                            default:
                                r.skipType(7 & e)
                        }
                    }
                    return a
                },
                fromJSON(e) {
                    let t = g();
                    return (0, a.isSet)(e.authority) && (t.authority = String(e.authority)), (0, a.isSet)(e.recipient) && (t.recipient = String(e.recipient)), Array.isArray(e ? .amount) && (t.amount = e.amount.map(e => n.Coin.fromJSON(e))), t
                },
                toJSON(e) {
                    let t = {};
                    return void 0 !== e.authority && (t.authority = e.authority), void 0 !== e.recipient && (t.recipient = e.recipient), e.amount ? t.amount = e.amount.map(e => e ? n.Coin.toJSON(e) : void 0) : t.amount = [], t
                },
                fromPartial(e) {
                    let t = g();
                    return t.authority = e.authority ? ? "", t.recipient = e.recipient ? ? "", t.amount = e.amount ? .map(e => n.Coin.fromPartial(e)) || [], t
                }
            }, t.MsgCommunityPoolSpendResponse = {
                typeUrl: "/cosmos.distribution.v1beta1.MsgCommunityPoolSpendResponse",
                encode: (e, t = i.BinaryWriter.create()) => t,
                decode(e, t) {
                    let r = e instanceof i.BinaryReader ? e : new i.BinaryReader(e),
                        n = void 0 === t ? r.len : r.pos + t;
                    for (; r.pos < n;) {
                        let e = r.uint32();
                        r.skipType(7 & e)
                    }
                    return {}
                },
                fromJSON: e => ({}),
                toJSON: e => ({}),
                fromPartial: e => ({})
            };
            class f {
                constructor(e) {
                    this.rpc = e, this.SetWithdrawAddress = this.SetWithdrawAddress.bind(this), this.WithdrawDelegatorReward = this.WithdrawDelegatorReward.bind(this), this.WithdrawValidatorCommission = this.WithdrawValidatorCommission.bind(this), this.FundCommunityPool = this.FundCommunityPool.bind(this), this.UpdateParams = this.UpdateParams.bind(this), this.CommunityPoolSpend = this.CommunityPoolSpend.bind(this)
                }
                SetWithdrawAddress(e) {
                    let r = t.MsgSetWithdrawAddress.encode(e).finish();
                    return this.rpc.request("cosmos.distribution.v1beta1.Msg", "SetWithdrawAddress", r).then(e => t.MsgSetWithdrawAddressResponse.decode(new i.BinaryReader(e)))
                }
                WithdrawDelegatorReward(e) {
                    let r = t.MsgWithdrawDelegatorReward.encode(e).finish();
                    return this.rpc.request("cosmos.distribution.v1beta1.Msg", "WithdrawDelegatorReward", r).then(e => t.MsgWithdrawDelegatorRewardResponse.decode(new i.BinaryReader(e)))
                }
                WithdrawValidatorCommission(e) {
                    let r = t.MsgWithdrawValidatorCommission.encode(e).finish();
                    return this.rpc.request("cosmos.distribution.v1beta1.Msg", "WithdrawValidatorCommission", r).then(e => t.MsgWithdrawValidatorCommissionResponse.decode(new i.BinaryReader(e)))
                }
                FundCommunityPool(e) {
                    let r = t.MsgFundCommunityPool.encode(e).finish();
                    return this.rpc.request("cosmos.distribution.v1beta1.Msg", "FundCommunityPool", r).then(e => t.MsgFundCommunityPoolResponse.decode(new i.BinaryReader(e)))
                }
                UpdateParams(e) {
                    let r = t.MsgUpdateParams.encode(e).finish();
                    return this.rpc.request("cosmos.distribution.v1beta1.Msg", "UpdateParams", r).then(e => t.MsgUpdateParamsResponse.decode(new i.BinaryReader(e)))
                }
                CommunityPoolSpend(e) {
                    let r = t.MsgCommunityPoolSpend.encode(e).finish();
                    return this.rpc.request("cosmos.distribution.v1beta1.Msg", "CommunityPoolSpend", r).then(e => t.MsgCommunityPoolSpendResponse.decode(new i.BinaryReader(e)))
                }
            }
            t.MsgClientImpl = f
        },
        29632: function(e, t, r) {
            "use strict";
            var n, o, i, a;
            Object.defineProperty(t, "__esModule", {
                value: !0
            }), t.ValidatorUpdates = t.Pool = t.RedelegationResponse = t.RedelegationEntryResponse = t.DelegationResponse = t.Params = t.Redelegation = t.RedelegationEntry = t.UnbondingDelegationEntry = t.UnbondingDelegation = t.Delegation = t.DVVTriplets = t.DVVTriplet = t.DVPairs = t.DVPair = t.ValAddresses = t.Validator = t.Description = t.Commission = t.CommissionRates = t.HistoricalInfo = t.infractionToJSON = t.infractionFromJSON = t.Infraction = t.bondStatusToJSON = t.bondStatusFromJSON = t.BondStatus = t.protobufPackage = void 0;
            let s = r(55081),
                d = r(42676),
                c = r(40747),
                l = r(14933),
                u = r(91408),
                p = r(88854),
                m = r(23795),
                g = r(96987);

            function f(e) {
                switch (e) {
                    case 0:
                    case "BOND_STATUS_UNSPECIFIED":
                        return n.BOND_STATUS_UNSPECIFIED;
                    case 1:
                    case "BOND_STATUS_UNBONDED":
                        return n.BOND_STATUS_UNBONDED;
                    case 2:
                    case "BOND_STATUS_UNBONDING":
                        return n.BOND_STATUS_UNBONDING;
                    case 3:
                    case "BOND_STATUS_BONDED":
                        return n.BOND_STATUS_BONDED;
                    default:
                        return n.UNRECOGNIZED
                }
            }

            function y(e) {
                switch (e) {
                    case n.BOND_STATUS_UNSPECIFIED:
                        return "BOND_STATUS_UNSPECIFIED";
                    case n.BOND_STATUS_UNBONDED:
                        return "BOND_STATUS_UNBONDED";
                    case n.BOND_STATUS_UNBONDING:
                        return "BOND_STATUS_UNBONDING";
                    case n.BOND_STATUS_BONDED:
                        return "BOND_STATUS_BONDED";
                    case n.UNRECOGNIZED:
                    default:
                        return "UNRECOGNIZED"
                }
            }

            function h() {
                return {
                    header: s.Header.fromPartial({}),
                    valset: []
                }
            }

            function v() {
                return {
                    rate: "",
                    maxRate: "",
                    maxChangeRate: ""
                }
            }

            function b() {
                return {
                    commissionRates: t.CommissionRates.fromPartial({}),
                    updateTime: d.Timestamp.fromPartial({})
                }
            }

            function S() {
                return {
                    moniker: "",
                    identity: "",
                    website: "",
                    securityContact: "",
                    details: ""
                }
            }

            function k() {
                return {
                    operatorAddress: "",
                    consensusPubkey: void 0,
                    jailed: !1,
                    status: 0,
                    tokens: "",
                    delegatorShares: "",
                    description: t.Description.fromPartial({}),
                    unbondingHeight: BigInt(0),
                    unbondingTime: d.Timestamp.fromPartial({}),
                    commission: t.Commission.fromPartial({}),
                    minSelfDelegation: "",
                    unbondingOnHoldRefCount: BigInt(0),
                    unbondingIds: []
                }
            }

            function P() {
                return {
                    addresses: []
                }
            }

            function _() {
                return {
                    delegatorAddress: "",
                    validatorAddress: ""
                }
            }

            function B() {
                return {
                    pairs: []
                }
            }

            function O() {
                return {
                    delegatorAddress: "",
                    validatorSrcAddress: "",
                    validatorDstAddress: ""
                }
            }

            function R() {
                return {
                    triplets: []
                }
            }

            function A() {
                return {
                    delegatorAddress: "",
                    validatorAddress: "",
                    shares: ""
                }
            }

            function I() {
                return {
                    delegatorAddress: "",
                    validatorAddress: "",
                    entries: []
                }
            }

            function w() {
                return {
                    creationHeight: BigInt(0),
                    completionTime: d.Timestamp.fromPartial({}),
                    initialBalance: "",
                    balance: "",
                    unbondingId: BigInt(0),
                    unbondingOnHoldRefCount: BigInt(0)
                }
            }

            function T() {
                return {
                    creationHeight: BigInt(0),
                    completionTime: d.Timestamp.fromPartial({}),
                    initialBalance: "",
                    sharesDst: "",
                    unbondingId: BigInt(0),
                    unbondingOnHoldRefCount: BigInt(0)
                }
            }

            function N() {
                return {
                    delegatorAddress: "",
                    validatorSrcAddress: "",
                    validatorDstAddress: "",
                    entries: []
                }
            }

            function C() {
                return {
                    unbondingTime: l.Duration.fromPartial({}),
                    maxValidators: 0,
                    maxEntries: 0,
                    historicalEntries: 0,
                    bondDenom: "",
                    minCommissionRate: ""
                }
            }

            function E() {
                return {
                    delegation: t.Delegation.fromPartial({}),
                    balance: u.Coin.fromPartial({})
                }
            }

            function x() {
                return {
                    redelegationEntry: t.RedelegationEntry.fromPartial({}),
                    balance: ""
                }
            }

            function U() {
                return {
                    redelegation: t.Redelegation.fromPartial({}),
                    entries: []
                }
            }

            function D() {
                return {
                    notBondedTokens: "",
                    bondedTokens: ""
                }
            }

            function M() {
                return {
                    updates: []
                }
            }
            t.protobufPackage = "cosmos.staking.v1beta1", (i = n || (t.BondStatus = n = {}))[i.BOND_STATUS_UNSPECIFIED = 0] = "BOND_STATUS_UNSPECIFIED", i[i.BOND_STATUS_UNBONDED = 1] = "BOND_STATUS_UNBONDED", i[i.BOND_STATUS_UNBONDING = 2] = "BOND_STATUS_UNBONDING", i[i.BOND_STATUS_BONDED = 3] = "BOND_STATUS_BONDED", i[i.UNRECOGNIZED = -1] = "UNRECOGNIZED", t.bondStatusFromJSON = f, t.bondStatusToJSON = y, (a = o || (t.Infraction = o = {}))[a.INFRACTION_UNSPECIFIED = 0] = "INFRACTION_UNSPECIFIED", a[a.INFRACTION_DOUBLE_SIGN = 1] = "INFRACTION_DOUBLE_SIGN", a[a.INFRACTION_DOWNTIME = 2] = "INFRACTION_DOWNTIME", a[a.UNRECOGNIZED = -1] = "UNRECOGNIZED", t.infractionFromJSON = function(e) {
                switch (e) {
                    case 0:
                    case "INFRACTION_UNSPECIFIED":
                        return o.INFRACTION_UNSPECIFIED;
                    case 1:
                    case "INFRACTION_DOUBLE_SIGN":
                        return o.INFRACTION_DOUBLE_SIGN;
                    case 2:
                    case "INFRACTION_DOWNTIME":
                        return o.INFRACTION_DOWNTIME;
                    default:
                        return o.UNRECOGNIZED
                }
            }, t.infractionToJSON = function(e) {
                switch (e) {
                    case o.INFRACTION_UNSPECIFIED:
                        return "INFRACTION_UNSPECIFIED";
                    case o.INFRACTION_DOUBLE_SIGN:
                        return "INFRACTION_DOUBLE_SIGN";
                    case o.INFRACTION_DOWNTIME:
                        return "INFRACTION_DOWNTIME";
                    case o.UNRECOGNIZED:
                    default:
                        return "UNRECOGNIZED"
                }
            }, t.HistoricalInfo = {
                typeUrl: "/cosmos.staking.v1beta1.HistoricalInfo",
                encode(e, r = m.BinaryWriter.create()) {
                    for (let n of (void 0 !== e.header && s.Header.encode(e.header, r.uint32(10).fork()).ldelim(), e.valset)) t.Validator.encode(n, r.uint32(18).fork()).ldelim();
                    return r
                },
                decode(e, r) {
                    let n = e instanceof m.BinaryReader ? e : new m.BinaryReader(e),
                        o = void 0 === r ? n.len : n.pos + r,
                        i = h();
                    for (; n.pos < o;) {
                        let e = n.uint32();
                        switch (e >>> 3) {
                            case 1:
                                i.header = s.Header.decode(n, n.uint32());
                                break;
                            case 2:
                                i.valset.push(t.Validator.decode(n, n.uint32()));
                                break;
                            default:
                                n.skipType(7 & e)
                        }
                    }
                    return i
                },
                fromJSON(e) {
                    let r = h();
                    return (0, g.isSet)(e.header) && (r.header = s.Header.fromJSON(e.header)), Array.isArray(e ? .valset) && (r.valset = e.valset.map(e => t.Validator.fromJSON(e))), r
                },
                toJSON(e) {
                    let r = {};
                    return void 0 !== e.header && (r.header = e.header ? s.Header.toJSON(e.header) : void 0), e.valset ? r.valset = e.valset.map(e => e ? t.Validator.toJSON(e) : void 0) : r.valset = [], r
                },
                fromPartial(e) {
                    let r = h();
                    return void 0 !== e.header && null !== e.header && (r.header = s.Header.fromPartial(e.header)), r.valset = e.valset ? .map(e => t.Validator.fromPartial(e)) || [], r
                }
            }, t.CommissionRates = {
                typeUrl: "/cosmos.staking.v1beta1.CommissionRates",
                encode: (e, t = m.BinaryWriter.create()) => ("" !== e.rate && t.uint32(10).string(e.rate), "" !== e.maxRate && t.uint32(18).string(e.maxRate), "" !== e.maxChangeRate && t.uint32(26).string(e.maxChangeRate), t),
                decode(e, t) {
                    let r = e instanceof m.BinaryReader ? e : new m.BinaryReader(e),
                        n = void 0 === t ? r.len : r.pos + t,
                        o = v();
                    for (; r.pos < n;) {
                        let e = r.uint32();
                        switch (e >>> 3) {
                            case 1:
                                o.rate = r.string();
                                break;
                            case 2:
                                o.maxRate = r.string();
                                break;
                            case 3:
                                o.maxChangeRate = r.string();
                                break;
                            default:
                                r.skipType(7 & e)
                        }
                    }
                    return o
                },
                fromJSON(e) {
                    let t = v();
                    return (0, g.isSet)(e.rate) && (t.rate = String(e.rate)), (0, g.isSet)(e.maxRate) && (t.maxRate = String(e.maxRate)), (0, g.isSet)(e.maxChangeRate) && (t.maxChangeRate = String(e.maxChangeRate)), t
                },
                toJSON(e) {
                    let t = {};
                    return void 0 !== e.rate && (t.rate = e.rate), void 0 !== e.maxRate && (t.maxRate = e.maxRate), void 0 !== e.maxChangeRate && (t.maxChangeRate = e.maxChangeRate), t
                },
                fromPartial(e) {
                    let t = v();
                    return t.rate = e.rate ? ? "", t.maxRate = e.maxRate ? ? "", t.maxChangeRate = e.maxChangeRate ? ? "", t
                }
            }, t.Commission = {
                typeUrl: "/cosmos.staking.v1beta1.Commission",
                encode: (e, r = m.BinaryWriter.create()) => (void 0 !== e.commissionRates && t.CommissionRates.encode(e.commissionRates, r.uint32(10).fork()).ldelim(), void 0 !== e.updateTime && d.Timestamp.encode(e.updateTime, r.uint32(18).fork()).ldelim(), r),
                decode(e, r) {
                    let n = e instanceof m.BinaryReader ? e : new m.BinaryReader(e),
                        o = void 0 === r ? n.len : n.pos + r,
                        i = b();
                    for (; n.pos < o;) {
                        let e = n.uint32();
                        switch (e >>> 3) {
                            case 1:
                                i.commissionRates = t.CommissionRates.decode(n, n.uint32());
                                break;
                            case 2:
                                i.updateTime = d.Timestamp.decode(n, n.uint32());
                                break;
                            default:
                                n.skipType(7 & e)
                        }
                    }
                    return i
                },
                fromJSON(e) {
                    let r = b();
                    return (0, g.isSet)(e.commissionRates) && (r.commissionRates = t.CommissionRates.fromJSON(e.commissionRates)), (0, g.isSet)(e.updateTime) && (r.updateTime = (0, g.fromJsonTimestamp)(e.updateTime)), r
                },
                toJSON(e) {
                    let r = {};
                    return void 0 !== e.commissionRates && (r.commissionRates = e.commissionRates ? t.CommissionRates.toJSON(e.commissionRates) : void 0), void 0 !== e.updateTime && (r.updateTime = (0, g.fromTimestamp)(e.updateTime).toISOString()), r
                },
                fromPartial(e) {
                    let r = b();
                    return void 0 !== e.commissionRates && null !== e.commissionRates && (r.commissionRates = t.CommissionRates.fromPartial(e.commissionRates)), void 0 !== e.updateTime && null !== e.updateTime && (r.updateTime = d.Timestamp.fromPartial(e.updateTime)), r
                }
            }, t.Description = {
                typeUrl: "/cosmos.staking.v1beta1.Description",
                encode: (e, t = m.BinaryWriter.create()) => ("" !== e.moniker && t.uint32(10).string(e.moniker), "" !== e.identity && t.uint32(18).string(e.identity), "" !== e.website && t.uint32(26).string(e.website), "" !== e.securityContact && t.uint32(34).string(e.securityContact), "" !== e.details && t.uint32(42).string(e.details), t),
                decode(e, t) {
                    let r = e instanceof m.BinaryReader ? e : new m.BinaryReader(e),
                        n = void 0 === t ? r.len : r.pos + t,
                        o = S();
                    for (; r.pos < n;) {
                        let e = r.uint32();
                        switch (e >>> 3) {
                            case 1:
                                o.moniker = r.string();
                                break;
                            case 2:
                                o.identity = r.string();
                                break;
                            case 3:
                                o.website = r.string();
                                break;
                            case 4:
                                o.securityContact = r.string();
                                break;
                            case 5:
                                o.details = r.string();
                                break;
                            default:
                                r.skipType(7 & e)
                        }
                    }
                    return o
                },
                fromJSON(e) {
                    let t = S();
                    return (0, g.isSet)(e.moniker) && (t.moniker = String(e.moniker)), (0, g.isSet)(e.identity) && (t.identity = String(e.identity)), (0, g.isSet)(e.website) && (t.website = String(e.website)), (0, g.isSet)(e.securityContact) && (t.securityContact = String(e.securityContact)), (0, g.isSet)(e.details) && (t.details = String(e.details)), t
                },
                toJSON(e) {
                    let t = {};
                    return void 0 !== e.moniker && (t.moniker = e.moniker), void 0 !== e.identity && (t.identity = e.identity), void 0 !== e.website && (t.website = e.website), void 0 !== e.securityContact && (t.securityContact = e.securityContact), void 0 !== e.details && (t.details = e.details), t
                },
                fromPartial(e) {
                    let t = S();
                    return t.moniker = e.moniker ? ? "", t.identity = e.identity ? ? "", t.website = e.website ? ? "", t.securityContact = e.securityContact ? ? "", t.details = e.details ? ? "", t
                }
            }, t.Validator = {
                typeUrl: "/cosmos.staking.v1beta1.Validator",
                encode(e, r = m.BinaryWriter.create()) {
                    for (let n of ("" !== e.operatorAddress && r.uint32(10).string(e.operatorAddress), void 0 !== e.consensusPubkey && c.Any.encode(e.consensusPubkey, r.uint32(18).fork()).ldelim(), !0 === e.jailed && r.uint32(24).bool(e.jailed), 0 !== e.status && r.uint32(32).int32(e.status), "" !== e.tokens && r.uint32(42).string(e.tokens), "" !== e.delegatorShares && r.uint32(50).string(e.delegatorShares), void 0 !== e.description && t.Description.encode(e.description, r.uint32(58).fork()).ldelim(), e.unbondingHeight !== BigInt(0) && r.uint32(64).int64(e.unbondingHeight), void 0 !== e.unbondingTime && d.Timestamp.encode(e.unbondingTime, r.uint32(74).fork()).ldelim(), void 0 !== e.commission && t.Commission.encode(e.commission, r.uint32(82).fork()).ldelim(), "" !== e.minSelfDelegation && r.uint32(90).string(e.minSelfDelegation), e.unbondingOnHoldRefCount !== BigInt(0) && r.uint32(96).int64(e.unbondingOnHoldRefCount), r.uint32(106).fork(), e.unbondingIds)) r.uint64(n);
                    return r.ldelim(), r
                },
                decode(e, r) {
                    let n = e instanceof m.BinaryReader ? e : new m.BinaryReader(e),
                        o = void 0 === r ? n.len : n.pos + r,
                        i = k();
                    for (; n.pos < o;) {
                        let e = n.uint32();
                        switch (e >>> 3) {
                            case 1:
                                i.operatorAddress = n.string();
                                break;
                            case 2:
                                i.consensusPubkey = c.Any.decode(n, n.uint32());
                                break;
                            case 3:
                                i.jailed = n.bool();
                                break;
                            case 4:
                                i.status = n.int32();
                                break;
                            case 5:
                                i.tokens = n.string();
                                break;
                            case 6:
                                i.delegatorShares = n.string();
                                break;
                            case 7:
                                i.description = t.Description.decode(n, n.uint32());
                                break;
                            case 8:
                                i.unbondingHeight = n.int64();
                                break;
                            case 9:
                                i.unbondingTime = d.Timestamp.decode(n, n.uint32());
                                break;
                            case 10:
                                i.commission = t.Commission.decode(n, n.uint32());
                                break;
                            case 11:
                                i.minSelfDelegation = n.string();
                                break;
                            case 12:
                                i.unbondingOnHoldRefCount = n.int64();
                                break;
                            case 13:
                                if ((7 & e) == 2) {
                                    let e = n.uint32() + n.pos;
                                    for (; n.pos < e;) i.unbondingIds.push(n.uint64())
                                } else i.unbondingIds.push(n.uint64());
                                break;
                            default:
                                n.skipType(7 & e)
                        }
                    }
                    return i
                },
                fromJSON(e) {
                    let r = k();
                    return (0, g.isSet)(e.operatorAddress) && (r.operatorAddress = String(e.operatorAddress)), (0, g.isSet)(e.consensusPubkey) && (r.consensusPubkey = c.Any.fromJSON(e.consensusPubkey)), (0, g.isSet)(e.jailed) && (r.jailed = !!e.jailed), (0, g.isSet)(e.status) && (r.status = f(e.status)), (0, g.isSet)(e.tokens) && (r.tokens = String(e.tokens)), (0, g.isSet)(e.delegatorShares) && (r.delegatorShares = String(e.delegatorShares)), (0, g.isSet)(e.description) && (r.description = t.Description.fromJSON(e.description)), (0, g.isSet)(e.unbondingHeight) && (r.unbondingHeight = BigInt(e.unbondingHeight.toString())), (0, g.isSet)(e.unbondingTime) && (r.unbondingTime = (0, g.fromJsonTimestamp)(e.unbondingTime)), (0, g.isSet)(e.commission) && (r.commission = t.Commission.fromJSON(e.commission)), (0, g.isSet)(e.minSelfDelegation) && (r.minSelfDelegation = String(e.minSelfDelegation)), (0, g.isSet)(e.unbondingOnHoldRefCount) && (r.unbondingOnHoldRefCount = BigInt(e.unbondingOnHoldRefCount.toString())), Array.isArray(e ? .unbondingIds) && (r.unbondingIds = e.unbondingIds.map(e => BigInt(e.toString()))), r
                },
                toJSON(e) {
                    let r = {};
                    return void 0 !== e.operatorAddress && (r.operatorAddress = e.operatorAddress), void 0 !== e.consensusPubkey && (r.consensusPubkey = e.consensusPubkey ? c.Any.toJSON(e.consensusPubkey) : void 0), void 0 !== e.jailed && (r.jailed = e.jailed), void 0 !== e.status && (r.status = y(e.status)), void 0 !== e.tokens && (r.tokens = e.tokens), void 0 !== e.delegatorShares && (r.delegatorShares = e.delegatorShares), void 0 !== e.description && (r.description = e.description ? t.Description.toJSON(e.description) : void 0), void 0 !== e.unbondingHeight && (r.unbondingHeight = (e.unbondingHeight || BigInt(0)).toString()), void 0 !== e.unbondingTime && (r.unbondingTime = (0, g.fromTimestamp)(e.unbondingTime).toISOString()), void 0 !== e.commission && (r.commission = e.commission ? t.Commission.toJSON(e.commission) : void 0), void 0 !== e.minSelfDelegation && (r.minSelfDelegation = e.minSelfDelegation), void 0 !== e.unbondingOnHoldRefCount && (r.unbondingOnHoldRefCount = (e.unbondingOnHoldRefCount || BigInt(0)).toString()), e.unbondingIds ? r.unbondingIds = e.unbondingIds.map(e => (e || BigInt(0)).toString()) : r.unbondingIds = [], r
                },
                fromPartial(e) {
                    let r = k();
                    return r.operatorAddress = e.operatorAddress ? ? "", void 0 !== e.consensusPubkey && null !== e.consensusPubkey && (r.consensusPubkey = c.Any.fromPartial(e.consensusPubkey)), r.jailed = e.jailed ? ? !1, r.status = e.status ? ? 0, r.tokens = e.tokens ? ? "", r.delegatorShares = e.delegatorShares ? ? "", void 0 !== e.description && null !== e.description && (r.description = t.Description.fromPartial(e.description)), void 0 !== e.unbondingHeight && null !== e.unbondingHeight && (r.unbondingHeight = BigInt(e.unbondingHeight.toString())), void 0 !== e.unbondingTime && null !== e.unbondingTime && (r.unbondingTime = d.Timestamp.fromPartial(e.unbondingTime)), void 0 !== e.commission && null !== e.commission && (r.commission = t.Commission.fromPartial(e.commission)), r.minSelfDelegation = e.minSelfDelegation ? ? "", void 0 !== e.unbondingOnHoldRefCount && null !== e.unbondingOnHoldRefCount && (r.unbondingOnHoldRefCount = BigInt(e.unbondingOnHoldRefCount.toString())), r.unbondingIds = e.unbondingIds ? .map(e => BigInt(e.toString())) || [], r
                }
            }, t.ValAddresses = {
                typeUrl: "/cosmos.staking.v1beta1.ValAddresses",
                encode(e, t = m.BinaryWriter.create()) {
                    for (let r of e.addresses) t.uint32(10).string(r);
                    return t
                },
                decode(e, t) {
                    let r = e instanceof m.BinaryReader ? e : new m.BinaryReader(e),
                        n = void 0 === t ? r.len : r.pos + t,
                        o = P();
                    for (; r.pos < n;) {
                        let e = r.uint32();
                        e >>> 3 == 1 ? o.addresses.push(r.string()) : r.skipType(7 & e)
                    }
                    return o
                },
                fromJSON(e) {
                    let t = P();
                    return Array.isArray(e ? .addresses) && (t.addresses = e.addresses.map(e => String(e))), t
                },
                toJSON(e) {
                    let t = {};
                    return e.addresses ? t.addresses = e.addresses.map(e => e) : t.addresses = [], t
                },
                fromPartial(e) {
                    let t = P();
                    return t.addresses = e.addresses ? .map(e => e) || [], t
                }
            }, t.DVPair = {
                typeUrl: "/cosmos.staking.v1beta1.DVPair",
                encode: (e, t = m.BinaryWriter.create()) => ("" !== e.delegatorAddress && t.uint32(10).string(e.delegatorAddress), "" !== e.validatorAddress && t.uint32(18).string(e.validatorAddress), t),
                decode(e, t) {
                    let r = e instanceof m.BinaryReader ? e : new m.BinaryReader(e),
                        n = void 0 === t ? r.len : r.pos + t,
                        o = _();
                    for (; r.pos < n;) {
                        let e = r.uint32();
                        switch (e >>> 3) {
                            case 1:
                                o.delegatorAddress = r.string();
                                break;
                            case 2:
                                o.validatorAddress = r.string();
                                break;
                            default:
                                r.skipType(7 & e)
                        }
                    }
                    return o
                },
                fromJSON(e) {
                    let t = _();
                    return (0, g.isSet)(e.delegatorAddress) && (t.delegatorAddress = String(e.delegatorAddress)), (0, g.isSet)(e.validatorAddress) && (t.validatorAddress = String(e.validatorAddress)), t
                },
                toJSON(e) {
                    let t = {};
                    return void 0 !== e.delegatorAddress && (t.delegatorAddress = e.delegatorAddress), void 0 !== e.validatorAddress && (t.validatorAddress = e.validatorAddress), t
                },
                fromPartial(e) {
                    let t = _();
                    return t.delegatorAddress = e.delegatorAddress ? ? "", t.validatorAddress = e.validatorAddress ? ? "", t
                }
            }, t.DVPairs = {
                typeUrl: "/cosmos.staking.v1beta1.DVPairs",
                encode(e, r = m.BinaryWriter.create()) {
                    for (let n of e.pairs) t.DVPair.encode(n, r.uint32(10).fork()).ldelim();
                    return r
                },
                decode(e, r) {
                    let n = e instanceof m.BinaryReader ? e : new m.BinaryReader(e),
                        o = void 0 === r ? n.len : n.pos + r,
                        i = B();
                    for (; n.pos < o;) {
                        let e = n.uint32();
                        e >>> 3 == 1 ? i.pairs.push(t.DVPair.decode(n, n.uint32())) : n.skipType(7 & e)
                    }
                    return i
                },
                fromJSON(e) {
                    let r = B();
                    return Array.isArray(e ? .pairs) && (r.pairs = e.pairs.map(e => t.DVPair.fromJSON(e))), r
                },
                toJSON(e) {
                    let r = {};
                    return e.pairs ? r.pairs = e.pairs.map(e => e ? t.DVPair.toJSON(e) : void 0) : r.pairs = [], r
                },
                fromPartial(e) {
                    let r = B();
                    return r.pairs = e.pairs ? .map(e => t.DVPair.fromPartial(e)) || [], r
                }
            }, t.DVVTriplet = {
                typeUrl: "/cosmos.staking.v1beta1.DVVTriplet",
                encode: (e, t = m.BinaryWriter.create()) => ("" !== e.delegatorAddress && t.uint32(10).string(e.delegatorAddress), "" !== e.validatorSrcAddress && t.uint32(18).string(e.validatorSrcAddress), "" !== e.validatorDstAddress && t.uint32(26).string(e.validatorDstAddress), t),
                decode(e, t) {
                    let r = e instanceof m.BinaryReader ? e : new m.BinaryReader(e),
                        n = void 0 === t ? r.len : r.pos + t,
                        o = O();
                    for (; r.pos < n;) {
                        let e = r.uint32();
                        switch (e >>> 3) {
                            case 1:
                                o.delegatorAddress = r.string();
                                break;
                            case 2:
                                o.validatorSrcAddress = r.string();
                                break;
                            case 3:
                                o.validatorDstAddress = r.string();
                                break;
                            default:
                                r.skipType(7 & e)
                        }
                    }
                    return o
                },
                fromJSON(e) {
                    let t = O();
                    return (0, g.isSet)(e.delegatorAddress) && (t.delegatorAddress = String(e.delegatorAddress)), (0, g.isSet)(e.validatorSrcAddress) && (t.validatorSrcAddress = String(e.validatorSrcAddress)), (0, g.isSet)(e.validatorDstAddress) && (t.validatorDstAddress = String(e.validatorDstAddress)), t
                },
                toJSON(e) {
                    let t = {};
                    return void 0 !== e.delegatorAddress && (t.delegatorAddress = e.delegatorAddress), void 0 !== e.validatorSrcAddress && (t.validatorSrcAddress = e.validatorSrcAddress), void 0 !== e.validatorDstAddress && (t.validatorDstAddress = e.validatorDstAddress), t
                },
                fromPartial(e) {
                    let t = O();
                    return t.delegatorAddress = e.delegatorAddress ? ? "", t.validatorSrcAddress = e.validatorSrcAddress ? ? "", t.validatorDstAddress = e.validatorDstAddress ? ? "", t
                }
            }, t.DVVTriplets = {
                typeUrl: "/cosmos.staking.v1beta1.DVVTriplets",
                encode(e, r = m.BinaryWriter.create()) {
                    for (let n of e.triplets) t.DVVTriplet.encode(n, r.uint32(10).fork()).ldelim();
                    return r
                },
                decode(e, r) {
                    let n = e instanceof m.BinaryReader ? e : new m.BinaryReader(e),
                        o = void 0 === r ? n.len : n.pos + r,
                        i = R();
                    for (; n.pos < o;) {
                        let e = n.uint32();
                        e >>> 3 == 1 ? i.triplets.push(t.DVVTriplet.decode(n, n.uint32())) : n.skipType(7 & e)
                    }
                    return i
                },
                fromJSON(e) {
                    let r = R();
                    return Array.isArray(e ? .triplets) && (r.triplets = e.triplets.map(e => t.DVVTriplet.fromJSON(e))), r
                },
                toJSON(e) {
                    let r = {};
                    return e.triplets ? r.triplets = e.triplets.map(e => e ? t.DVVTriplet.toJSON(e) : void 0) : r.triplets = [], r
                },
                fromPartial(e) {
                    let r = R();
                    return r.triplets = e.triplets ? .map(e => t.DVVTriplet.fromPartial(e)) || [], r
                }
            }, t.Delegation = {
                typeUrl: "/cosmos.staking.v1beta1.Delegation",
                encode: (e, t = m.BinaryWriter.create()) => ("" !== e.delegatorAddress && t.uint32(10).string(e.delegatorAddress), "" !== e.validatorAddress && t.uint32(18).string(e.validatorAddress), "" !== e.shares && t.uint32(26).string(e.shares), t),
                decode(e, t) {
                    let r = e instanceof m.BinaryReader ? e : new m.BinaryReader(e),
                        n = void 0 === t ? r.len : r.pos + t,
                        o = A();
                    for (; r.pos < n;) {
                        let e = r.uint32();
                        switch (e >>> 3) {
                            case 1:
                                o.delegatorAddress = r.string();
                                break;
                            case 2:
                                o.validatorAddress = r.string();
                                break;
                            case 3:
                                o.shares = r.string();
                                break;
                            default:
                                r.skipType(7 & e)
                        }
                    }
                    return o
                },
                fromJSON(e) {
                    let t = A();
                    return (0, g.isSet)(e.delegatorAddress) && (t.delegatorAddress = String(e.delegatorAddress)), (0, g.isSet)(e.validatorAddress) && (t.validatorAddress = String(e.validatorAddress)), (0, g.isSet)(e.shares) && (t.shares = String(e.shares)), t
                },
                toJSON(e) {
                    let t = {};
                    return void 0 !== e.delegatorAddress && (t.delegatorAddress = e.delegatorAddress), void 0 !== e.validatorAddress && (t.validatorAddress = e.validatorAddress), void 0 !== e.shares && (t.shares = e.shares), t
                },
                fromPartial(e) {
                    let t = A();
                    return t.delegatorAddress = e.delegatorAddress ? ? "", t.validatorAddress = e.validatorAddress ? ? "", t.shares = e.shares ? ? "", t
                }
            }, t.UnbondingDelegation = {
                typeUrl: "/cosmos.staking.v1beta1.UnbondingDelegation",
                encode(e, r = m.BinaryWriter.create()) {
                    for (let n of ("" !== e.delegatorAddress && r.uint32(10).string(e.delegatorAddress), "" !== e.validatorAddress && r.uint32(18).string(e.validatorAddress), e.entries)) t.UnbondingDelegationEntry.encode(n, r.uint32(26).fork()).ldelim();
                    return r
                },
                decode(e, r) {
                    let n = e instanceof m.BinaryReader ? e : new m.BinaryReader(e),
                        o = void 0 === r ? n.len : n.pos + r,
                        i = I();
                    for (; n.pos < o;) {
                        let e = n.uint32();
                        switch (e >>> 3) {
                            case 1:
                                i.delegatorAddress = n.string();
                                break;
                            case 2:
                                i.validatorAddress = n.string();
                                break;
                            case 3:
                                i.entries.push(t.UnbondingDelegationEntry.decode(n, n.uint32()));
                                break;
                            default:
                                n.skipType(7 & e)
                        }
                    }
                    return i
                },
                fromJSON(e) {
                    let r = I();
                    return (0, g.isSet)(e.delegatorAddress) && (r.delegatorAddress = String(e.delegatorAddress)), (0, g.isSet)(e.validatorAddress) && (r.validatorAddress = String(e.validatorAddress)), Array.isArray(e ? .entries) && (r.entries = e.entries.map(e => t.UnbondingDelegationEntry.fromJSON(e))), r
                },
                toJSON(e) {
                    let r = {};
                    return void 0 !== e.delegatorAddress && (r.delegatorAddress = e.delegatorAddress), void 0 !== e.validatorAddress && (r.validatorAddress = e.validatorAddress), e.entries ? r.entries = e.entries.map(e => e ? t.UnbondingDelegationEntry.toJSON(e) : void 0) : r.entries = [], r
                },
                fromPartial(e) {
                    let r = I();
                    return r.delegatorAddress = e.delegatorAddress ? ? "", r.validatorAddress = e.validatorAddress ? ? "", r.entries = e.entries ? .map(e => t.UnbondingDelegationEntry.fromPartial(e)) || [], r
                }
            }, t.UnbondingDelegationEntry = {
                typeUrl: "/cosmos.staking.v1beta1.UnbondingDelegationEntry",
                encode: (e, t = m.BinaryWriter.create()) => (e.creationHeight !== BigInt(0) && t.uint32(8).int64(e.creationHeight), void 0 !== e.completionTime && d.Timestamp.encode(e.completionTime, t.uint32(18).fork()).ldelim(), "" !== e.initialBalance && t.uint32(26).string(e.initialBalance), "" !== e.balance && t.uint32(34).string(e.balance), e.unbondingId !== BigInt(0) && t.uint32(40).uint64(e.unbondingId), e.unbondingOnHoldRefCount !== BigInt(0) && t.uint32(48).int64(e.unbondingOnHoldRefCount), t),
                decode(e, t) {
                    let r = e instanceof m.BinaryReader ? e : new m.BinaryReader(e),
                        n = void 0 === t ? r.len : r.pos + t,
                        o = w();
                    for (; r.pos < n;) {
                        let e = r.uint32();
                        switch (e >>> 3) {
                            case 1:
                                o.creationHeight = r.int64();
                                break;
                            case 2:
                                o.completionTime = d.Timestamp.decode(r, r.uint32());
                                break;
                            case 3:
                                o.initialBalance = r.string();
                                break;
                            case 4:
                                o.balance = r.string();
                                break;
                            case 5:
                                o.unbondingId = r.uint64();
                                break;
                            case 6:
                                o.unbondingOnHoldRefCount = r.int64();
                                break;
                            default:
                                r.skipType(7 & e)
                        }
                    }
                    return o
                },
                fromJSON(e) {
                    let t = w();
                    return (0, g.isSet)(e.creationHeight) && (t.creationHeight = BigInt(e.creationHeight.toString())), (0, g.isSet)(e.completionTime) && (t.completionTime = (0, g.fromJsonTimestamp)(e.completionTime)), (0, g.isSet)(e.initialBalance) && (t.initialBalance = String(e.initialBalance)), (0, g.isSet)(e.balance) && (t.balance = String(e.balance)), (0, g.isSet)(e.unbondingId) && (t.unbondingId = BigInt(e.unbondingId.toString())), (0, g.isSet)(e.unbondingOnHoldRefCount) && (t.unbondingOnHoldRefCount = BigInt(e.unbondingOnHoldRefCount.toString())), t
                },
                toJSON(e) {
                    let t = {};
                    return void 0 !== e.creationHeight && (t.creationHeight = (e.creationHeight || BigInt(0)).toString()), void 0 !== e.completionTime && (t.completionTime = (0, g.fromTimestamp)(e.completionTime).toISOString()), void 0 !== e.initialBalance && (t.initialBalance = e.initialBalance), void 0 !== e.balance && (t.balance = e.balance), void 0 !== e.unbondingId && (t.unbondingId = (e.unbondingId || BigInt(0)).toString()), void 0 !== e.unbondingOnHoldRefCount && (t.unbondingOnHoldRefCount = (e.unbondingOnHoldRefCount || BigInt(0)).toString()), t
                },
                fromPartial(e) {
                    let t = w();
                    return void 0 !== e.creationHeight && null !== e.creationHeight && (t.creationHeight = BigInt(e.creationHeight.toString())), void 0 !== e.completionTime && null !== e.completionTime && (t.completionTime = d.Timestamp.fromPartial(e.completionTime)), t.initialBalance = e.initialBalance ? ? "", t.balance = e.balance ? ? "", void 0 !== e.unbondingId && null !== e.unbondingId && (t.unbondingId = BigInt(e.unbondingId.toString())), void 0 !== e.unbondingOnHoldRefCount && null !== e.unbondingOnHoldRefCount && (t.unbondingOnHoldRefCount = BigInt(e.unbondingOnHoldRefCount.toString())), t
                }
            }, t.RedelegationEntry = {
                typeUrl: "/cosmos.staking.v1beta1.RedelegationEntry",
                encode: (e, t = m.BinaryWriter.create()) => (e.creationHeight !== BigInt(0) && t.uint32(8).int64(e.creationHeight), void 0 !== e.completionTime && d.Timestamp.encode(e.completionTime, t.uint32(18).fork()).ldelim(), "" !== e.initialBalance && t.uint32(26).string(e.initialBalance), "" !== e.sharesDst && t.uint32(34).string(e.sharesDst), e.unbondingId !== BigInt(0) && t.uint32(40).uint64(e.unbondingId), e.unbondingOnHoldRefCount !== BigInt(0) && t.uint32(48).int64(e.unbondingOnHoldRefCount), t),
                decode(e, t) {
                    let r = e instanceof m.BinaryReader ? e : new m.BinaryReader(e),
                        n = void 0 === t ? r.len : r.pos + t,
                        o = T();
                    for (; r.pos < n;) {
                        let e = r.uint32();
                        switch (e >>> 3) {
                            case 1:
                                o.creationHeight = r.int64();
                                break;
                            case 2:
                                o.completionTime = d.Timestamp.decode(r, r.uint32());
                                break;
                            case 3:
                                o.initialBalance = r.string();
                                break;
                            case 4:
                                o.sharesDst = r.string();
                                break;
                            case 5:
                                o.unbondingId = r.uint64();
                                break;
                            case 6:
                                o.unbondingOnHoldRefCount = r.int64();
                                break;
                            default:
                                r.skipType(7 & e)
                        }
                    }
                    return o
                },
                fromJSON(e) {
                    let t = T();
                    return (0, g.isSet)(e.creationHeight) && (t.creationHeight = BigInt(e.creationHeight.toString())), (0, g.isSet)(e.completionTime) && (t.completionTime = (0, g.fromJsonTimestamp)(e.completionTime)), (0, g.isSet)(e.initialBalance) && (t.initialBalance = String(e.initialBalance)), (0, g.isSet)(e.sharesDst) && (t.sharesDst = String(e.sharesDst)), (0, g.isSet)(e.unbondingId) && (t.unbondingId = BigInt(e.unbondingId.toString())), (0, g.isSet)(e.unbondingOnHoldRefCount) && (t.unbondingOnHoldRefCount = BigInt(e.unbondingOnHoldRefCount.toString())), t
                },
                toJSON(e) {
                    let t = {};
                    return void 0 !== e.creationHeight && (t.creationHeight = (e.creationHeight || BigInt(0)).toString()), void 0 !== e.completionTime && (t.completionTime = (0, g.fromTimestamp)(e.completionTime).toISOString()), void 0 !== e.initialBalance && (t.initialBalance = e.initialBalance), void 0 !== e.sharesDst && (t.sharesDst = e.sharesDst), void 0 !== e.unbondingId && (t.unbondingId = (e.unbondingId || BigInt(0)).toString()), void 0 !== e.unbondingOnHoldRefCount && (t.unbondingOnHoldRefCount = (e.unbondingOnHoldRefCount || BigInt(0)).toString()), t
                },
                fromPartial(e) {
                    let t = T();
                    return void 0 !== e.creationHeight && null !== e.creationHeight && (t.creationHeight = BigInt(e.creationHeight.toString())), void 0 !== e.completionTime && null !== e.completionTime && (t.completionTime = d.Timestamp.fromPartial(e.completionTime)), t.initialBalance = e.initialBalance ? ? "", t.sharesDst = e.sharesDst ? ? "", void 0 !== e.unbondingId && null !== e.unbondingId && (t.unbondingId = BigInt(e.unbondingId.toString())), void 0 !== e.unbondingOnHoldRefCount && null !== e.unbondingOnHoldRefCount && (t.unbondingOnHoldRefCount = BigInt(e.unbondingOnHoldRefCount.toString())), t
                }
            }, t.Redelegation = {
                typeUrl: "/cosmos.staking.v1beta1.Redelegation",
                encode(e, r = m.BinaryWriter.create()) {
                    for (let n of ("" !== e.delegatorAddress && r.uint32(10).string(e.delegatorAddress), "" !== e.validatorSrcAddress && r.uint32(18).string(e.validatorSrcAddress), "" !== e.validatorDstAddress && r.uint32(26).string(e.validatorDstAddress), e.entries)) t.RedelegationEntry.encode(n, r.uint32(34).fork()).ldelim();
                    return r
                },
                decode(e, r) {
                    let n = e instanceof m.BinaryReader ? e : new m.BinaryReader(e),
                        o = void 0 === r ? n.len : n.pos + r,
                        i = N();
                    for (; n.pos < o;) {
                        let e = n.uint32();
                        switch (e >>> 3) {
                            case 1:
                                i.delegatorAddress = n.string();
                                break;
                            case 2:
                                i.validatorSrcAddress = n.string();
                                break;
                            case 3:
                                i.validatorDstAddress = n.string();
                                break;
                            case 4:
                                i.entries.push(t.RedelegationEntry.decode(n, n.uint32()));
                                break;
                            default:
                                n.skipType(7 & e)
                        }
                    }
                    return i
                },
                fromJSON(e) {
                    let r = N();
                    return (0, g.isSet)(e.delegatorAddress) && (r.delegatorAddress = String(e.delegatorAddress)), (0, g.isSet)(e.validatorSrcAddress) && (r.validatorSrcAddress = String(e.validatorSrcAddress)), (0, g.isSet)(e.validatorDstAddress) && (r.validatorDstAddress = String(e.validatorDstAddress)), Array.isArray(e ? .entries) && (r.entries = e.entries.map(e => t.RedelegationEntry.fromJSON(e))), r
                },
                toJSON(e) {
                    let r = {};
                    return void 0 !== e.delegatorAddress && (r.delegatorAddress = e.delegatorAddress), void 0 !== e.validatorSrcAddress && (r.validatorSrcAddress = e.validatorSrcAddress), void 0 !== e.validatorDstAddress && (r.validatorDstAddress = e.validatorDstAddress), e.entries ? r.entries = e.entries.map(e => e ? t.RedelegationEntry.toJSON(e) : void 0) : r.entries = [], r
                },
                fromPartial(e) {
                    let r = N();
                    return r.delegatorAddress = e.delegatorAddress ? ? "", r.validatorSrcAddress = e.validatorSrcAddress ? ? "", r.validatorDstAddress = e.validatorDstAddress ? ? "", r.entries = e.entries ? .map(e => t.RedelegationEntry.fromPartial(e)) || [], r
                }
            }, t.Params = {
                typeUrl: "/cosmos.staking.v1beta1.Params",
                encode: (e, t = m.BinaryWriter.create()) => (void 0 !== e.unbondingTime && l.Duration.encode(e.unbondingTime, t.uint32(10).fork()).ldelim(), 0 !== e.maxValidators && t.uint32(16).uint32(e.maxValidators), 0 !== e.maxEntries && t.uint32(24).uint32(e.maxEntries), 0 !== e.historicalEntries && t.uint32(32).uint32(e.historicalEntries), "" !== e.bondDenom && t.uint32(42).string(e.bondDenom), "" !== e.minCommissionRate && t.uint32(50).string(e.minCommissionRate), t),
                decode(e, t) {
                    let r = e instanceof m.BinaryReader ? e : new m.BinaryReader(e),
                        n = void 0 === t ? r.len : r.pos + t,
                        o = C();
                    for (; r.pos < n;) {
                        let e = r.uint32();
                        switch (e >>> 3) {
                            case 1:
                                o.unbondingTime = l.Duration.decode(r, r.uint32());
                                break;
                            case 2:
                                o.maxValidators = r.uint32();
                                break;
                            case 3:
                                o.maxEntries = r.uint32();
                                break;
                            case 4:
                                o.historicalEntries = r.uint32();
                                break;
                            case 5:
                                o.bondDenom = r.string();
                                break;
                            case 6:
                                o.minCommissionRate = r.string();
                                break;
                            default:
                                r.skipType(7 & e)
                        }
                    }
                    return o
                },
                fromJSON(e) {
                    let t = C();
                    return (0, g.isSet)(e.unbondingTime) && (t.unbondingTime = l.Duration.fromJSON(e.unbondingTime)), (0, g.isSet)(e.maxValidators) && (t.maxValidators = Number(e.maxValidators)), (0, g.isSet)(e.maxEntries) && (t.maxEntries = Number(e.maxEntries)), (0, g.isSet)(e.historicalEntries) && (t.historicalEntries = Number(e.historicalEntries)), (0, g.isSet)(e.bondDenom) && (t.bondDenom = String(e.bondDenom)), (0, g.isSet)(e.minCommissionRate) && (t.minCommissionRate = String(e.minCommissionRate)), t
                },
                toJSON(e) {
                    let t = {};
                    return void 0 !== e.unbondingTime && (t.unbondingTime = e.unbondingTime ? l.Duration.toJSON(e.unbondingTime) : void 0), void 0 !== e.maxValidators && (t.maxValidators = Math.round(e.maxValidators)), void 0 !== e.maxEntries && (t.maxEntries = Math.round(e.maxEntries)), void 0 !== e.historicalEntries && (t.historicalEntries = Math.round(e.historicalEntries)), void 0 !== e.bondDenom && (t.bondDenom = e.bondDenom), void 0 !== e.minCommissionRate && (t.minCommissionRate = e.minCommissionRate), t
                },
                fromPartial(e) {
                    let t = C();
                    return void 0 !== e.unbondingTime && null !== e.unbondingTime && (t.unbondingTime = l.Duration.fromPartial(e.unbondingTime)), t.maxValidators = e.maxValidators ? ? 0, t.maxEntries = e.maxEntries ? ? 0, t.historicalEntries = e.historicalEntries ? ? 0, t.bondDenom = e.bondDenom ? ? "", t.minCommissionRate = e.minCommissionRate ? ? "", t
                }
            }, t.DelegationResponse = {
                typeUrl: "/cosmos.staking.v1beta1.DelegationResponse",
                encode: (e, r = m.BinaryWriter.create()) => (void 0 !== e.delegation && t.Delegation.encode(e.delegation, r.uint32(10).fork()).ldelim(), void 0 !== e.balance && u.Coin.encode(e.balance, r.uint32(18).fork()).ldelim(), r),
                decode(e, r) {
                    let n = e instanceof m.BinaryReader ? e : new m.BinaryReader(e),
                        o = void 0 === r ? n.len : n.pos + r,
                        i = E();
                    for (; n.pos < o;) {
                        let e = n.uint32();
                        switch (e >>> 3) {
                            case 1:
                                i.delegation = t.Delegation.decode(n, n.uint32());
                                break;
                            case 2:
                                i.balance = u.Coin.decode(n, n.uint32());
                                break;
                            default:
                                n.skipType(7 & e)
                        }
                    }
                    return i
                },
                fromJSON(e) {
                    let r = E();
                    return (0, g.isSet)(e.delegation) && (r.delegation = t.Delegation.fromJSON(e.delegation)), (0, g.isSet)(e.balance) && (r.balance = u.Coin.fromJSON(e.balance)), r
                },
                toJSON(e) {
                    let r = {};
                    return void 0 !== e.delegation && (r.delegation = e.delegation ? t.Delegation.toJSON(e.delegation) : void 0), void 0 !== e.balance && (r.balance = e.balance ? u.Coin.toJSON(e.balance) : void 0), r
                },
                fromPartial(e) {
                    let r = E();
                    return void 0 !== e.delegation && null !== e.delegation && (r.delegation = t.Delegation.fromPartial(e.delegation)), void 0 !== e.balance && null !== e.balance && (r.balance = u.Coin.fromPartial(e.balance)), r
                }
            }, t.RedelegationEntryResponse = {
                typeUrl: "/cosmos.staking.v1beta1.RedelegationEntryResponse",
                encode: (e, r = m.BinaryWriter.create()) => (void 0 !== e.redelegationEntry && t.RedelegationEntry.encode(e.redelegationEntry, r.uint32(10).fork()).ldelim(), "" !== e.balance && r.uint32(34).string(e.balance), r),
                decode(e, r) {
                    let n = e instanceof m.BinaryReader ? e : new m.BinaryReader(e),
                        o = void 0 === r ? n.len : n.pos + r,
                        i = x();
                    for (; n.pos < o;) {
                        let e = n.uint32();
                        switch (e >>> 3) {
                            case 1:
                                i.redelegationEntry = t.RedelegationEntry.decode(n, n.uint32());
                                break;
                            case 4:
                                i.balance = n.string();
                                break;
                            default:
                                n.skipType(7 & e)
                        }
                    }
                    return i
                },
                fromJSON(e) {
                    let r = x();
                    return (0, g.isSet)(e.redelegationEntry) && (r.redelegationEntry = t.RedelegationEntry.fromJSON(e.redelegationEntry)), (0, g.isSet)(e.balance) && (r.balance = String(e.balance)), r
                },
                toJSON(e) {
                    let r = {};
                    return void 0 !== e.redelegationEntry && (r.redelegationEntry = e.redelegationEntry ? t.RedelegationEntry.toJSON(e.redelegationEntry) : void 0), void 0 !== e.balance && (r.balance = e.balance), r
                },
                fromPartial(e) {
                    let r = x();
                    return void 0 !== e.redelegationEntry && null !== e.redelegationEntry && (r.redelegationEntry = t.RedelegationEntry.fromPartial(e.redelegationEntry)), r.balance = e.balance ? ? "", r
                }
            }, t.RedelegationResponse = {
                typeUrl: "/cosmos.staking.v1beta1.RedelegationResponse",
                encode(e, r = m.BinaryWriter.create()) {
                    for (let n of (void 0 !== e.redelegation && t.Redelegation.encode(e.redelegation, r.uint32(10).fork()).ldelim(), e.entries)) t.RedelegationEntryResponse.encode(n, r.uint32(18).fork()).ldelim();
                    return r
                },
                decode(e, r) {
                    let n = e instanceof m.BinaryReader ? e : new m.BinaryReader(e),
                        o = void 0 === r ? n.len : n.pos + r,
                        i = U();
                    for (; n.pos < o;) {
                        let e = n.uint32();
                        switch (e >>> 3) {
                            case 1:
                                i.redelegation = t.Redelegation.decode(n, n.uint32());
                                break;
                            case 2:
                                i.entries.push(t.RedelegationEntryResponse.decode(n, n.uint32()));
                                break;
                            default:
                                n.skipType(7 & e)
                        }
                    }
                    return i
                },
                fromJSON(e) {
                    let r = U();
                    return (0, g.isSet)(e.redelegation) && (r.redelegation = t.Redelegation.fromJSON(e.redelegation)), Array.isArray(e ? .entries) && (r.entries = e.entries.map(e => t.RedelegationEntryResponse.fromJSON(e))), r
                },
                toJSON(e) {
                    let r = {};
                    return void 0 !== e.redelegation && (r.redelegation = e.redelegation ? t.Redelegation.toJSON(e.redelegation) : void 0), e.entries ? r.entries = e.entries.map(e => e ? t.RedelegationEntryResponse.toJSON(e) : void 0) : r.entries = [], r
                },
                fromPartial(e) {
                    let r = U();
                    return void 0 !== e.redelegation && null !== e.redelegation && (r.redelegation = t.Redelegation.fromPartial(e.redelegation)), r.entries = e.entries ? .map(e => t.RedelegationEntryResponse.fromPartial(e)) || [], r
                }
            }, t.Pool = {
                typeUrl: "/cosmos.staking.v1beta1.Pool",
                encode: (e, t = m.BinaryWriter.create()) => ("" !== e.notBondedTokens && t.uint32(10).string(e.notBondedTokens), "" !== e.bondedTokens && t.uint32(18).string(e.bondedTokens), t),
                decode(e, t) {
                    let r = e instanceof m.BinaryReader ? e : new m.BinaryReader(e),
                        n = void 0 === t ? r.len : r.pos + t,
                        o = D();
                    for (; r.pos < n;) {
                        let e = r.uint32();
                        switch (e >>> 3) {
                            case 1:
                                o.notBondedTokens = r.string();
                                break;
                            case 2:
                                o.bondedTokens = r.string();
                                break;
                            default:
                                r.skipType(7 & e)
                        }
                    }
                    return o
                },
                fromJSON(e) {
                    let t = D();
                    return (0, g.isSet)(e.notBondedTokens) && (t.notBondedTokens = String(e.notBondedTokens)), (0, g.isSet)(e.bondedTokens) && (t.bondedTokens = String(e.bondedTokens)), t
                },
                toJSON(e) {
                    let t = {};
                    return void 0 !== e.notBondedTokens && (t.notBondedTokens = e.notBondedTokens), void 0 !== e.bondedTokens && (t.bondedTokens = e.bondedTokens), t
                },
                fromPartial(e) {
                    let t = D();
                    return t.notBondedTokens = e.notBondedTokens ? ? "", t.bondedTokens = e.bondedTokens ? ? "", t
                }
            }, t.ValidatorUpdates = {
                typeUrl: "/cosmos.staking.v1beta1.ValidatorUpdates",
                encode(e, t = m.BinaryWriter.create()) {
                    for (let r of e.updates) p.ValidatorUpdate.encode(r, t.uint32(10).fork()).ldelim();
                    return t
                },
                decode(e, t) {
                    let r = e instanceof m.BinaryReader ? e : new m.BinaryReader(e),
                        n = void 0 === t ? r.len : r.pos + t,
                        o = M();
                    for (; r.pos < n;) {
                        let e = r.uint32();
                        e >>> 3 == 1 ? o.updates.push(p.ValidatorUpdate.decode(r, r.uint32())) : r.skipType(7 & e)
                    }
                    return o
                },
                fromJSON(e) {
                    let t = M();
                    return Array.isArray(e ? .updates) && (t.updates = e.updates.map(e => p.ValidatorUpdate.fromJSON(e))), t
                },
                toJSON(e) {
                    let t = {};
                    return e.updates ? t.updates = e.updates.map(e => e ? p.ValidatorUpdate.toJSON(e) : void 0) : t.updates = [], t
                },
                fromPartial(e) {
                    let t = M();
                    return t.updates = e.updates ? .map(e => p.ValidatorUpdate.fromPartial(e)) || [], t
                }
            }
        },
        31528: function(e, t, r) {
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: !0
            }), t.MsgClientImpl = t.MsgUpdateParamsResponse = t.MsgUpdateParams = t.MsgCancelUnbondingDelegationResponse = t.MsgCancelUnbondingDelegation = t.MsgUndelegateResponse = t.MsgUndelegate = t.MsgBeginRedelegateResponse = t.MsgBeginRedelegate = t.MsgDelegateResponse = t.MsgDelegate = t.MsgEditValidatorResponse = t.MsgEditValidator = t.MsgCreateValidatorResponse = t.MsgCreateValidator = t.protobufPackage = void 0;
            let n = r(29632),
                o = r(40747),
                i = r(91408),
                a = r(42676),
                s = r(23795),
                d = r(96987);

            function c() {
                return {
                    description: n.Description.fromPartial({}),
                    commission: n.CommissionRates.fromPartial({}),
                    minSelfDelegation: "",
                    delegatorAddress: "",
                    validatorAddress: "",
                    pubkey: void 0,
                    value: i.Coin.fromPartial({})
                }
            }

            function l() {
                return {
                    description: n.Description.fromPartial({}),
                    validatorAddress: "",
                    commissionRate: "",
                    minSelfDelegation: ""
                }
            }

            function u() {
                return {
                    delegatorAddress: "",
                    validatorAddress: "",
                    amount: i.Coin.fromPartial({})
                }
            }

            function p() {
                return {
                    delegatorAddress: "",
                    validatorSrcAddress: "",
                    validatorDstAddress: "",
                    amount: i.Coin.fromPartial({})
                }
            }

            function m() {
                return {
                    completionTime: a.Timestamp.fromPartial({})
                }
            }

            function g() {
                return {
                    delegatorAddress: "",
                    validatorAddress: "",
                    amount: i.Coin.fromPartial({})
                }
            }

            function f() {
                return {
                    completionTime: a.Timestamp.fromPartial({})
                }
            }

            function y() {
                return {
                    delegatorAddress: "",
                    validatorAddress: "",
                    amount: i.Coin.fromPartial({}),
                    creationHeight: BigInt(0)
                }
            }

            function h() {
                return {
                    authority: "",
                    params: n.Params.fromPartial({})
                }
            }
            t.protobufPackage = "cosmos.staking.v1beta1", t.MsgCreateValidator = {
                typeUrl: "/cosmos.staking.v1beta1.MsgCreateValidator",
                encode: (e, t = s.BinaryWriter.create()) => (void 0 !== e.description && n.Description.encode(e.description, t.uint32(10).fork()).ldelim(), void 0 !== e.commission && n.CommissionRates.encode(e.commission, t.uint32(18).fork()).ldelim(), "" !== e.minSelfDelegation && t.uint32(26).string(e.minSelfDelegation), "" !== e.delegatorAddress && t.uint32(34).string(e.delegatorAddress), "" !== e.validatorAddress && t.uint32(42).string(e.validatorAddress), void 0 !== e.pubkey && o.Any.encode(e.pubkey, t.uint32(50).fork()).ldelim(), void 0 !== e.value && i.Coin.encode(e.value, t.uint32(58).fork()).ldelim(), t),
                decode(e, t) {
                    let r = e instanceof s.BinaryReader ? e : new s.BinaryReader(e),
                        a = void 0 === t ? r.len : r.pos + t,
                        d = c();
                    for (; r.pos < a;) {
                        let e = r.uint32();
                        switch (e >>> 3) {
                            case 1:
                                d.description = n.Description.decode(r, r.uint32());
                                break;
                            case 2:
                                d.commission = n.CommissionRates.decode(r, r.uint32());
                                break;
                            case 3:
                                d.minSelfDelegation = r.string();
                                break;
                            case 4:
                                d.delegatorAddress = r.string();
                                break;
                            case 5:
                                d.validatorAddress = r.string();
                                break;
                            case 6:
                                d.pubkey = o.Any.decode(r, r.uint32());
                                break;
                            case 7:
                                d.value = i.Coin.decode(r, r.uint32());
                                break;
                            default:
                                r.skipType(7 & e)
                        }
                    }
                    return d
                },
                fromJSON(e) {
                    let t = c();
                    return (0, d.isSet)(e.description) && (t.description = n.Description.fromJSON(e.description)), (0, d.isSet)(e.commission) && (t.commission = n.CommissionRates.fromJSON(e.commission)), (0, d.isSet)(e.minSelfDelegation) && (t.minSelfDelegation = String(e.minSelfDelegation)), (0, d.isSet)(e.delegatorAddress) && (t.delegatorAddress = String(e.delegatorAddress)), (0, d.isSet)(e.validatorAddress) && (t.validatorAddress = String(e.validatorAddress)), (0, d.isSet)(e.pubkey) && (t.pubkey = o.Any.fromJSON(e.pubkey)), (0, d.isSet)(e.value) && (t.value = i.Coin.fromJSON(e.value)), t
                },
                toJSON(e) {
                    let t = {};
                    return void 0 !== e.description && (t.description = e.description ? n.Description.toJSON(e.description) : void 0), void 0 !== e.commission && (t.commission = e.commission ? n.CommissionRates.toJSON(e.commission) : void 0), void 0 !== e.minSelfDelegation && (t.minSelfDelegation = e.minSelfDelegation), void 0 !== e.delegatorAddress && (t.delegatorAddress = e.delegatorAddress), void 0 !== e.validatorAddress && (t.validatorAddress = e.validatorAddress), void 0 !== e.pubkey && (t.pubkey = e.pubkey ? o.Any.toJSON(e.pubkey) : void 0), void 0 !== e.value && (t.value = e.value ? i.Coin.toJSON(e.value) : void 0), t
                },
                fromPartial(e) {
                    let t = c();
                    return void 0 !== e.description && null !== e.description && (t.description = n.Description.fromPartial(e.description)), void 0 !== e.commission && null !== e.commission && (t.commission = n.CommissionRates.fromPartial(e.commission)), t.minSelfDelegation = e.minSelfDelegation ? ? "", t.delegatorAddress = e.delegatorAddress ? ? "", t.validatorAddress = e.validatorAddress ? ? "", void 0 !== e.pubkey && null !== e.pubkey && (t.pubkey = o.Any.fromPartial(e.pubkey)), void 0 !== e.value && null !== e.value && (t.value = i.Coin.fromPartial(e.value)), t
                }
            }, t.MsgCreateValidatorResponse = {
                typeUrl: "/cosmos.staking.v1beta1.MsgCreateValidatorResponse",
                encode: (e, t = s.BinaryWriter.create()) => t,
                decode(e, t) {
                    let r = e instanceof s.BinaryReader ? e : new s.BinaryReader(e),
                        n = void 0 === t ? r.len : r.pos + t;
                    for (; r.pos < n;) {
                        let e = r.uint32();
                        r.skipType(7 & e)
                    }
                    return {}
                },
                fromJSON: e => ({}),
                toJSON: e => ({}),
                fromPartial: e => ({})
            }, t.MsgEditValidator = {
                typeUrl: "/cosmos.staking.v1beta1.MsgEditValidator",
                encode: (e, t = s.BinaryWriter.create()) => (void 0 !== e.description && n.Description.encode(e.description, t.uint32(10).fork()).ldelim(), "" !== e.validatorAddress && t.uint32(18).string(e.validatorAddress), "" !== e.commissionRate && t.uint32(26).string(e.commissionRate), "" !== e.minSelfDelegation && t.uint32(34).string(e.minSelfDelegation), t),
                decode(e, t) {
                    let r = e instanceof s.BinaryReader ? e : new s.BinaryReader(e),
                        o = void 0 === t ? r.len : r.pos + t,
                        i = l();
                    for (; r.pos < o;) {
                        let e = r.uint32();
                        switch (e >>> 3) {
                            case 1:
                                i.description = n.Description.decode(r, r.uint32());
                                break;
                            case 2:
                                i.validatorAddress = r.string();
                                break;
                            case 3:
                                i.commissionRate = r.string();
                                break;
                            case 4:
                                i.minSelfDelegation = r.string();
                                break;
                            default:
                                r.skipType(7 & e)
                        }
                    }
                    return i
                },
                fromJSON(e) {
                    let t = l();
                    return (0, d.isSet)(e.description) && (t.description = n.Description.fromJSON(e.description)), (0, d.isSet)(e.validatorAddress) && (t.validatorAddress = String(e.validatorAddress)), (0, d.isSet)(e.commissionRate) && (t.commissionRate = String(e.commissionRate)), (0, d.isSet)(e.minSelfDelegation) && (t.minSelfDelegation = String(e.minSelfDelegation)), t
                },
                toJSON(e) {
                    let t = {};
                    return void 0 !== e.description && (t.description = e.description ? n.Description.toJSON(e.description) : void 0), void 0 !== e.validatorAddress && (t.validatorAddress = e.validatorAddress), void 0 !== e.commissionRate && (t.commissionRate = e.commissionRate), void 0 !== e.minSelfDelegation && (t.minSelfDelegation = e.minSelfDelegation), t
                },
                fromPartial(e) {
                    let t = l();
                    return void 0 !== e.description && null !== e.description && (t.description = n.Description.fromPartial(e.description)), t.validatorAddress = e.validatorAddress ? ? "", t.commissionRate = e.commissionRate ? ? "", t.minSelfDelegation = e.minSelfDelegation ? ? "", t
                }
            }, t.MsgEditValidatorResponse = {
                typeUrl: "/cosmos.staking.v1beta1.MsgEditValidatorResponse",
                encode: (e, t = s.BinaryWriter.create()) => t,
                decode(e, t) {
                    let r = e instanceof s.BinaryReader ? e : new s.BinaryReader(e),
                        n = void 0 === t ? r.len : r.pos + t;
                    for (; r.pos < n;) {
                        let e = r.uint32();
                        r.skipType(7 & e)
                    }
                    return {}
                },
                fromJSON: e => ({}),
                toJSON: e => ({}),
                fromPartial: e => ({})
            }, t.MsgDelegate = {
                typeUrl: "/cosmos.staking.v1beta1.MsgDelegate",
                encode: (e, t = s.BinaryWriter.create()) => ("" !== e.delegatorAddress && t.uint32(10).string(e.delegatorAddress), "" !== e.validatorAddress && t.uint32(18).string(e.validatorAddress), void 0 !== e.amount && i.Coin.encode(e.amount, t.uint32(26).fork()).ldelim(), t),
                decode(e, t) {
                    let r = e instanceof s.BinaryReader ? e : new s.BinaryReader(e),
                        n = void 0 === t ? r.len : r.pos + t,
                        o = u();
                    for (; r.pos < n;) {
                        let e = r.uint32();
                        switch (e >>> 3) {
                            case 1:
                                o.delegatorAddress = r.string();
                                break;
                            case 2:
                                o.validatorAddress = r.string();
                                break;
                            case 3:
                                o.amount = i.Coin.decode(r, r.uint32());
                                break;
                            default:
                                r.skipType(7 & e)
                        }
                    }
                    return o
                },
                fromJSON(e) {
                    let t = u();
                    return (0, d.isSet)(e.delegatorAddress) && (t.delegatorAddress = String(e.delegatorAddress)), (0, d.isSet)(e.validatorAddress) && (t.validatorAddress = String(e.validatorAddress)), (0, d.isSet)(e.amount) && (t.amount = i.Coin.fromJSON(e.amount)), t
                },
                toJSON(e) {
                    let t = {};
                    return void 0 !== e.delegatorAddress && (t.delegatorAddress = e.delegatorAddress), void 0 !== e.validatorAddress && (t.validatorAddress = e.validatorAddress), void 0 !== e.amount && (t.amount = e.amount ? i.Coin.toJSON(e.amount) : void 0), t
                },
                fromPartial(e) {
                    let t = u();
                    return t.delegatorAddress = e.delegatorAddress ? ? "", t.validatorAddress = e.validatorAddress ? ? "", void 0 !== e.amount && null !== e.amount && (t.amount = i.Coin.fromPartial(e.amount)), t
                }
            }, t.MsgDelegateResponse = {
                typeUrl: "/cosmos.staking.v1beta1.MsgDelegateResponse",
                encode: (e, t = s.BinaryWriter.create()) => t,
                decode(e, t) {
                    let r = e instanceof s.BinaryReader ? e : new s.BinaryReader(e),
                        n = void 0 === t ? r.len : r.pos + t;
                    for (; r.pos < n;) {
                        let e = r.uint32();
                        r.skipType(7 & e)
                    }
                    return {}
                },
                fromJSON: e => ({}),
                toJSON: e => ({}),
                fromPartial: e => ({})
            }, t.MsgBeginRedelegate = {
                typeUrl: "/cosmos.staking.v1beta1.MsgBeginRedelegate",
                encode: (e, t = s.BinaryWriter.create()) => ("" !== e.delegatorAddress && t.uint32(10).string(e.delegatorAddress), "" !== e.validatorSrcAddress && t.uint32(18).string(e.validatorSrcAddress), "" !== e.validatorDstAddress && t.uint32(26).string(e.validatorDstAddress), void 0 !== e.amount && i.Coin.encode(e.amount, t.uint32(34).fork()).ldelim(), t),
                decode(e, t) {
                    let r = e instanceof s.BinaryReader ? e : new s.BinaryReader(e),
                        n = void 0 === t ? r.len : r.pos + t,
                        o = p();
                    for (; r.pos < n;) {
                        let e = r.uint32();
                        switch (e >>> 3) {
                            case 1:
                                o.delegatorAddress = r.string();
                                break;
                            case 2:
                                o.validatorSrcAddress = r.string();
                                break;
                            case 3:
                                o.validatorDstAddress = r.string();
                                break;
                            case 4:
                                o.amount = i.Coin.decode(r, r.uint32());
                                break;
                            default:
                                r.skipType(7 & e)
                        }
                    }
                    return o
                },
                fromJSON(e) {
                    let t = p();
                    return (0, d.isSet)(e.delegatorAddress) && (t.delegatorAddress = String(e.delegatorAddress)), (0, d.isSet)(e.validatorSrcAddress) && (t.validatorSrcAddress = String(e.validatorSrcAddress)), (0, d.isSet)(e.validatorDstAddress) && (t.validatorDstAddress = String(e.validatorDstAddress)), (0, d.isSet)(e.amount) && (t.amount = i.Coin.fromJSON(e.amount)), t
                },
                toJSON(e) {
                    let t = {};
                    return void 0 !== e.delegatorAddress && (t.delegatorAddress = e.delegatorAddress), void 0 !== e.validatorSrcAddress && (t.validatorSrcAddress = e.validatorSrcAddress), void 0 !== e.validatorDstAddress && (t.validatorDstAddress = e.validatorDstAddress), void 0 !== e.amount && (t.amount = e.amount ? i.Coin.toJSON(e.amount) : void 0), t
                },
                fromPartial(e) {
                    let t = p();
                    return t.delegatorAddress = e.delegatorAddress ? ? "", t.validatorSrcAddress = e.validatorSrcAddress ? ? "", t.validatorDstAddress = e.validatorDstAddress ? ? "", void 0 !== e.amount && null !== e.amount && (t.amount = i.Coin.fromPartial(e.amount)), t
                }
            }, t.MsgBeginRedelegateResponse = {
                typeUrl: "/cosmos.staking.v1beta1.MsgBeginRedelegateResponse",
                encode: (e, t = s.BinaryWriter.create()) => (void 0 !== e.completionTime && a.Timestamp.encode(e.completionTime, t.uint32(10).fork()).ldelim(), t),
                decode(e, t) {
                    let r = e instanceof s.BinaryReader ? e : new s.BinaryReader(e),
                        n = void 0 === t ? r.len : r.pos + t,
                        o = m();
                    for (; r.pos < n;) {
                        let e = r.uint32();
                        e >>> 3 == 1 ? o.completionTime = a.Timestamp.decode(r, r.uint32()) : r.skipType(7 & e)
                    }
                    return o
                },
                fromJSON(e) {
                    let t = m();
                    return (0, d.isSet)(e.completionTime) && (t.completionTime = (0, d.fromJsonTimestamp)(e.completionTime)), t
                },
                toJSON(e) {
                    let t = {};
                    return void 0 !== e.completionTime && (t.completionTime = (0, d.fromTimestamp)(e.completionTime).toISOString()), t
                },
                fromPartial(e) {
                    let t = m();
                    return void 0 !== e.completionTime && null !== e.completionTime && (t.completionTime = a.Timestamp.fromPartial(e.completionTime)), t
                }
            }, t.MsgUndelegate = {
                typeUrl: "/cosmos.staking.v1beta1.MsgUndelegate",
                encode: (e, t = s.BinaryWriter.create()) => ("" !== e.delegatorAddress && t.uint32(10).string(e.delegatorAddress), "" !== e.validatorAddress && t.uint32(18).string(e.validatorAddress), void 0 !== e.amount && i.Coin.encode(e.amount, t.uint32(26).fork()).ldelim(), t),
                decode(e, t) {
                    let r = e instanceof s.BinaryReader ? e : new s.BinaryReader(e),
                        n = void 0 === t ? r.len : r.pos + t,
                        o = g();
                    for (; r.pos < n;) {
                        let e = r.uint32();
                        switch (e >>> 3) {
                            case 1:
                                o.delegatorAddress = r.string();
                                break;
                            case 2:
                                o.validatorAddress = r.string();
                                break;
                            case 3:
                                o.amount = i.Coin.decode(r, r.uint32());
                                break;
                            default:
                                r.skipType(7 & e)
                        }
                    }
                    return o
                },
                fromJSON(e) {
                    let t = g();
                    return (0, d.isSet)(e.delegatorAddress) && (t.delegatorAddress = String(e.delegatorAddress)), (0, d.isSet)(e.validatorAddress) && (t.validatorAddress = String(e.validatorAddress)), (0, d.isSet)(e.amount) && (t.amount = i.Coin.fromJSON(e.amount)), t
                },
                toJSON(e) {
                    let t = {};
                    return void 0 !== e.delegatorAddress && (t.delegatorAddress = e.delegatorAddress), void 0 !== e.validatorAddress && (t.validatorAddress = e.validatorAddress), void 0 !== e.amount && (t.amount = e.amount ? i.Coin.toJSON(e.amount) : void 0), t
                },
                fromPartial(e) {
                    let t = g();
                    return t.delegatorAddress = e.delegatorAddress ? ? "", t.validatorAddress = e.validatorAddress ? ? "", void 0 !== e.amount && null !== e.amount && (t.amount = i.Coin.fromPartial(e.amount)), t
                }
            }, t.MsgUndelegateResponse = {
                typeUrl: "/cosmos.staking.v1beta1.MsgUndelegateResponse",
                encode: (e, t = s.BinaryWriter.create()) => (void 0 !== e.completionTime && a.Timestamp.encode(e.completionTime, t.uint32(10).fork()).ldelim(), t),
                decode(e, t) {
                    let r = e instanceof s.BinaryReader ? e : new s.BinaryReader(e),
                        n = void 0 === t ? r.len : r.pos + t,
                        o = f();
                    for (; r.pos < n;) {
                        let e = r.uint32();
                        e >>> 3 == 1 ? o.completionTime = a.Timestamp.decode(r, r.uint32()) : r.skipType(7 & e)
                    }
                    return o
                },
                fromJSON(e) {
                    let t = f();
                    return (0, d.isSet)(e.completionTime) && (t.completionTime = (0, d.fromJsonTimestamp)(e.completionTime)), t
                },
                toJSON(e) {
                    let t = {};
                    return void 0 !== e.completionTime && (t.completionTime = (0, d.fromTimestamp)(e.completionTime).toISOString()), t
                },
                fromPartial(e) {
                    let t = f();
                    return void 0 !== e.completionTime && null !== e.completionTime && (t.completionTime = a.Timestamp.fromPartial(e.completionTime)), t
                }
            }, t.MsgCancelUnbondingDelegation = {
                typeUrl: "/cosmos.staking.v1beta1.MsgCancelUnbondingDelegation",
                encode: (e, t = s.BinaryWriter.create()) => ("" !== e.delegatorAddress && t.uint32(10).string(e.delegatorAddress), "" !== e.validatorAddress && t.uint32(18).string(e.validatorAddress), void 0 !== e.amount && i.Coin.encode(e.amount, t.uint32(26).fork()).ldelim(), e.creationHeight !== BigInt(0) && t.uint32(32).int64(e.creationHeight), t),
                decode(e, t) {
                    let r = e instanceof s.BinaryReader ? e : new s.BinaryReader(e),
                        n = void 0 === t ? r.len : r.pos + t,
                        o = y();
                    for (; r.pos < n;) {
                        let e = r.uint32();
                        switch (e >>> 3) {
                            case 1:
                                o.delegatorAddress = r.string();
                                break;
                            case 2:
                                o.validatorAddress = r.string();
                                break;
                            case 3:
                                o.amount = i.Coin.decode(r, r.uint32());
                                break;
                            case 4:
                                o.creationHeight = r.int64();
                                break;
                            default:
                                r.skipType(7 & e)
                        }
                    }
                    return o
                },
                fromJSON(e) {
                    let t = y();
                    return (0, d.isSet)(e.delegatorAddress) && (t.delegatorAddress = String(e.delegatorAddress)), (0, d.isSet)(e.validatorAddress) && (t.validatorAddress = String(e.validatorAddress)), (0, d.isSet)(e.amount) && (t.amount = i.Coin.fromJSON(e.amount)), (0, d.isSet)(e.creationHeight) && (t.creationHeight = BigInt(e.creationHeight.toString())), t
                },
                toJSON(e) {
                    let t = {};
                    return void 0 !== e.delegatorAddress && (t.delegatorAddress = e.delegatorAddress), void 0 !== e.validatorAddress && (t.validatorAddress = e.validatorAddress), void 0 !== e.amount && (t.amount = e.amount ? i.Coin.toJSON(e.amount) : void 0), void 0 !== e.creationHeight && (t.creationHeight = (e.creationHeight || BigInt(0)).toString()), t
                },
                fromPartial(e) {
                    let t = y();
                    return t.delegatorAddress = e.delegatorAddress ? ? "", t.validatorAddress = e.validatorAddress ? ? "", void 0 !== e.amount && null !== e.amount && (t.amount = i.Coin.fromPartial(e.amount)), void 0 !== e.creationHeight && null !== e.creationHeight && (t.creationHeight = BigInt(e.creationHeight.toString())), t
                }
            }, t.MsgCancelUnbondingDelegationResponse = {
                typeUrl: "/cosmos.staking.v1beta1.MsgCancelUnbondingDelegationResponse",
                encode: (e, t = s.BinaryWriter.create()) => t,
                decode(e, t) {
                    let r = e instanceof s.BinaryReader ? e : new s.BinaryReader(e),
                        n = void 0 === t ? r.len : r.pos + t;
                    for (; r.pos < n;) {
                        let e = r.uint32();
                        r.skipType(7 & e)
                    }
                    return {}
                },
                fromJSON: e => ({}),
                toJSON: e => ({}),
                fromPartial: e => ({})
            }, t.MsgUpdateParams = {
                typeUrl: "/cosmos.staking.v1beta1.MsgUpdateParams",
                encode: (e, t = s.BinaryWriter.create()) => ("" !== e.authority && t.uint32(10).string(e.authority), void 0 !== e.params && n.Params.encode(e.params, t.uint32(18).fork()).ldelim(), t),
                decode(e, t) {
                    let r = e instanceof s.BinaryReader ? e : new s.BinaryReader(e),
                        o = void 0 === t ? r.len : r.pos + t,
                        i = h();
                    for (; r.pos < o;) {
                        let e = r.uint32();
                        switch (e >>> 3) {
                            case 1:
                                i.authority = r.string();
                                break;
                            case 2:
                                i.params = n.Params.decode(r, r.uint32());
                                break;
                            default:
                                r.skipType(7 & e)
                        }
                    }
                    return i
                },
                fromJSON(e) {
                    let t = h();
                    return (0, d.isSet)(e.authority) && (t.authority = String(e.authority)), (0, d.isSet)(e.params) && (t.params = n.Params.fromJSON(e.params)), t
                },
                toJSON(e) {
                    let t = {};
                    return void 0 !== e.authority && (t.authority = e.authority), void 0 !== e.params && (t.params = e.params ? n.Params.toJSON(e.params) : void 0), t
                },
                fromPartial(e) {
                    let t = h();
                    return t.authority = e.authority ? ? "", void 0 !== e.params && null !== e.params && (t.params = n.Params.fromPartial(e.params)), t
                }
            }, t.MsgUpdateParamsResponse = {
                typeUrl: "/cosmos.staking.v1beta1.MsgUpdateParamsResponse",
                encode: (e, t = s.BinaryWriter.create()) => t,
                decode(e, t) {
                    let r = e instanceof s.BinaryReader ? e : new s.BinaryReader(e),
                        n = void 0 === t ? r.len : r.pos + t;
                    for (; r.pos < n;) {
                        let e = r.uint32();
                        r.skipType(7 & e)
                    }
                    return {}
                },
                fromJSON: e => ({}),
                toJSON: e => ({}),
                fromPartial: e => ({})
            };
            class v {
                constructor(e) {
                    this.rpc = e, this.CreateValidator = this.CreateValidator.bind(this), this.EditValidator = this.EditValidator.bind(this), this.Delegate = this.Delegate.bind(this), this.BeginRedelegate = this.BeginRedelegate.bind(this), this.Undelegate = this.Undelegate.bind(this), this.CancelUnbondingDelegation = this.CancelUnbondingDelegation.bind(this), this.UpdateParams = this.UpdateParams.bind(this)
                }
                CreateValidator(e) {
                    let r = t.MsgCreateValidator.encode(e).finish();
                    return this.rpc.request("cosmos.staking.v1beta1.Msg", "CreateValidator", r).then(e => t.MsgCreateValidatorResponse.decode(new s.BinaryReader(e)))
                }
                EditValidator(e) {
                    let r = t.MsgEditValidator.encode(e).finish();
                    return this.rpc.request("cosmos.staking.v1beta1.Msg", "EditValidator", r).then(e => t.MsgEditValidatorResponse.decode(new s.BinaryReader(e)))
                }
                Delegate(e) {
                    let r = t.MsgDelegate.encode(e).finish();
                    return this.rpc.request("cosmos.staking.v1beta1.Msg", "Delegate", r).then(e => t.MsgDelegateResponse.decode(new s.BinaryReader(e)))
                }
                BeginRedelegate(e) {
                    let r = t.MsgBeginRedelegate.encode(e).finish();
                    return this.rpc.request("cosmos.staking.v1beta1.Msg", "BeginRedelegate", r).then(e => t.MsgBeginRedelegateResponse.decode(new s.BinaryReader(e)))
                }
                Undelegate(e) {
                    let r = t.MsgUndelegate.encode(e).finish();
                    return this.rpc.request("cosmos.staking.v1beta1.Msg", "Undelegate", r).then(e => t.MsgUndelegateResponse.decode(new s.BinaryReader(e)))
                }
                CancelUnbondingDelegation(e) {
                    let r = t.MsgCancelUnbondingDelegation.encode(e).finish();
                    return this.rpc.request("cosmos.staking.v1beta1.Msg", "CancelUnbondingDelegation", r).then(e => t.MsgCancelUnbondingDelegationResponse.decode(new s.BinaryReader(e)))
                }
                UpdateParams(e) {
                    let r = t.MsgUpdateParams.encode(e).finish();
                    return this.rpc.request("cosmos.staking.v1beta1.Msg", "UpdateParams", r).then(e => t.MsgUpdateParamsResponse.decode(new s.BinaryReader(e)))
                }
            }
            t.MsgClientImpl = v
        },
        63702: function(e, t, r) {
            "use strict";
            var n, o;
            Object.defineProperty(t, "__esModule", {
                value: !0
            }), t.SignatureDescriptor_Data_Multi = t.SignatureDescriptor_Data_Single = t.SignatureDescriptor_Data = t.SignatureDescriptor = t.SignatureDescriptors = t.signModeToJSON = t.signModeFromJSON = t.SignMode = t.protobufPackage = void 0;
            let i = r(80758),
                a = r(40747),
                s = r(23795),
                d = r(96987);

            function c(e) {
                switch (e) {
                    case 0:
                    case "SIGN_MODE_UNSPECIFIED":
                        return n.SIGN_MODE_UNSPECIFIED;
                    case 1:
                    case "SIGN_MODE_DIRECT":
                        return n.SIGN_MODE_DIRECT;
                    case 2:
                    case "SIGN_MODE_TEXTUAL":
                        return n.SIGN_MODE_TEXTUAL;
                    case 3:
                    case "SIGN_MODE_DIRECT_AUX":
                        return n.SIGN_MODE_DIRECT_AUX;
                    case 127:
                    case "SIGN_MODE_LEGACY_AMINO_JSON":
                        return n.SIGN_MODE_LEGACY_AMINO_JSON;
                    case 191:
                    case "SIGN_MODE_EIP_191":
                        return n.SIGN_MODE_EIP_191;
                    default:
                        return n.UNRECOGNIZED
                }
            }

            function l(e) {
                switch (e) {
                    case n.SIGN_MODE_UNSPECIFIED:
                        return "SIGN_MODE_UNSPECIFIED";
                    case n.SIGN_MODE_DIRECT:
                        return "SIGN_MODE_DIRECT";
                    case n.SIGN_MODE_TEXTUAL:
                        return "SIGN_MODE_TEXTUAL";
                    case n.SIGN_MODE_DIRECT_AUX:
                        return "SIGN_MODE_DIRECT_AUX";
                    case n.SIGN_MODE_LEGACY_AMINO_JSON:
                        return "SIGN_MODE_LEGACY_AMINO_JSON";
                    case n.SIGN_MODE_EIP_191:
                        return "SIGN_MODE_EIP_191";
                    case n.UNRECOGNIZED:
                    default:
                        return "UNRECOGNIZED"
                }
            }

            function u() {
                return {
                    signatures: []
                }
            }

            function p() {
                return {
                    publicKey: void 0,
                    data: void 0,
                    sequence: BigInt(0)
                }
            }

            function m() {
                return {
                    single: void 0,
                    multi: void 0
                }
            }

            function g() {
                return {
                    mode: 0,
                    signature: new Uint8Array
                }
            }

            function f() {
                return {
                    bitarray: void 0,
                    signatures: []
                }
            }
            t.protobufPackage = "cosmos.tx.signing.v1beta1", (o = n || (t.SignMode = n = {}))[o.SIGN_MODE_UNSPECIFIED = 0] = "SIGN_MODE_UNSPECIFIED", o[o.SIGN_MODE_DIRECT = 1] = "SIGN_MODE_DIRECT", o[o.SIGN_MODE_TEXTUAL = 2] = "SIGN_MODE_TEXTUAL", o[o.SIGN_MODE_DIRECT_AUX = 3] = "SIGN_MODE_DIRECT_AUX", o[o.SIGN_MODE_LEGACY_AMINO_JSON = 127] = "SIGN_MODE_LEGACY_AMINO_JSON", o[o.SIGN_MODE_EIP_191 = 191] = "SIGN_MODE_EIP_191", o[o.UNRECOGNIZED = -1] = "UNRECOGNIZED", t.signModeFromJSON = c, t.signModeToJSON = l, t.SignatureDescriptors = {
                typeUrl: "/cosmos.tx.signing.v1beta1.SignatureDescriptors",
                encode(e, r = s.BinaryWriter.create()) {
                    for (let n of e.signatures) t.SignatureDescriptor.encode(n, r.uint32(10).fork()).ldelim();
                    return r
                },
                decode(e, r) {
                    let n = e instanceof s.BinaryReader ? e : new s.BinaryReader(e),
                        o = void 0 === r ? n.len : n.pos + r,
                        i = u();
                    for (; n.pos < o;) {
                        let e = n.uint32();
                        e >>> 3 == 1 ? i.signatures.push(t.SignatureDescriptor.decode(n, n.uint32())) : n.skipType(7 & e)
                    }
                    return i
                },
                fromJSON(e) {
                    let r = u();
                    return Array.isArray(e ? .signatures) && (r.signatures = e.signatures.map(e => t.SignatureDescriptor.fromJSON(e))), r
                },
                toJSON(e) {
                    let r = {};
                    return e.signatures ? r.signatures = e.signatures.map(e => e ? t.SignatureDescriptor.toJSON(e) : void 0) : r.signatures = [], r
                },
                fromPartial(e) {
                    let r = u();
                    return r.signatures = e.signatures ? .map(e => t.SignatureDescriptor.fromPartial(e)) || [], r
                }
            }, t.SignatureDescriptor = {
                typeUrl: "/cosmos.tx.signing.v1beta1.SignatureDescriptor",
                encode: (e, r = s.BinaryWriter.create()) => (void 0 !== e.publicKey && a.Any.encode(e.publicKey, r.uint32(10).fork()).ldelim(), void 0 !== e.data && t.SignatureDescriptor_Data.encode(e.data, r.uint32(18).fork()).ldelim(), e.sequence !== BigInt(0) && r.uint32(24).uint64(e.sequence), r),
                decode(e, r) {
                    let n = e instanceof s.BinaryReader ? e : new s.BinaryReader(e),
                        o = void 0 === r ? n.len : n.pos + r,
                        i = p();
                    for (; n.pos < o;) {
                        let e = n.uint32();
                        switch (e >>> 3) {
                            case 1:
                                i.publicKey = a.Any.decode(n, n.uint32());
                                break;
                            case 2:
                                i.data = t.SignatureDescriptor_Data.decode(n, n.uint32());
                                break;
                            case 3:
                                i.sequence = n.uint64();
                                break;
                            default:
                                n.skipType(7 & e)
                        }
                    }
                    return i
                },
                fromJSON(e) {
                    let r = p();
                    return (0, d.isSet)(e.publicKey) && (r.publicKey = a.Any.fromJSON(e.publicKey)), (0, d.isSet)(e.data) && (r.data = t.SignatureDescriptor_Data.fromJSON(e.data)), (0, d.isSet)(e.sequence) && (r.sequence = BigInt(e.sequence.toString())), r
                },
                toJSON(e) {
                    let r = {};
                    return void 0 !== e.publicKey && (r.publicKey = e.publicKey ? a.Any.toJSON(e.publicKey) : void 0), void 0 !== e.data && (r.data = e.data ? t.SignatureDescriptor_Data.toJSON(e.data) : void 0), void 0 !== e.sequence && (r.sequence = (e.sequence || BigInt(0)).toString()), r
                },
                fromPartial(e) {
                    let r = p();
                    return void 0 !== e.publicKey && null !== e.publicKey && (r.publicKey = a.Any.fromPartial(e.publicKey)), void 0 !== e.data && null !== e.data && (r.data = t.SignatureDescriptor_Data.fromPartial(e.data)), void 0 !== e.sequence && null !== e.sequence && (r.sequence = BigInt(e.sequence.toString())), r
                }
            }, t.SignatureDescriptor_Data = {
                typeUrl: "/cosmos.tx.signing.v1beta1.Data",
                encode: (e, r = s.BinaryWriter.create()) => (void 0 !== e.single && t.SignatureDescriptor_Data_Single.encode(e.single, r.uint32(10).fork()).ldelim(), void 0 !== e.multi && t.SignatureDescriptor_Data_Multi.encode(e.multi, r.uint32(18).fork()).ldelim(), r),
                decode(e, r) {
                    let n = e instanceof s.BinaryReader ? e : new s.BinaryReader(e),
                        o = void 0 === r ? n.len : n.pos + r,
                        i = m();
                    for (; n.pos < o;) {
                        let e = n.uint32();
                        switch (e >>> 3) {
                            case 1:
                                i.single = t.SignatureDescriptor_Data_Single.decode(n, n.uint32());
                                break;
                            case 2:
                                i.multi = t.SignatureDescriptor_Data_Multi.decode(n, n.uint32());
                                break;
                            default:
                                n.skipType(7 & e)
                        }
                    }
                    return i
                },
                fromJSON(e) {
                    let r = m();
                    return (0, d.isSet)(e.single) && (r.single = t.SignatureDescriptor_Data_Single.fromJSON(e.single)), (0, d.isSet)(e.multi) && (r.multi = t.SignatureDescriptor_Data_Multi.fromJSON(e.multi)), r
                },
                toJSON(e) {
                    let r = {};
                    return void 0 !== e.single && (r.single = e.single ? t.SignatureDescriptor_Data_Single.toJSON(e.single) : void 0), void 0 !== e.multi && (r.multi = e.multi ? t.SignatureDescriptor_Data_Multi.toJSON(e.multi) : void 0), r
                },
                fromPartial(e) {
                    let r = m();
                    return void 0 !== e.single && null !== e.single && (r.single = t.SignatureDescriptor_Data_Single.fromPartial(e.single)), void 0 !== e.multi && null !== e.multi && (r.multi = t.SignatureDescriptor_Data_Multi.fromPartial(e.multi)), r
                }
            }, t.SignatureDescriptor_Data_Single = {
                typeUrl: "/cosmos.tx.signing.v1beta1.Single",
                encode: (e, t = s.BinaryWriter.create()) => (0 !== e.mode && t.uint32(8).int32(e.mode), 0 !== e.signature.length && t.uint32(18).bytes(e.signature), t),
                decode(e, t) {
                    let r = e instanceof s.BinaryReader ? e : new s.BinaryReader(e),
                        n = void 0 === t ? r.len : r.pos + t,
                        o = g();
                    for (; r.pos < n;) {
                        let e = r.uint32();
                        switch (e >>> 3) {
                            case 1:
                                o.mode = r.int32();
                                break;
                            case 2:
                                o.signature = r.bytes();
                                break;
                            default:
                                r.skipType(7 & e)
                        }
                    }
                    return o
                },
                fromJSON(e) {
                    let t = g();
                    return (0, d.isSet)(e.mode) && (t.mode = c(e.mode)), (0, d.isSet)(e.signature) && (t.signature = (0, d.bytesFromBase64)(e.signature)), t
                },
                toJSON(e) {
                    let t = {};
                    return void 0 !== e.mode && (t.mode = l(e.mode)), void 0 !== e.signature && (t.signature = (0, d.base64FromBytes)(void 0 !== e.signature ? e.signature : new Uint8Array)), t
                },
                fromPartial(e) {
                    let t = g();
                    return t.mode = e.mode ? ? 0, t.signature = e.signature ? ? new Uint8Array, t
                }
            }, t.SignatureDescriptor_Data_Multi = {
                typeUrl: "/cosmos.tx.signing.v1beta1.Multi",
                encode(e, r = s.BinaryWriter.create()) {
                    for (let n of (void 0 !== e.bitarray && i.CompactBitArray.encode(e.bitarray, r.uint32(10).fork()).ldelim(), e.signatures)) t.SignatureDescriptor_Data.encode(n, r.uint32(18).fork()).ldelim();
                    return r
                },
                decode(e, r) {
                    let n = e instanceof s.BinaryReader ? e : new s.BinaryReader(e),
                        o = void 0 === r ? n.len : n.pos + r,
                        a = f();
                    for (; n.pos < o;) {
                        let e = n.uint32();
                        switch (e >>> 3) {
                            case 1:
                                a.bitarray = i.CompactBitArray.decode(n, n.uint32());
                                break;
                            case 2:
                                a.signatures.push(t.SignatureDescriptor_Data.decode(n, n.uint32()));
                                break;
                            default:
                                n.skipType(7 & e)
                        }
                    }
                    return a
                },
                fromJSON(e) {
                    let r = f();
                    return (0, d.isSet)(e.bitarray) && (r.bitarray = i.CompactBitArray.fromJSON(e.bitarray)), Array.isArray(e ? .signatures) && (r.signatures = e.signatures.map(e => t.SignatureDescriptor_Data.fromJSON(e))), r
                },
                toJSON(e) {
                    let r = {};
                    return void 0 !== e.bitarray && (r.bitarray = e.bitarray ? i.CompactBitArray.toJSON(e.bitarray) : void 0), e.signatures ? r.signatures = e.signatures.map(e => e ? t.SignatureDescriptor_Data.toJSON(e) : void 0) : r.signatures = [], r
                },
                fromPartial(e) {
                    let r = f();
                    return void 0 !== e.bitarray && null !== e.bitarray && (r.bitarray = i.CompactBitArray.fromPartial(e.bitarray)), r.signatures = e.signatures ? .map(e => t.SignatureDescriptor_Data.fromPartial(e)) || [], r
                }
            }
        },
        9858: function(e, t, r) {
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: !0
            }), t.AuxSignerData = t.Tip = t.Fee = t.ModeInfo_Multi = t.ModeInfo_Single = t.ModeInfo = t.SignerInfo = t.AuthInfo = t.TxBody = t.SignDocDirectAux = t.SignDoc = t.TxRaw = t.Tx = t.protobufPackage = void 0;
            let n = r(40747),
                o = r(63702),
                i = r(80758),
                a = r(91408),
                s = r(23795),
                d = r(96987);

            function c() {
                return {
                    body: void 0,
                    authInfo: void 0,
                    signatures: []
                }
            }

            function l() {
                return {
                    bodyBytes: new Uint8Array,
                    authInfoBytes: new Uint8Array,
                    signatures: []
                }
            }

            function u() {
                return {
                    bodyBytes: new Uint8Array,
                    authInfoBytes: new Uint8Array,
                    chainId: "",
                    accountNumber: BigInt(0)
                }
            }

            function p() {
                return {
                    bodyBytes: new Uint8Array,
                    publicKey: void 0,
                    chainId: "",
                    accountNumber: BigInt(0),
                    sequence: BigInt(0),
                    tip: void 0
                }
            }

            function m() {
                return {
                    messages: [],
                    memo: "",
                    timeoutHeight: BigInt(0),
                    extensionOptions: [],
                    nonCriticalExtensionOptions: []
                }
            }

            function g() {
                return {
                    signerInfos: [],
                    fee: void 0,
                    tip: void 0
                }
            }

            function f() {
                return {
                    publicKey: void 0,
                    modeInfo: void 0,
                    sequence: BigInt(0)
                }
            }

            function y() {
                return {
                    single: void 0,
                    multi: void 0
                }
            }

            function h() {
                return {
                    mode: 0
                }
            }

            function v() {
                return {
                    bitarray: void 0,
                    modeInfos: []
                }
            }

            function b() {
                return {
                    amount: [],
                    gasLimit: BigInt(0),
                    payer: "",
                    granter: ""
                }
            }

            function S() {
                return {
                    amount: [],
                    tipper: ""
                }
            }

            function k() {
                return {
                    address: "",
                    signDoc: void 0,
                    mode: 0,
                    sig: new Uint8Array
                }
            }
            t.protobufPackage = "cosmos.tx.v1beta1", t.Tx = {
                typeUrl: "/cosmos.tx.v1beta1.Tx",
                encode(e, r = s.BinaryWriter.create()) {
                    for (let n of (void 0 !== e.body && t.TxBody.encode(e.body, r.uint32(10).fork()).ldelim(), void 0 !== e.authInfo && t.AuthInfo.encode(e.authInfo, r.uint32(18).fork()).ldelim(), e.signatures)) r.uint32(26).bytes(n);
                    return r
                },
                decode(e, r) {
                    let n = e instanceof s.BinaryReader ? e : new s.BinaryReader(e),
                        o = void 0 === r ? n.len : n.pos + r,
                        i = c();
                    for (; n.pos < o;) {
                        let e = n.uint32();
                        switch (e >>> 3) {
                            case 1:
                                i.body = t.TxBody.decode(n, n.uint32());
                                break;
                            case 2:
                                i.authInfo = t.AuthInfo.decode(n, n.uint32());
                                break;
                            case 3:
                                i.signatures.push(n.bytes());
                                break;
                            default:
                                n.skipType(7 & e)
                        }
                    }
                    return i
                },
                fromJSON(e) {
                    let r = c();
                    return (0, d.isSet)(e.body) && (r.body = t.TxBody.fromJSON(e.body)), (0, d.isSet)(e.authInfo) && (r.authInfo = t.AuthInfo.fromJSON(e.authInfo)), Array.isArray(e ? .signatures) && (r.signatures = e.signatures.map(e => (0, d.bytesFromBase64)(e))), r
                },
                toJSON(e) {
                    let r = {};
                    return void 0 !== e.body && (r.body = e.body ? t.TxBody.toJSON(e.body) : void 0), void 0 !== e.authInfo && (r.authInfo = e.authInfo ? t.AuthInfo.toJSON(e.authInfo) : void 0), e.signatures ? r.signatures = e.signatures.map(e => (0, d.base64FromBytes)(void 0 !== e ? e : new Uint8Array)) : r.signatures = [], r
                },
                fromPartial(e) {
                    let r = c();
                    return void 0 !== e.body && null !== e.body && (r.body = t.TxBody.fromPartial(e.body)), void 0 !== e.authInfo && null !== e.authInfo && (r.authInfo = t.AuthInfo.fromPartial(e.authInfo)), r.signatures = e.signatures ? .map(e => e) || [], r
                }
            }, t.TxRaw = {
                typeUrl: "/cosmos.tx.v1beta1.TxRaw",
                encode(e, t = s.BinaryWriter.create()) {
                    for (let r of (0 !== e.bodyBytes.length && t.uint32(10).bytes(e.bodyBytes), 0 !== e.authInfoBytes.length && t.uint32(18).bytes(e.authInfoBytes), e.signatures)) t.uint32(26).bytes(r);
                    return t
                },
                decode(e, t) {
                    let r = e instanceof s.BinaryReader ? e : new s.BinaryReader(e),
                        n = void 0 === t ? r.len : r.pos + t,
                        o = l();
                    for (; r.pos < n;) {
                        let e = r.uint32();
                        switch (e >>> 3) {
                            case 1:
                                o.bodyBytes = r.bytes();
                                break;
                            case 2:
                                o.authInfoBytes = r.bytes();
                                break;
                            case 3:
                                o.signatures.push(r.bytes());
                                break;
                            default:
                                r.skipType(7 & e)
                        }
                    }
                    return o
                },
                fromJSON(e) {
                    let t = l();
                    return (0, d.isSet)(e.bodyBytes) && (t.bodyBytes = (0, d.bytesFromBase64)(e.bodyBytes)), (0, d.isSet)(e.authInfoBytes) && (t.authInfoBytes = (0, d.bytesFromBase64)(e.authInfoBytes)), Array.isArray(e ? .signatures) && (t.signatures = e.signatures.map(e => (0, d.bytesFromBase64)(e))), t
                },
                toJSON(e) {
                    let t = {};
                    return void 0 !== e.bodyBytes && (t.bodyBytes = (0, d.base64FromBytes)(void 0 !== e.bodyBytes ? e.bodyBytes : new Uint8Array)), void 0 !== e.authInfoBytes && (t.authInfoBytes = (0, d.base64FromBytes)(void 0 !== e.authInfoBytes ? e.authInfoBytes : new Uint8Array)), e.signatures ? t.signatures = e.signatures.map(e => (0, d.base64FromBytes)(void 0 !== e ? e : new Uint8Array)) : t.signatures = [], t
                },
                fromPartial(e) {
                    let t = l();
                    return t.bodyBytes = e.bodyBytes ? ? new Uint8Array, t.authInfoBytes = e.authInfoBytes ? ? new Uint8Array, t.signatures = e.signatures ? .map(e => e) || [], t
                }
            }, t.SignDoc = {
                typeUrl: "/cosmos.tx.v1beta1.SignDoc",
                encode: (e, t = s.BinaryWriter.create()) => (0 !== e.bodyBytes.length && t.uint32(10).bytes(e.bodyBytes), 0 !== e.authInfoBytes.length && t.uint32(18).bytes(e.authInfoBytes), "" !== e.chainId && t.uint32(26).string(e.chainId), e.accountNumber !== BigInt(0) && t.uint32(32).uint64(e.accountNumber), t),
                decode(e, t) {
                    let r = e instanceof s.BinaryReader ? e : new s.BinaryReader(e),
                        n = void 0 === t ? r.len : r.pos + t,
                        o = u();
                    for (; r.pos < n;) {
                        let e = r.uint32();
                        switch (e >>> 3) {
                            case 1:
                                o.bodyBytes = r.bytes();
                                break;
                            case 2:
                                o.authInfoBytes = r.bytes();
                                break;
                            case 3:
                                o.chainId = r.string();
                                break;
                            case 4:
                                o.accountNumber = r.uint64();
                                break;
                            default:
                                r.skipType(7 & e)
                        }
                    }
                    return o
                },
                fromJSON(e) {
                    let t = u();
                    return (0, d.isSet)(e.bodyBytes) && (t.bodyBytes = (0, d.bytesFromBase64)(e.bodyBytes)), (0, d.isSet)(e.authInfoBytes) && (t.authInfoBytes = (0, d.bytesFromBase64)(e.authInfoBytes)), (0, d.isSet)(e.chainId) && (t.chainId = String(e.chainId)), (0, d.isSet)(e.accountNumber) && (t.accountNumber = BigInt(e.accountNumber.toString())), t
                },
                toJSON(e) {
                    let t = {};
                    return void 0 !== e.bodyBytes && (t.bodyBytes = (0, d.base64FromBytes)(void 0 !== e.bodyBytes ? e.bodyBytes : new Uint8Array)), void 0 !== e.authInfoBytes && (t.authInfoBytes = (0, d.base64FromBytes)(void 0 !== e.authInfoBytes ? e.authInfoBytes : new Uint8Array)), void 0 !== e.chainId && (t.chainId = e.chainId), void 0 !== e.accountNumber && (t.accountNumber = (e.accountNumber || BigInt(0)).toString()), t
                },
                fromPartial(e) {
                    let t = u();
                    return t.bodyBytes = e.bodyBytes ? ? new Uint8Array, t.authInfoBytes = e.authInfoBytes ? ? new Uint8Array, t.chainId = e.chainId ? ? "", void 0 !== e.accountNumber && null !== e.accountNumber && (t.accountNumber = BigInt(e.accountNumber.toString())), t
                }
            }, t.SignDocDirectAux = {
                typeUrl: "/cosmos.tx.v1beta1.SignDocDirectAux",
                encode: (e, r = s.BinaryWriter.create()) => (0 !== e.bodyBytes.length && r.uint32(10).bytes(e.bodyBytes), void 0 !== e.publicKey && n.Any.encode(e.publicKey, r.uint32(18).fork()).ldelim(), "" !== e.chainId && r.uint32(26).string(e.chainId), e.accountNumber !== BigInt(0) && r.uint32(32).uint64(e.accountNumber), e.sequence !== BigInt(0) && r.uint32(40).uint64(e.sequence), void 0 !== e.tip && t.Tip.encode(e.tip, r.uint32(50).fork()).ldelim(), r),
                decode(e, r) {
                    let o = e instanceof s.BinaryReader ? e : new s.BinaryReader(e),
                        i = void 0 === r ? o.len : o.pos + r,
                        a = p();
                    for (; o.pos < i;) {
                        let e = o.uint32();
                        switch (e >>> 3) {
                            case 1:
                                a.bodyBytes = o.bytes();
                                break;
                            case 2:
                                a.publicKey = n.Any.decode(o, o.uint32());
                                break;
                            case 3:
                                a.chainId = o.string();
                                break;
                            case 4:
                                a.accountNumber = o.uint64();
                                break;
                            case 5:
                                a.sequence = o.uint64();
                                break;
                            case 6:
                                a.tip = t.Tip.decode(o, o.uint32());
                                break;
                            default:
                                o.skipType(7 & e)
                        }
                    }
                    return a
                },
                fromJSON(e) {
                    let r = p();
                    return (0, d.isSet)(e.bodyBytes) && (r.bodyBytes = (0, d.bytesFromBase64)(e.bodyBytes)), (0, d.isSet)(e.publicKey) && (r.publicKey = n.Any.fromJSON(e.publicKey)), (0, d.isSet)(e.chainId) && (r.chainId = String(e.chainId)), (0, d.isSet)(e.accountNumber) && (r.accountNumber = BigInt(e.accountNumber.toString())), (0, d.isSet)(e.sequence) && (r.sequence = BigInt(e.sequence.toString())), (0, d.isSet)(e.tip) && (r.tip = t.Tip.fromJSON(e.tip)), r
                },
                toJSON(e) {
                    let r = {};
                    return void 0 !== e.bodyBytes && (r.bodyBytes = (0, d.base64FromBytes)(void 0 !== e.bodyBytes ? e.bodyBytes : new Uint8Array)), void 0 !== e.publicKey && (r.publicKey = e.publicKey ? n.Any.toJSON(e.publicKey) : void 0), void 0 !== e.chainId && (r.chainId = e.chainId), void 0 !== e.accountNumber && (r.accountNumber = (e.accountNumber || BigInt(0)).toString()), void 0 !== e.sequence && (r.sequence = (e.sequence || BigInt(0)).toString()), void 0 !== e.tip && (r.tip = e.tip ? t.Tip.toJSON(e.tip) : void 0), r
                },
                fromPartial(e) {
                    let r = p();
                    return r.bodyBytes = e.bodyBytes ? ? new Uint8Array, void 0 !== e.publicKey && null !== e.publicKey && (r.publicKey = n.Any.fromPartial(e.publicKey)), r.chainId = e.chainId ? ? "", void 0 !== e.accountNumber && null !== e.accountNumber && (r.accountNumber = BigInt(e.accountNumber.toString())), void 0 !== e.sequence && null !== e.sequence && (r.sequence = BigInt(e.sequence.toString())), void 0 !== e.tip && null !== e.tip && (r.tip = t.Tip.fromPartial(e.tip)), r
                }
            }, t.TxBody = {
                typeUrl: "/cosmos.tx.v1beta1.TxBody",
                encode(e, t = s.BinaryWriter.create()) {
                    for (let r of e.messages) n.Any.encode(r, t.uint32(10).fork()).ldelim();
                    for (let r of ("" !== e.memo && t.uint32(18).string(e.memo), e.timeoutHeight !== BigInt(0) && t.uint32(24).uint64(e.timeoutHeight), e.extensionOptions)) n.Any.encode(r, t.uint32(8186).fork()).ldelim();
                    for (let r of e.nonCriticalExtensionOptions) n.Any.encode(r, t.uint32(16378).fork()).ldelim();
                    return t
                },
                decode(e, t) {
                    let r = e instanceof s.BinaryReader ? e : new s.BinaryReader(e),
                        o = void 0 === t ? r.len : r.pos + t,
                        i = m();
                    for (; r.pos < o;) {
                        let e = r.uint32();
                        switch (e >>> 3) {
                            case 1:
                                i.messages.push(n.Any.decode(r, r.uint32()));
                                break;
                            case 2:
                                i.memo = r.string();
                                break;
                            case 3:
                                i.timeoutHeight = r.uint64();
                                break;
                            case 1023:
                                i.extensionOptions.push(n.Any.decode(r, r.uint32()));
                                break;
                            case 2047:
                                i.nonCriticalExtensionOptions.push(n.Any.decode(r, r.uint32()));
                                break;
                            default:
                                r.skipType(7 & e)
                        }
                    }
                    return i
                },
                fromJSON(e) {
                    let t = m();
                    return Array.isArray(e ? .messages) && (t.messages = e.messages.map(e => n.Any.fromJSON(e))), (0, d.isSet)(e.memo) && (t.memo = String(e.memo)), (0, d.isSet)(e.timeoutHeight) && (t.timeoutHeight = BigInt(e.timeoutHeight.toString())), Array.isArray(e ? .extensionOptions) && (t.extensionOptions = e.extensionOptions.map(e => n.Any.fromJSON(e))), Array.isArray(e ? .nonCriticalExtensionOptions) && (t.nonCriticalExtensionOptions = e.nonCriticalExtensionOptions.map(e => n.Any.fromJSON(e))), t
                },
                toJSON(e) {
                    let t = {};
                    return e.messages ? t.messages = e.messages.map(e => e ? n.Any.toJSON(e) : void 0) : t.messages = [], void 0 !== e.memo && (t.memo = e.memo), void 0 !== e.timeoutHeight && (t.timeoutHeight = (e.timeoutHeight || BigInt(0)).toString()), e.extensionOptions ? t.extensionOptions = e.extensionOptions.map(e => e ? n.Any.toJSON(e) : void 0) : t.extensionOptions = [], e.nonCriticalExtensionOptions ? t.nonCriticalExtensionOptions = e.nonCriticalExtensionOptions.map(e => e ? n.Any.toJSON(e) : void 0) : t.nonCriticalExtensionOptions = [], t
                },
                fromPartial(e) {
                    let t = m();
                    return t.messages = e.messages ? .map(e => n.Any.fromPartial(e)) || [], t.memo = e.memo ? ? "", void 0 !== e.timeoutHeight && null !== e.timeoutHeight && (t.timeoutHeight = BigInt(e.timeoutHeight.toString())), t.extensionOptions = e.extensionOptions ? .map(e => n.Any.fromPartial(e)) || [], t.nonCriticalExtensionOptions = e.nonCriticalExtensionOptions ? .map(e => n.Any.fromPartial(e)) || [], t
                }
            }, t.AuthInfo = {
                typeUrl: "/cosmos.tx.v1beta1.AuthInfo",
                encode(e, r = s.BinaryWriter.create()) {
                    for (let n of e.signerInfos) t.SignerInfo.encode(n, r.uint32(10).fork()).ldelim();
                    return void 0 !== e.fee && t.Fee.encode(e.fee, r.uint32(18).fork()).ldelim(), void 0 !== e.tip && t.Tip.encode(e.tip, r.uint32(26).fork()).ldelim(), r
                },
                decode(e, r) {
                    let n = e instanceof s.BinaryReader ? e : new s.BinaryReader(e),
                        o = void 0 === r ? n.len : n.pos + r,
                        i = g();
                    for (; n.pos < o;) {
                        let e = n.uint32();
                        switch (e >>> 3) {
                            case 1:
                                i.signerInfos.push(t.SignerInfo.decode(n, n.uint32()));
                                break;
                            case 2:
                                i.fee = t.Fee.decode(n, n.uint32());
                                break;
                            case 3:
                                i.tip = t.Tip.decode(n, n.uint32());
                                break;
                            default:
                                n.skipType(7 & e)
                        }
                    }
                    return i
                },
                fromJSON(e) {
                    let r = g();
                    return Array.isArray(e ? .signerInfos) && (r.signerInfos = e.signerInfos.map(e => t.SignerInfo.fromJSON(e))), (0, d.isSet)(e.fee) && (r.fee = t.Fee.fromJSON(e.fee)), (0, d.isSet)(e.tip) && (r.tip = t.Tip.fromJSON(e.tip)), r
                },
                toJSON(e) {
                    let r = {};
                    return e.signerInfos ? r.signerInfos = e.signerInfos.map(e => e ? t.SignerInfo.toJSON(e) : void 0) : r.signerInfos = [], void 0 !== e.fee && (r.fee = e.fee ? t.Fee.toJSON(e.fee) : void 0), void 0 !== e.tip && (r.tip = e.tip ? t.Tip.toJSON(e.tip) : void 0), r
                },
                fromPartial(e) {
                    let r = g();
                    return r.signerInfos = e.signerInfos ? .map(e => t.SignerInfo.fromPartial(e)) || [], void 0 !== e.fee && null !== e.fee && (r.fee = t.Fee.fromPartial(e.fee)), void 0 !== e.tip && null !== e.tip && (r.tip = t.Tip.fromPartial(e.tip)), r
                }
            }, t.SignerInfo = {
                typeUrl: "/cosmos.tx.v1beta1.SignerInfo",
                encode: (e, r = s.BinaryWriter.create()) => (void 0 !== e.publicKey && n.Any.encode(e.publicKey, r.uint32(10).fork()).ldelim(), void 0 !== e.modeInfo && t.ModeInfo.encode(e.modeInfo, r.uint32(18).fork()).ldelim(), e.sequence !== BigInt(0) && r.uint32(24).uint64(e.sequence), r),
                decode(e, r) {
                    let o = e instanceof s.BinaryReader ? e : new s.BinaryReader(e),
                        i = void 0 === r ? o.len : o.pos + r,
                        a = f();
                    for (; o.pos < i;) {
                        let e = o.uint32();
                        switch (e >>> 3) {
                            case 1:
                                a.publicKey = n.Any.decode(o, o.uint32());
                                break;
                            case 2:
                                a.modeInfo = t.ModeInfo.decode(o, o.uint32());
                                break;
                            case 3:
                                a.sequence = o.uint64();
                                break;
                            default:
                                o.skipType(7 & e)
                        }
                    }
                    return a
                },
                fromJSON(e) {
                    let r = f();
                    return (0, d.isSet)(e.publicKey) && (r.publicKey = n.Any.fromJSON(e.publicKey)), (0, d.isSet)(e.modeInfo) && (r.modeInfo = t.ModeInfo.fromJSON(e.modeInfo)), (0, d.isSet)(e.sequence) && (r.sequence = BigInt(e.sequence.toString())), r
                },
                toJSON(e) {
                    let r = {};
                    return void 0 !== e.publicKey && (r.publicKey = e.publicKey ? n.Any.toJSON(e.publicKey) : void 0), void 0 !== e.modeInfo && (r.modeInfo = e.modeInfo ? t.ModeInfo.toJSON(e.modeInfo) : void 0), void 0 !== e.sequence && (r.sequence = (e.sequence || BigInt(0)).toString()), r
                },
                fromPartial(e) {
                    let r = f();
                    return void 0 !== e.publicKey && null !== e.publicKey && (r.publicKey = n.Any.fromPartial(e.publicKey)), void 0 !== e.modeInfo && null !== e.modeInfo && (r.modeInfo = t.ModeInfo.fromPartial(e.modeInfo)), void 0 !== e.sequence && null !== e.sequence && (r.sequence = BigInt(e.sequence.toString())), r
                }
            }, t.ModeInfo = {
                typeUrl: "/cosmos.tx.v1beta1.ModeInfo",
                encode: (e, r = s.BinaryWriter.create()) => (void 0 !== e.single && t.ModeInfo_Single.encode(e.single, r.uint32(10).fork()).ldelim(), void 0 !== e.multi && t.ModeInfo_Multi.encode(e.multi, r.uint32(18).fork()).ldelim(), r),
                decode(e, r) {
                    let n = e instanceof s.BinaryReader ? e : new s.BinaryReader(e),
                        o = void 0 === r ? n.len : n.pos + r,
                        i = y();
                    for (; n.pos < o;) {
                        let e = n.uint32();
                        switch (e >>> 3) {
                            case 1:
                                i.single = t.ModeInfo_Single.decode(n, n.uint32());
                                break;
                            case 2:
                                i.multi = t.ModeInfo_Multi.decode(n, n.uint32());
                                break;
                            default:
                                n.skipType(7 & e)
                        }
                    }
                    return i
                },
                fromJSON(e) {
                    let r = y();
                    return (0, d.isSet)(e.single) && (r.single = t.ModeInfo_Single.fromJSON(e.single)), (0, d.isSet)(e.multi) && (r.multi = t.ModeInfo_Multi.fromJSON(e.multi)), r
                },
                toJSON(e) {
                    let r = {};
                    return void 0 !== e.single && (r.single = e.single ? t.ModeInfo_Single.toJSON(e.single) : void 0), void 0 !== e.multi && (r.multi = e.multi ? t.ModeInfo_Multi.toJSON(e.multi) : void 0), r
                },
                fromPartial(e) {
                    let r = y();
                    return void 0 !== e.single && null !== e.single && (r.single = t.ModeInfo_Single.fromPartial(e.single)), void 0 !== e.multi && null !== e.multi && (r.multi = t.ModeInfo_Multi.fromPartial(e.multi)), r
                }
            }, t.ModeInfo_Single = {
                typeUrl: "/cosmos.tx.v1beta1.Single",
                encode: (e, t = s.BinaryWriter.create()) => (0 !== e.mode && t.uint32(8).int32(e.mode), t),
                decode(e, t) {
                    let r = e instanceof s.BinaryReader ? e : new s.BinaryReader(e),
                        n = void 0 === t ? r.len : r.pos + t,
                        o = h();
                    for (; r.pos < n;) {
                        let e = r.uint32();
                        e >>> 3 == 1 ? o.mode = r.int32() : r.skipType(7 & e)
                    }
                    return o
                },
                fromJSON(e) {
                    let t = h();
                    return (0, d.isSet)(e.mode) && (t.mode = (0, o.signModeFromJSON)(e.mode)), t
                },
                toJSON(e) {
                    let t = {};
                    return void 0 !== e.mode && (t.mode = (0, o.signModeToJSON)(e.mode)), t
                },
                fromPartial(e) {
                    let t = h();
                    return t.mode = e.mode ? ? 0, t
                }
            }, t.ModeInfo_Multi = {
                typeUrl: "/cosmos.tx.v1beta1.Multi",
                encode(e, r = s.BinaryWriter.create()) {
                    for (let n of (void 0 !== e.bitarray && i.CompactBitArray.encode(e.bitarray, r.uint32(10).fork()).ldelim(), e.modeInfos)) t.ModeInfo.encode(n, r.uint32(18).fork()).ldelim();
                    return r
                },
                decode(e, r) {
                    let n = e instanceof s.BinaryReader ? e : new s.BinaryReader(e),
                        o = void 0 === r ? n.len : n.pos + r,
                        a = v();
                    for (; n.pos < o;) {
                        let e = n.uint32();
                        switch (e >>> 3) {
                            case 1:
                                a.bitarray = i.CompactBitArray.decode(n, n.uint32());
                                break;
                            case 2:
                                a.modeInfos.push(t.ModeInfo.decode(n, n.uint32()));
                                break;
                            default:
                                n.skipType(7 & e)
                        }
                    }
                    return a
                },
                fromJSON(e) {
                    let r = v();
                    return (0, d.isSet)(e.bitarray) && (r.bitarray = i.CompactBitArray.fromJSON(e.bitarray)), Array.isArray(e ? .modeInfos) && (r.modeInfos = e.modeInfos.map(e => t.ModeInfo.fromJSON(e))), r
                },
                toJSON(e) {
                    let r = {};
                    return void 0 !== e.bitarray && (r.bitarray = e.bitarray ? i.CompactBitArray.toJSON(e.bitarray) : void 0), e.modeInfos ? r.modeInfos = e.modeInfos.map(e => e ? t.ModeInfo.toJSON(e) : void 0) : r.modeInfos = [], r
                },
                fromPartial(e) {
                    let r = v();
                    return void 0 !== e.bitarray && null !== e.bitarray && (r.bitarray = i.CompactBitArray.fromPartial(e.bitarray)), r.modeInfos = e.modeInfos ? .map(e => t.ModeInfo.fromPartial(e)) || [], r
                }
            }, t.Fee = {
                typeUrl: "/cosmos.tx.v1beta1.Fee",
                encode(e, t = s.BinaryWriter.create()) {
                    for (let r of e.amount) a.Coin.encode(r, t.uint32(10).fork()).ldelim();
                    return e.gasLimit !== BigInt(0) && t.uint32(16).uint64(e.gasLimit), "" !== e.payer && t.uint32(26).string(e.payer), "" !== e.granter && t.uint32(34).string(e.granter), t
                },
                decode(e, t) {
                    let r = e instanceof s.BinaryReader ? e : new s.BinaryReader(e),
                        n = void 0 === t ? r.len : r.pos + t,
                        o = b();
                    for (; r.pos < n;) {
                        let e = r.uint32();
                        switch (e >>> 3) {
                            case 1:
                                o.amount.push(a.Coin.decode(r, r.uint32()));
                                break;
                            case 2:
                                o.gasLimit = r.uint64();
                                break;
                            case 3:
                                o.payer = r.string();
                                break;
                            case 4:
                                o.granter = r.string();
                                break;
                            default:
                                r.skipType(7 & e)
                        }
                    }
                    return o
                },
                fromJSON(e) {
                    let t = b();
                    return Array.isArray(e ? .amount) && (t.amount = e.amount.map(e => a.Coin.fromJSON(e))), (0, d.isSet)(e.gasLimit) && (t.gasLimit = BigInt(e.gasLimit.toString())), (0, d.isSet)(e.payer) && (t.payer = String(e.payer)), (0, d.isSet)(e.granter) && (t.granter = String(e.granter)), t
                },
                toJSON(e) {
                    let t = {};
                    return e.amount ? t.amount = e.amount.map(e => e ? a.Coin.toJSON(e) : void 0) : t.amount = [], void 0 !== e.gasLimit && (t.gasLimit = (e.gasLimit || BigInt(0)).toString()), void 0 !== e.payer && (t.payer = e.payer), void 0 !== e.granter && (t.granter = e.granter), t
                },
                fromPartial(e) {
                    let t = b();
                    return t.amount = e.amount ? .map(e => a.Coin.fromPartial(e)) || [], void 0 !== e.gasLimit && null !== e.gasLimit && (t.gasLimit = BigInt(e.gasLimit.toString())), t.payer = e.payer ? ? "", t.granter = e.granter ? ? "", t
                }
            }, t.Tip = {
                typeUrl: "/cosmos.tx.v1beta1.Tip",
                encode(e, t = s.BinaryWriter.create()) {
                    for (let r of e.amount) a.Coin.encode(r, t.uint32(10).fork()).ldelim();
                    return "" !== e.tipper && t.uint32(18).string(e.tipper), t
                },
                decode(e, t) {
                    let r = e instanceof s.BinaryReader ? e : new s.BinaryReader(e),
                        n = void 0 === t ? r.len : r.pos + t,
                        o = S();
                    for (; r.pos < n;) {
                        let e = r.uint32();
                        switch (e >>> 3) {
                            case 1:
                                o.amount.push(a.Coin.decode(r, r.uint32()));
                                break;
                            case 2:
                                o.tipper = r.string();
                                break;
                            default:
                                r.skipType(7 & e)
                        }
                    }
                    return o
                },
                fromJSON(e) {
                    let t = S();
                    return Array.isArray(e ? .amount) && (t.amount = e.amount.map(e => a.Coin.fromJSON(e))), (0, d.isSet)(e.tipper) && (t.tipper = String(e.tipper)), t
                },
                toJSON(e) {
                    let t = {};
                    return e.amount ? t.amount = e.amount.map(e => e ? a.Coin.toJSON(e) : void 0) : t.amount = [], void 0 !== e.tipper && (t.tipper = e.tipper), t
                },
                fromPartial(e) {
                    let t = S();
                    return t.amount = e.amount ? .map(e => a.Coin.fromPartial(e)) || [], t.tipper = e.tipper ? ? "", t
                }
            }, t.AuxSignerData = {
                typeUrl: "/cosmos.tx.v1beta1.AuxSignerData",
                encode: (e, r = s.BinaryWriter.create()) => ("" !== e.address && r.uint32(10).string(e.address), void 0 !== e.signDoc && t.SignDocDirectAux.encode(e.signDoc, r.uint32(18).fork()).ldelim(), 0 !== e.mode && r.uint32(24).int32(e.mode), 0 !== e.sig.length && r.uint32(34).bytes(e.sig), r),
                decode(e, r) {
                    let n = e instanceof s.BinaryReader ? e : new s.BinaryReader(e),
                        o = void 0 === r ? n.len : n.pos + r,
                        i = k();
                    for (; n.pos < o;) {
                        let e = n.uint32();
                        switch (e >>> 3) {
                            case 1:
                                i.address = n.string();
                                break;
                            case 2:
                                i.signDoc = t.SignDocDirectAux.decode(n, n.uint32());
                                break;
                            case 3:
                                i.mode = n.int32();
                                break;
                            case 4:
                                i.sig = n.bytes();
                                break;
                            default:
                                n.skipType(7 & e)
                        }
                    }
                    return i
                },
                fromJSON(e) {
                    let r = k();
                    return (0, d.isSet)(e.address) && (r.address = String(e.address)), (0, d.isSet)(e.signDoc) && (r.signDoc = t.SignDocDirectAux.fromJSON(e.signDoc)), (0, d.isSet)(e.mode) && (r.mode = (0, o.signModeFromJSON)(e.mode)), (0, d.isSet)(e.sig) && (r.sig = (0, d.bytesFromBase64)(e.sig)), r
                },
                toJSON(e) {
                    let r = {};
                    return void 0 !== e.address && (r.address = e.address), void 0 !== e.signDoc && (r.signDoc = e.signDoc ? t.SignDocDirectAux.toJSON(e.signDoc) : void 0), void 0 !== e.mode && (r.mode = (0, o.signModeToJSON)(e.mode)), void 0 !== e.sig && (r.sig = (0, d.base64FromBytes)(void 0 !== e.sig ? e.sig : new Uint8Array)), r
                },
                fromPartial(e) {
                    let r = k();
                    return r.address = e.address ? ? "", void 0 !== e.signDoc && null !== e.signDoc && (r.signDoc = t.SignDocDirectAux.fromPartial(e.signDoc)), r.mode = e.mode ? ? 0, r.sig = e.sig ? ? new Uint8Array, r
                }
            }
        },
        8307: function(e, t, r) {
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: !0
            }), t.QueryClientImpl = t.QueryContractsByCreatorResponse = t.QueryContractsByCreatorRequest = t.QueryParamsResponse = t.QueryParamsRequest = t.QueryPinnedCodesResponse = t.QueryPinnedCodesRequest = t.QueryCodesResponse = t.QueryCodesRequest = t.QueryCodeResponse = t.CodeInfoResponse = t.QueryCodeRequest = t.QuerySmartContractStateResponse = t.QuerySmartContractStateRequest = t.QueryRawContractStateResponse = t.QueryRawContractStateRequest = t.QueryAllContractStateResponse = t.QueryAllContractStateRequest = t.QueryContractsByCodeResponse = t.QueryContractsByCodeRequest = t.QueryContractHistoryResponse = t.QueryContractHistoryRequest = t.QueryContractInfoResponse = t.QueryContractInfoRequest = t.protobufPackage = void 0;
            let n = r(40425),
                o = r(29229),
                i = r(23795),
                a = r(96987);

            function s() {
                return {
                    address: ""
                }
            }

            function d() {
                return {
                    address: "",
                    contractInfo: o.ContractInfo.fromPartial({})
                }
            }

            function c() {
                return {
                    address: "",
                    pagination: void 0
                }
            }

            function l() {
                return {
                    entries: [],
                    pagination: void 0
                }
            }

            function u() {
                return {
                    codeId: BigInt(0),
                    pagination: void 0
                }
            }

            function p() {
                return {
                    contracts: [],
                    pagination: void 0
                }
            }

            function m() {
                return {
                    address: "",
                    pagination: void 0
                }
            }

            function g() {
                return {
                    models: [],
                    pagination: void 0
                }
            }

            function f() {
                return {
                    address: "",
                    queryData: new Uint8Array
                }
            }

            function y() {
                return {
                    data: new Uint8Array
                }
            }

            function h() {
                return {
                    address: "",
                    queryData: new Uint8Array
                }
            }

            function v() {
                return {
                    data: new Uint8Array
                }
            }

            function b() {
                return {
                    codeId: BigInt(0)
                }
            }

            function S() {
                return {
                    codeId: BigInt(0),
                    creator: "",
                    dataHash: new Uint8Array,
                    instantiatePermission: o.AccessConfig.fromPartial({})
                }
            }

            function k() {
                return {
                    codeInfo: void 0,
                    data: new Uint8Array
                }
            }

            function P() {
                return {
                    pagination: void 0
                }
            }

            function _() {
                return {
                    codeInfos: [],
                    pagination: void 0
                }
            }

            function B() {
                return {
                    pagination: void 0
                }
            }

            function O() {
                return {
                    codeIds: [],
                    pagination: void 0
                }
            }

            function R() {
                return {
                    params: o.Params.fromPartial({})
                }
            }

            function A() {
                return {
                    creatorAddress: "",
                    pagination: void 0
                }
            }

            function I() {
                return {
                    contractAddresses: [],
                    pagination: void 0
                }
            }
            t.protobufPackage = "cosmwasm.wasm.v1", t.QueryContractInfoRequest = {
                typeUrl: "/cosmwasm.wasm.v1.QueryContractInfoRequest",
                encode: (e, t = i.BinaryWriter.create()) => ("" !== e.address && t.uint32(10).string(e.address), t),
                decode(e, t) {
                    let r = e instanceof i.BinaryReader ? e : new i.BinaryReader(e),
                        n = void 0 === t ? r.len : r.pos + t,
                        o = s();
                    for (; r.pos < n;) {
                        let e = r.uint32();
                        e >>> 3 == 1 ? o.address = r.string() : r.skipType(7 & e)
                    }
                    return o
                },
                fromJSON(e) {
                    let t = s();
                    return (0, a.isSet)(e.address) && (t.address = String(e.address)), t
                },
                toJSON(e) {
                    let t = {};
                    return void 0 !== e.address && (t.address = e.address), t
                },
                fromPartial(e) {
                    let t = s();
                    return t.address = e.address ? ? "", t
                }
            }, t.QueryContractInfoResponse = {
                typeUrl: "/cosmwasm.wasm.v1.QueryContractInfoResponse",
                encode: (e, t = i.BinaryWriter.create()) => ("" !== e.address && t.uint32(10).string(e.address), void 0 !== e.contractInfo && o.ContractInfo.encode(e.contractInfo, t.uint32(18).fork()).ldelim(), t),
                decode(e, t) {
                    let r = e instanceof i.BinaryReader ? e : new i.BinaryReader(e),
                        n = void 0 === t ? r.len : r.pos + t,
                        a = d();
                    for (; r.pos < n;) {
                        let e = r.uint32();
                        switch (e >>> 3) {
                            case 1:
                                a.address = r.string();
                                break;
                            case 2:
                                a.contractInfo = o.ContractInfo.decode(r, r.uint32());
                                break;
                            default:
                                r.skipType(7 & e)
                        }
                    }
                    return a
                },
                fromJSON(e) {
                    let t = d();
                    return (0, a.isSet)(e.address) && (t.address = String(e.address)), (0, a.isSet)(e.contractInfo) && (t.contractInfo = o.ContractInfo.fromJSON(e.contractInfo)), t
                },
                toJSON(e) {
                    let t = {};
                    return void 0 !== e.address && (t.address = e.address), void 0 !== e.contractInfo && (t.contractInfo = e.contractInfo ? o.ContractInfo.toJSON(e.contractInfo) : void 0), t
                },
                fromPartial(e) {
                    let t = d();
                    return t.address = e.address ? ? "", void 0 !== e.contractInfo && null !== e.contractInfo && (t.contractInfo = o.ContractInfo.fromPartial(e.contractInfo)), t
                }
            }, t.QueryContractHistoryRequest = {
                typeUrl: "/cosmwasm.wasm.v1.QueryContractHistoryRequest",
                encode: (e, t = i.BinaryWriter.create()) => ("" !== e.address && t.uint32(10).string(e.address), void 0 !== e.pagination && n.PageRequest.encode(e.pagination, t.uint32(18).fork()).ldelim(), t),
                decode(e, t) {
                    let r = e instanceof i.BinaryReader ? e : new i.BinaryReader(e),
                        o = void 0 === t ? r.len : r.pos + t,
                        a = c();
                    for (; r.pos < o;) {
                        let e = r.uint32();
                        switch (e >>> 3) {
                            case 1:
                                a.address = r.string();
                                break;
                            case 2:
                                a.pagination = n.PageRequest.decode(r, r.uint32());
                                break;
                            default:
                                r.skipType(7 & e)
                        }
                    }
                    return a
                },
                fromJSON(e) {
                    let t = c();
                    return (0, a.isSet)(e.address) && (t.address = String(e.address)), (0, a.isSet)(e.pagination) && (t.pagination = n.PageRequest.fromJSON(e.pagination)), t
                },
                toJSON(e) {
                    let t = {};
                    return void 0 !== e.address && (t.address = e.address), void 0 !== e.pagination && (t.pagination = e.pagination ? n.PageRequest.toJSON(e.pagination) : void 0), t
                },
                fromPartial(e) {
                    let t = c();
                    return t.address = e.address ? ? "", void 0 !== e.pagination && null !== e.pagination && (t.pagination = n.PageRequest.fromPartial(e.pagination)), t
                }
            }, t.QueryContractHistoryResponse = {
                typeUrl: "/cosmwasm.wasm.v1.QueryContractHistoryResponse",
                encode(e, t = i.BinaryWriter.create()) {
                    for (let r of e.entries) o.ContractCodeHistoryEntry.encode(r, t.uint32(10).fork()).ldelim();
                    return void 0 !== e.pagination && n.PageResponse.encode(e.pagination, t.uint32(18).fork()).ldelim(), t
                },
                decode(e, t) {
                    let r = e instanceof i.BinaryReader ? e : new i.BinaryReader(e),
                        a = void 0 === t ? r.len : r.pos + t,
                        s = l();
                    for (; r.pos < a;) {
                        let e = r.uint32();
                        switch (e >>> 3) {
                            case 1:
                                s.entries.push(o.ContractCodeHistoryEntry.decode(r, r.uint32()));
                                break;
                            case 2:
                                s.pagination = n.PageResponse.decode(r, r.uint32());
                                break;
                            default:
                                r.skipType(7 & e)
                        }
                    }
                    return s
                },
                fromJSON(e) {
                    let t = l();
                    return Array.isArray(e ? .entries) && (t.entries = e.entries.map(e => o.ContractCodeHistoryEntry.fromJSON(e))), (0, a.isSet)(e.pagination) && (t.pagination = n.PageResponse.fromJSON(e.pagination)), t
                },
                toJSON(e) {
                    let t = {};
                    return e.entries ? t.entries = e.entries.map(e => e ? o.ContractCodeHistoryEntry.toJSON(e) : void 0) : t.entries = [], void 0 !== e.pagination && (t.pagination = e.pagination ? n.PageResponse.toJSON(e.pagination) : void 0), t
                },
                fromPartial(e) {
                    let t = l();
                    return t.entries = e.entries ? .map(e => o.ContractCodeHistoryEntry.fromPartial(e)) || [], void 0 !== e.pagination && null !== e.pagination && (t.pagination = n.PageResponse.fromPartial(e.pagination)), t
                }
            }, t.QueryContractsByCodeRequest = {
                typeUrl: "/cosmwasm.wasm.v1.QueryContractsByCodeRequest",
                encode: (e, t = i.BinaryWriter.create()) => (e.codeId !== BigInt(0) && t.uint32(8).uint64(e.codeId), void 0 !== e.pagination && n.PageRequest.encode(e.pagination, t.uint32(18).fork()).ldelim(), t),
                decode(e, t) {
                    let r = e instanceof i.BinaryReader ? e : new i.BinaryReader(e),
                        o = void 0 === t ? r.len : r.pos + t,
                        a = u();
                    for (; r.pos < o;) {
                        let e = r.uint32();
                        switch (e >>> 3) {
                            case 1:
                                a.codeId = r.uint64();
                                break;
                            case 2:
                                a.pagination = n.PageRequest.decode(r, r.uint32());
                                break;
                            default:
                                r.skipType(7 & e)
                        }
                    }
                    return a
                },
                fromJSON(e) {
                    let t = u();
                    return (0, a.isSet)(e.codeId) && (t.codeId = BigInt(e.codeId.toString())), (0, a.isSet)(e.pagination) && (t.pagination = n.PageRequest.fromJSON(e.pagination)), t
                },
                toJSON(e) {
                    let t = {};
                    return void 0 !== e.codeId && (t.codeId = (e.codeId || BigInt(0)).toString()), void 0 !== e.pagination && (t.pagination = e.pagination ? n.PageRequest.toJSON(e.pagination) : void 0), t
                },
                fromPartial(e) {
                    let t = u();
                    return void 0 !== e.codeId && null !== e.codeId && (t.codeId = BigInt(e.codeId.toString())), void 0 !== e.pagination && null !== e.pagination && (t.pagination = n.PageRequest.fromPartial(e.pagination)), t
                }
            }, t.QueryContractsByCodeResponse = {
                typeUrl: "/cosmwasm.wasm.v1.QueryContractsByCodeResponse",
                encode(e, t = i.BinaryWriter.create()) {
                    for (let r of e.contracts) t.uint32(10).string(r);
                    return void 0 !== e.pagination && n.PageResponse.encode(e.pagination, t.uint32(18).fork()).ldelim(), t
                },
                decode(e, t) {
                    let r = e instanceof i.BinaryReader ? e : new i.BinaryReader(e),
                        o = void 0 === t ? r.len : r.pos + t,
                        a = p();
                    for (; r.pos < o;) {
                        let e = r.uint32();
                        switch (e >>> 3) {
                            case 1:
                                a.contracts.push(r.string());
                                break;
                            case 2:
                                a.pagination = n.PageResponse.decode(r, r.uint32());
                                break;
                            default:
                                r.skipType(7 & e)
                        }
                    }
                    return a
                },
                fromJSON(e) {
                    let t = p();
                    return Array.isArray(e ? .contracts) && (t.contracts = e.contracts.map(e => String(e))), (0, a.isSet)(e.pagination) && (t.pagination = n.PageResponse.fromJSON(e.pagination)), t
                },
                toJSON(e) {
                    let t = {};
                    return e.contracts ? t.contracts = e.contracts.map(e => e) : t.contracts = [], void 0 !== e.pagination && (t.pagination = e.pagination ? n.PageResponse.toJSON(e.pagination) : void 0), t
                },
                fromPartial(e) {
                    let t = p();
                    return t.contracts = e.contracts ? .map(e => e) || [], void 0 !== e.pagination && null !== e.pagination && (t.pagination = n.PageResponse.fromPartial(e.pagination)), t
                }
            }, t.QueryAllContractStateRequest = {
                typeUrl: "/cosmwasm.wasm.v1.QueryAllContractStateRequest",
                encode: (e, t = i.BinaryWriter.create()) => ("" !== e.address && t.uint32(10).string(e.address), void 0 !== e.pagination && n.PageRequest.encode(e.pagination, t.uint32(18).fork()).ldelim(), t),
                decode(e, t) {
                    let r = e instanceof i.BinaryReader ? e : new i.BinaryReader(e),
                        o = void 0 === t ? r.len : r.pos + t,
                        a = m();
                    for (; r.pos < o;) {
                        let e = r.uint32();
                        switch (e >>> 3) {
                            case 1:
                                a.address = r.string();
                                break;
                            case 2:
                                a.pagination = n.PageRequest.decode(r, r.uint32());
                                break;
                            default:
                                r.skipType(7 & e)
                        }
                    }
                    return a
                },
                fromJSON(e) {
                    let t = m();
                    return (0, a.isSet)(e.address) && (t.address = String(e.address)), (0, a.isSet)(e.pagination) && (t.pagination = n.PageRequest.fromJSON(e.pagination)), t
                },
                toJSON(e) {
                    let t = {};
                    return void 0 !== e.address && (t.address = e.address), void 0 !== e.pagination && (t.pagination = e.pagination ? n.PageRequest.toJSON(e.pagination) : void 0), t
                },
                fromPartial(e) {
                    let t = m();
                    return t.address = e.address ? ? "", void 0 !== e.pagination && null !== e.pagination && (t.pagination = n.PageRequest.fromPartial(e.pagination)), t
                }
            }, t.QueryAllContractStateResponse = {
                typeUrl: "/cosmwasm.wasm.v1.QueryAllContractStateResponse",
                encode(e, t = i.BinaryWriter.create()) {
                    for (let r of e.models) o.Model.encode(r, t.uint32(10).fork()).ldelim();
                    return void 0 !== e.pagination && n.PageResponse.encode(e.pagination, t.uint32(18).fork()).ldelim(), t
                },
                decode(e, t) {
                    let r = e instanceof i.BinaryReader ? e : new i.BinaryReader(e),
                        a = void 0 === t ? r.len : r.pos + t,
                        s = g();
                    for (; r.pos < a;) {
                        let e = r.uint32();
                        switch (e >>> 3) {
                            case 1:
                                s.models.push(o.Model.decode(r, r.uint32()));
                                break;
                            case 2:
                                s.pagination = n.PageResponse.decode(r, r.uint32());
                                break;
                            default:
                                r.skipType(7 & e)
                        }
                    }
                    return s
                },
                fromJSON(e) {
                    let t = g();
                    return Array.isArray(e ? .models) && (t.models = e.models.map(e => o.Model.fromJSON(e))), (0, a.isSet)(e.pagination) && (t.pagination = n.PageResponse.fromJSON(e.pagination)), t
                },
                toJSON(e) {
                    let t = {};
                    return e.models ? t.models = e.models.map(e => e ? o.Model.toJSON(e) : void 0) : t.models = [], void 0 !== e.pagination && (t.pagination = e.pagination ? n.PageResponse.toJSON(e.pagination) : void 0), t
                },
                fromPartial(e) {
                    let t = g();
                    return t.models = e.models ? .map(e => o.Model.fromPartial(e)) || [], void 0 !== e.pagination && null !== e.pagination && (t.pagination = n.PageResponse.fromPartial(e.pagination)), t
                }
            }, t.QueryRawContractStateRequest = {
                typeUrl: "/cosmwasm.wasm.v1.QueryRawContractStateRequest",
                encode: (e, t = i.BinaryWriter.create()) => ("" !== e.address && t.uint32(10).string(e.address), 0 !== e.queryData.length && t.uint32(18).bytes(e.queryData), t),
                decode(e, t) {
                    let r = e instanceof i.BinaryReader ? e : new i.BinaryReader(e),
                        n = void 0 === t ? r.len : r.pos + t,
                        o = f();
                    for (; r.pos < n;) {
                        let e = r.uint32();
                        switch (e >>> 3) {
                            case 1:
                                o.address = r.string();
                                break;
                            case 2:
                                o.queryData = r.bytes();
                                break;
                            default:
                                r.skipType(7 & e)
                        }
                    }
                    return o
                },
                fromJSON(e) {
                    let t = f();
                    return (0, a.isSet)(e.address) && (t.address = String(e.address)), (0, a.isSet)(e.queryData) && (t.queryData = (0, a.bytesFromBase64)(e.queryData)), t
                },
                toJSON(e) {
                    let t = {};
                    return void 0 !== e.address && (t.address = e.address), void 0 !== e.queryData && (t.queryData = (0, a.base64FromBytes)(void 0 !== e.queryData ? e.queryData : new Uint8Array)), t
                },
                fromPartial(e) {
                    let t = f();
                    return t.address = e.address ? ? "", t.queryData = e.queryData ? ? new Uint8Array, t
                }
            }, t.QueryRawContractStateResponse = {
                typeUrl: "/cosmwasm.wasm.v1.QueryRawContractStateResponse",
                encode: (e, t = i.BinaryWriter.create()) => (0 !== e.data.length && t.uint32(10).bytes(e.data), t),
                decode(e, t) {
                    let r = e instanceof i.BinaryReader ? e : new i.BinaryReader(e),
                        n = void 0 === t ? r.len : r.pos + t,
                        o = y();
                    for (; r.pos < n;) {
                        let e = r.uint32();
                        e >>> 3 == 1 ? o.data = r.bytes() : r.skipType(7 & e)
                    }
                    return o
                },
                fromJSON(e) {
                    let t = y();
                    return (0, a.isSet)(e.data) && (t.data = (0, a.bytesFromBase64)(e.data)), t
                },
                toJSON(e) {
                    let t = {};
                    return void 0 !== e.data && (t.data = (0, a.base64FromBytes)(void 0 !== e.data ? e.data : new Uint8Array)), t
                },
                fromPartial(e) {
                    let t = y();
                    return t.data = e.data ? ? new Uint8Array, t
                }
            }, t.QuerySmartContractStateRequest = {
                typeUrl: "/cosmwasm.wasm.v1.QuerySmartContractStateRequest",
                encode: (e, t = i.BinaryWriter.create()) => ("" !== e.address && t.uint32(10).string(e.address), 0 !== e.queryData.length && t.uint32(18).bytes(e.queryData), t),
                decode(e, t) {
                    let r = e instanceof i.BinaryReader ? e : new i.BinaryReader(e),
                        n = void 0 === t ? r.len : r.pos + t,
                        o = h();
                    for (; r.pos < n;) {
                        let e = r.uint32();
                        switch (e >>> 3) {
                            case 1:
                                o.address = r.string();
                                break;
                            case 2:
                                o.queryData = r.bytes();
                                break;
                            default:
                                r.skipType(7 & e)
                        }
                    }
                    return o
                },
                fromJSON(e) {
                    let t = h();
                    return (0, a.isSet)(e.address) && (t.address = String(e.address)), (0, a.isSet)(e.queryData) && (t.queryData = (0, a.bytesFromBase64)(e.queryData)), t
                },
                toJSON(e) {
                    let t = {};
                    return void 0 !== e.address && (t.address = e.address), void 0 !== e.queryData && (t.queryData = (0, a.base64FromBytes)(void 0 !== e.queryData ? e.queryData : new Uint8Array)), t
                },
                fromPartial(e) {
                    let t = h();
                    return t.address = e.address ? ? "", t.queryData = e.queryData ? ? new Uint8Array, t
                }
            }, t.QuerySmartContractStateResponse = {
                typeUrl: "/cosmwasm.wasm.v1.QuerySmartContractStateResponse",
                encode: (e, t = i.BinaryWriter.create()) => (0 !== e.data.length && t.uint32(10).bytes(e.data), t),
                decode(e, t) {
                    let r = e instanceof i.BinaryReader ? e : new i.BinaryReader(e),
                        n = void 0 === t ? r.len : r.pos + t,
                        o = v();
                    for (; r.pos < n;) {
                        let e = r.uint32();
                        e >>> 3 == 1 ? o.data = r.bytes() : r.skipType(7 & e)
                    }
                    return o
                },
                fromJSON(e) {
                    let t = v();
                    return (0, a.isSet)(e.data) && (t.data = (0, a.bytesFromBase64)(e.data)), t
                },
                toJSON(e) {
                    let t = {};
                    return void 0 !== e.data && (t.data = (0, a.base64FromBytes)(void 0 !== e.data ? e.data : new Uint8Array)), t
                },
                fromPartial(e) {
                    let t = v();
                    return t.data = e.data ? ? new Uint8Array, t
                }
            }, t.QueryCodeRequest = {
                typeUrl: "/cosmwasm.wasm.v1.QueryCodeRequest",
                encode: (e, t = i.BinaryWriter.create()) => (e.codeId !== BigInt(0) && t.uint32(8).uint64(e.codeId), t),
                decode(e, t) {
                    let r = e instanceof i.BinaryReader ? e : new i.BinaryReader(e),
                        n = void 0 === t ? r.len : r.pos + t,
                        o = b();
                    for (; r.pos < n;) {
                        let e = r.uint32();
                        e >>> 3 == 1 ? o.codeId = r.uint64() : r.skipType(7 & e)
                    }
                    return o
                },
                fromJSON(e) {
                    let t = b();
                    return (0, a.isSet)(e.codeId) && (t.codeId = BigInt(e.codeId.toString())), t
                },
                toJSON(e) {
                    let t = {};
                    return void 0 !== e.codeId && (t.codeId = (e.codeId || BigInt(0)).toString()), t
                },
                fromPartial(e) {
                    let t = b();
                    return void 0 !== e.codeId && null !== e.codeId && (t.codeId = BigInt(e.codeId.toString())), t
                }
            }, t.CodeInfoResponse = {
                typeUrl: "/cosmwasm.wasm.v1.CodeInfoResponse",
                encode: (e, t = i.BinaryWriter.create()) => (e.codeId !== BigInt(0) && t.uint32(8).uint64(e.codeId), "" !== e.creator && t.uint32(18).string(e.creator), 0 !== e.dataHash.length && t.uint32(26).bytes(e.dataHash), void 0 !== e.instantiatePermission && o.AccessConfig.encode(e.instantiatePermission, t.uint32(50).fork()).ldelim(), t),
                decode(e, t) {
                    let r = e instanceof i.BinaryReader ? e : new i.BinaryReader(e),
                        n = void 0 === t ? r.len : r.pos + t,
                        a = S();
                    for (; r.pos < n;) {
                        let e = r.uint32();
                        switch (e >>> 3) {
                            case 1:
                                a.codeId = r.uint64();
                                break;
                            case 2:
                                a.creator = r.string();
                                break;
                            case 3:
                                a.dataHash = r.bytes();
                                break;
                            case 6:
                                a.instantiatePermission = o.AccessConfig.decode(r, r.uint32());
                                break;
                            default:
                                r.skipType(7 & e)
                        }
                    }
                    return a
                },
                fromJSON(e) {
                    let t = S();
                    return (0, a.isSet)(e.codeId) && (t.codeId = BigInt(e.codeId.toString())), (0, a.isSet)(e.creator) && (t.creator = String(e.creator)), (0, a.isSet)(e.dataHash) && (t.dataHash = (0, a.bytesFromBase64)(e.dataHash)), (0, a.isSet)(e.instantiatePermission) && (t.instantiatePermission = o.AccessConfig.fromJSON(e.instantiatePermission)), t
                },
                toJSON(e) {
                    let t = {};
                    return void 0 !== e.codeId && (t.codeId = (e.codeId || BigInt(0)).toString()), void 0 !== e.creator && (t.creator = e.creator), void 0 !== e.dataHash && (t.dataHash = (0, a.base64FromBytes)(void 0 !== e.dataHash ? e.dataHash : new Uint8Array)), void 0 !== e.instantiatePermission && (t.instantiatePermission = e.instantiatePermission ? o.AccessConfig.toJSON(e.instantiatePermission) : void 0), t
                },
                fromPartial(e) {
                    let t = S();
                    return void 0 !== e.codeId && null !== e.codeId && (t.codeId = BigInt(e.codeId.toString())), t.creator = e.creator ? ? "", t.dataHash = e.dataHash ? ? new Uint8Array, void 0 !== e.instantiatePermission && null !== e.instantiatePermission && (t.instantiatePermission = o.AccessConfig.fromPartial(e.instantiatePermission)), t
                }
            }, t.QueryCodeResponse = {
                typeUrl: "/cosmwasm.wasm.v1.QueryCodeResponse",
                encode: (e, r = i.BinaryWriter.create()) => (void 0 !== e.codeInfo && t.CodeInfoResponse.encode(e.codeInfo, r.uint32(10).fork()).ldelim(), 0 !== e.data.length && r.uint32(18).bytes(e.data), r),
                decode(e, r) {
                    let n = e instanceof i.BinaryReader ? e : new i.BinaryReader(e),
                        o = void 0 === r ? n.len : n.pos + r,
                        a = k();
                    for (; n.pos < o;) {
                        let e = n.uint32();
                        switch (e >>> 3) {
                            case 1:
                                a.codeInfo = t.CodeInfoResponse.decode(n, n.uint32());
                                break;
                            case 2:
                                a.data = n.bytes();
                                break;
                            default:
                                n.skipType(7 & e)
                        }
                    }
                    return a
                },
                fromJSON(e) {
                    let r = k();
                    return (0, a.isSet)(e.codeInfo) && (r.codeInfo = t.CodeInfoResponse.fromJSON(e.codeInfo)), (0, a.isSet)(e.data) && (r.data = (0, a.bytesFromBase64)(e.data)), r
                },
                toJSON(e) {
                    let r = {};
                    return void 0 !== e.codeInfo && (r.codeInfo = e.codeInfo ? t.CodeInfoResponse.toJSON(e.codeInfo) : void 0), void 0 !== e.data && (r.data = (0, a.base64FromBytes)(void 0 !== e.data ? e.data : new Uint8Array)), r
                },
                fromPartial(e) {
                    let r = k();
                    return void 0 !== e.codeInfo && null !== e.codeInfo && (r.codeInfo = t.CodeInfoResponse.fromPartial(e.codeInfo)), r.data = e.data ? ? new Uint8Array, r
                }
            }, t.QueryCodesRequest = {
                typeUrl: "/cosmwasm.wasm.v1.QueryCodesRequest",
                encode: (e, t = i.BinaryWriter.create()) => (void 0 !== e.pagination && n.PageRequest.encode(e.pagination, t.uint32(10).fork()).ldelim(), t),
                decode(e, t) {
                    let r = e instanceof i.BinaryReader ? e : new i.BinaryReader(e),
                        o = void 0 === t ? r.len : r.pos + t,
                        a = P();
                    for (; r.pos < o;) {
                        let e = r.uint32();
                        e >>> 3 == 1 ? a.pagination = n.PageRequest.decode(r, r.uint32()) : r.skipType(7 & e)
                    }
                    return a
                },
                fromJSON(e) {
                    let t = P();
                    return (0, a.isSet)(e.pagination) && (t.pagination = n.PageRequest.fromJSON(e.pagination)), t
                },
                toJSON(e) {
                    let t = {};
                    return void 0 !== e.pagination && (t.pagination = e.pagination ? n.PageRequest.toJSON(e.pagination) : void 0), t
                },
                fromPartial(e) {
                    let t = P();
                    return void 0 !== e.pagination && null !== e.pagination && (t.pagination = n.PageRequest.fromPartial(e.pagination)), t
                }
            }, t.QueryCodesResponse = {
                typeUrl: "/cosmwasm.wasm.v1.QueryCodesResponse",
                encode(e, r = i.BinaryWriter.create()) {
                    for (let n of e.codeInfos) t.CodeInfoResponse.encode(n, r.uint32(10).fork()).ldelim();
                    return void 0 !== e.pagination && n.PageResponse.encode(e.pagination, r.uint32(18).fork()).ldelim(), r
                },
                decode(e, r) {
                    let o = e instanceof i.BinaryReader ? e : new i.BinaryReader(e),
                        a = void 0 === r ? o.len : o.pos + r,
                        s = _();
                    for (; o.pos < a;) {
                        let e = o.uint32();
                        switch (e >>> 3) {
                            case 1:
                                s.codeInfos.push(t.CodeInfoResponse.decode(o, o.uint32()));
                                break;
                            case 2:
                                s.pagination = n.PageResponse.decode(o, o.uint32());
                                break;
                            default:
                                o.skipType(7 & e)
                        }
                    }
                    return s
                },
                fromJSON(e) {
                    let r = _();
                    return Array.isArray(e ? .codeInfos) && (r.codeInfos = e.codeInfos.map(e => t.CodeInfoResponse.fromJSON(e))), (0, a.isSet)(e.pagination) && (r.pagination = n.PageResponse.fromJSON(e.pagination)), r
                },
                toJSON(e) {
                    let r = {};
                    return e.codeInfos ? r.codeInfos = e.codeInfos.map(e => e ? t.CodeInfoResponse.toJSON(e) : void 0) : r.codeInfos = [], void 0 !== e.pagination && (r.pagination = e.pagination ? n.PageResponse.toJSON(e.pagination) : void 0), r
                },
                fromPartial(e) {
                    let r = _();
                    return r.codeInfos = e.codeInfos ? .map(e => t.CodeInfoResponse.fromPartial(e)) || [], void 0 !== e.pagination && null !== e.pagination && (r.pagination = n.PageResponse.fromPartial(e.pagination)), r
                }
            }, t.QueryPinnedCodesRequest = {
                typeUrl: "/cosmwasm.wasm.v1.QueryPinnedCodesRequest",
                encode: (e, t = i.BinaryWriter.create()) => (void 0 !== e.pagination && n.PageRequest.encode(e.pagination, t.uint32(18).fork()).ldelim(), t),
                decode(e, t) {
                    let r = e instanceof i.BinaryReader ? e : new i.BinaryReader(e),
                        o = void 0 === t ? r.len : r.pos + t,
                        a = B();
                    for (; r.pos < o;) {
                        let e = r.uint32();
                        e >>> 3 == 2 ? a.pagination = n.PageRequest.decode(r, r.uint32()) : r.skipType(7 & e)
                    }
                    return a
                },
                fromJSON(e) {
                    let t = B();
                    return (0, a.isSet)(e.pagination) && (t.pagination = n.PageRequest.fromJSON(e.pagination)), t
                },
                toJSON(e) {
                    let t = {};
                    return void 0 !== e.pagination && (t.pagination = e.pagination ? n.PageRequest.toJSON(e.pagination) : void 0), t
                },
                fromPartial(e) {
                    let t = B();
                    return void 0 !== e.pagination && null !== e.pagination && (t.pagination = n.PageRequest.fromPartial(e.pagination)), t
                }
            }, t.QueryPinnedCodesResponse = {
                typeUrl: "/cosmwasm.wasm.v1.QueryPinnedCodesResponse",
                encode(e, t = i.BinaryWriter.create()) {
                    for (let r of (t.uint32(10).fork(), e.codeIds)) t.uint64(r);
                    return t.ldelim(), void 0 !== e.pagination && n.PageResponse.encode(e.pagination, t.uint32(18).fork()).ldelim(), t
                },
                decode(e, t) {
                    let r = e instanceof i.BinaryReader ? e : new i.BinaryReader(e),
                        o = void 0 === t ? r.len : r.pos + t,
                        a = O();
                    for (; r.pos < o;) {
                        let e = r.uint32();
                        switch (e >>> 3) {
                            case 1:
                                if ((7 & e) == 2) {
                                    let e = r.uint32() + r.pos;
                                    for (; r.pos < e;) a.codeIds.push(r.uint64())
                                } else a.codeIds.push(r.uint64());
                                break;
                            case 2:
                                a.pagination = n.PageResponse.decode(r, r.uint32());
                                break;
                            default:
                                r.skipType(7 & e)
                        }
                    }
                    return a
                },
                fromJSON(e) {
                    let t = O();
                    return Array.isArray(e ? .codeIds) && (t.codeIds = e.codeIds.map(e => BigInt(e.toString()))), (0, a.isSet)(e.pagination) && (t.pagination = n.PageResponse.fromJSON(e.pagination)), t
                },
                toJSON(e) {
                    let t = {};
                    return e.codeIds ? t.codeIds = e.codeIds.map(e => (e || BigInt(0)).toString()) : t.codeIds = [], void 0 !== e.pagination && (t.pagination = e.pagination ? n.PageResponse.toJSON(e.pagination) : void 0), t
                },
                fromPartial(e) {
                    let t = O();
                    return t.codeIds = e.codeIds ? .map(e => BigInt(e.toString())) || [], void 0 !== e.pagination && null !== e.pagination && (t.pagination = n.PageResponse.fromPartial(e.pagination)), t
                }
            }, t.QueryParamsRequest = {
                typeUrl: "/cosmwasm.wasm.v1.QueryParamsRequest",
                encode: (e, t = i.BinaryWriter.create()) => t,
                decode(e, t) {
                    let r = e instanceof i.BinaryReader ? e : new i.BinaryReader(e),
                        n = void 0 === t ? r.len : r.pos + t;
                    for (; r.pos < n;) {
                        let e = r.uint32();
                        r.skipType(7 & e)
                    }
                    return {}
                },
                fromJSON: e => ({}),
                toJSON: e => ({}),
                fromPartial: e => ({})
            }, t.QueryParamsResponse = {
                typeUrl: "/cosmwasm.wasm.v1.QueryParamsResponse",
                encode: (e, t = i.BinaryWriter.create()) => (void 0 !== e.params && o.Params.encode(e.params, t.uint32(10).fork()).ldelim(), t),
                decode(e, t) {
                    let r = e instanceof i.BinaryReader ? e : new i.BinaryReader(e),
                        n = void 0 === t ? r.len : r.pos + t,
                        a = R();
                    for (; r.pos < n;) {
                        let e = r.uint32();
                        e >>> 3 == 1 ? a.params = o.Params.decode(r, r.uint32()) : r.skipType(7 & e)
                    }
                    return a
                },
                fromJSON(e) {
                    let t = R();
                    return (0, a.isSet)(e.params) && (t.params = o.Params.fromJSON(e.params)), t
                },
                toJSON(e) {
                    let t = {};
                    return void 0 !== e.params && (t.params = e.params ? o.Params.toJSON(e.params) : void 0), t
                },
                fromPartial(e) {
                    let t = R();
                    return void 0 !== e.params && null !== e.params && (t.params = o.Params.fromPartial(e.params)), t
                }
            }, t.QueryContractsByCreatorRequest = {
                typeUrl: "/cosmwasm.wasm.v1.QueryContractsByCreatorRequest",
                encode: (e, t = i.BinaryWriter.create()) => ("" !== e.creatorAddress && t.uint32(10).string(e.creatorAddress), void 0 !== e.pagination && n.PageRequest.encode(e.pagination, t.uint32(18).fork()).ldelim(), t),
                decode(e, t) {
                    let r = e instanceof i.BinaryReader ? e : new i.BinaryReader(e),
                        o = void 0 === t ? r.len : r.pos + t,
                        a = A();
                    for (; r.pos < o;) {
                        let e = r.uint32();
                        switch (e >>> 3) {
                            case 1:
                                a.creatorAddress = r.string();
                                break;
                            case 2:
                                a.pagination = n.PageRequest.decode(r, r.uint32());
                                break;
                            default:
                                r.skipType(7 & e)
                        }
                    }
                    return a
                },
                fromJSON(e) {
                    let t = A();
                    return (0, a.isSet)(e.creatorAddress) && (t.creatorAddress = String(e.creatorAddress)), (0, a.isSet)(e.pagination) && (t.pagination = n.PageRequest.fromJSON(e.pagination)), t
                },
                toJSON(e) {
                    let t = {};
                    return void 0 !== e.creatorAddress && (t.creatorAddress = e.creatorAddress), void 0 !== e.pagination && (t.pagination = e.pagination ? n.PageRequest.toJSON(e.pagination) : void 0), t
                },
                fromPartial(e) {
                    let t = A();
                    return t.creatorAddress = e.creatorAddress ? ? "", void 0 !== e.pagination && null !== e.pagination && (t.pagination = n.PageRequest.fromPartial(e.pagination)), t
                }
            }, t.QueryContractsByCreatorResponse = {
                typeUrl: "/cosmwasm.wasm.v1.QueryContractsByCreatorResponse",
                encode(e, t = i.BinaryWriter.create()) {
                    for (let r of e.contractAddresses) t.uint32(10).string(r);
                    return void 0 !== e.pagination && n.PageResponse.encode(e.pagination, t.uint32(18).fork()).ldelim(), t
                },
                decode(e, t) {
                    let r = e instanceof i.BinaryReader ? e : new i.BinaryReader(e),
                        o = void 0 === t ? r.len : r.pos + t,
                        a = I();
                    for (; r.pos < o;) {
                        let e = r.uint32();
                        switch (e >>> 3) {
                            case 1:
                                a.contractAddresses.push(r.string());
                                break;
                            case 2:
                                a.pagination = n.PageResponse.decode(r, r.uint32());
                                break;
                            default:
                                r.skipType(7 & e)
                        }
                    }
                    return a
                },
                fromJSON(e) {
                    let t = I();
                    return Array.isArray(e ? .contractAddresses) && (t.contractAddresses = e.contractAddresses.map(e => String(e))), (0, a.isSet)(e.pagination) && (t.pagination = n.PageResponse.fromJSON(e.pagination)), t
                },
                toJSON(e) {
                    let t = {};
                    return e.contractAddresses ? t.contractAddresses = e.contractAddresses.map(e => e) : t.contractAddresses = [], void 0 !== e.pagination && (t.pagination = e.pagination ? n.PageResponse.toJSON(e.pagination) : void 0), t
                },
                fromPartial(e) {
                    let t = I();
                    return t.contractAddresses = e.contractAddresses ? .map(e => e) || [], void 0 !== e.pagination && null !== e.pagination && (t.pagination = n.PageResponse.fromPartial(e.pagination)), t
                }
            };
            class w {
                constructor(e) {
                    this.rpc = e, this.ContractInfo = this.ContractInfo.bind(this), this.ContractHistory = this.ContractHistory.bind(this), this.ContractsByCode = this.ContractsByCode.bind(this), this.AllContractState = this.AllContractState.bind(this), this.RawContractState = this.RawContractState.bind(this), this.SmartContractState = this.SmartContractState.bind(this), this.Code = this.Code.bind(this), this.Codes = this.Codes.bind(this), this.PinnedCodes = this.PinnedCodes.bind(this), this.Params = this.Params.bind(this), this.ContractsByCreator = this.ContractsByCreator.bind(this)
                }
                ContractInfo(e) {
                    let r = t.QueryContractInfoRequest.encode(e).finish();
                    return this.rpc.request("cosmwasm.wasm.v1.Query", "ContractInfo", r).then(e => t.QueryContractInfoResponse.decode(new i.BinaryReader(e)))
                }
                ContractHistory(e) {
                    let r = t.QueryContractHistoryRequest.encode(e).finish();
                    return this.rpc.request("cosmwasm.wasm.v1.Query", "ContractHistory", r).then(e => t.QueryContractHistoryResponse.decode(new i.BinaryReader(e)))
                }
                ContractsByCode(e) {
                    let r = t.QueryContractsByCodeRequest.encode(e).finish();
                    return this.rpc.request("cosmwasm.wasm.v1.Query", "ContractsByCode", r).then(e => t.QueryContractsByCodeResponse.decode(new i.BinaryReader(e)))
                }
                AllContractState(e) {
                    let r = t.QueryAllContractStateRequest.encode(e).finish();
                    return this.rpc.request("cosmwasm.wasm.v1.Query", "AllContractState", r).then(e => t.QueryAllContractStateResponse.decode(new i.BinaryReader(e)))
                }
                RawContractState(e) {
                    let r = t.QueryRawContractStateRequest.encode(e).finish();
                    return this.rpc.request("cosmwasm.wasm.v1.Query", "RawContractState", r).then(e => t.QueryRawContractStateResponse.decode(new i.BinaryReader(e)))
                }
                SmartContractState(e) {
                    let r = t.QuerySmartContractStateRequest.encode(e).finish();
                    return this.rpc.request("cosmwasm.wasm.v1.Query", "SmartContractState", r).then(e => t.QuerySmartContractStateResponse.decode(new i.BinaryReader(e)))
                }
                Code(e) {
                    let r = t.QueryCodeRequest.encode(e).finish();
                    return this.rpc.request("cosmwasm.wasm.v1.Query", "Code", r).then(e => t.QueryCodeResponse.decode(new i.BinaryReader(e)))
                }
                Codes(e = {
                    pagination: n.PageRequest.fromPartial({})
                }) {
                    let r = t.QueryCodesRequest.encode(e).finish();
                    return this.rpc.request("cosmwasm.wasm.v1.Query", "Codes", r).then(e => t.QueryCodesResponse.decode(new i.BinaryReader(e)))
                }
                PinnedCodes(e = {
                    pagination: n.PageRequest.fromPartial({})
                }) {
                    let r = t.QueryPinnedCodesRequest.encode(e).finish();
                    return this.rpc.request("cosmwasm.wasm.v1.Query", "PinnedCodes", r).then(e => t.QueryPinnedCodesResponse.decode(new i.BinaryReader(e)))
                }
                Params(e = {}) {
                    let r = t.QueryParamsRequest.encode(e).finish();
                    return this.rpc.request("cosmwasm.wasm.v1.Query", "Params", r).then(e => t.QueryParamsResponse.decode(new i.BinaryReader(e)))
                }
                ContractsByCreator(e) {
                    let r = t.QueryContractsByCreatorRequest.encode(e).finish();
                    return this.rpc.request("cosmwasm.wasm.v1.Query", "ContractsByCreator", r).then(e => t.QueryContractsByCreatorResponse.decode(new i.BinaryReader(e)))
                }
            }
            t.QueryClientImpl = w
        },
        91420: function(e, t, r) {
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: !0
            }), t.MsgClientImpl = t.MsgUpdateInstantiateConfigResponse = t.MsgUpdateInstantiateConfig = t.MsgClearAdminResponse = t.MsgClearAdmin = t.MsgUpdateAdminResponse = t.MsgUpdateAdmin = t.MsgMigrateContractResponse = t.MsgMigrateContract = t.MsgExecuteContractResponse = t.MsgExecuteContract = t.MsgInstantiateContract2Response = t.MsgInstantiateContractResponse = t.MsgInstantiateContract2 = t.MsgInstantiateContract = t.MsgStoreCodeResponse = t.MsgStoreCode = t.protobufPackage = void 0;
            let n = r(29229),
                o = r(91408),
                i = r(23795),
                a = r(96987);

            function s() {
                return {
                    sender: "",
                    wasmByteCode: new Uint8Array,
                    instantiatePermission: void 0
                }
            }

            function d() {
                return {
                    codeId: BigInt(0),
                    checksum: new Uint8Array
                }
            }

            function c() {
                return {
                    sender: "",
                    admin: "",
                    codeId: BigInt(0),
                    label: "",
                    msg: new Uint8Array,
                    funds: []
                }
            }

            function l() {
                return {
                    sender: "",
                    admin: "",
                    codeId: BigInt(0),
                    label: "",
                    msg: new Uint8Array,
                    funds: [],
                    salt: new Uint8Array,
                    fixMsg: !1
                }
            }

            function u() {
                return {
                    address: "",
                    data: new Uint8Array
                }
            }

            function p() {
                return {
                    address: "",
                    data: new Uint8Array
                }
            }

            function m() {
                return {
                    sender: "",
                    contract: "",
                    msg: new Uint8Array,
                    funds: []
                }
            }

            function g() {
                return {
                    data: new Uint8Array
                }
            }

            function f() {
                return {
                    sender: "",
                    contract: "",
                    codeId: BigInt(0),
                    msg: new Uint8Array
                }
            }

            function y() {
                return {
                    data: new Uint8Array
                }
            }

            function h() {
                return {
                    sender: "",
                    newAdmin: "",
                    contract: ""
                }
            }

            function v() {
                return {
                    sender: "",
                    contract: ""
                }
            }

            function b() {
                return {
                    sender: "",
                    codeId: BigInt(0),
                    newInstantiatePermission: void 0
                }
            }
            t.protobufPackage = "cosmwasm.wasm.v1", t.MsgStoreCode = {
                typeUrl: "/cosmwasm.wasm.v1.MsgStoreCode",
                encode: (e, t = i.BinaryWriter.create()) => ("" !== e.sender && t.uint32(10).string(e.sender), 0 !== e.wasmByteCode.length && t.uint32(18).bytes(e.wasmByteCode), void 0 !== e.instantiatePermission && n.AccessConfig.encode(e.instantiatePermission, t.uint32(42).fork()).ldelim(), t),
                decode(e, t) {
                    let r = e instanceof i.BinaryReader ? e : new i.BinaryReader(e),
                        o = void 0 === t ? r.len : r.pos + t,
                        a = s();
                    for (; r.pos < o;) {
                        let e = r.uint32();
                        switch (e >>> 3) {
                            case 1:
                                a.sender = r.string();
                                break;
                            case 2:
                                a.wasmByteCode = r.bytes();
                                break;
                            case 5:
                                a.instantiatePermission = n.AccessConfig.decode(r, r.uint32());
                                break;
                            default:
                                r.skipType(7 & e)
                        }
                    }
                    return a
                },
                fromJSON(e) {
                    let t = s();
                    return (0, a.isSet)(e.sender) && (t.sender = String(e.sender)), (0, a.isSet)(e.wasmByteCode) && (t.wasmByteCode = (0, a.bytesFromBase64)(e.wasmByteCode)), (0, a.isSet)(e.instantiatePermission) && (t.instantiatePermission = n.AccessConfig.fromJSON(e.instantiatePermission)), t
                },
                toJSON(e) {
                    let t = {};
                    return void 0 !== e.sender && (t.sender = e.sender), void 0 !== e.wasmByteCode && (t.wasmByteCode = (0, a.base64FromBytes)(void 0 !== e.wasmByteCode ? e.wasmByteCode : new Uint8Array)), void 0 !== e.instantiatePermission && (t.instantiatePermission = e.instantiatePermission ? n.AccessConfig.toJSON(e.instantiatePermission) : void 0), t
                },
                fromPartial(e) {
                    let t = s();
                    return t.sender = e.sender ? ? "", t.wasmByteCode = e.wasmByteCode ? ? new Uint8Array, void 0 !== e.instantiatePermission && null !== e.instantiatePermission && (t.instantiatePermission = n.AccessConfig.fromPartial(e.instantiatePermission)), t
                }
            }, t.MsgStoreCodeResponse = {
                typeUrl: "/cosmwasm.wasm.v1.MsgStoreCodeResponse",
                encode: (e, t = i.BinaryWriter.create()) => (e.codeId !== BigInt(0) && t.uint32(8).uint64(e.codeId), 0 !== e.checksum.length && t.uint32(18).bytes(e.checksum), t),
                decode(e, t) {
                    let r = e instanceof i.BinaryReader ? e : new i.BinaryReader(e),
                        n = void 0 === t ? r.len : r.pos + t,
                        o = d();
                    for (; r.pos < n;) {
                        let e = r.uint32();
                        switch (e >>> 3) {
                            case 1:
                                o.codeId = r.uint64();
                                break;
                            case 2:
                                o.checksum = r.bytes();
                                break;
                            default:
                                r.skipType(7 & e)
                        }
                    }
                    return o
                },
                fromJSON(e) {
                    let t = d();
                    return (0, a.isSet)(e.codeId) && (t.codeId = BigInt(e.codeId.toString())), (0, a.isSet)(e.checksum) && (t.checksum = (0, a.bytesFromBase64)(e.checksum)), t
                },
                toJSON(e) {
                    let t = {};
                    return void 0 !== e.codeId && (t.codeId = (e.codeId || BigInt(0)).toString()), void 0 !== e.checksum && (t.checksum = (0, a.base64FromBytes)(void 0 !== e.checksum ? e.checksum : new Uint8Array)), t
                },
                fromPartial(e) {
                    let t = d();
                    return void 0 !== e.codeId && null !== e.codeId && (t.codeId = BigInt(e.codeId.toString())), t.checksum = e.checksum ? ? new Uint8Array, t
                }
            }, t.MsgInstantiateContract = {
                typeUrl: "/cosmwasm.wasm.v1.MsgInstantiateContract",
                encode(e, t = i.BinaryWriter.create()) {
                    for (let r of ("" !== e.sender && t.uint32(10).string(e.sender), "" !== e.admin && t.uint32(18).string(e.admin), e.codeId !== BigInt(0) && t.uint32(24).uint64(e.codeId), "" !== e.label && t.uint32(34).string(e.label), 0 !== e.msg.length && t.uint32(42).bytes(e.msg), e.funds)) o.Coin.encode(r, t.uint32(50).fork()).ldelim();
                    return t
                },
                decode(e, t) {
                    let r = e instanceof i.BinaryReader ? e : new i.BinaryReader(e),
                        n = void 0 === t ? r.len : r.pos + t,
                        a = c();
                    for (; r.pos < n;) {
                        let e = r.uint32();
                        switch (e >>> 3) {
                            case 1:
                                a.sender = r.string();
                                break;
                            case 2:
                                a.admin = r.string();
                                break;
                            case 3:
                                a.codeId = r.uint64();
                                break;
                            case 4:
                                a.label = r.string();
                                break;
                            case 5:
                                a.msg = r.bytes();
                                break;
                            case 6:
                                a.funds.push(o.Coin.decode(r, r.uint32()));
                                break;
                            default:
                                r.skipType(7 & e)
                        }
                    }
                    return a
                },
                fromJSON(e) {
                    let t = c();
                    return (0, a.isSet)(e.sender) && (t.sender = String(e.sender)), (0, a.isSet)(e.admin) && (t.admin = String(e.admin)), (0, a.isSet)(e.codeId) && (t.codeId = BigInt(e.codeId.toString())), (0, a.isSet)(e.label) && (t.label = String(e.label)), (0, a.isSet)(e.msg) && (t.msg = (0, a.bytesFromBase64)(e.msg)), Array.isArray(e ? .funds) && (t.funds = e.funds.map(e => o.Coin.fromJSON(e))), t
                },
                toJSON(e) {
                    let t = {};
                    return void 0 !== e.sender && (t.sender = e.sender), void 0 !== e.admin && (t.admin = e.admin), void 0 !== e.codeId && (t.codeId = (e.codeId || BigInt(0)).toString()), void 0 !== e.label && (t.label = e.label), void 0 !== e.msg && (t.msg = (0, a.base64FromBytes)(void 0 !== e.msg ? e.msg : new Uint8Array)), e.funds ? t.funds = e.funds.map(e => e ? o.Coin.toJSON(e) : void 0) : t.funds = [], t
                },
                fromPartial(e) {
                    let t = c();
                    return t.sender = e.sender ? ? "", t.admin = e.admin ? ? "", void 0 !== e.codeId && null !== e.codeId && (t.codeId = BigInt(e.codeId.toString())), t.label = e.label ? ? "", t.msg = e.msg ? ? new Uint8Array, t.funds = e.funds ? .map(e => o.Coin.fromPartial(e)) || [], t
                }
            }, t.MsgInstantiateContract2 = {
                typeUrl: "/cosmwasm.wasm.v1.MsgInstantiateContract2",
                encode(e, t = i.BinaryWriter.create()) {
                    for (let r of ("" !== e.sender && t.uint32(10).string(e.sender), "" !== e.admin && t.uint32(18).string(e.admin), e.codeId !== BigInt(0) && t.uint32(24).uint64(e.codeId), "" !== e.label && t.uint32(34).string(e.label), 0 !== e.msg.length && t.uint32(42).bytes(e.msg), e.funds)) o.Coin.encode(r, t.uint32(50).fork()).ldelim();
                    return 0 !== e.salt.length && t.uint32(58).bytes(e.salt), !0 === e.fixMsg && t.uint32(64).bool(e.fixMsg), t
                },
                decode(e, t) {
                    let r = e instanceof i.BinaryReader ? e : new i.BinaryReader(e),
                        n = void 0 === t ? r.len : r.pos + t,
                        a = l();
                    for (; r.pos < n;) {
                        let e = r.uint32();
                        switch (e >>> 3) {
                            case 1:
                                a.sender = r.string();
                                break;
                            case 2:
                                a.admin = r.string();
                                break;
                            case 3:
                                a.codeId = r.uint64();
                                break;
                            case 4:
                                a.label = r.string();
                                break;
                            case 5:
                                a.msg = r.bytes();
                                break;
                            case 6:
                                a.funds.push(o.Coin.decode(r, r.uint32()));
                                break;
                            case 7:
                                a.salt = r.bytes();
                                break;
                            case 8:
                                a.fixMsg = r.bool();
                                break;
                            default:
                                r.skipType(7 & e)
                        }
                    }
                    return a
                },
                fromJSON(e) {
                    let t = l();
                    return (0, a.isSet)(e.sender) && (t.sender = String(e.sender)), (0, a.isSet)(e.admin) && (t.admin = String(e.admin)), (0, a.isSet)(e.codeId) && (t.codeId = BigInt(e.codeId.toString())), (0, a.isSet)(e.label) && (t.label = String(e.label)), (0, a.isSet)(e.msg) && (t.msg = (0, a.bytesFromBase64)(e.msg)), Array.isArray(e ? .funds) && (t.funds = e.funds.map(e => o.Coin.fromJSON(e))), (0, a.isSet)(e.salt) && (t.salt = (0, a.bytesFromBase64)(e.salt)), (0, a.isSet)(e.fixMsg) && (t.fixMsg = !!e.fixMsg), t
                },
                toJSON(e) {
                    let t = {};
                    return void 0 !== e.sender && (t.sender = e.sender), void 0 !== e.admin && (t.admin = e.admin), void 0 !== e.codeId && (t.codeId = (e.codeId || BigInt(0)).toString()), void 0 !== e.label && (t.label = e.label), void 0 !== e.msg && (t.msg = (0, a.base64FromBytes)(void 0 !== e.msg ? e.msg : new Uint8Array)), e.funds ? t.funds = e.funds.map(e => e ? o.Coin.toJSON(e) : void 0) : t.funds = [], void 0 !== e.salt && (t.salt = (0, a.base64FromBytes)(void 0 !== e.salt ? e.salt : new Uint8Array)), void 0 !== e.fixMsg && (t.fixMsg = e.fixMsg), t
                },
                fromPartial(e) {
                    let t = l();
                    return t.sender = e.sender ? ? "", t.admin = e.admin ? ? "", void 0 !== e.codeId && null !== e.codeId && (t.codeId = BigInt(e.codeId.toString())), t.label = e.label ? ? "", t.msg = e.msg ? ? new Uint8Array, t.funds = e.funds ? .map(e => o.Coin.fromPartial(e)) || [], t.salt = e.salt ? ? new Uint8Array, t.fixMsg = e.fixMsg ? ? !1, t
                }
            }, t.MsgInstantiateContractResponse = {
                typeUrl: "/cosmwasm.wasm.v1.MsgInstantiateContractResponse",
                encode: (e, t = i.BinaryWriter.create()) => ("" !== e.address && t.uint32(10).string(e.address), 0 !== e.data.length && t.uint32(18).bytes(e.data), t),
                decode(e, t) {
                    let r = e instanceof i.BinaryReader ? e : new i.BinaryReader(e),
                        n = void 0 === t ? r.len : r.pos + t,
                        o = u();
                    for (; r.pos < n;) {
                        let e = r.uint32();
                        switch (e >>> 3) {
                            case 1:
                                o.address = r.string();
                                break;
                            case 2:
                                o.data = r.bytes();
                                break;
                            default:
                                r.skipType(7 & e)
                        }
                    }
                    return o
                },
                fromJSON(e) {
                    let t = u();
                    return (0, a.isSet)(e.address) && (t.address = String(e.address)), (0, a.isSet)(e.data) && (t.data = (0, a.bytesFromBase64)(e.data)), t
                },
                toJSON(e) {
                    let t = {};
                    return void 0 !== e.address && (t.address = e.address), void 0 !== e.data && (t.data = (0, a.base64FromBytes)(void 0 !== e.data ? e.data : new Uint8Array)), t
                },
                fromPartial(e) {
                    let t = u();
                    return t.address = e.address ? ? "", t.data = e.data ? ? new Uint8Array, t
                }
            }, t.MsgInstantiateContract2Response = {
                typeUrl: "/cosmwasm.wasm.v1.MsgInstantiateContract2Response",
                encode: (e, t = i.BinaryWriter.create()) => ("" !== e.address && t.uint32(10).string(e.address), 0 !== e.data.length && t.uint32(18).bytes(e.data), t),
                decode(e, t) {
                    let r = e instanceof i.BinaryReader ? e : new i.BinaryReader(e),
                        n = void 0 === t ? r.len : r.pos + t,
                        o = p();
                    for (; r.pos < n;) {
                        let e = r.uint32();
                        switch (e >>> 3) {
                            case 1:
                                o.address = r.string();
                                break;
                            case 2:
                                o.data = r.bytes();
                                break;
                            default:
                                r.skipType(7 & e)
                        }
                    }
                    return o
                },
                fromJSON(e) {
                    let t = p();
                    return (0, a.isSet)(e.address) && (t.address = String(e.address)), (0, a.isSet)(e.data) && (t.data = (0, a.bytesFromBase64)(e.data)), t
                },
                toJSON(e) {
                    let t = {};
                    return void 0 !== e.address && (t.address = e.address), void 0 !== e.data && (t.data = (0, a.base64FromBytes)(void 0 !== e.data ? e.data : new Uint8Array)), t
                },
                fromPartial(e) {
                    let t = p();
                    return t.address = e.address ? ? "", t.data = e.data ? ? new Uint8Array, t
                }
            }, t.MsgExecuteContract = {
                typeUrl: "/cosmwasm.wasm.v1.MsgExecuteContract",
                encode(e, t = i.BinaryWriter.create()) {
                    for (let r of ("" !== e.sender && t.uint32(10).string(e.sender), "" !== e.contract && t.uint32(18).string(e.contract), 0 !== e.msg.length && t.uint32(26).bytes(e.msg), e.funds)) o.Coin.encode(r, t.uint32(42).fork()).ldelim();
                    return t
                },
                decode(e, t) {
                    let r = e instanceof i.BinaryReader ? e : new i.BinaryReader(e),
                        n = void 0 === t ? r.len : r.pos + t,
                        a = m();
                    for (; r.pos < n;) {
                        let e = r.uint32();
                        switch (e >>> 3) {
                            case 1:
                                a.sender = r.string();
                                break;
                            case 2:
                                a.contract = r.string();
                                break;
                            case 3:
                                a.msg = r.bytes();
                                break;
                            case 5:
                                a.funds.push(o.Coin.decode(r, r.uint32()));
                                break;
                            default:
                                r.skipType(7 & e)
                        }
                    }
                    return a
                },
                fromJSON(e) {
                    let t = m();
                    return (0, a.isSet)(e.sender) && (t.sender = String(e.sender)), (0, a.isSet)(e.contract) && (t.contract = String(e.contract)), (0, a.isSet)(e.msg) && (t.msg = (0, a.bytesFromBase64)(e.msg)), Array.isArray(e ? .funds) && (t.funds = e.funds.map(e => o.Coin.fromJSON(e))), t
                },
                toJSON(e) {
                    let t = {};
                    return void 0 !== e.sender && (t.sender = e.sender), void 0 !== e.contract && (t.contract = e.contract), void 0 !== e.msg && (t.msg = (0, a.base64FromBytes)(void 0 !== e.msg ? e.msg : new Uint8Array)), e.funds ? t.funds = e.funds.map(e => e ? o.Coin.toJSON(e) : void 0) : t.funds = [], t
                },
                fromPartial(e) {
                    let t = m();
                    return t.sender = e.sender ? ? "", t.contract = e.contract ? ? "", t.msg = e.msg ? ? new Uint8Array, t.funds = e.funds ? .map(e => o.Coin.fromPartial(e)) || [], t
                }
            }, t.MsgExecuteContractResponse = {
                typeUrl: "/cosmwasm.wasm.v1.MsgExecuteContractResponse",
                encode: (e, t = i.BinaryWriter.create()) => (0 !== e.data.length && t.uint32(10).bytes(e.data), t),
                decode(e, t) {
                    let r = e instanceof i.BinaryReader ? e : new i.BinaryReader(e),
                        n = void 0 === t ? r.len : r.pos + t,
                        o = g();
                    for (; r.pos < n;) {
                        let e = r.uint32();
                        e >>> 3 == 1 ? o.data = r.bytes() : r.skipType(7 & e)
                    }
                    return o
                },
                fromJSON(e) {
                    let t = g();
                    return (0, a.isSet)(e.data) && (t.data = (0, a.bytesFromBase64)(e.data)), t
                },
                toJSON(e) {
                    let t = {};
                    return void 0 !== e.data && (t.data = (0, a.base64FromBytes)(void 0 !== e.data ? e.data : new Uint8Array)), t
                },
                fromPartial(e) {
                    let t = g();
                    return t.data = e.data ? ? new Uint8Array, t
                }
            }, t.MsgMigrateContract = {
                typeUrl: "/cosmwasm.wasm.v1.MsgMigrateContract",
                encode: (e, t = i.BinaryWriter.create()) => ("" !== e.sender && t.uint32(10).string(e.sender), "" !== e.contract && t.uint32(18).string(e.contract), e.codeId !== BigInt(0) && t.uint32(24).uint64(e.codeId), 0 !== e.msg.length && t.uint32(34).bytes(e.msg), t),
                decode(e, t) {
                    let r = e instanceof i.BinaryReader ? e : new i.BinaryReader(e),
                        n = void 0 === t ? r.len : r.pos + t,
                        o = f();
                    for (; r.pos < n;) {
                        let e = r.uint32();
                        switch (e >>> 3) {
                            case 1:
                                o.sender = r.string();
                                break;
                            case 2:
                                o.contract = r.string();
                                break;
                            case 3:
                                o.codeId = r.uint64();
                                break;
                            case 4:
                                o.msg = r.bytes();
                                break;
                            default:
                                r.skipType(7 & e)
                        }
                    }
                    return o
                },
                fromJSON(e) {
                    let t = f();
                    return (0, a.isSet)(e.sender) && (t.sender = String(e.sender)), (0, a.isSet)(e.contract) && (t.contract = String(e.contract)), (0, a.isSet)(e.codeId) && (t.codeId = BigInt(e.codeId.toString())), (0, a.isSet)(e.msg) && (t.msg = (0, a.bytesFromBase64)(e.msg)), t
                },
                toJSON(e) {
                    let t = {};
                    return void 0 !== e.sender && (t.sender = e.sender), void 0 !== e.contract && (t.contract = e.contract), void 0 !== e.codeId && (t.codeId = (e.codeId || BigInt(0)).toString()), void 0 !== e.msg && (t.msg = (0, a.base64FromBytes)(void 0 !== e.msg ? e.msg : new Uint8Array)), t
                },
                fromPartial(e) {
                    let t = f();
                    return t.sender = e.sender ? ? "", t.contract = e.contract ? ? "", void 0 !== e.codeId && null !== e.codeId && (t.codeId = BigInt(e.codeId.toString())), t.msg = e.msg ? ? new Uint8Array, t
                }
            }, t.MsgMigrateContractResponse = {
                typeUrl: "/cosmwasm.wasm.v1.MsgMigrateContractResponse",
                encode: (e, t = i.BinaryWriter.create()) => (0 !== e.data.length && t.uint32(10).bytes(e.data), t),
                decode(e, t) {
                    let r = e instanceof i.BinaryReader ? e : new i.BinaryReader(e),
                        n = void 0 === t ? r.len : r.pos + t,
                        o = y();
                    for (; r.pos < n;) {
                        let e = r.uint32();
                        e >>> 3 == 1 ? o.data = r.bytes() : r.skipType(7 & e)
                    }
                    return o
                },
                fromJSON(e) {
                    let t = y();
                    return (0, a.isSet)(e.data) && (t.data = (0, a.bytesFromBase64)(e.data)), t
                },
                toJSON(e) {
                    let t = {};
                    return void 0 !== e.data && (t.data = (0, a.base64FromBytes)(void 0 !== e.data ? e.data : new Uint8Array)), t
                },
                fromPartial(e) {
                    let t = y();
                    return t.data = e.data ? ? new Uint8Array, t
                }
            }, t.MsgUpdateAdmin = {
                typeUrl: "/cosmwasm.wasm.v1.MsgUpdateAdmin",
                encode: (e, t = i.BinaryWriter.create()) => ("" !== e.sender && t.uint32(10).string(e.sender), "" !== e.newAdmin && t.uint32(18).string(e.newAdmin), "" !== e.contract && t.uint32(26).string(e.contract), t),
                decode(e, t) {
                    let r = e instanceof i.BinaryReader ? e : new i.BinaryReader(e),
                        n = void 0 === t ? r.len : r.pos + t,
                        o = h();
                    for (; r.pos < n;) {
                        let e = r.uint32();
                        switch (e >>> 3) {
                            case 1:
                                o.sender = r.string();
                                break;
                            case 2:
                                o.newAdmin = r.string();
                                break;
                            case 3:
                                o.contract = r.string();
                                break;
                            default:
                                r.skipType(7 & e)
                        }
                    }
                    return o
                },
                fromJSON(e) {
                    let t = h();
                    return (0, a.isSet)(e.sender) && (t.sender = String(e.sender)), (0, a.isSet)(e.newAdmin) && (t.newAdmin = String(e.newAdmin)), (0, a.isSet)(e.contract) && (t.contract = String(e.contract)), t
                },
                toJSON(e) {
                    let t = {};
                    return void 0 !== e.sender && (t.sender = e.sender), void 0 !== e.newAdmin && (t.newAdmin = e.newAdmin), void 0 !== e.contract && (t.contract = e.contract), t
                },
                fromPartial(e) {
                    let t = h();
                    return t.sender = e.sender ? ? "", t.newAdmin = e.newAdmin ? ? "", t.contract = e.contract ? ? "", t
                }
            }, t.MsgUpdateAdminResponse = {
                typeUrl: "/cosmwasm.wasm.v1.MsgUpdateAdminResponse",
                encode: (e, t = i.BinaryWriter.create()) => t,
                decode(e, t) {
                    let r = e instanceof i.BinaryReader ? e : new i.BinaryReader(e),
                        n = void 0 === t ? r.len : r.pos + t;
                    for (; r.pos < n;) {
                        let e = r.uint32();
                        r.skipType(7 & e)
                    }
                    return {}
                },
                fromJSON: e => ({}),
                toJSON: e => ({}),
                fromPartial: e => ({})
            }, t.MsgClearAdmin = {
                typeUrl: "/cosmwasm.wasm.v1.MsgClearAdmin",
                encode: (e, t = i.BinaryWriter.create()) => ("" !== e.sender && t.uint32(10).string(e.sender), "" !== e.contract && t.uint32(26).string(e.contract), t),
                decode(e, t) {
                    let r = e instanceof i.BinaryReader ? e : new i.BinaryReader(e),
                        n = void 0 === t ? r.len : r.pos + t,
                        o = v();
                    for (; r.pos < n;) {
                        let e = r.uint32();
                        switch (e >>> 3) {
                            case 1:
                                o.sender = r.string();
                                break;
                            case 3:
                                o.contract = r.string();
                                break;
                            default:
                                r.skipType(7 & e)
                        }
                    }
                    return o
                },
                fromJSON(e) {
                    let t = v();
                    return (0, a.isSet)(e.sender) && (t.sender = String(e.sender)), (0, a.isSet)(e.contract) && (t.contract = String(e.contract)), t
                },
                toJSON(e) {
                    let t = {};
                    return void 0 !== e.sender && (t.sender = e.sender), void 0 !== e.contract && (t.contract = e.contract), t
                },
                fromPartial(e) {
                    let t = v();
                    return t.sender = e.sender ? ? "", t.contract = e.contract ? ? "", t
                }
            }, t.MsgClearAdminResponse = {
                typeUrl: "/cosmwasm.wasm.v1.MsgClearAdminResponse",
                encode: (e, t = i.BinaryWriter.create()) => t,
                decode(e, t) {
                    let r = e instanceof i.BinaryReader ? e : new i.BinaryReader(e),
                        n = void 0 === t ? r.len : r.pos + t;
                    for (; r.pos < n;) {
                        let e = r.uint32();
                        r.skipType(7 & e)
                    }
                    return {}
                },
                fromJSON: e => ({}),
                toJSON: e => ({}),
                fromPartial: e => ({})
            }, t.MsgUpdateInstantiateConfig = {
                typeUrl: "/cosmwasm.wasm.v1.MsgUpdateInstantiateConfig",
                encode: (e, t = i.BinaryWriter.create()) => ("" !== e.sender && t.uint32(10).string(e.sender), e.codeId !== BigInt(0) && t.uint32(16).uint64(e.codeId), void 0 !== e.newInstantiatePermission && n.AccessConfig.encode(e.newInstantiatePermission, t.uint32(26).fork()).ldelim(), t),
                decode(e, t) {
                    let r = e instanceof i.BinaryReader ? e : new i.BinaryReader(e),
                        o = void 0 === t ? r.len : r.pos + t,
                        a = b();
                    for (; r.pos < o;) {
                        let e = r.uint32();
                        switch (e >>> 3) {
                            case 1:
                                a.sender = r.string();
                                break;
                            case 2:
                                a.codeId = r.uint64();
                                break;
                            case 3:
                                a.newInstantiatePermission = n.AccessConfig.decode(r, r.uint32());
                                break;
                            default:
                                r.skipType(7 & e)
                        }
                    }
                    return a
                },
                fromJSON(e) {
                    let t = b();
                    return (0, a.isSet)(e.sender) && (t.sender = String(e.sender)), (0, a.isSet)(e.codeId) && (t.codeId = BigInt(e.codeId.toString())), (0, a.isSet)(e.newInstantiatePermission) && (t.newInstantiatePermission = n.AccessConfig.fromJSON(e.newInstantiatePermission)), t
                },
                toJSON(e) {
                    let t = {};
                    return void 0 !== e.sender && (t.sender = e.sender), void 0 !== e.codeId && (t.codeId = (e.codeId || BigInt(0)).toString()), void 0 !== e.newInstantiatePermission && (t.newInstantiatePermission = e.newInstantiatePermission ? n.AccessConfig.toJSON(e.newInstantiatePermission) : void 0), t
                },
                fromPartial(e) {
                    let t = b();
                    return t.sender = e.sender ? ? "", void 0 !== e.codeId && null !== e.codeId && (t.codeId = BigInt(e.codeId.toString())), void 0 !== e.newInstantiatePermission && null !== e.newInstantiatePermission && (t.newInstantiatePermission = n.AccessConfig.fromPartial(e.newInstantiatePermission)), t
                }
            }, t.MsgUpdateInstantiateConfigResponse = {
                typeUrl: "/cosmwasm.wasm.v1.MsgUpdateInstantiateConfigResponse",
                encode: (e, t = i.BinaryWriter.create()) => t,
                decode(e, t) {
                    let r = e instanceof i.BinaryReader ? e : new i.BinaryReader(e),
                        n = void 0 === t ? r.len : r.pos + t;
                    for (; r.pos < n;) {
                        let e = r.uint32();
                        r.skipType(7 & e)
                    }
                    return {}
                },
                fromJSON: e => ({}),
                toJSON: e => ({}),
                fromPartial: e => ({})
            };
            class S {
                constructor(e) {
                    this.rpc = e, this.StoreCode = this.StoreCode.bind(this), this.InstantiateContract = this.InstantiateContract.bind(this), this.InstantiateContract2 = this.InstantiateContract2.bind(this), this.ExecuteContract = this.ExecuteContract.bind(this), this.MigrateContract = this.MigrateContract.bind(this), this.UpdateAdmin = this.UpdateAdmin.bind(this), this.ClearAdmin = this.ClearAdmin.bind(this), this.UpdateInstantiateConfig = this.UpdateInstantiateConfig.bind(this)
                }
                StoreCode(e) {
                    let r = t.MsgStoreCode.encode(e).finish();
                    return this.rpc.request("cosmwasm.wasm.v1.Msg", "StoreCode", r).then(e => t.MsgStoreCodeResponse.decode(new i.BinaryReader(e)))
                }
                InstantiateContract(e) {
                    let r = t.MsgInstantiateContract.encode(e).finish();
                    return this.rpc.request("cosmwasm.wasm.v1.Msg", "InstantiateContract", r).then(e => t.MsgInstantiateContractResponse.decode(new i.BinaryReader(e)))
                }
                InstantiateContract2(e) {
                    let r = t.MsgInstantiateContract2.encode(e).finish();
                    return this.rpc.request("cosmwasm.wasm.v1.Msg", "InstantiateContract2", r).then(e => t.MsgInstantiateContract2Response.decode(new i.BinaryReader(e)))
                }
                ExecuteContract(e) {
                    let r = t.MsgExecuteContract.encode(e).finish();
                    return this.rpc.request("cosmwasm.wasm.v1.Msg", "ExecuteContract", r).then(e => t.MsgExecuteContractResponse.decode(new i.BinaryReader(e)))
                }
                MigrateContract(e) {
                    let r = t.MsgMigrateContract.encode(e).finish();
                    return this.rpc.request("cosmwasm.wasm.v1.Msg", "MigrateContract", r).then(e => t.MsgMigrateContractResponse.decode(new i.BinaryReader(e)))
                }
                UpdateAdmin(e) {
                    let r = t.MsgUpdateAdmin.encode(e).finish();
                    return this.rpc.request("cosmwasm.wasm.v1.Msg", "UpdateAdmin", r).then(e => t.MsgUpdateAdminResponse.decode(new i.BinaryReader(e)))
                }
                ClearAdmin(e) {
                    let r = t.MsgClearAdmin.encode(e).finish();
                    return this.rpc.request("cosmwasm.wasm.v1.Msg", "ClearAdmin", r).then(e => t.MsgClearAdminResponse.decode(new i.BinaryReader(e)))
                }
                UpdateInstantiateConfig(e) {
                    let r = t.MsgUpdateInstantiateConfig.encode(e).finish();
                    return this.rpc.request("cosmwasm.wasm.v1.Msg", "UpdateInstantiateConfig", r).then(e => t.MsgUpdateInstantiateConfigResponse.decode(new i.BinaryReader(e)))
                }
            }
            t.MsgClientImpl = S
        },
        29229: function(e, t, r) {
            "use strict";
            var n, o, i, a;
            Object.defineProperty(t, "__esModule", {
                value: !0
            }), t.Model = t.AbsoluteTxPosition = t.ContractCodeHistoryEntry = t.ContractInfo = t.CodeInfo = t.Params = t.AccessConfig = t.AccessTypeParam = t.contractCodeHistoryOperationTypeToJSON = t.contractCodeHistoryOperationTypeFromJSON = t.ContractCodeHistoryOperationType = t.accessTypeToJSON = t.accessTypeFromJSON = t.AccessType = t.protobufPackage = void 0;
            let s = r(40747),
                d = r(23795),
                c = r(96987);

            function l(e) {
                switch (e) {
                    case 0:
                    case "ACCESS_TYPE_UNSPECIFIED":
                        return n.ACCESS_TYPE_UNSPECIFIED;
                    case 1:
                    case "ACCESS_TYPE_NOBODY":
                        return n.ACCESS_TYPE_NOBODY;
                    case 2:
                    case "ACCESS_TYPE_ONLY_ADDRESS":
                        return n.ACCESS_TYPE_ONLY_ADDRESS;
                    case 3:
                    case "ACCESS_TYPE_EVERYBODY":
                        return n.ACCESS_TYPE_EVERYBODY;
                    case 4:
                    case "ACCESS_TYPE_ANY_OF_ADDRESSES":
                        return n.ACCESS_TYPE_ANY_OF_ADDRESSES;
                    default:
                        return n.UNRECOGNIZED
                }
            }

            function u(e) {
                switch (e) {
                    case n.ACCESS_TYPE_UNSPECIFIED:
                        return "ACCESS_TYPE_UNSPECIFIED";
                    case n.ACCESS_TYPE_NOBODY:
                        return "ACCESS_TYPE_NOBODY";
                    case n.ACCESS_TYPE_ONLY_ADDRESS:
                        return "ACCESS_TYPE_ONLY_ADDRESS";
                    case n.ACCESS_TYPE_EVERYBODY:
                        return "ACCESS_TYPE_EVERYBODY";
                    case n.ACCESS_TYPE_ANY_OF_ADDRESSES:
                        return "ACCESS_TYPE_ANY_OF_ADDRESSES";
                    case n.UNRECOGNIZED:
                    default:
                        return "UNRECOGNIZED"
                }
            }

            function p(e) {
                switch (e) {
                    case 0:
                    case "CONTRACT_CODE_HISTORY_OPERATION_TYPE_UNSPECIFIED":
                        return o.CONTRACT_CODE_HISTORY_OPERATION_TYPE_UNSPECIFIED;
                    case 1:
                    case "CONTRACT_CODE_HISTORY_OPERATION_TYPE_INIT":
                        return o.CONTRACT_CODE_HISTORY_OPERATION_TYPE_INIT;
                    case 2:
                    case "CONTRACT_CODE_HISTORY_OPERATION_TYPE_MIGRATE":
                        return o.CONTRACT_CODE_HISTORY_OPERATION_TYPE_MIGRATE;
                    case 3:
                    case "CONTRACT_CODE_HISTORY_OPERATION_TYPE_GENESIS":
                        return o.CONTRACT_CODE_HISTORY_OPERATION_TYPE_GENESIS;
                    default:
                        return o.UNRECOGNIZED
                }
            }

            function m(e) {
                switch (e) {
                    case o.CONTRACT_CODE_HISTORY_OPERATION_TYPE_UNSPECIFIED:
                        return "CONTRACT_CODE_HISTORY_OPERATION_TYPE_UNSPECIFIED";
                    case o.CONTRACT_CODE_HISTORY_OPERATION_TYPE_INIT:
                        return "CONTRACT_CODE_HISTORY_OPERATION_TYPE_INIT";
                    case o.CONTRACT_CODE_HISTORY_OPERATION_TYPE_MIGRATE:
                        return "CONTRACT_CODE_HISTORY_OPERATION_TYPE_MIGRATE";
                    case o.CONTRACT_CODE_HISTORY_OPERATION_TYPE_GENESIS:
                        return "CONTRACT_CODE_HISTORY_OPERATION_TYPE_GENESIS";
                    case o.UNRECOGNIZED:
                    default:
                        return "UNRECOGNIZED"
                }
            }

            function g() {
                return {
                    value: 0
                }
            }

            function f() {
                return {
                    permission: 0,
                    address: "",
                    addresses: []
                }
            }

            function y() {
                return {
                    codeUploadAccess: t.AccessConfig.fromPartial({}),
                    instantiateDefaultPermission: 0
                }
            }

            function h() {
                return {
                    codeHash: new Uint8Array,
                    creator: "",
                    instantiateConfig: t.AccessConfig.fromPartial({})
                }
            }

            function v() {
                return {
                    codeId: BigInt(0),
                    creator: "",
                    admin: "",
                    label: "",
                    created: void 0,
                    ibcPortId: "",
                    extension: void 0
                }
            }

            function b() {
                return {
                    operation: 0,
                    codeId: BigInt(0),
                    updated: void 0,
                    msg: new Uint8Array
                }
            }

            function S() {
                return {
                    blockHeight: BigInt(0),
                    txIndex: BigInt(0)
                }
            }

            function k() {
                return {
                    key: new Uint8Array,
                    value: new Uint8Array
                }
            }
            t.protobufPackage = "cosmwasm.wasm.v1", (i = n || (t.AccessType = n = {}))[i.ACCESS_TYPE_UNSPECIFIED = 0] = "ACCESS_TYPE_UNSPECIFIED", i[i.ACCESS_TYPE_NOBODY = 1] = "ACCESS_TYPE_NOBODY", i[i.ACCESS_TYPE_ONLY_ADDRESS = 2] = "ACCESS_TYPE_ONLY_ADDRESS", i[i.ACCESS_TYPE_EVERYBODY = 3] = "ACCESS_TYPE_EVERYBODY", i[i.ACCESS_TYPE_ANY_OF_ADDRESSES = 4] = "ACCESS_TYPE_ANY_OF_ADDRESSES", i[i.UNRECOGNIZED = -1] = "UNRECOGNIZED", t.accessTypeFromJSON = l, t.accessTypeToJSON = u, (a = o || (t.ContractCodeHistoryOperationType = o = {}))[a.CONTRACT_CODE_HISTORY_OPERATION_TYPE_UNSPECIFIED = 0] = "CONTRACT_CODE_HISTORY_OPERATION_TYPE_UNSPECIFIED", a[a.CONTRACT_CODE_HISTORY_OPERATION_TYPE_INIT = 1] = "CONTRACT_CODE_HISTORY_OPERATION_TYPE_INIT", a[a.CONTRACT_CODE_HISTORY_OPERATION_TYPE_MIGRATE = 2] = "CONTRACT_CODE_HISTORY_OPERATION_TYPE_MIGRATE", a[a.CONTRACT_CODE_HISTORY_OPERATION_TYPE_GENESIS = 3] = "CONTRACT_CODE_HISTORY_OPERATION_TYPE_GENESIS", a[a.UNRECOGNIZED = -1] = "UNRECOGNIZED", t.contractCodeHistoryOperationTypeFromJSON = p, t.contractCodeHistoryOperationTypeToJSON = m, t.AccessTypeParam = {
                typeUrl: "/cosmwasm.wasm.v1.AccessTypeParam",
                encode: (e, t = d.BinaryWriter.create()) => (0 !== e.value && t.uint32(8).int32(e.value), t),
                decode(e, t) {
                    let r = e instanceof d.BinaryReader ? e : new d.BinaryReader(e),
                        n = void 0 === t ? r.len : r.pos + t,
                        o = g();
                    for (; r.pos < n;) {
                        let e = r.uint32();
                        e >>> 3 == 1 ? o.value = r.int32() : r.skipType(7 & e)
                    }
                    return o
                },
                fromJSON(e) {
                    let t = g();
                    return (0, c.isSet)(e.value) && (t.value = l(e.value)), t
                },
                toJSON(e) {
                    let t = {};
                    return void 0 !== e.value && (t.value = u(e.value)), t
                },
                fromPartial(e) {
                    let t = g();
                    return t.value = e.value ? ? 0, t
                }
            }, t.AccessConfig = {
                typeUrl: "/cosmwasm.wasm.v1.AccessConfig",
                encode(e, t = d.BinaryWriter.create()) {
                    for (let r of (0 !== e.permission && t.uint32(8).int32(e.permission), "" !== e.address && t.uint32(18).string(e.address), e.addresses)) t.uint32(26).string(r);
                    return t
                },
                decode(e, t) {
                    let r = e instanceof d.BinaryReader ? e : new d.BinaryReader(e),
                        n = void 0 === t ? r.len : r.pos + t,
                        o = f();
                    for (; r.pos < n;) {
                        let e = r.uint32();
                        switch (e >>> 3) {
                            case 1:
                                o.permission = r.int32();
                                break;
                            case 2:
                                o.address = r.string();
                                break;
                            case 3:
                                o.addresses.push(r.string());
                                break;
                            default:
                                r.skipType(7 & e)
                        }
                    }
                    return o
                },
                fromJSON(e) {
                    let t = f();
                    return (0, c.isSet)(e.permission) && (t.permission = l(e.permission)), (0, c.isSet)(e.address) && (t.address = String(e.address)), Array.isArray(e ? .addresses) && (t.addresses = e.addresses.map(e => String(e))), t
                },
                toJSON(e) {
                    let t = {};
                    return void 0 !== e.permission && (t.permission = u(e.permission)), void 0 !== e.address && (t.address = e.address), e.addresses ? t.addresses = e.addresses.map(e => e) : t.addresses = [], t
                },
                fromPartial(e) {
                    let t = f();
                    return t.permission = e.permission ? ? 0, t.address = e.address ? ? "", t.addresses = e.addresses ? .map(e => e) || [], t
                }
            }, t.Params = {
                typeUrl: "/cosmwasm.wasm.v1.Params",
                encode: (e, r = d.BinaryWriter.create()) => (void 0 !== e.codeUploadAccess && t.AccessConfig.encode(e.codeUploadAccess, r.uint32(10).fork()).ldelim(), 0 !== e.instantiateDefaultPermission && r.uint32(16).int32(e.instantiateDefaultPermission), r),
                decode(e, r) {
                    let n = e instanceof d.BinaryReader ? e : new d.BinaryReader(e),
                        o = void 0 === r ? n.len : n.pos + r,
                        i = y();
                    for (; n.pos < o;) {
                        let e = n.uint32();
                        switch (e >>> 3) {
                            case 1:
                                i.codeUploadAccess = t.AccessConfig.decode(n, n.uint32());
                                break;
                            case 2:
                                i.instantiateDefaultPermission = n.int32();
                                break;
                            default:
                                n.skipType(7 & e)
                        }
                    }
                    return i
                },
                fromJSON(e) {
                    let r = y();
                    return (0, c.isSet)(e.codeUploadAccess) && (r.codeUploadAccess = t.AccessConfig.fromJSON(e.codeUploadAccess)), (0, c.isSet)(e.instantiateDefaultPermission) && (r.instantiateDefaultPermission = l(e.instantiateDefaultPermission)), r
                },
                toJSON(e) {
                    let r = {};
                    return void 0 !== e.codeUploadAccess && (r.codeUploadAccess = e.codeUploadAccess ? t.AccessConfig.toJSON(e.codeUploadAccess) : void 0), void 0 !== e.instantiateDefaultPermission && (r.instantiateDefaultPermission = u(e.instantiateDefaultPermission)), r
                },
                fromPartial(e) {
                    let r = y();
                    return void 0 !== e.codeUploadAccess && null !== e.codeUploadAccess && (r.codeUploadAccess = t.AccessConfig.fromPartial(e.codeUploadAccess)), r.instantiateDefaultPermission = e.instantiateDefaultPermission ? ? 0, r
                }
            }, t.CodeInfo = {
                typeUrl: "/cosmwasm.wasm.v1.CodeInfo",
                encode: (e, r = d.BinaryWriter.create()) => (0 !== e.codeHash.length && r.uint32(10).bytes(e.codeHash), "" !== e.creator && r.uint32(18).string(e.creator), void 0 !== e.instantiateConfig && t.AccessConfig.encode(e.instantiateConfig, r.uint32(42).fork()).ldelim(), r),
                decode(e, r) {
                    let n = e instanceof d.BinaryReader ? e : new d.BinaryReader(e),
                        o = void 0 === r ? n.len : n.pos + r,
                        i = h();
                    for (; n.pos < o;) {
                        let e = n.uint32();
                        switch (e >>> 3) {
                            case 1:
                                i.codeHash = n.bytes();
                                break;
                            case 2:
                                i.creator = n.string();
                                break;
                            case 5:
                                i.instantiateConfig = t.AccessConfig.decode(n, n.uint32());
                                break;
                            default:
                                n.skipType(7 & e)
                        }
                    }
                    return i
                },
                fromJSON(e) {
                    let r = h();
                    return (0, c.isSet)(e.codeHash) && (r.codeHash = (0, c.bytesFromBase64)(e.codeHash)), (0, c.isSet)(e.creator) && (r.creator = String(e.creator)), (0, c.isSet)(e.instantiateConfig) && (r.instantiateConfig = t.AccessConfig.fromJSON(e.instantiateConfig)), r
                },
                toJSON(e) {
                    let r = {};
                    return void 0 !== e.codeHash && (r.codeHash = (0, c.base64FromBytes)(void 0 !== e.codeHash ? e.codeHash : new Uint8Array)), void 0 !== e.creator && (r.creator = e.creator), void 0 !== e.instantiateConfig && (r.instantiateConfig = e.instantiateConfig ? t.AccessConfig.toJSON(e.instantiateConfig) : void 0), r
                },
                fromPartial(e) {
                    let r = h();
                    return r.codeHash = e.codeHash ? ? new Uint8Array, r.creator = e.creator ? ? "", void 0 !== e.instantiateConfig && null !== e.instantiateConfig && (r.instantiateConfig = t.AccessConfig.fromPartial(e.instantiateConfig)), r
                }
            }, t.ContractInfo = {
                typeUrl: "/cosmwasm.wasm.v1.ContractInfo",
                encode: (e, r = d.BinaryWriter.create()) => (e.codeId !== BigInt(0) && r.uint32(8).uint64(e.codeId), "" !== e.creator && r.uint32(18).string(e.creator), "" !== e.admin && r.uint32(26).string(e.admin), "" !== e.label && r.uint32(34).string(e.label), void 0 !== e.created && t.AbsoluteTxPosition.encode(e.created, r.uint32(42).fork()).ldelim(), "" !== e.ibcPortId && r.uint32(50).string(e.ibcPortId), void 0 !== e.extension && s.Any.encode(e.extension, r.uint32(58).fork()).ldelim(), r),
                decode(e, r) {
                    let n = e instanceof d.BinaryReader ? e : new d.BinaryReader(e),
                        o = void 0 === r ? n.len : n.pos + r,
                        i = v();
                    for (; n.pos < o;) {
                        let e = n.uint32();
                        switch (e >>> 3) {
                            case 1:
                                i.codeId = n.uint64();
                                break;
                            case 2:
                                i.creator = n.string();
                                break;
                            case 3:
                                i.admin = n.string();
                                break;
                            case 4:
                                i.label = n.string();
                                break;
                            case 5:
                                i.created = t.AbsoluteTxPosition.decode(n, n.uint32());
                                break;
                            case 6:
                                i.ibcPortId = n.string();
                                break;
                            case 7:
                                i.extension = s.Any.decode(n, n.uint32());
                                break;
                            default:
                                n.skipType(7 & e)
                        }
                    }
                    return i
                },
                fromJSON(e) {
                    let r = v();
                    return (0, c.isSet)(e.codeId) && (r.codeId = BigInt(e.codeId.toString())), (0, c.isSet)(e.creator) && (r.creator = String(e.creator)), (0, c.isSet)(e.admin) && (r.admin = String(e.admin)), (0, c.isSet)(e.label) && (r.label = String(e.label)), (0, c.isSet)(e.created) && (r.created = t.AbsoluteTxPosition.fromJSON(e.created)), (0, c.isSet)(e.ibcPortId) && (r.ibcPortId = String(e.ibcPortId)), (0, c.isSet)(e.extension) && (r.extension = s.Any.fromJSON(e.extension)), r
                },
                toJSON(e) {
                    let r = {};
                    return void 0 !== e.codeId && (r.codeId = (e.codeId || BigInt(0)).toString()), void 0 !== e.creator && (r.creator = e.creator), void 0 !== e.admin && (r.admin = e.admin), void 0 !== e.label && (r.label = e.label), void 0 !== e.created && (r.created = e.created ? t.AbsoluteTxPosition.toJSON(e.created) : void 0), void 0 !== e.ibcPortId && (r.ibcPortId = e.ibcPortId), void 0 !== e.extension && (r.extension = e.extension ? s.Any.toJSON(e.extension) : void 0), r
                },
                fromPartial(e) {
                    let r = v();
                    return void 0 !== e.codeId && null !== e.codeId && (r.codeId = BigInt(e.codeId.toString())), r.creator = e.creator ? ? "", r.admin = e.admin ? ? "", r.label = e.label ? ? "", void 0 !== e.created && null !== e.created && (r.created = t.AbsoluteTxPosition.fromPartial(e.created)), r.ibcPortId = e.ibcPortId ? ? "", void 0 !== e.extension && null !== e.extension && (r.extension = s.Any.fromPartial(e.extension)), r
                }
            }, t.ContractCodeHistoryEntry = {
                typeUrl: "/cosmwasm.wasm.v1.ContractCodeHistoryEntry",
                encode: (e, r = d.BinaryWriter.create()) => (0 !== e.operation && r.uint32(8).int32(e.operation), e.codeId !== BigInt(0) && r.uint32(16).uint64(e.codeId), void 0 !== e.updated && t.AbsoluteTxPosition.encode(e.updated, r.uint32(26).fork()).ldelim(), 0 !== e.msg.length && r.uint32(34).bytes(e.msg), r),
                decode(e, r) {
                    let n = e instanceof d.BinaryReader ? e : new d.BinaryReader(e),
                        o = void 0 === r ? n.len : n.pos + r,
                        i = b();
                    for (; n.pos < o;) {
                        let e = n.uint32();
                        switch (e >>> 3) {
                            case 1:
                                i.operation = n.int32();
                                break;
                            case 2:
                                i.codeId = n.uint64();
                                break;
                            case 3:
                                i.updated = t.AbsoluteTxPosition.decode(n, n.uint32());
                                break;
                            case 4:
                                i.msg = n.bytes();
                                break;
                            default:
                                n.skipType(7 & e)
                        }
                    }
                    return i
                },
                fromJSON(e) {
                    let r = b();
                    return (0, c.isSet)(e.operation) && (r.operation = p(e.operation)), (0, c.isSet)(e.codeId) && (r.codeId = BigInt(e.codeId.toString())), (0, c.isSet)(e.updated) && (r.updated = t.AbsoluteTxPosition.fromJSON(e.updated)), (0, c.isSet)(e.msg) && (r.msg = (0, c.bytesFromBase64)(e.msg)), r
                },
                toJSON(e) {
                    let r = {};
                    return void 0 !== e.operation && (r.operation = m(e.operation)), void 0 !== e.codeId && (r.codeId = (e.codeId || BigInt(0)).toString()), void 0 !== e.updated && (r.updated = e.updated ? t.AbsoluteTxPosition.toJSON(e.updated) : void 0), void 0 !== e.msg && (r.msg = (0, c.base64FromBytes)(void 0 !== e.msg ? e.msg : new Uint8Array)), r
                },
                fromPartial(e) {
                    let r = b();
                    return r.operation = e.operation ? ? 0, void 0 !== e.codeId && null !== e.codeId && (r.codeId = BigInt(e.codeId.toString())), void 0 !== e.updated && null !== e.updated && (r.updated = t.AbsoluteTxPosition.fromPartial(e.updated)), r.msg = e.msg ? ? new Uint8Array, r
                }
            }, t.AbsoluteTxPosition = {
                typeUrl: "/cosmwasm.wasm.v1.AbsoluteTxPosition",
                encode: (e, t = d.BinaryWriter.create()) => (e.blockHeight !== BigInt(0) && t.uint32(8).uint64(e.blockHeight), e.txIndex !== BigInt(0) && t.uint32(16).uint64(e.txIndex), t),
                decode(e, t) {
                    let r = e instanceof d.BinaryReader ? e : new d.BinaryReader(e),
                        n = void 0 === t ? r.len : r.pos + t,
                        o = S();
                    for (; r.pos < n;) {
                        let e = r.uint32();
                        switch (e >>> 3) {
                            case 1:
                                o.blockHeight = r.uint64();
                                break;
                            case 2:
                                o.txIndex = r.uint64();
                                break;
                            default:
                                r.skipType(7 & e)
                        }
                    }
                    return o
                },
                fromJSON(e) {
                    let t = S();
                    return (0, c.isSet)(e.blockHeight) && (t.blockHeight = BigInt(e.blockHeight.toString())), (0, c.isSet)(e.txIndex) && (t.txIndex = BigInt(e.txIndex.toString())), t
                },
                toJSON(e) {
                    let t = {};
                    return void 0 !== e.blockHeight && (t.blockHeight = (e.blockHeight || BigInt(0)).toString()), void 0 !== e.txIndex && (t.txIndex = (e.txIndex || BigInt(0)).toString()), t
                },
                fromPartial(e) {
                    let t = S();
                    return void 0 !== e.blockHeight && null !== e.blockHeight && (t.blockHeight = BigInt(e.blockHeight.toString())), void 0 !== e.txIndex && null !== e.txIndex && (t.txIndex = BigInt(e.txIndex.toString())), t
                }
            }, t.Model = {
                typeUrl: "/cosmwasm.wasm.v1.Model",
                encode: (e, t = d.BinaryWriter.create()) => (0 !== e.key.length && t.uint32(10).bytes(e.key), 0 !== e.value.length && t.uint32(18).bytes(e.value), t),
                decode(e, t) {
                    let r = e instanceof d.BinaryReader ? e : new d.BinaryReader(e),
                        n = void 0 === t ? r.len : r.pos + t,
                        o = k();
                    for (; r.pos < n;) {
                        let e = r.uint32();
                        switch (e >>> 3) {
                            case 1:
                                o.key = r.bytes();
                                break;
                            case 2:
                                o.value = r.bytes();
                                break;
                            default:
                                r.skipType(7 & e)
                        }
                    }
                    return o
                },
                fromJSON(e) {
                    let t = k();
                    return (0, c.isSet)(e.key) && (t.key = (0, c.bytesFromBase64)(e.key)), (0, c.isSet)(e.value) && (t.value = (0, c.bytesFromBase64)(e.value)), t
                },
                toJSON(e) {
                    let t = {};
                    return void 0 !== e.key && (t.key = (0, c.base64FromBytes)(void 0 !== e.key ? e.key : new Uint8Array)), void 0 !== e.value && (t.value = (0, c.base64FromBytes)(void 0 !== e.value ? e.value : new Uint8Array)), t
                },
                fromPartial(e) {
                    let t = k();
                    return t.key = e.key ? ? new Uint8Array, t.value = e.value ? ? new Uint8Array, t
                }
            }
        },
        40747: function(e, t, r) {
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: !0
            }), t.Any = t.protobufPackage = void 0;
            let n = r(23795),
                o = r(96987);

            function i() {
                return {
                    typeUrl: "",
                    value: new Uint8Array
                }
            }
            t.protobufPackage = "google.protobuf", t.Any = {
                typeUrl: "/google.protobuf.Any",
                encode: (e, t = n.BinaryWriter.create()) => ("" !== e.typeUrl && t.uint32(10).string(e.typeUrl), 0 !== e.value.length && t.uint32(18).bytes(e.value), t),
                decode(e, t) {
                    let r = e instanceof n.BinaryReader ? e : new n.BinaryReader(e),
                        o = void 0 === t ? r.len : r.pos + t,
                        a = i();
                    for (; r.pos < o;) {
                        let e = r.uint32();
                        switch (e >>> 3) {
                            case 1:
                                a.typeUrl = r.string();
                                break;
                            case 2:
                                a.value = r.bytes();
                                break;
                            default:
                                r.skipType(7 & e)
                        }
                    }
                    return a
                },
                fromJSON(e) {
                    let t = i();
                    return (0, o.isSet)(e.typeUrl) && (t.typeUrl = String(e.typeUrl)), (0, o.isSet)(e.value) && (t.value = (0, o.bytesFromBase64)(e.value)), t
                },
                toJSON(e) {
                    let t = {};
                    return void 0 !== e.typeUrl && (t.typeUrl = e.typeUrl), void 0 !== e.value && (t.value = (0, o.base64FromBytes)(void 0 !== e.value ? e.value : new Uint8Array)), t
                },
                fromPartial(e) {
                    let t = i();
                    return t.typeUrl = e.typeUrl ? ? "", t.value = e.value ? ? new Uint8Array, t
                }
            }
        },
        14933: function(e, t, r) {
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: !0
            }), t.Duration = t.protobufPackage = void 0;
            let n = r(23795),
                o = r(96987);

            function i() {
                return {
                    seconds: BigInt(0),
                    nanos: 0
                }
            }
            t.protobufPackage = "google.protobuf", t.Duration = {
                typeUrl: "/google.protobuf.Duration",
                encode: (e, t = n.BinaryWriter.create()) => (e.seconds !== BigInt(0) && t.uint32(8).int64(e.seconds), 0 !== e.nanos && t.uint32(16).int32(e.nanos), t),
                decode(e, t) {
                    let r = e instanceof n.BinaryReader ? e : new n.BinaryReader(e),
                        o = void 0 === t ? r.len : r.pos + t,
                        a = i();
                    for (; r.pos < o;) {
                        let e = r.uint32();
                        switch (e >>> 3) {
                            case 1:
                                a.seconds = r.int64();
                                break;
                            case 2:
                                a.nanos = r.int32();
                                break;
                            default:
                                r.skipType(7 & e)
                        }
                    }
                    return a
                },
                fromJSON(e) {
                    let t = i();
                    return (0, o.isSet)(e.seconds) && (t.seconds = BigInt(e.seconds.toString())), (0, o.isSet)(e.nanos) && (t.nanos = Number(e.nanos)), t
                },
                toJSON(e) {
                    let t = {};
                    return void 0 !== e.seconds && (t.seconds = (e.seconds || BigInt(0)).toString()), void 0 !== e.nanos && (t.nanos = Math.round(e.nanos)), t
                },
                fromPartial(e) {
                    let t = i();
                    return void 0 !== e.seconds && null !== e.seconds && (t.seconds = BigInt(e.seconds.toString())), t.nanos = e.nanos ? ? 0, t
                }
            }
        },
        42676: function(e, t, r) {
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: !0
            }), t.Timestamp = t.protobufPackage = void 0;
            let n = r(23795),
                o = r(96987);

            function i() {
                return {
                    seconds: BigInt(0),
                    nanos: 0
                }
            }
            t.protobufPackage = "google.protobuf", t.Timestamp = {
                typeUrl: "/google.protobuf.Timestamp",
                encode: (e, t = n.BinaryWriter.create()) => (e.seconds !== BigInt(0) && t.uint32(8).int64(e.seconds), 0 !== e.nanos && t.uint32(16).int32(e.nanos), t),
                decode(e, t) {
                    let r = e instanceof n.BinaryReader ? e : new n.BinaryReader(e),
                        o = void 0 === t ? r.len : r.pos + t,
                        a = i();
                    for (; r.pos < o;) {
                        let e = r.uint32();
                        switch (e >>> 3) {
                            case 1:
                                a.seconds = r.int64();
                                break;
                            case 2:
                                a.nanos = r.int32();
                                break;
                            default:
                                r.skipType(7 & e)
                        }
                    }
                    return a
                },
                fromJSON(e) {
                    let t = i();
                    return (0, o.isSet)(e.seconds) && (t.seconds = BigInt(e.seconds.toString())), (0, o.isSet)(e.nanos) && (t.nanos = Number(e.nanos)), t
                },
                toJSON(e) {
                    let t = {};
                    return void 0 !== e.seconds && (t.seconds = (e.seconds || BigInt(0)).toString()), void 0 !== e.nanos && (t.nanos = Math.round(e.nanos)), t
                },
                fromPartial(e) {
                    let t = i();
                    return void 0 !== e.seconds && null !== e.seconds && (t.seconds = BigInt(e.seconds.toString())), t.nanos = e.nanos ? ? 0, t
                }
            }
        },
        96987: function(e, t, r) {
            "use strict";
            var n = r(48764).Buffer;
            Object.defineProperty(t, "__esModule", {
                value: !0
            }), t.fromJsonTimestamp = t.fromTimestamp = t.toTimestamp = t.setPaginationParams = t.isObject = t.isSet = t.fromDuration = t.toDuration = t.omitDefault = t.base64FromBytes = t.bytesFromBase64 = void 0;
            var o = (() => {
                if (void 0 !== o) return o;
                if ("undefined" != typeof self) return self;
                if ("undefined" != typeof window) return window;
                if (void 0 !== r.g) return r.g;
                throw "Unable to locate global object"
            })();
            let i = o.atob || (e => o.Buffer.from(e, "base64").toString("binary"));
            t.bytesFromBase64 = function(e) {
                let t = i(e),
                    r = new Uint8Array(t.length);
                for (let e = 0; e < t.length; ++e) r[e] = t.charCodeAt(e);
                return r
            };
            let a = o.btoa || (e => o.Buffer.from(e, "binary").toString("base64"));

            function s(e) {
                return null != e
            }

            function d(e) {
                return {
                    seconds: BigInt(Math.trunc(e.getTime() / 1e3)),
                    nanos: e.getTime() % 1e3 * 1e6
                }
            }
            t.base64FromBytes = function(e) {
                let t = [];
                return e.forEach(e => {
                    t.push(String.fromCharCode(e))
                }), a(t.join(""))
            }, t.omitDefault = function(e) {
                if ("string" == typeof e) return "" === e ? void 0 : e;
                if ("number" == typeof e) return 0 === e ? void 0 : e;
                if ("bigint" == typeof e) return e === BigInt(0) ? void 0 : e;
                throw Error(`Got unsupported type ${typeof e}`)
            }, t.toDuration = function(e) {
                return {
                    seconds: BigInt(Math.floor(parseInt(e) / 1e9)),
                    nanos: parseInt(e) % 1e9
                }
            }, t.fromDuration = function(e) {
                return (1e9 * parseInt(e.seconds.toString()) + e.nanos).toString()
            }, t.isSet = s, t.isObject = function(e) {
                return "object" == typeof e && null !== e
            }, t.setPaginationParams = (e, t) => (t && (void 0 !== t ? .countTotal && (e.params["pagination.count_total"] = t.countTotal), void 0 !== t ? .key && (e.params["pagination.key"] = n.from(t.key).toString("base64")), void 0 !== t ? .limit && (e.params["pagination.limit"] = t.limit.toString()), void 0 !== t ? .offset && (e.params["pagination.offset"] = t.offset.toString()), void 0 !== t ? .reverse && (e.params["pagination.reverse"] = t.reverse)), e), t.toTimestamp = d, t.fromTimestamp = function(e) {
                let t = 1e3 * Number(e.seconds);
                return new Date(t += e.nanos / 1e6)
            };
            let c = e => ({
                seconds: s(e.seconds) ? BigInt(e.seconds.toString()) : BigInt(0),
                nanos: s(e.nanos) ? Number(e.nanos) : 0
            });
            t.fromJsonTimestamp = function(e) {
                return e instanceof Date ? d(e) : "string" == typeof e ? d(new Date(e)) : c(e)
            }
        },
        76057: function(e, t, r) {
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: !0
            }), t.PublicKey = t.protobufPackage = void 0;
            let n = r(23795),
                o = r(96987);

            function i() {
                return {
                    ed25519: void 0,
                    secp256k1: void 0
                }
            }
            t.protobufPackage = "tendermint.crypto", t.PublicKey = {
                typeUrl: "/tendermint.crypto.PublicKey",
                encode: (e, t = n.BinaryWriter.create()) => (void 0 !== e.ed25519 && t.uint32(10).bytes(e.ed25519), void 0 !== e.secp256k1 && t.uint32(18).bytes(e.secp256k1), t),
                decode(e, t) {
                    let r = e instanceof n.BinaryReader ? e : new n.BinaryReader(e),
                        o = void 0 === t ? r.len : r.pos + t,
                        a = i();
                    for (; r.pos < o;) {
                        let e = r.uint32();
                        switch (e >>> 3) {
                            case 1:
                                a.ed25519 = r.bytes();
                                break;
                            case 2:
                                a.secp256k1 = r.bytes();
                                break;
                            default:
                                r.skipType(7 & e)
                        }
                    }
                    return a
                },
                fromJSON(e) {
                    let t = i();
                    return (0, o.isSet)(e.ed25519) && (t.ed25519 = (0, o.bytesFromBase64)(e.ed25519)), (0, o.isSet)(e.secp256k1) && (t.secp256k1 = (0, o.bytesFromBase64)(e.secp256k1)), t
                },
                toJSON(e) {
                    let t = {};
                    return void 0 !== e.ed25519 && (t.ed25519 = void 0 !== e.ed25519 ? (0, o.base64FromBytes)(e.ed25519) : void 0), void 0 !== e.secp256k1 && (t.secp256k1 = void 0 !== e.secp256k1 ? (0, o.base64FromBytes)(e.secp256k1) : void 0), t
                },
                fromPartial(e) {
                    let t = i();
                    return t.ed25519 = e.ed25519 ? ? void 0, t.secp256k1 = e.secp256k1 ? ? void 0, t
                }
            }
        },
        24635: function(e, t, r) {
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: !0
            }), t.ProofOps = t.ProofOp = t.DominoOp = t.ValueOp = t.Proof = t.protobufPackage = void 0;
            let n = r(23795),
                o = r(96987);

            function i() {
                return {
                    total: BigInt(0),
                    index: BigInt(0),
                    leafHash: new Uint8Array,
                    aunts: []
                }
            }

            function a() {
                return {
                    key: new Uint8Array,
                    proof: void 0
                }
            }

            function s() {
                return {
                    key: "",
                    input: "",
                    output: ""
                }
            }

            function d() {
                return {
                    type: "",
                    key: new Uint8Array,
                    data: new Uint8Array
                }
            }

            function c() {
                return {
                    ops: []
                }
            }
            t.protobufPackage = "tendermint.crypto", t.Proof = {
                typeUrl: "/tendermint.crypto.Proof",
                encode(e, t = n.BinaryWriter.create()) {
                    for (let r of (e.total !== BigInt(0) && t.uint32(8).int64(e.total), e.index !== BigInt(0) && t.uint32(16).int64(e.index), 0 !== e.leafHash.length && t.uint32(26).bytes(e.leafHash), e.aunts)) t.uint32(34).bytes(r);
                    return t
                },
                decode(e, t) {
                    let r = e instanceof n.BinaryReader ? e : new n.BinaryReader(e),
                        o = void 0 === t ? r.len : r.pos + t,
                        a = i();
                    for (; r.pos < o;) {
                        let e = r.uint32();
                        switch (e >>> 3) {
                            case 1:
                                a.total = r.int64();
                                break;
                            case 2:
                                a.index = r.int64();
                                break;
                            case 3:
                                a.leafHash = r.bytes();
                                break;
                            case 4:
                                a.aunts.push(r.bytes());
                                break;
                            default:
                                r.skipType(7 & e)
                        }
                    }
                    return a
                },
                fromJSON(e) {
                    let t = i();
                    return (0, o.isSet)(e.total) && (t.total = BigInt(e.total.toString())), (0, o.isSet)(e.index) && (t.index = BigInt(e.index.toString())), (0, o.isSet)(e.leafHash) && (t.leafHash = (0, o.bytesFromBase64)(e.leafHash)), Array.isArray(e ? .aunts) && (t.aunts = e.aunts.map(e => (0, o.bytesFromBase64)(e))), t
                },
                toJSON(e) {
                    let t = {};
                    return void 0 !== e.total && (t.total = (e.total || BigInt(0)).toString()), void 0 !== e.index && (t.index = (e.index || BigInt(0)).toString()), void 0 !== e.leafHash && (t.leafHash = (0, o.base64FromBytes)(void 0 !== e.leafHash ? e.leafHash : new Uint8Array)), e.aunts ? t.aunts = e.aunts.map(e => (0, o.base64FromBytes)(void 0 !== e ? e : new Uint8Array)) : t.aunts = [], t
                },
                fromPartial(e) {
                    let t = i();
                    return void 0 !== e.total && null !== e.total && (t.total = BigInt(e.total.toString())), void 0 !== e.index && null !== e.index && (t.index = BigInt(e.index.toString())), t.leafHash = e.leafHash ? ? new Uint8Array, t.aunts = e.aunts ? .map(e => e) || [], t
                }
            }, t.ValueOp = {
                typeUrl: "/tendermint.crypto.ValueOp",
                encode: (e, r = n.BinaryWriter.create()) => (0 !== e.key.length && r.uint32(10).bytes(e.key), void 0 !== e.proof && t.Proof.encode(e.proof, r.uint32(18).fork()).ldelim(), r),
                decode(e, r) {
                    let o = e instanceof n.BinaryReader ? e : new n.BinaryReader(e),
                        i = void 0 === r ? o.len : o.pos + r,
                        s = a();
                    for (; o.pos < i;) {
                        let e = o.uint32();
                        switch (e >>> 3) {
                            case 1:
                                s.key = o.bytes();
                                break;
                            case 2:
                                s.proof = t.Proof.decode(o, o.uint32());
                                break;
                            default:
                                o.skipType(7 & e)
                        }
                    }
                    return s
                },
                fromJSON(e) {
                    let r = a();
                    return (0, o.isSet)(e.key) && (r.key = (0, o.bytesFromBase64)(e.key)), (0, o.isSet)(e.proof) && (r.proof = t.Proof.fromJSON(e.proof)), r
                },
                toJSON(e) {
                    let r = {};
                    return void 0 !== e.key && (r.key = (0, o.base64FromBytes)(void 0 !== e.key ? e.key : new Uint8Array)), void 0 !== e.proof && (r.proof = e.proof ? t.Proof.toJSON(e.proof) : void 0), r
                },
                fromPartial(e) {
                    let r = a();
                    return r.key = e.key ? ? new Uint8Array, void 0 !== e.proof && null !== e.proof && (r.proof = t.Proof.fromPartial(e.proof)), r
                }
            }, t.DominoOp = {
                typeUrl: "/tendermint.crypto.DominoOp",
                encode: (e, t = n.BinaryWriter.create()) => ("" !== e.key && t.uint32(10).string(e.key), "" !== e.input && t.uint32(18).string(e.input), "" !== e.output && t.uint32(26).string(e.output), t),
                decode(e, t) {
                    let r = e instanceof n.BinaryReader ? e : new n.BinaryReader(e),
                        o = void 0 === t ? r.len : r.pos + t,
                        i = s();
                    for (; r.pos < o;) {
                        let e = r.uint32();
                        switch (e >>> 3) {
                            case 1:
                                i.key = r.string();
                                break;
                            case 2:
                                i.input = r.string();
                                break;
                            case 3:
                                i.output = r.string();
                                break;
                            default:
                                r.skipType(7 & e)
                        }
                    }
                    return i
                },
                fromJSON(e) {
                    let t = s();
                    return (0, o.isSet)(e.key) && (t.key = String(e.key)), (0, o.isSet)(e.input) && (t.input = String(e.input)), (0, o.isSet)(e.output) && (t.output = String(e.output)), t
                },
                toJSON(e) {
                    let t = {};
                    return void 0 !== e.key && (t.key = e.key), void 0 !== e.input && (t.input = e.input), void 0 !== e.output && (t.output = e.output), t
                },
                fromPartial(e) {
                    let t = s();
                    return t.key = e.key ? ? "", t.input = e.input ? ? "", t.output = e.output ? ? "", t
                }
            }, t.ProofOp = {
                typeUrl: "/tendermint.crypto.ProofOp",
                encode: (e, t = n.BinaryWriter.create()) => ("" !== e.type && t.uint32(10).string(e.type), 0 !== e.key.length && t.uint32(18).bytes(e.key), 0 !== e.data.length && t.uint32(26).bytes(e.data), t),
                decode(e, t) {
                    let r = e instanceof n.BinaryReader ? e : new n.BinaryReader(e),
                        o = void 0 === t ? r.len : r.pos + t,
                        i = d();
                    for (; r.pos < o;) {
                        let e = r.uint32();
                        switch (e >>> 3) {
                            case 1:
                                i.type = r.string();
                                break;
                            case 2:
                                i.key = r.bytes();
                                break;
                            case 3:
                                i.data = r.bytes();
                                break;
                            default:
                                r.skipType(7 & e)
                        }
                    }
                    return i
                },
                fromJSON(e) {
                    let t = d();
                    return (0, o.isSet)(e.type) && (t.type = String(e.type)), (0, o.isSet)(e.key) && (t.key = (0, o.bytesFromBase64)(e.key)), (0, o.isSet)(e.data) && (t.data = (0, o.bytesFromBase64)(e.data)), t
                },
                toJSON(e) {
                    let t = {};
                    return void 0 !== e.type && (t.type = e.type), void 0 !== e.key && (t.key = (0, o.base64FromBytes)(void 0 !== e.key ? e.key : new Uint8Array)), void 0 !== e.data && (t.data = (0, o.base64FromBytes)(void 0 !== e.data ? e.data : new Uint8Array)), t
                },
                fromPartial(e) {
                    let t = d();
                    return t.type = e.type ? ? "", t.key = e.key ? ? new Uint8Array, t.data = e.data ? ? new Uint8Array, t
                }
            }, t.ProofOps = {
                typeUrl: "/tendermint.crypto.ProofOps",
                encode(e, r = n.BinaryWriter.create()) {
                    for (let n of e.ops) t.ProofOp.encode(n, r.uint32(10).fork()).ldelim();
                    return r
                },
                decode(e, r) {
                    let o = e instanceof n.BinaryReader ? e : new n.BinaryReader(e),
                        i = void 0 === r ? o.len : o.pos + r,
                        a = c();
                    for (; o.pos < i;) {
                        let e = o.uint32();
                        e >>> 3 == 1 ? a.ops.push(t.ProofOp.decode(o, o.uint32())) : o.skipType(7 & e)
                    }
                    return a
                },
                fromJSON(e) {
                    let r = c();
                    return Array.isArray(e ? .ops) && (r.ops = e.ops.map(e => t.ProofOp.fromJSON(e))), r
                },
                toJSON(e) {
                    let r = {};
                    return e.ops ? r.ops = e.ops.map(e => e ? t.ProofOp.toJSON(e) : void 0) : r.ops = [], r
                },
                fromPartial(e) {
                    let r = c();
                    return r.ops = e.ops ? .map(e => t.ProofOp.fromPartial(e)) || [], r
                }
            }
        },
        16987: function(e, t, r) {
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: !0
            }), t.HashedParams = t.VersionParams = t.ValidatorParams = t.EvidenceParams = t.BlockParams = t.ConsensusParams = t.protobufPackage = void 0;
            let n = r(14933),
                o = r(23795),
                i = r(96987);

            function a() {
                return {
                    block: void 0,
                    evidence: void 0,
                    validator: void 0,
                    version: void 0
                }
            }

            function s() {
                return {
                    maxBytes: BigInt(0),
                    maxGas: BigInt(0)
                }
            }

            function d() {
                return {
                    maxAgeNumBlocks: BigInt(0),
                    maxAgeDuration: n.Duration.fromPartial({}),
                    maxBytes: BigInt(0)
                }
            }

            function c() {
                return {
                    pubKeyTypes: []
                }
            }

            function l() {
                return {
                    app: BigInt(0)
                }
            }

            function u() {
                return {
                    blockMaxBytes: BigInt(0),
                    blockMaxGas: BigInt(0)
                }
            }
            t.protobufPackage = "tendermint.types", t.ConsensusParams = {
                typeUrl: "/tendermint.types.ConsensusParams",
                encode: (e, r = o.BinaryWriter.create()) => (void 0 !== e.block && t.BlockParams.encode(e.block, r.uint32(10).fork()).ldelim(), void 0 !== e.evidence && t.EvidenceParams.encode(e.evidence, r.uint32(18).fork()).ldelim(), void 0 !== e.validator && t.ValidatorParams.encode(e.validator, r.uint32(26).fork()).ldelim(), void 0 !== e.version && t.VersionParams.encode(e.version, r.uint32(34).fork()).ldelim(), r),
                decode(e, r) {
                    let n = e instanceof o.BinaryReader ? e : new o.BinaryReader(e),
                        i = void 0 === r ? n.len : n.pos + r,
                        s = a();
                    for (; n.pos < i;) {
                        let e = n.uint32();
                        switch (e >>> 3) {
                            case 1:
                                s.block = t.BlockParams.decode(n, n.uint32());
                                break;
                            case 2:
                                s.evidence = t.EvidenceParams.decode(n, n.uint32());
                                break;
                            case 3:
                                s.validator = t.ValidatorParams.decode(n, n.uint32());
                                break;
                            case 4:
                                s.version = t.VersionParams.decode(n, n.uint32());
                                break;
                            default:
                                n.skipType(7 & e)
                        }
                    }
                    return s
                },
                fromJSON(e) {
                    let r = a();
                    return (0, i.isSet)(e.block) && (r.block = t.BlockParams.fromJSON(e.block)), (0, i.isSet)(e.evidence) && (r.evidence = t.EvidenceParams.fromJSON(e.evidence)), (0, i.isSet)(e.validator) && (r.validator = t.ValidatorParams.fromJSON(e.validator)), (0, i.isSet)(e.version) && (r.version = t.VersionParams.fromJSON(e.version)), r
                },
                toJSON(e) {
                    let r = {};
                    return void 0 !== e.block && (r.block = e.block ? t.BlockParams.toJSON(e.block) : void 0), void 0 !== e.evidence && (r.evidence = e.evidence ? t.EvidenceParams.toJSON(e.evidence) : void 0), void 0 !== e.validator && (r.validator = e.validator ? t.ValidatorParams.toJSON(e.validator) : void 0), void 0 !== e.version && (r.version = e.version ? t.VersionParams.toJSON(e.version) : void 0), r
                },
                fromPartial(e) {
                    let r = a();
                    return void 0 !== e.block && null !== e.block && (r.block = t.BlockParams.fromPartial(e.block)), void 0 !== e.evidence && null !== e.evidence && (r.evidence = t.EvidenceParams.fromPartial(e.evidence)), void 0 !== e.validator && null !== e.validator && (r.validator = t.ValidatorParams.fromPartial(e.validator)), void 0 !== e.version && null !== e.version && (r.version = t.VersionParams.fromPartial(e.version)), r
                }
            }, t.BlockParams = {
                typeUrl: "/tendermint.types.BlockParams",
                encode: (e, t = o.BinaryWriter.create()) => (e.maxBytes !== BigInt(0) && t.uint32(8).int64(e.maxBytes), e.maxGas !== BigInt(0) && t.uint32(16).int64(e.maxGas), t),
                decode(e, t) {
                    let r = e instanceof o.BinaryReader ? e : new o.BinaryReader(e),
                        n = void 0 === t ? r.len : r.pos + t,
                        i = s();
                    for (; r.pos < n;) {
                        let e = r.uint32();
                        switch (e >>> 3) {
                            case 1:
                                i.maxBytes = r.int64();
                                break;
                            case 2:
                                i.maxGas = r.int64();
                                break;
                            default:
                                r.skipType(7 & e)
                        }
                    }
                    return i
                },
                fromJSON(e) {
                    let t = s();
                    return (0, i.isSet)(e.maxBytes) && (t.maxBytes = BigInt(e.maxBytes.toString())), (0, i.isSet)(e.maxGas) && (t.maxGas = BigInt(e.maxGas.toString())), t
                },
                toJSON(e) {
                    let t = {};
                    return void 0 !== e.maxBytes && (t.maxBytes = (e.maxBytes || BigInt(0)).toString()), void 0 !== e.maxGas && (t.maxGas = (e.maxGas || BigInt(0)).toString()), t
                },
                fromPartial(e) {
                    let t = s();
                    return void 0 !== e.maxBytes && null !== e.maxBytes && (t.maxBytes = BigInt(e.maxBytes.toString())), void 0 !== e.maxGas && null !== e.maxGas && (t.maxGas = BigInt(e.maxGas.toString())), t
                }
            }, t.EvidenceParams = {
                typeUrl: "/tendermint.types.EvidenceParams",
                encode: (e, t = o.BinaryWriter.create()) => (e.maxAgeNumBlocks !== BigInt(0) && t.uint32(8).int64(e.maxAgeNumBlocks), void 0 !== e.maxAgeDuration && n.Duration.encode(e.maxAgeDuration, t.uint32(18).fork()).ldelim(), e.maxBytes !== BigInt(0) && t.uint32(24).int64(e.maxBytes), t),
                decode(e, t) {
                    let r = e instanceof o.BinaryReader ? e : new o.BinaryReader(e),
                        i = void 0 === t ? r.len : r.pos + t,
                        a = d();
                    for (; r.pos < i;) {
                        let e = r.uint32();
                        switch (e >>> 3) {
                            case 1:
                                a.maxAgeNumBlocks = r.int64();
                                break;
                            case 2:
                                a.maxAgeDuration = n.Duration.decode(r, r.uint32());
                                break;
                            case 3:
                                a.maxBytes = r.int64();
                                break;
                            default:
                                r.skipType(7 & e)
                        }
                    }
                    return a
                },
                fromJSON(e) {
                    let t = d();
                    return (0, i.isSet)(e.maxAgeNumBlocks) && (t.maxAgeNumBlocks = BigInt(e.maxAgeNumBlocks.toString())), (0, i.isSet)(e.maxAgeDuration) && (t.maxAgeDuration = n.Duration.fromJSON(e.maxAgeDuration)), (0, i.isSet)(e.maxBytes) && (t.maxBytes = BigInt(e.maxBytes.toString())), t
                },
                toJSON(e) {
                    let t = {};
                    return void 0 !== e.maxAgeNumBlocks && (t.maxAgeNumBlocks = (e.maxAgeNumBlocks || BigInt(0)).toString()), void 0 !== e.maxAgeDuration && (t.maxAgeDuration = e.maxAgeDuration ? n.Duration.toJSON(e.maxAgeDuration) : void 0), void 0 !== e.maxBytes && (t.maxBytes = (e.maxBytes || BigInt(0)).toString()), t
                },
                fromPartial(e) {
                    let t = d();
                    return void 0 !== e.maxAgeNumBlocks && null !== e.maxAgeNumBlocks && (t.maxAgeNumBlocks = BigInt(e.maxAgeNumBlocks.toString())), void 0 !== e.maxAgeDuration && null !== e.maxAgeDuration && (t.maxAgeDuration = n.Duration.fromPartial(e.maxAgeDuration)), void 0 !== e.maxBytes && null !== e.maxBytes && (t.maxBytes = BigInt(e.maxBytes.toString())), t
                }
            }, t.ValidatorParams = {
                typeUrl: "/tendermint.types.ValidatorParams",
                encode(e, t = o.BinaryWriter.create()) {
                    for (let r of e.pubKeyTypes) t.uint32(10).string(r);
                    return t
                },
                decode(e, t) {
                    let r = e instanceof o.BinaryReader ? e : new o.BinaryReader(e),
                        n = void 0 === t ? r.len : r.pos + t,
                        i = c();
                    for (; r.pos < n;) {
                        let e = r.uint32();
                        e >>> 3 == 1 ? i.pubKeyTypes.push(r.string()) : r.skipType(7 & e)
                    }
                    return i
                },
                fromJSON(e) {
                    let t = c();
                    return Array.isArray(e ? .pubKeyTypes) && (t.pubKeyTypes = e.pubKeyTypes.map(e => String(e))), t
                },
                toJSON(e) {
                    let t = {};
                    return e.pubKeyTypes ? t.pubKeyTypes = e.pubKeyTypes.map(e => e) : t.pubKeyTypes = [], t
                },
                fromPartial(e) {
                    let t = c();
                    return t.pubKeyTypes = e.pubKeyTypes ? .map(e => e) || [], t
                }
            }, t.VersionParams = {
                typeUrl: "/tendermint.types.VersionParams",
                encode: (e, t = o.BinaryWriter.create()) => (e.app !== BigInt(0) && t.uint32(8).uint64(e.app), t),
                decode(e, t) {
                    let r = e instanceof o.BinaryReader ? e : new o.BinaryReader(e),
                        n = void 0 === t ? r.len : r.pos + t,
                        i = l();
                    for (; r.pos < n;) {
                        let e = r.uint32();
                        e >>> 3 == 1 ? i.app = r.uint64() : r.skipType(7 & e)
                    }
                    return i
                },
                fromJSON(e) {
                    let t = l();
                    return (0, i.isSet)(e.app) && (t.app = BigInt(e.app.toString())), t
                },
                toJSON(e) {
                    let t = {};
                    return void 0 !== e.app && (t.app = (e.app || BigInt(0)).toString()), t
                },
                fromPartial(e) {
                    let t = l();
                    return void 0 !== e.app && null !== e.app && (t.app = BigInt(e.app.toString())), t
                }
            }, t.HashedParams = {
                typeUrl: "/tendermint.types.HashedParams",
                encode: (e, t = o.BinaryWriter.create()) => (e.blockMaxBytes !== BigInt(0) && t.uint32(8).int64(e.blockMaxBytes), e.blockMaxGas !== BigInt(0) && t.uint32(16).int64(e.blockMaxGas), t),
                decode(e, t) {
                    let r = e instanceof o.BinaryReader ? e : new o.BinaryReader(e),
                        n = void 0 === t ? r.len : r.pos + t,
                        i = u();
                    for (; r.pos < n;) {
                        let e = r.uint32();
                        switch (e >>> 3) {
                            case 1:
                                i.blockMaxBytes = r.int64();
                                break;
                            case 2:
                                i.blockMaxGas = r.int64();
                                break;
                            default:
                                r.skipType(7 & e)
                        }
                    }
                    return i
                },
                fromJSON(e) {
                    let t = u();
                    return (0, i.isSet)(e.blockMaxBytes) && (t.blockMaxBytes = BigInt(e.blockMaxBytes.toString())), (0, i.isSet)(e.blockMaxGas) && (t.blockMaxGas = BigInt(e.blockMaxGas.toString())), t
                },
                toJSON(e) {
                    let t = {};
                    return void 0 !== e.blockMaxBytes && (t.blockMaxBytes = (e.blockMaxBytes || BigInt(0)).toString()), void 0 !== e.blockMaxGas && (t.blockMaxGas = (e.blockMaxGas || BigInt(0)).toString()), t
                },
                fromPartial(e) {
                    let t = u();
                    return void 0 !== e.blockMaxBytes && null !== e.blockMaxBytes && (t.blockMaxBytes = BigInt(e.blockMaxBytes.toString())), void 0 !== e.blockMaxGas && null !== e.blockMaxGas && (t.blockMaxGas = BigInt(e.blockMaxGas.toString())), t
                }
            }
        },
        55081: function(e, t, r) {
            "use strict";
            var n, o, i, a;
            Object.defineProperty(t, "__esModule", {
                value: !0
            }), t.TxProof = t.BlockMeta = t.LightBlock = t.SignedHeader = t.Proposal = t.CommitSig = t.Commit = t.Vote = t.Data = t.Header = t.BlockID = t.Part = t.PartSetHeader = t.signedMsgTypeToJSON = t.signedMsgTypeFromJSON = t.SignedMsgType = t.blockIDFlagToJSON = t.blockIDFlagFromJSON = t.BlockIDFlag = t.protobufPackage = void 0;
            let s = r(24635),
                d = r(46874),
                c = r(42676),
                l = r(67112),
                u = r(23795),
                p = r(96987);

            function m(e) {
                switch (e) {
                    case 0:
                    case "BLOCK_ID_FLAG_UNKNOWN":
                        return n.BLOCK_ID_FLAG_UNKNOWN;
                    case 1:
                    case "BLOCK_ID_FLAG_ABSENT":
                        return n.BLOCK_ID_FLAG_ABSENT;
                    case 2:
                    case "BLOCK_ID_FLAG_COMMIT":
                        return n.BLOCK_ID_FLAG_COMMIT;
                    case 3:
                    case "BLOCK_ID_FLAG_NIL":
                        return n.BLOCK_ID_FLAG_NIL;
                    default:
                        return n.UNRECOGNIZED
                }
            }

            function g(e) {
                switch (e) {
                    case n.BLOCK_ID_FLAG_UNKNOWN:
                        return "BLOCK_ID_FLAG_UNKNOWN";
                    case n.BLOCK_ID_FLAG_ABSENT:
                        return "BLOCK_ID_FLAG_ABSENT";
                    case n.BLOCK_ID_FLAG_COMMIT:
                        return "BLOCK_ID_FLAG_COMMIT";
                    case n.BLOCK_ID_FLAG_NIL:
                        return "BLOCK_ID_FLAG_NIL";
                    case n.UNRECOGNIZED:
                    default:
                        return "UNRECOGNIZED"
                }
            }

            function f(e) {
                switch (e) {
                    case 0:
                    case "SIGNED_MSG_TYPE_UNKNOWN":
                        return o.SIGNED_MSG_TYPE_UNKNOWN;
                    case 1:
                    case "SIGNED_MSG_TYPE_PREVOTE":
                        return o.SIGNED_MSG_TYPE_PREVOTE;
                    case 2:
                    case "SIGNED_MSG_TYPE_PRECOMMIT":
                        return o.SIGNED_MSG_TYPE_PRECOMMIT;
                    case 32:
                    case "SIGNED_MSG_TYPE_PROPOSAL":
                        return o.SIGNED_MSG_TYPE_PROPOSAL;
                    default:
                        return o.UNRECOGNIZED
                }
            }

            function y(e) {
                switch (e) {
                    case o.SIGNED_MSG_TYPE_UNKNOWN:
                        return "SIGNED_MSG_TYPE_UNKNOWN";
                    case o.SIGNED_MSG_TYPE_PREVOTE:
                        return "SIGNED_MSG_TYPE_PREVOTE";
                    case o.SIGNED_MSG_TYPE_PRECOMMIT:
                        return "SIGNED_MSG_TYPE_PRECOMMIT";
                    case o.SIGNED_MSG_TYPE_PROPOSAL:
                        return "SIGNED_MSG_TYPE_PROPOSAL";
                    case o.UNRECOGNIZED:
                    default:
                        return "UNRECOGNIZED"
                }
            }

            function h() {
                return {
                    total: 0,
                    hash: new Uint8Array
                }
            }

            function v() {
                return {
                    index: 0,
                    bytes: new Uint8Array,
                    proof: s.Proof.fromPartial({})
                }
            }

            function b() {
                return {
                    hash: new Uint8Array,
                    partSetHeader: t.PartSetHeader.fromPartial({})
                }
            }

            function S() {
                return {
                    version: d.Consensus.fromPartial({}),
                    chainId: "",
                    height: BigInt(0),
                    time: c.Timestamp.fromPartial({}),
                    lastBlockId: t.BlockID.fromPartial({}),
                    lastCommitHash: new Uint8Array,
                    dataHash: new Uint8Array,
                    validatorsHash: new Uint8Array,
                    nextValidatorsHash: new Uint8Array,
                    consensusHash: new Uint8Array,
                    appHash: new Uint8Array,
                    lastResultsHash: new Uint8Array,
                    evidenceHash: new Uint8Array,
                    proposerAddress: new Uint8Array
                }
            }

            function k() {
                return {
                    txs: []
                }
            }

            function P() {
                return {
                    type: 0,
                    height: BigInt(0),
                    round: 0,
                    blockId: t.BlockID.fromPartial({}),
                    timestamp: c.Timestamp.fromPartial({}),
                    validatorAddress: new Uint8Array,
                    validatorIndex: 0,
                    signature: new Uint8Array
                }
            }

            function _() {
                return {
                    height: BigInt(0),
                    round: 0,
                    blockId: t.BlockID.fromPartial({}),
                    signatures: []
                }
            }

            function B() {
                return {
                    blockIdFlag: 0,
                    validatorAddress: new Uint8Array,
                    timestamp: c.Timestamp.fromPartial({}),
                    signature: new Uint8Array
                }
            }

            function O() {
                return {
                    type: 0,
                    height: BigInt(0),
                    round: 0,
                    polRound: 0,
                    blockId: t.BlockID.fromPartial({}),
                    timestamp: c.Timestamp.fromPartial({}),
                    signature: new Uint8Array
                }
            }

            function R() {
                return {
                    header: void 0,
                    commit: void 0
                }
            }

            function A() {
                return {
                    signedHeader: void 0,
                    validatorSet: void 0
                }
            }

            function I() {
                return {
                    blockId: t.BlockID.fromPartial({}),
                    blockSize: BigInt(0),
                    header: t.Header.fromPartial({}),
                    numTxs: BigInt(0)
                }
            }

            function w() {
                return {
                    rootHash: new Uint8Array,
                    data: new Uint8Array,
                    proof: void 0
                }
            }
            t.protobufPackage = "tendermint.types", (i = n || (t.BlockIDFlag = n = {}))[i.BLOCK_ID_FLAG_UNKNOWN = 0] = "BLOCK_ID_FLAG_UNKNOWN", i[i.BLOCK_ID_FLAG_ABSENT = 1] = "BLOCK_ID_FLAG_ABSENT", i[i.BLOCK_ID_FLAG_COMMIT = 2] = "BLOCK_ID_FLAG_COMMIT", i[i.BLOCK_ID_FLAG_NIL = 3] = "BLOCK_ID_FLAG_NIL", i[i.UNRECOGNIZED = -1] = "UNRECOGNIZED", t.blockIDFlagFromJSON = m, t.blockIDFlagToJSON = g, (a = o || (t.SignedMsgType = o = {}))[a.SIGNED_MSG_TYPE_UNKNOWN = 0] = "SIGNED_MSG_TYPE_UNKNOWN", a[a.SIGNED_MSG_TYPE_PREVOTE = 1] = "SIGNED_MSG_TYPE_PREVOTE", a[a.SIGNED_MSG_TYPE_PRECOMMIT = 2] = "SIGNED_MSG_TYPE_PRECOMMIT", a[a.SIGNED_MSG_TYPE_PROPOSAL = 32] = "SIGNED_MSG_TYPE_PROPOSAL", a[a.UNRECOGNIZED = -1] = "UNRECOGNIZED", t.signedMsgTypeFromJSON = f, t.signedMsgTypeToJSON = y, t.PartSetHeader = {
                typeUrl: "/tendermint.types.PartSetHeader",
                encode: (e, t = u.BinaryWriter.create()) => (0 !== e.total && t.uint32(8).uint32(e.total), 0 !== e.hash.length && t.uint32(18).bytes(e.hash), t),
                decode(e, t) {
                    let r = e instanceof u.BinaryReader ? e : new u.BinaryReader(e),
                        n = void 0 === t ? r.len : r.pos + t,
                        o = h();
                    for (; r.pos < n;) {
                        let e = r.uint32();
                        switch (e >>> 3) {
                            case 1:
                                o.total = r.uint32();
                                break;
                            case 2:
                                o.hash = r.bytes();
                                break;
                            default:
                                r.skipType(7 & e)
                        }
                    }
                    return o
                },
                fromJSON(e) {
                    let t = h();
                    return (0, p.isSet)(e.total) && (t.total = Number(e.total)), (0, p.isSet)(e.hash) && (t.hash = (0, p.bytesFromBase64)(e.hash)), t
                },
                toJSON(e) {
                    let t = {};
                    return void 0 !== e.total && (t.total = Math.round(e.total)), void 0 !== e.hash && (t.hash = (0, p.base64FromBytes)(void 0 !== e.hash ? e.hash : new Uint8Array)), t
                },
                fromPartial(e) {
                    let t = h();
                    return t.total = e.total ? ? 0, t.hash = e.hash ? ? new Uint8Array, t
                }
            }, t.Part = {
                typeUrl: "/tendermint.types.Part",
                encode: (e, t = u.BinaryWriter.create()) => (0 !== e.index && t.uint32(8).uint32(e.index), 0 !== e.bytes.length && t.uint32(18).bytes(e.bytes), void 0 !== e.proof && s.Proof.encode(e.proof, t.uint32(26).fork()).ldelim(), t),
                decode(e, t) {
                    let r = e instanceof u.BinaryReader ? e : new u.BinaryReader(e),
                        n = void 0 === t ? r.len : r.pos + t,
                        o = v();
                    for (; r.pos < n;) {
                        let e = r.uint32();
                        switch (e >>> 3) {
                            case 1:
                                o.index = r.uint32();
                                break;
                            case 2:
                                o.bytes = r.bytes();
                                break;
                            case 3:
                                o.proof = s.Proof.decode(r, r.uint32());
                                break;
                            default:
                                r.skipType(7 & e)
                        }
                    }
                    return o
                },
                fromJSON(e) {
                    let t = v();
                    return (0, p.isSet)(e.index) && (t.index = Number(e.index)), (0, p.isSet)(e.bytes) && (t.bytes = (0, p.bytesFromBase64)(e.bytes)), (0, p.isSet)(e.proof) && (t.proof = s.Proof.fromJSON(e.proof)), t
                },
                toJSON(e) {
                    let t = {};
                    return void 0 !== e.index && (t.index = Math.round(e.index)), void 0 !== e.bytes && (t.bytes = (0, p.base64FromBytes)(void 0 !== e.bytes ? e.bytes : new Uint8Array)), void 0 !== e.proof && (t.proof = e.proof ? s.Proof.toJSON(e.proof) : void 0), t
                },
                fromPartial(e) {
                    let t = v();
                    return t.index = e.index ? ? 0, t.bytes = e.bytes ? ? new Uint8Array, void 0 !== e.proof && null !== e.proof && (t.proof = s.Proof.fromPartial(e.proof)), t
                }
            }, t.BlockID = {
                typeUrl: "/tendermint.types.BlockID",
                encode: (e, r = u.BinaryWriter.create()) => (0 !== e.hash.length && r.uint32(10).bytes(e.hash), void 0 !== e.partSetHeader && t.PartSetHeader.encode(e.partSetHeader, r.uint32(18).fork()).ldelim(), r),
                decode(e, r) {
                    let n = e instanceof u.BinaryReader ? e : new u.BinaryReader(e),
                        o = void 0 === r ? n.len : n.pos + r,
                        i = b();
                    for (; n.pos < o;) {
                        let e = n.uint32();
                        switch (e >>> 3) {
                            case 1:
                                i.hash = n.bytes();
                                break;
                            case 2:
                                i.partSetHeader = t.PartSetHeader.decode(n, n.uint32());
                                break;
                            default:
                                n.skipType(7 & e)
                        }
                    }
                    return i
                },
                fromJSON(e) {
                    let r = b();
                    return (0, p.isSet)(e.hash) && (r.hash = (0, p.bytesFromBase64)(e.hash)), (0, p.isSet)(e.partSetHeader) && (r.partSetHeader = t.PartSetHeader.fromJSON(e.partSetHeader)), r
                },
                toJSON(e) {
                    let r = {};
                    return void 0 !== e.hash && (r.hash = (0, p.base64FromBytes)(void 0 !== e.hash ? e.hash : new Uint8Array)), void 0 !== e.partSetHeader && (r.partSetHeader = e.partSetHeader ? t.PartSetHeader.toJSON(e.partSetHeader) : void 0), r
                },
                fromPartial(e) {
                    let r = b();
                    return r.hash = e.hash ? ? new Uint8Array, void 0 !== e.partSetHeader && null !== e.partSetHeader && (r.partSetHeader = t.PartSetHeader.fromPartial(e.partSetHeader)), r
                }
            }, t.Header = {
                typeUrl: "/tendermint.types.Header",
                encode: (e, r = u.BinaryWriter.create()) => (void 0 !== e.version && d.Consensus.encode(e.version, r.uint32(10).fork()).ldelim(), "" !== e.chainId && r.uint32(18).string(e.chainId), e.height !== BigInt(0) && r.uint32(24).int64(e.height), void 0 !== e.time && c.Timestamp.encode(e.time, r.uint32(34).fork()).ldelim(), void 0 !== e.lastBlockId && t.BlockID.encode(e.lastBlockId, r.uint32(42).fork()).ldelim(), 0 !== e.lastCommitHash.length && r.uint32(50).bytes(e.lastCommitHash), 0 !== e.dataHash.length && r.uint32(58).bytes(e.dataHash), 0 !== e.validatorsHash.length && r.uint32(66).bytes(e.validatorsHash), 0 !== e.nextValidatorsHash.length && r.uint32(74).bytes(e.nextValidatorsHash), 0 !== e.consensusHash.length && r.uint32(82).bytes(e.consensusHash), 0 !== e.appHash.length && r.uint32(90).bytes(e.appHash), 0 !== e.lastResultsHash.length && r.uint32(98).bytes(e.lastResultsHash), 0 !== e.evidenceHash.length && r.uint32(106).bytes(e.evidenceHash), 0 !== e.proposerAddress.length && r.uint32(114).bytes(e.proposerAddress), r),
                decode(e, r) {
                    let n = e instanceof u.BinaryReader ? e : new u.BinaryReader(e),
                        o = void 0 === r ? n.len : n.pos + r,
                        i = S();
                    for (; n.pos < o;) {
                        let e = n.uint32();
                        switch (e >>> 3) {
                            case 1:
                                i.version = d.Consensus.decode(n, n.uint32());
                                break;
                            case 2:
                                i.chainId = n.string();
                                break;
                            case 3:
                                i.height = n.int64();
                                break;
                            case 4:
                                i.time = c.Timestamp.decode(n, n.uint32());
                                break;
                            case 5:
                                i.lastBlockId = t.BlockID.decode(n, n.uint32());
                                break;
                            case 6:
                                i.lastCommitHash = n.bytes();
                                break;
                            case 7:
                                i.dataHash = n.bytes();
                                break;
                            case 8:
                                i.validatorsHash = n.bytes();
                                break;
                            case 9:
                                i.nextValidatorsHash = n.bytes();
                                break;
                            case 10:
                                i.consensusHash = n.bytes();
                                break;
                            case 11:
                                i.appHash = n.bytes();
                                break;
                            case 12:
                                i.lastResultsHash = n.bytes();
                                break;
                            case 13:
                                i.evidenceHash = n.bytes();
                                break;
                            case 14:
                                i.proposerAddress = n.bytes();
                                break;
                            default:
                                n.skipType(7 & e)
                        }
                    }
                    return i
                },
                fromJSON(e) {
                    let r = S();
                    return (0, p.isSet)(e.version) && (r.version = d.Consensus.fromJSON(e.version)), (0, p.isSet)(e.chainId) && (r.chainId = String(e.chainId)), (0, p.isSet)(e.height) && (r.height = BigInt(e.height.toString())), (0, p.isSet)(e.time) && (r.time = (0, p.fromJsonTimestamp)(e.time)), (0, p.isSet)(e.lastBlockId) && (r.lastBlockId = t.BlockID.fromJSON(e.lastBlockId)), (0, p.isSet)(e.lastCommitHash) && (r.lastCommitHash = (0, p.bytesFromBase64)(e.lastCommitHash)), (0, p.isSet)(e.dataHash) && (r.dataHash = (0, p.bytesFromBase64)(e.dataHash)), (0, p.isSet)(e.validatorsHash) && (r.validatorsHash = (0, p.bytesFromBase64)(e.validatorsHash)), (0, p.isSet)(e.nextValidatorsHash) && (r.nextValidatorsHash = (0, p.bytesFromBase64)(e.nextValidatorsHash)), (0, p.isSet)(e.consensusHash) && (r.consensusHash = (0, p.bytesFromBase64)(e.consensusHash)), (0, p.isSet)(e.appHash) && (r.appHash = (0, p.bytesFromBase64)(e.appHash)), (0, p.isSet)(e.lastResultsHash) && (r.lastResultsHash = (0, p.bytesFromBase64)(e.lastResultsHash)), (0, p.isSet)(e.evidenceHash) && (r.evidenceHash = (0, p.bytesFromBase64)(e.evidenceHash)), (0, p.isSet)(e.proposerAddress) && (r.proposerAddress = (0, p.bytesFromBase64)(e.proposerAddress)), r
                },
                toJSON(e) {
                    let r = {};
                    return void 0 !== e.version && (r.version = e.version ? d.Consensus.toJSON(e.version) : void 0), void 0 !== e.chainId && (r.chainId = e.chainId), void 0 !== e.height && (r.height = (e.height || BigInt(0)).toString()), void 0 !== e.time && (r.time = (0, p.fromTimestamp)(e.time).toISOString()), void 0 !== e.lastBlockId && (r.lastBlockId = e.lastBlockId ? t.BlockID.toJSON(e.lastBlockId) : void 0), void 0 !== e.lastCommitHash && (r.lastCommitHash = (0, p.base64FromBytes)(void 0 !== e.lastCommitHash ? e.lastCommitHash : new Uint8Array)), void 0 !== e.dataHash && (r.dataHash = (0, p.base64FromBytes)(void 0 !== e.dataHash ? e.dataHash : new Uint8Array)), void 0 !== e.validatorsHash && (r.validatorsHash = (0, p.base64FromBytes)(void 0 !== e.validatorsHash ? e.validatorsHash : new Uint8Array)), void 0 !== e.nextValidatorsHash && (r.nextValidatorsHash = (0, p.base64FromBytes)(void 0 !== e.nextValidatorsHash ? e.nextValidatorsHash : new Uint8Array)), void 0 !== e.consensusHash && (r.consensusHash = (0, p.base64FromBytes)(void 0 !== e.consensusHash ? e.consensusHash : new Uint8Array)), void 0 !== e.appHash && (r.appHash = (0, p.base64FromBytes)(void 0 !== e.appHash ? e.appHash : new Uint8Array)), void 0 !== e.lastResultsHash && (r.lastResultsHash = (0, p.base64FromBytes)(void 0 !== e.lastResultsHash ? e.lastResultsHash : new Uint8Array)), void 0 !== e.evidenceHash && (r.evidenceHash = (0, p.base64FromBytes)(void 0 !== e.evidenceHash ? e.evidenceHash : new Uint8Array)), void 0 !== e.proposerAddress && (r.proposerAddress = (0, p.base64FromBytes)(void 0 !== e.proposerAddress ? e.proposerAddress : new Uint8Array)), r
                },
                fromPartial(e) {
                    let r = S();
                    return void 0 !== e.version && null !== e.version && (r.version = d.Consensus.fromPartial(e.version)), r.chainId = e.chainId ? ? "", void 0 !== e.height && null !== e.height && (r.height = BigInt(e.height.toString())), void 0 !== e.time && null !== e.time && (r.time = c.Timestamp.fromPartial(e.time)), void 0 !== e.lastBlockId && null !== e.lastBlockId && (r.lastBlockId = t.BlockID.fromPartial(e.lastBlockId)), r.lastCommitHash = e.lastCommitHash ? ? new Uint8Array, r.dataHash = e.dataHash ? ? new Uint8Array, r.validatorsHash = e.validatorsHash ? ? new Uint8Array, r.nextValidatorsHash = e.nextValidatorsHash ? ? new Uint8Array, r.consensusHash = e.consensusHash ? ? new Uint8Array, r.appHash = e.appHash ? ? new Uint8Array, r.lastResultsHash = e.lastResultsHash ? ? new Uint8Array, r.evidenceHash = e.evidenceHash ? ? new Uint8Array, r.proposerAddress = e.proposerAddress ? ? new Uint8Array, r
                }
            }, t.Data = {
                typeUrl: "/tendermint.types.Data",
                encode(e, t = u.BinaryWriter.create()) {
                    for (let r of e.txs) t.uint32(10).bytes(r);
                    return t
                },
                decode(e, t) {
                    let r = e instanceof u.BinaryReader ? e : new u.BinaryReader(e),
                        n = void 0 === t ? r.len : r.pos + t,
                        o = k();
                    for (; r.pos < n;) {
                        let e = r.uint32();
                        e >>> 3 == 1 ? o.txs.push(r.bytes()) : r.skipType(7 & e)
                    }
                    return o
                },
                fromJSON(e) {
                    let t = k();
                    return Array.isArray(e ? .txs) && (t.txs = e.txs.map(e => (0, p.bytesFromBase64)(e))), t
                },
                toJSON(e) {
                    let t = {};
                    return e.txs ? t.txs = e.txs.map(e => (0, p.base64FromBytes)(void 0 !== e ? e : new Uint8Array)) : t.txs = [], t
                },
                fromPartial(e) {
                    let t = k();
                    return t.txs = e.txs ? .map(e => e) || [], t
                }
            }, t.Vote = {
                typeUrl: "/tendermint.types.Vote",
                encode: (e, r = u.BinaryWriter.create()) => (0 !== e.type && r.uint32(8).int32(e.type), e.height !== BigInt(0) && r.uint32(16).int64(e.height), 0 !== e.round && r.uint32(24).int32(e.round), void 0 !== e.blockId && t.BlockID.encode(e.blockId, r.uint32(34).fork()).ldelim(), void 0 !== e.timestamp && c.Timestamp.encode(e.timestamp, r.uint32(42).fork()).ldelim(), 0 !== e.validatorAddress.length && r.uint32(50).bytes(e.validatorAddress), 0 !== e.validatorIndex && r.uint32(56).int32(e.validatorIndex), 0 !== e.signature.length && r.uint32(66).bytes(e.signature), r),
                decode(e, r) {
                    let n = e instanceof u.BinaryReader ? e : new u.BinaryReader(e),
                        o = void 0 === r ? n.len : n.pos + r,
                        i = P();
                    for (; n.pos < o;) {
                        let e = n.uint32();
                        switch (e >>> 3) {
                            case 1:
                                i.type = n.int32();
                                break;
                            case 2:
                                i.height = n.int64();
                                break;
                            case 3:
                                i.round = n.int32();
                                break;
                            case 4:
                                i.blockId = t.BlockID.decode(n, n.uint32());
                                break;
                            case 5:
                                i.timestamp = c.Timestamp.decode(n, n.uint32());
                                break;
                            case 6:
                                i.validatorAddress = n.bytes();
                                break;
                            case 7:
                                i.validatorIndex = n.int32();
                                break;
                            case 8:
                                i.signature = n.bytes();
                                break;
                            default:
                                n.skipType(7 & e)
                        }
                    }
                    return i
                },
                fromJSON(e) {
                    let r = P();
                    return (0, p.isSet)(e.type) && (r.type = f(e.type)), (0, p.isSet)(e.height) && (r.height = BigInt(e.height.toString())), (0, p.isSet)(e.round) && (r.round = Number(e.round)), (0, p.isSet)(e.blockId) && (r.blockId = t.BlockID.fromJSON(e.blockId)), (0, p.isSet)(e.timestamp) && (r.timestamp = (0, p.fromJsonTimestamp)(e.timestamp)), (0, p.isSet)(e.validatorAddress) && (r.validatorAddress = (0, p.bytesFromBase64)(e.validatorAddress)), (0, p.isSet)(e.validatorIndex) && (r.validatorIndex = Number(e.validatorIndex)), (0, p.isSet)(e.signature) && (r.signature = (0, p.bytesFromBase64)(e.signature)), r
                },
                toJSON(e) {
                    let r = {};
                    return void 0 !== e.type && (r.type = y(e.type)), void 0 !== e.height && (r.height = (e.height || BigInt(0)).toString()), void 0 !== e.round && (r.round = Math.round(e.round)), void 0 !== e.blockId && (r.blockId = e.blockId ? t.BlockID.toJSON(e.blockId) : void 0), void 0 !== e.timestamp && (r.timestamp = (0, p.fromTimestamp)(e.timestamp).toISOString()), void 0 !== e.validatorAddress && (r.validatorAddress = (0, p.base64FromBytes)(void 0 !== e.validatorAddress ? e.validatorAddress : new Uint8Array)), void 0 !== e.validatorIndex && (r.validatorIndex = Math.round(e.validatorIndex)), void 0 !== e.signature && (r.signature = (0, p.base64FromBytes)(void 0 !== e.signature ? e.signature : new Uint8Array)), r
                },
                fromPartial(e) {
                    let r = P();
                    return r.type = e.type ? ? 0, void 0 !== e.height && null !== e.height && (r.height = BigInt(e.height.toString())), r.round = e.round ? ? 0, void 0 !== e.blockId && null !== e.blockId && (r.blockId = t.BlockID.fromPartial(e.blockId)), void 0 !== e.timestamp && null !== e.timestamp && (r.timestamp = c.Timestamp.fromPartial(e.timestamp)), r.validatorAddress = e.validatorAddress ? ? new Uint8Array, r.validatorIndex = e.validatorIndex ? ? 0, r.signature = e.signature ? ? new Uint8Array, r
                }
            }, t.Commit = {
                typeUrl: "/tendermint.types.Commit",
                encode(e, r = u.BinaryWriter.create()) {
                    for (let n of (e.height !== BigInt(0) && r.uint32(8).int64(e.height), 0 !== e.round && r.uint32(16).int32(e.round), void 0 !== e.blockId && t.BlockID.encode(e.blockId, r.uint32(26).fork()).ldelim(), e.signatures)) t.CommitSig.encode(n, r.uint32(34).fork()).ldelim();
                    return r
                },
                decode(e, r) {
                    let n = e instanceof u.BinaryReader ? e : new u.BinaryReader(e),
                        o = void 0 === r ? n.len : n.pos + r,
                        i = _();
                    for (; n.pos < o;) {
                        let e = n.uint32();
                        switch (e >>> 3) {
                            case 1:
                                i.height = n.int64();
                                break;
                            case 2:
                                i.round = n.int32();
                                break;
                            case 3:
                                i.blockId = t.BlockID.decode(n, n.uint32());
                                break;
                            case 4:
                                i.signatures.push(t.CommitSig.decode(n, n.uint32()));
                                break;
                            default:
                                n.skipType(7 & e)
                        }
                    }
                    return i
                },
                fromJSON(e) {
                    let r = _();
                    return (0, p.isSet)(e.height) && (r.height = BigInt(e.height.toString())), (0, p.isSet)(e.round) && (r.round = Number(e.round)), (0, p.isSet)(e.blockId) && (r.blockId = t.BlockID.fromJSON(e.blockId)), Array.isArray(e ? .signatures) && (r.signatures = e.signatures.map(e => t.CommitSig.fromJSON(e))), r
                },
                toJSON(e) {
                    let r = {};
                    return void 0 !== e.height && (r.height = (e.height || BigInt(0)).toString()), void 0 !== e.round && (r.round = Math.round(e.round)), void 0 !== e.blockId && (r.blockId = e.blockId ? t.BlockID.toJSON(e.blockId) : void 0), e.signatures ? r.signatures = e.signatures.map(e => e ? t.CommitSig.toJSON(e) : void 0) : r.signatures = [], r
                },
                fromPartial(e) {
                    let r = _();
                    return void 0 !== e.height && null !== e.height && (r.height = BigInt(e.height.toString())), r.round = e.round ? ? 0, void 0 !== e.blockId && null !== e.blockId && (r.blockId = t.BlockID.fromPartial(e.blockId)), r.signatures = e.signatures ? .map(e => t.CommitSig.fromPartial(e)) || [], r
                }
            }, t.CommitSig = {
                typeUrl: "/tendermint.types.CommitSig",
                encode: (e, t = u.BinaryWriter.create()) => (0 !== e.blockIdFlag && t.uint32(8).int32(e.blockIdFlag), 0 !== e.validatorAddress.length && t.uint32(18).bytes(e.validatorAddress), void 0 !== e.timestamp && c.Timestamp.encode(e.timestamp, t.uint32(26).fork()).ldelim(), 0 !== e.signature.length && t.uint32(34).bytes(e.signature), t),
                decode(e, t) {
                    let r = e instanceof u.BinaryReader ? e : new u.BinaryReader(e),
                        n = void 0 === t ? r.len : r.pos + t,
                        o = B();
                    for (; r.pos < n;) {
                        let e = r.uint32();
                        switch (e >>> 3) {
                            case 1:
                                o.blockIdFlag = r.int32();
                                break;
                            case 2:
                                o.validatorAddress = r.bytes();
                                break;
                            case 3:
                                o.timestamp = c.Timestamp.decode(r, r.uint32());
                                break;
                            case 4:
                                o.signature = r.bytes();
                                break;
                            default:
                                r.skipType(7 & e)
                        }
                    }
                    return o
                },
                fromJSON(e) {
                    let t = B();
                    return (0, p.isSet)(e.blockIdFlag) && (t.blockIdFlag = m(e.blockIdFlag)), (0, p.isSet)(e.validatorAddress) && (t.validatorAddress = (0, p.bytesFromBase64)(e.validatorAddress)), (0, p.isSet)(e.timestamp) && (t.timestamp = (0, p.fromJsonTimestamp)(e.timestamp)), (0, p.isSet)(e.signature) && (t.signature = (0, p.bytesFromBase64)(e.signature)), t
                },
                toJSON(e) {
                    let t = {};
                    return void 0 !== e.blockIdFlag && (t.blockIdFlag = g(e.blockIdFlag)), void 0 !== e.validatorAddress && (t.validatorAddress = (0, p.base64FromBytes)(void 0 !== e.validatorAddress ? e.validatorAddress : new Uint8Array)), void 0 !== e.timestamp && (t.timestamp = (0, p.fromTimestamp)(e.timestamp).toISOString()), void 0 !== e.signature && (t.signature = (0, p.base64FromBytes)(void 0 !== e.signature ? e.signature : new Uint8Array)), t
                },
                fromPartial(e) {
                    let t = B();
                    return t.blockIdFlag = e.blockIdFlag ? ? 0, t.validatorAddress = e.validatorAddress ? ? new Uint8Array, void 0 !== e.timestamp && null !== e.timestamp && (t.timestamp = c.Timestamp.fromPartial(e.timestamp)), t.signature = e.signature ? ? new Uint8Array, t
                }
            }, t.Proposal = {
                typeUrl: "/tendermint.types.Proposal",
                encode: (e, r = u.BinaryWriter.create()) => (0 !== e.type && r.uint32(8).int32(e.type), e.height !== BigInt(0) && r.uint32(16).int64(e.height), 0 !== e.round && r.uint32(24).int32(e.round), 0 !== e.polRound && r.uint32(32).int32(e.polRound), void 0 !== e.blockId && t.BlockID.encode(e.blockId, r.uint32(42).fork()).ldelim(), void 0 !== e.timestamp && c.Timestamp.encode(e.timestamp, r.uint32(50).fork()).ldelim(), 0 !== e.signature.length && r.uint32(58).bytes(e.signature), r),
                decode(e, r) {
                    let n = e instanceof u.BinaryReader ? e : new u.BinaryReader(e),
                        o = void 0 === r ? n.len : n.pos + r,
                        i = O();
                    for (; n.pos < o;) {
                        let e = n.uint32();
                        switch (e >>> 3) {
                            case 1:
                                i.type = n.int32();
                                break;
                            case 2:
                                i.height = n.int64();
                                break;
                            case 3:
                                i.round = n.int32();
                                break;
                            case 4:
                                i.polRound = n.int32();
                                break;
                            case 5:
                                i.blockId = t.BlockID.decode(n, n.uint32());
                                break;
                            case 6:
                                i.timestamp = c.Timestamp.decode(n, n.uint32());
                                break;
                            case 7:
                                i.signature = n.bytes();
                                break;
                            default:
                                n.skipType(7 & e)
                        }
                    }
                    return i
                },
                fromJSON(e) {
                    let r = O();
                    return (0, p.isSet)(e.type) && (r.type = f(e.type)), (0, p.isSet)(e.height) && (r.height = BigInt(e.height.toString())), (0, p.isSet)(e.round) && (r.round = Number(e.round)), (0, p.isSet)(e.polRound) && (r.polRound = Number(e.polRound)), (0, p.isSet)(e.blockId) && (r.blockId = t.BlockID.fromJSON(e.blockId)), (0, p.isSet)(e.timestamp) && (r.timestamp = (0, p.fromJsonTimestamp)(e.timestamp)), (0, p.isSet)(e.signature) && (r.signature = (0, p.bytesFromBase64)(e.signature)), r
                },
                toJSON(e) {
                    let r = {};
                    return void 0 !== e.type && (r.type = y(e.type)), void 0 !== e.height && (r.height = (e.height || BigInt(0)).toString()), void 0 !== e.round && (r.round = Math.round(e.round)), void 0 !== e.polRound && (r.polRound = Math.round(e.polRound)), void 0 !== e.blockId && (r.blockId = e.blockId ? t.BlockID.toJSON(e.blockId) : void 0), void 0 !== e.timestamp && (r.timestamp = (0, p.fromTimestamp)(e.timestamp).toISOString()), void 0 !== e.signature && (r.signature = (0, p.base64FromBytes)(void 0 !== e.signature ? e.signature : new Uint8Array)), r
                },
                fromPartial(e) {
                    let r = O();
                    return r.type = e.type ? ? 0, void 0 !== e.height && null !== e.height && (r.height = BigInt(e.height.toString())), r.round = e.round ? ? 0, r.polRound = e.polRound ? ? 0, void 0 !== e.blockId && null !== e.blockId && (r.blockId = t.BlockID.fromPartial(e.blockId)), void 0 !== e.timestamp && null !== e.timestamp && (r.timestamp = c.Timestamp.fromPartial(e.timestamp)), r.signature = e.signature ? ? new Uint8Array, r
                }
            }, t.SignedHeader = {
                typeUrl: "/tendermint.types.SignedHeader",
                encode: (e, r = u.BinaryWriter.create()) => (void 0 !== e.header && t.Header.encode(e.header, r.uint32(10).fork()).ldelim(), void 0 !== e.commit && t.Commit.encode(e.commit, r.uint32(18).fork()).ldelim(), r),
                decode(e, r) {
                    let n = e instanceof u.BinaryReader ? e : new u.BinaryReader(e),
                        o = void 0 === r ? n.len : n.pos + r,
                        i = R();
                    for (; n.pos < o;) {
                        let e = n.uint32();
                        switch (e >>> 3) {
                            case 1:
                                i.header = t.Header.decode(n, n.uint32());
                                break;
                            case 2:
                                i.commit = t.Commit.decode(n, n.uint32());
                                break;
                            default:
                                n.skipType(7 & e)
                        }
                    }
                    return i
                },
                fromJSON(e) {
                    let r = R();
                    return (0, p.isSet)(e.header) && (r.header = t.Header.fromJSON(e.header)), (0, p.isSet)(e.commit) && (r.commit = t.Commit.fromJSON(e.commit)), r
                },
                toJSON(e) {
                    let r = {};
                    return void 0 !== e.header && (r.header = e.header ? t.Header.toJSON(e.header) : void 0), void 0 !== e.commit && (r.commit = e.commit ? t.Commit.toJSON(e.commit) : void 0), r
                },
                fromPartial(e) {
                    let r = R();
                    return void 0 !== e.header && null !== e.header && (r.header = t.Header.fromPartial(e.header)), void 0 !== e.commit && null !== e.commit && (r.commit = t.Commit.fromPartial(e.commit)), r
                }
            }, t.LightBlock = {
                typeUrl: "/tendermint.types.LightBlock",
                encode: (e, r = u.BinaryWriter.create()) => (void 0 !== e.signedHeader && t.SignedHeader.encode(e.signedHeader, r.uint32(10).fork()).ldelim(), void 0 !== e.validatorSet && l.ValidatorSet.encode(e.validatorSet, r.uint32(18).fork()).ldelim(), r),
                decode(e, r) {
                    let n = e instanceof u.BinaryReader ? e : new u.BinaryReader(e),
                        o = void 0 === r ? n.len : n.pos + r,
                        i = A();
                    for (; n.pos < o;) {
                        let e = n.uint32();
                        switch (e >>> 3) {
                            case 1:
                                i.signedHeader = t.SignedHeader.decode(n, n.uint32());
                                break;
                            case 2:
                                i.validatorSet = l.ValidatorSet.decode(n, n.uint32());
                                break;
                            default:
                                n.skipType(7 & e)
                        }
                    }
                    return i
                },
                fromJSON(e) {
                    let r = A();
                    return (0, p.isSet)(e.signedHeader) && (r.signedHeader = t.SignedHeader.fromJSON(e.signedHeader)), (0, p.isSet)(e.validatorSet) && (r.validatorSet = l.ValidatorSet.fromJSON(e.validatorSet)), r
                },
                toJSON(e) {
                    let r = {};
                    return void 0 !== e.signedHeader && (r.signedHeader = e.signedHeader ? t.SignedHeader.toJSON(e.signedHeader) : void 0), void 0 !== e.validatorSet && (r.validatorSet = e.validatorSet ? l.ValidatorSet.toJSON(e.validatorSet) : void 0), r
                },
                fromPartial(e) {
                    let r = A();
                    return void 0 !== e.signedHeader && null !== e.signedHeader && (r.signedHeader = t.SignedHeader.fromPartial(e.signedHeader)), void 0 !== e.validatorSet && null !== e.validatorSet && (r.validatorSet = l.ValidatorSet.fromPartial(e.validatorSet)), r
                }
            }, t.BlockMeta = {
                typeUrl: "/tendermint.types.BlockMeta",
                encode: (e, r = u.BinaryWriter.create()) => (void 0 !== e.blockId && t.BlockID.encode(e.blockId, r.uint32(10).fork()).ldelim(), e.blockSize !== BigInt(0) && r.uint32(16).int64(e.blockSize), void 0 !== e.header && t.Header.encode(e.header, r.uint32(26).fork()).ldelim(), e.numTxs !== BigInt(0) && r.uint32(32).int64(e.numTxs), r),
                decode(e, r) {
                    let n = e instanceof u.BinaryReader ? e : new u.BinaryReader(e),
                        o = void 0 === r ? n.len : n.pos + r,
                        i = I();
                    for (; n.pos < o;) {
                        let e = n.uint32();
                        switch (e >>> 3) {
                            case 1:
                                i.blockId = t.BlockID.decode(n, n.uint32());
                                break;
                            case 2:
                                i.blockSize = n.int64();
                                break;
                            case 3:
                                i.header = t.Header.decode(n, n.uint32());
                                break;
                            case 4:
                                i.numTxs = n.int64();
                                break;
                            default:
                                n.skipType(7 & e)
                        }
                    }
                    return i
                },
                fromJSON(e) {
                    let r = I();
                    return (0, p.isSet)(e.blockId) && (r.blockId = t.BlockID.fromJSON(e.blockId)), (0, p.isSet)(e.blockSize) && (r.blockSize = BigInt(e.blockSize.toString())), (0, p.isSet)(e.header) && (r.header = t.Header.fromJSON(e.header)), (0, p.isSet)(e.numTxs) && (r.numTxs = BigInt(e.numTxs.toString())), r
                },
                toJSON(e) {
                    let r = {};
                    return void 0 !== e.blockId && (r.blockId = e.blockId ? t.BlockID.toJSON(e.blockId) : void 0), void 0 !== e.blockSize && (r.blockSize = (e.blockSize || BigInt(0)).toString()), void 0 !== e.header && (r.header = e.header ? t.Header.toJSON(e.header) : void 0), void 0 !== e.numTxs && (r.numTxs = (e.numTxs || BigInt(0)).toString()), r
                },
                fromPartial(e) {
                    let r = I();
                    return void 0 !== e.blockId && null !== e.blockId && (r.blockId = t.BlockID.fromPartial(e.blockId)), void 0 !== e.blockSize && null !== e.blockSize && (r.blockSize = BigInt(e.blockSize.toString())), void 0 !== e.header && null !== e.header && (r.header = t.Header.fromPartial(e.header)), void 0 !== e.numTxs && null !== e.numTxs && (r.numTxs = BigInt(e.numTxs.toString())), r
                }
            }, t.TxProof = {
                typeUrl: "/tendermint.types.TxProof",
                encode: (e, t = u.BinaryWriter.create()) => (0 !== e.rootHash.length && t.uint32(10).bytes(e.rootHash), 0 !== e.data.length && t.uint32(18).bytes(e.data), void 0 !== e.proof && s.Proof.encode(e.proof, t.uint32(26).fork()).ldelim(), t),
                decode(e, t) {
                    let r = e instanceof u.BinaryReader ? e : new u.BinaryReader(e),
                        n = void 0 === t ? r.len : r.pos + t,
                        o = w();
                    for (; r.pos < n;) {
                        let e = r.uint32();
                        switch (e >>> 3) {
                            case 1:
                                o.rootHash = r.bytes();
                                break;
                            case 2:
                                o.data = r.bytes();
                                break;
                            case 3:
                                o.proof = s.Proof.decode(r, r.uint32());
                                break;
                            default:
                                r.skipType(7 & e)
                        }
                    }
                    return o
                },
                fromJSON(e) {
                    let t = w();
                    return (0, p.isSet)(e.rootHash) && (t.rootHash = (0, p.bytesFromBase64)(e.rootHash)), (0, p.isSet)(e.data) && (t.data = (0, p.bytesFromBase64)(e.data)), (0, p.isSet)(e.proof) && (t.proof = s.Proof.fromJSON(e.proof)), t
                },
                toJSON(e) {
                    let t = {};
                    return void 0 !== e.rootHash && (t.rootHash = (0, p.base64FromBytes)(void 0 !== e.rootHash ? e.rootHash : new Uint8Array)), void 0 !== e.data && (t.data = (0, p.base64FromBytes)(void 0 !== e.data ? e.data : new Uint8Array)), void 0 !== e.proof && (t.proof = e.proof ? s.Proof.toJSON(e.proof) : void 0), t
                },
                fromPartial(e) {
                    let t = w();
                    return t.rootHash = e.rootHash ? ? new Uint8Array, t.data = e.data ? ? new Uint8Array, void 0 !== e.proof && null !== e.proof && (t.proof = s.Proof.fromPartial(e.proof)), t
                }
            }
        },
        67112: function(e, t, r) {
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: !0
            }), t.SimpleValidator = t.Validator = t.ValidatorSet = t.protobufPackage = void 0;
            let n = r(76057),
                o = r(23795),
                i = r(96987);

            function a() {
                return {
                    validators: [],
                    proposer: void 0,
                    totalVotingPower: BigInt(0)
                }
            }

            function s() {
                return {
                    address: new Uint8Array,
                    pubKey: n.PublicKey.fromPartial({}),
                    votingPower: BigInt(0),
                    proposerPriority: BigInt(0)
                }
            }

            function d() {
                return {
                    pubKey: void 0,
                    votingPower: BigInt(0)
                }
            }
            t.protobufPackage = "tendermint.types", t.ValidatorSet = {
                typeUrl: "/tendermint.types.ValidatorSet",
                encode(e, r = o.BinaryWriter.create()) {
                    for (let n of e.validators) t.Validator.encode(n, r.uint32(10).fork()).ldelim();
                    return void 0 !== e.proposer && t.Validator.encode(e.proposer, r.uint32(18).fork()).ldelim(), e.totalVotingPower !== BigInt(0) && r.uint32(24).int64(e.totalVotingPower), r
                },
                decode(e, r) {
                    let n = e instanceof o.BinaryReader ? e : new o.BinaryReader(e),
                        i = void 0 === r ? n.len : n.pos + r,
                        s = a();
                    for (; n.pos < i;) {
                        let e = n.uint32();
                        switch (e >>> 3) {
                            case 1:
                                s.validators.push(t.Validator.decode(n, n.uint32()));
                                break;
                            case 2:
                                s.proposer = t.Validator.decode(n, n.uint32());
                                break;
                            case 3:
                                s.totalVotingPower = n.int64();
                                break;
                            default:
                                n.skipType(7 & e)
                        }
                    }
                    return s
                },
                fromJSON(e) {
                    let r = a();
                    return Array.isArray(e ? .validators) && (r.validators = e.validators.map(e => t.Validator.fromJSON(e))), (0, i.isSet)(e.proposer) && (r.proposer = t.Validator.fromJSON(e.proposer)), (0, i.isSet)(e.totalVotingPower) && (r.totalVotingPower = BigInt(e.totalVotingPower.toString())), r
                },
                toJSON(e) {
                    let r = {};
                    return e.validators ? r.validators = e.validators.map(e => e ? t.Validator.toJSON(e) : void 0) : r.validators = [], void 0 !== e.proposer && (r.proposer = e.proposer ? t.Validator.toJSON(e.proposer) : void 0), void 0 !== e.totalVotingPower && (r.totalVotingPower = (e.totalVotingPower || BigInt(0)).toString()), r
                },
                fromPartial(e) {
                    let r = a();
                    return r.validators = e.validators ? .map(e => t.Validator.fromPartial(e)) || [], void 0 !== e.proposer && null !== e.proposer && (r.proposer = t.Validator.fromPartial(e.proposer)), void 0 !== e.totalVotingPower && null !== e.totalVotingPower && (r.totalVotingPower = BigInt(e.totalVotingPower.toString())), r
                }
            }, t.Validator = {
                typeUrl: "/tendermint.types.Validator",
                encode: (e, t = o.BinaryWriter.create()) => (0 !== e.address.length && t.uint32(10).bytes(e.address), void 0 !== e.pubKey && n.PublicKey.encode(e.pubKey, t.uint32(18).fork()).ldelim(), e.votingPower !== BigInt(0) && t.uint32(24).int64(e.votingPower), e.proposerPriority !== BigInt(0) && t.uint32(32).int64(e.proposerPriority), t),
                decode(e, t) {
                    let r = e instanceof o.BinaryReader ? e : new o.BinaryReader(e),
                        i = void 0 === t ? r.len : r.pos + t,
                        a = s();
                    for (; r.pos < i;) {
                        let e = r.uint32();
                        switch (e >>> 3) {
                            case 1:
                                a.address = r.bytes();
                                break;
                            case 2:
                                a.pubKey = n.PublicKey.decode(r, r.uint32());
                                break;
                            case 3:
                                a.votingPower = r.int64();
                                break;
                            case 4:
                                a.proposerPriority = r.int64();
                                break;
                            default:
                                r.skipType(7 & e)
                        }
                    }
                    return a
                },
                fromJSON(e) {
                    let t = s();
                    return (0, i.isSet)(e.address) && (t.address = (0, i.bytesFromBase64)(e.address)), (0, i.isSet)(e.pubKey) && (t.pubKey = n.PublicKey.fromJSON(e.pubKey)), (0, i.isSet)(e.votingPower) && (t.votingPower = BigInt(e.votingPower.toString())), (0, i.isSet)(e.proposerPriority) && (t.proposerPriority = BigInt(e.proposerPriority.toString())), t
                },
                toJSON(e) {
                    let t = {};
                    return void 0 !== e.address && (t.address = (0, i.base64FromBytes)(void 0 !== e.address ? e.address : new Uint8Array)), void 0 !== e.pubKey && (t.pubKey = e.pubKey ? n.PublicKey.toJSON(e.pubKey) : void 0), void 0 !== e.votingPower && (t.votingPower = (e.votingPower || BigInt(0)).toString()), void 0 !== e.proposerPriority && (t.proposerPriority = (e.proposerPriority || BigInt(0)).toString()), t
                },
                fromPartial(e) {
                    let t = s();
                    return t.address = e.address ? ? new Uint8Array, void 0 !== e.pubKey && null !== e.pubKey && (t.pubKey = n.PublicKey.fromPartial(e.pubKey)), void 0 !== e.votingPower && null !== e.votingPower && (t.votingPower = BigInt(e.votingPower.toString())), void 0 !== e.proposerPriority && null !== e.proposerPriority && (t.proposerPriority = BigInt(e.proposerPriority.toString())), t
                }
            }, t.SimpleValidator = {
                typeUrl: "/tendermint.types.SimpleValidator",
                encode: (e, t = o.BinaryWriter.create()) => (void 0 !== e.pubKey && n.PublicKey.encode(e.pubKey, t.uint32(10).fork()).ldelim(), e.votingPower !== BigInt(0) && t.uint32(16).int64(e.votingPower), t),
                decode(e, t) {
                    let r = e instanceof o.BinaryReader ? e : new o.BinaryReader(e),
                        i = void 0 === t ? r.len : r.pos + t,
                        a = d();
                    for (; r.pos < i;) {
                        let e = r.uint32();
                        switch (e >>> 3) {
                            case 1:
                                a.pubKey = n.PublicKey.decode(r, r.uint32());
                                break;
                            case 2:
                                a.votingPower = r.int64();
                                break;
                            default:
                                r.skipType(7 & e)
                        }
                    }
                    return a
                },
                fromJSON(e) {
                    let t = d();
                    return (0, i.isSet)(e.pubKey) && (t.pubKey = n.PublicKey.fromJSON(e.pubKey)), (0, i.isSet)(e.votingPower) && (t.votingPower = BigInt(e.votingPower.toString())), t
                },
                toJSON(e) {
                    let t = {};
                    return void 0 !== e.pubKey && (t.pubKey = e.pubKey ? n.PublicKey.toJSON(e.pubKey) : void 0), void 0 !== e.votingPower && (t.votingPower = (e.votingPower || BigInt(0)).toString()), t
                },
                fromPartial(e) {
                    let t = d();
                    return void 0 !== e.pubKey && null !== e.pubKey && (t.pubKey = n.PublicKey.fromPartial(e.pubKey)), void 0 !== e.votingPower && null !== e.votingPower && (t.votingPower = BigInt(e.votingPower.toString())), t
                }
            }
        },
        46874: function(e, t, r) {
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: !0
            }), t.Consensus = t.App = t.protobufPackage = void 0;
            let n = r(23795),
                o = r(96987);

            function i() {
                return {
                    protocol: BigInt(0),
                    software: ""
                }
            }

            function a() {
                return {
                    block: BigInt(0),
                    app: BigInt(0)
                }
            }
            t.protobufPackage = "tendermint.version", t.App = {
                typeUrl: "/tendermint.version.App",
                encode: (e, t = n.BinaryWriter.create()) => (e.protocol !== BigInt(0) && t.uint32(8).uint64(e.protocol), "" !== e.software && t.uint32(18).string(e.software), t),
                decode(e, t) {
                    let r = e instanceof n.BinaryReader ? e : new n.BinaryReader(e),
                        o = void 0 === t ? r.len : r.pos + t,
                        a = i();
                    for (; r.pos < o;) {
                        let e = r.uint32();
                        switch (e >>> 3) {
                            case 1:
                                a.protocol = r.uint64();
                                break;
                            case 2:
                                a.software = r.string();
                                break;
                            default:
                                r.skipType(7 & e)
                        }
                    }
                    return a
                },
                fromJSON(e) {
                    let t = i();
                    return (0, o.isSet)(e.protocol) && (t.protocol = BigInt(e.protocol.toString())), (0, o.isSet)(e.software) && (t.software = String(e.software)), t
                },
                toJSON(e) {
                    let t = {};
                    return void 0 !== e.protocol && (t.protocol = (e.protocol || BigInt(0)).toString()), void 0 !== e.software && (t.software = e.software), t
                },
                fromPartial(e) {
                    let t = i();
                    return void 0 !== e.protocol && null !== e.protocol && (t.protocol = BigInt(e.protocol.toString())), t.software = e.software ? ? "", t
                }
            }, t.Consensus = {
                typeUrl: "/tendermint.version.Consensus",
                encode: (e, t = n.BinaryWriter.create()) => (e.block !== BigInt(0) && t.uint32(8).uint64(e.block), e.app !== BigInt(0) && t.uint32(16).uint64(e.app), t),
                decode(e, t) {
                    let r = e instanceof n.BinaryReader ? e : new n.BinaryReader(e),
                        o = void 0 === t ? r.len : r.pos + t,
                        i = a();
                    for (; r.pos < o;) {
                        let e = r.uint32();
                        switch (e >>> 3) {
                            case 1:
                                i.block = r.uint64();
                                break;
                            case 2:
                                i.app = r.uint64();
                                break;
                            default:
                                r.skipType(7 & e)
                        }
                    }
                    return i
                },
                fromJSON(e) {
                    let t = a();
                    return (0, o.isSet)(e.block) && (t.block = BigInt(e.block.toString())), (0, o.isSet)(e.app) && (t.app = BigInt(e.app.toString())), t
                },
                toJSON(e) {
                    let t = {};
                    return void 0 !== e.block && (t.block = (e.block || BigInt(0)).toString()), void 0 !== e.app && (t.app = (e.app || BigInt(0)).toString()), t
                },
                fromPartial(e) {
                    let t = a();
                    return void 0 !== e.block && null !== e.block && (t.block = BigInt(e.block.toString())), void 0 !== e.app && null !== e.app && (t.app = BigInt(e.app.toString())), t
                }
            }
        },
        82208: function(e, t) {
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: !0
            }), t.utf8Write = t.utf8Read = t.utf8Length = void 0, t.utf8Length = function(e) {
                let t = 0,
                    r = 0;
                for (let n = 0; n < e.length; ++n)(r = e.charCodeAt(n)) < 128 ? t += 1 : r < 2048 ? t += 2 : (64512 & r) == 55296 && (64512 & e.charCodeAt(n + 1)) == 56320 ? (++n, t += 4) : t += 3;
                return t
            }, t.utf8Read = function(e, t, r) {
                if (r - t < 1) return "";
                let n = [],
                    o = [],
                    i = 0,
                    a;
                for (; t < r;)(a = e[t++]) < 128 ? n[i++] = a : a > 191 && a < 224 ? n[i++] = (31 & a) << 6 | 63 & e[t++] : a > 239 && a < 365 ? (a = ((7 & a) << 18 | (63 & e[t++]) << 12 | (63 & e[t++]) << 6 | 63 & e[t++]) - 65536, n[i++] = 55296 + (a >> 10), n[i++] = 56320 + (1023 & a)) : n[i++] = (15 & a) << 12 | (63 & e[t++]) << 6 | 63 & e[t++], i > 8191 && ((o || (o = [])).push(String.fromCharCode(...n)), i = 0);
                return o ? (i && o.push(String.fromCharCode(...n.slice(0, i))), o.join("")) : String.fromCharCode(...n.slice(0, i))
            }, t.utf8Write = function(e, t, r) {
                let n, o;
                let i = r;
                for (let i = 0; i < e.length; ++i)(n = e.charCodeAt(i)) < 128 ? t[r++] = n : (n < 2048 ? t[r++] = n >> 6 | 192 : ((64512 & n) == 55296 && (64512 & (o = e.charCodeAt(i + 1))) == 56320 ? (n = 65536 + ((1023 & n) << 10) + (1023 & o), ++i, t[r++] = n >> 18 | 240, t[r++] = n >> 12 & 63 | 128) : t[r++] = n >> 12 | 224, t[r++] = n >> 6 & 63 | 128), t[r++] = 63 & n | 128);
                return r - i
            }
        },
        73238: function(e, t) {
            "use strict";

            function r(e, t) {
                if ({
                        lo: e,
                        hi: t
                    } = {
                        lo: e >>> 0,
                        hi: t >>> 0
                    }, t <= 2097151) return String(4294967296 * t + e);
                let r = 16777215 & e,
                    n = (e >>> 24 | t << 8) & 16777215,
                    o = t >> 16 & 65535,
                    a = r + 6777216 * n + 6710656 * o,
                    s = n + 8147497 * o,
                    d = 2 * o;
                return a >= 1e7 && (s += Math.floor(a / 1e7), a %= 1e7), s >= 1e7 && (d += Math.floor(s / 1e7), s %= 1e7), d.toString() + i(s) + i(a)
            }

            function n(e, t) {
                return {
                    lo: 0 | e,
                    hi: 0 | t
                }
            }

            function o(e, t) {
                return t = ~t, e ? e = ~e + 1 : t += 1, n(e, t)
            }
            Object.defineProperty(t, "__esModule", {
                value: !0
            }), t.writeByte = t.writeFixed32 = t.int64Length = t.writeVarint64 = t.writeVarint32 = t.readInt32 = t.readUInt32 = t.zzDecode = t.zzEncode = t.varint32read = t.varint32write = t.uInt64ToString = t.int64ToString = t.int64FromString = t.varint64write = t.varint64read = void 0, t.varint64read = function() {
                let e = 0,
                    t = 0;
                for (let r = 0; r < 28; r += 7) {
                    let n = this.buf[this.pos++];
                    if (e |= (127 & n) << r, (128 & n) == 0) return this.assertBounds(), [e, t]
                }
                let r = this.buf[this.pos++];
                if (e |= (15 & r) << 28, t = (112 & r) >> 4, (128 & r) == 0) return this.assertBounds(), [e, t];
                for (let r = 3; r <= 31; r += 7) {
                    let n = this.buf[this.pos++];
                    if (t |= (127 & n) << r, (128 & n) == 0) return this.assertBounds(), [e, t]
                }
                throw Error("invalid varint")
            }, t.varint64write = function(e, t, r) {
                for (let n = 0; n < 28; n += 7) {
                    let o = e >>> n,
                        i = !(o >>> 7 == 0 && 0 == t),
                        a = (i ? 128 | o : o) & 255;
                    if (r.push(a), !i) return
                }
                let n = e >>> 28 & 15 | (7 & t) << 4,
                    o = t >> 3 != 0;
                if (r.push((o ? 128 | n : n) & 255), o) {
                    for (let e = 3; e < 31; e += 7) {
                        let n = t >>> e,
                            o = n >>> 7 != 0,
                            i = (o ? 128 | n : n) & 255;
                        if (r.push(i), !o) return
                    }
                    r.push(t >>> 31 & 1)
                }
            }, t.int64FromString = function(e) {
                let t = "-" === e[0];
                t && (e = e.slice(1));
                let r = 0,
                    i = 0;

                function a(t, n) {
                    let o = Number(e.slice(t, n));
                    i *= 1e6, (r = 1e6 * r + o) >= 4294967296 && (i += r / 4294967296 | 0, r %= 4294967296)
                }
                return a(-24, -18), a(-18, -12), a(-12, -6), a(-6), t ? o(r, i) : n(r, i)
            }, t.int64ToString = function(e, t) {
                let i = n(e, t),
                    a = 2147483648 & i.hi;
                a && (i = o(i.lo, i.hi));
                let s = r(i.lo, i.hi);
                return a ? "-" + s : s
            }, t.uInt64ToString = r;
            let i = e => {
                let t = String(e);
                return "0000000".slice(t.length) + t
            };
            t.varint32write = function(e, t) {
                if (e >= 0) {
                    for (; e > 127;) t.push(127 & e | 128), e >>>= 7;
                    t.push(e)
                } else {
                    for (let r = 0; r < 9; r++) t.push(127 & e | 128), e >>= 7;
                    t.push(1)
                }
            }, t.varint32read = function() {
                let e = this.buf[this.pos++],
                    t = 127 & e;
                if ((128 & e) == 0 || (t |= (127 & (e = this.buf[this.pos++])) << 7, (128 & e) == 0) || (t |= (127 & (e = this.buf[this.pos++])) << 14, (128 & e) == 0) || (t |= (127 & (e = this.buf[this.pos++])) << 21, (128 & e) == 0)) return this.assertBounds(), t;
                t |= (15 & (e = this.buf[this.pos++])) << 28;
                for (let t = 5;
                    (128 & e) != 0 && t < 10; t++) e = this.buf[this.pos++];
                if ((128 & e) != 0) throw Error("invalid varint");
                return this.assertBounds(), t >>> 0
            }, t.zzEncode = function(e, t) {
                let r = t >> 31;
                return t = ((t << 1 | e >>> 31) ^ r) >>> 0, [e = (e << 1 ^ r) >>> 0, t]
            }, t.zzDecode = function(e, t) {
                let r = -(1 & e);
                return [e = ((e >>> 1 | t << 31) ^ r) >>> 0, t = (t >>> 1 ^ r) >>> 0]
            }, t.readUInt32 = function(e, t) {
                return (e[t] | e[t + 1] << 8 | e[t + 2] << 16) + 16777216 * e[t + 3]
            }, t.readInt32 = function(e, t) {
                return (e[t] | e[t + 1] << 8 | e[t + 2] << 16) + (e[t + 3] << 24)
            }, t.writeVarint32 = function(e, t, r) {
                for (; e > 127;) t[r++] = 127 & e | 128, e >>>= 7;
                t[r] = e
            }, t.writeVarint64 = function(e, t, r) {
                for (; e.hi;) t[r++] = 127 & e.lo | 128, e.lo = (e.lo >>> 7 | e.hi << 25) >>> 0, e.hi >>>= 7;
                for (; e.lo > 127;) t[r++] = 127 & e.lo | 128, e.lo = e.lo >>> 7;
                t[r++] = e.lo
            }, t.int64Length = function(e, t) {
                let r = (e >>> 28 | t << 4) >>> 0,
                    n = t >>> 24;
                return 0 === n ? 0 === r ? e < 16384 ? e < 128 ? 1 : 2 : e < 2097152 ? 3 : 4 : r < 16384 ? r < 128 ? 5 : 6 : r < 2097152 ? 7 : 8 : n < 128 ? 9 : 10
            }, t.writeFixed32 = function(e, t, r) {
                t[r] = 255 & e, t[r + 1] = e >>> 8 & 255, t[r + 2] = e >>> 16 & 255, t[r + 3] = e >>> 24
            }, t.writeByte = function(e, t, r) {
                t[r] = 255 & e
            }
        },
        92538: function(e, t, r) {
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: !0
            }), t.accountFromAny = void 0;
            let n = r(38051),
                o = r(39712),
                i = r(93337),
                a = r(50166),
                s = r(71667);

            function d(e) {
                return n.Uint64.fromString(e.toString())
            }

            function c(e) {
                let {
                    address: t,
                    pubKey: r,
                    accountNumber: n,
                    sequence: i
                } = e;
                return {
                    address: t,
                    pubkey: (0, o.decodeOptionalPubkey)(r),
                    accountNumber: d(n).toNumber(),
                    sequence: d(i).toNumber()
                }
            }
            t.accountFromAny = function(e) {
                let {
                    typeUrl: t,
                    value: r
                } = e;
                switch (t) {
                    case "/cosmos.auth.v1beta1.BaseAccount":
                        return c(a.BaseAccount.decode(r));
                    case "/cosmos.auth.v1beta1.ModuleAccount":
                        {
                            let e = a.ModuleAccount.decode(r).baseAccount;
                            return (0, i.assert)(e),
                            c(e)
                        }
                    case "/cosmos.vesting.v1beta1.BaseVestingAccount":
                        {
                            let e = s.BaseVestingAccount.decode(r) ? .baseAccount;
                            return (0, i.assert)(e),
                            c(e)
                        }
                    case "/cosmos.vesting.v1beta1.ContinuousVestingAccount":
                        {
                            let e = s.ContinuousVestingAccount.decode(r) ? .baseVestingAccount ? .baseAccount;
                            return (0, i.assert)(e),
                            c(e)
                        }
                    case "/cosmos.vesting.v1beta1.DelayedVestingAccount":
                        {
                            let e = s.DelayedVestingAccount.decode(r) ? .baseVestingAccount ? .baseAccount;
                            return (0, i.assert)(e),
                            c(e)
                        }
                    case "/cosmos.vesting.v1beta1.PeriodicVestingAccount":
                        {
                            let e = s.PeriodicVestingAccount.decode(r) ? .baseVestingAccount ? .baseAccount;
                            return (0, i.assert)(e),
                            c(e)
                        }
                    default:
                        throw Error(`Unsupported type: '${t}'`)
                }
            }
        },
        86111: function(e, t) {
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: !0
            }), t.AminoTypes = void 0;
            class r {
                constructor(e) {
                    this.register = e
                }
                toAmino({
                    typeUrl: e,
                    value: t
                }) {
                    let r = this.register[e];
                    if (!r) throw Error(`Type URL '${e}' does not exist in the Amino message type register. If you need support for this message type, you can pass in additional entries to the AminoTypes constructor. If you think this message type should be included by default, please open an issue at https://github.com/cosmos/cosmjs/issues.`);
                    return {
                        type: r.aminoType,
                        value: r.toAmino(t)
                    }
                }
                fromAmino({
                    type: e,
                    value: t
                }) {
                    let r = Object.entries(this.register).filter(([t, {
                        aminoType: r
                    }]) => r === e);
                    switch (r.length) {
                        case 0:
                            throw Error(`Amino type identifier '${e}' does not exist in the Amino message type register. If you need support for this message type, you can pass in additional entries to the AminoTypes constructor. If you think this message type should be included by default, please open an issue at https://github.com/cosmos/cosmjs/issues.`);
                        case 1:
                            {
                                let [e, n] = r[0];
                                return {
                                    typeUrl: e,
                                    value: n.fromAmino(t)
                                }
                            }
                        default:
                            throw Error(`Multiple types are registered with Amino type identifier '${e}': '` + r.map(([e, t]) => e).sort().join("', '") + "'. Thus fromAmino cannot be performed.")
                    }
                }
            }
            t.AminoTypes = r
        },
        76615: function(e, t, r) {
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: !0
            }), t.fromTendermintEvent = void 0;
            let n = r(15050);
            t.fromTendermintEvent = function(e) {
                return {
                    type: e.type,
                    attributes: e.attributes.map(e => ({
                        key: "string" == typeof e.key ? e.key : (0, n.fromUtf8)(e.key, !0),
                        value: "string" == typeof e.value ? e.value : (0, n.fromUtf8)(e.value, !0)
                    }))
                }
            }
        },
        91371: function(e, t, r) {
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: !0
            }), t.calculateFee = t.GasPrice = void 0;
            let n = r(38051),
                o = r(39712);
            class i {
                constructor(e, t) {
                    this.amount = e, this.denom = t
                }
                static fromString(e) {
                    let t = e.match(/^([0-9.]+)([a-zA-Z][a-zA-Z0-9/:._-]*)$/);
                    if (!t) throw Error("Invalid gas price string");
                    let [r, o, a] = t;
                    return ! function(e) {
                        if (e.length < 3 || e.length > 128) throw Error("Denom must be between 3 and 128 characters")
                    }(a), new i(n.Decimal.fromUserInput(o, 18), a)
                }
                toString() {
                    return this.amount.toString() + this.denom
                }
            }
            t.GasPrice = i, t.calculateFee = function(e, t) {
                let {
                    denom: r,
                    amount: a
                } = "string" == typeof t ? i.fromString(t) : t, s = a.multiply(new n.Uint53(e)).ceil().toString();
                return {
                    amount: (0, o.coins)(s, r),
                    gas: e.toString()
                }
            }
        },
        24658: function(e, t, r) {
            "use strict";
            var n = this && this.__createBinding || (Object.create ? function(e, t, r, n) {
                    void 0 === n && (n = r);
                    var o = Object.getOwnPropertyDescriptor(t, r);
                    (!o || ("get" in o ? !t.__esModule : o.writable || o.configurable)) && (o = {
                        enumerable: !0,
                        get: function() {
                            return t[r]
                        }
                    }), Object.defineProperty(e, n, o)
                } : function(e, t, r, n) {
                    void 0 === n && (n = r), e[n] = t[r]
                }),
                o = this && this.__setModuleDefault || (Object.create ? function(e, t) {
                    Object.defineProperty(e, "default", {
                        enumerable: !0,
                        value: t
                    })
                } : function(e, t) {
                    e.default = t
                }),
                i = this && this.__importStar || function(e) {
                    if (e && e.__esModule) return e;
                    var t = {};
                    if (null != e)
                        for (var r in e) "default" !== r && Object.prototype.hasOwnProperty.call(e, r) && n(t, e, r);
                    return o(t, e), t
                };
            Object.defineProperty(t, "__esModule", {
                value: !0
            }), t.isMsgWithdrawDelegatorRewardEncodeObject = t.isMsgVoteWeightedEncodeObject = t.isMsgVoteEncodeObject = t.isMsgUndelegateEncodeObject = t.isMsgTransferEncodeObject = t.isMsgSubmitProposalEncodeObject = t.isMsgSendEncodeObject = t.isMsgEditValidatorEncodeObject = t.isMsgDepositEncodeObject = t.isMsgDelegateEncodeObject = t.isMsgCreateValidatorEncodeObject = t.isMsgBeginRedelegateEncodeObject = t.isAminoMsgWithdrawValidatorCommission = t.isAminoMsgWithdrawDelegatorReward = t.isAminoMsgVoteWeighted = t.isAminoMsgVote = t.isAminoMsgVerifyInvariant = t.isAminoMsgUnjail = t.isAminoMsgUndelegate = t.isAminoMsgTransfer = t.isAminoMsgSubmitProposal = t.isAminoMsgSubmitEvidence = t.isAminoMsgSetWithdrawAddress = t.isAminoMsgSend = t.isAminoMsgMultiSend = t.isAminoMsgFundCommunityPool = t.isAminoMsgEditValidator = t.isAminoMsgDeposit = t.isAminoMsgDelegate = t.isAminoMsgCreateVestingAccount = t.isAminoMsgCreateValidator = t.isAminoMsgBeginRedelegate = t.createVestingAminoConverters = t.createStakingAminoConverters = t.createSlashingAminoConverters = t.createIbcAminoConverters = t.createGroupAminoConverters = t.createGovAminoConverters = t.createFeegrantAminoConverters = t.createEvidenceAminoConverters = t.createDistributionAminoConverters = t.createCrysisAminoConverters = t.createBankAminoConverters = t.createAuthzAminoConverters = t.logs = t.GasPrice = t.calculateFee = t.fromTendermintEvent = t.AminoTypes = t.accountFromAny = void 0, t.parseCoins = t.makeCosmoshubPath = t.coins = t.coin = t.TimeoutError = t.StargateClient = t.isDeliverTxSuccess = t.isDeliverTxFailure = t.BroadcastTxError = t.assertIsDeliverTxSuccess = t.assertIsDeliverTxFailure = t.SigningStargateClient = t.defaultRegistryTypes = t.createDefaultAminoConverters = t.isSearchTxQueryArray = t.QueryClient = t.decodeCosmosSdkDecFromProto = t.createProtobufRpcClient = t.createPagination = t.makeMultisignedTxBytes = t.makeMultisignedTx = t.setupTxExtension = t.setupStakingExtension = t.setupSlashingExtension = t.setupMintExtension = t.setupIbcExtension = t.setupGovExtension = t.setupFeegrantExtension = t.setupDistributionExtension = t.setupBankExtension = t.setupAuthzExtension = t.setupAuthExtension = void 0;
            var a = r(92538);
            Object.defineProperty(t, "accountFromAny", {
                enumerable: !0,
                get: function() {
                    return a.accountFromAny
                }
            });
            var s = r(86111);
            Object.defineProperty(t, "AminoTypes", {
                enumerable: !0,
                get: function() {
                    return s.AminoTypes
                }
            });
            var d = r(76615);
            Object.defineProperty(t, "fromTendermintEvent", {
                enumerable: !0,
                get: function() {
                    return d.fromTendermintEvent
                }
            });
            var c = r(91371);
            Object.defineProperty(t, "calculateFee", {
                enumerable: !0,
                get: function() {
                    return c.calculateFee
                }
            }), Object.defineProperty(t, "GasPrice", {
                enumerable: !0,
                get: function() {
                    return c.GasPrice
                }
            }), t.logs = i(r(52082));
            var l = r(27393);
            Object.defineProperty(t, "createAuthzAminoConverters", {
                enumerable: !0,
                get: function() {
                    return l.createAuthzAminoConverters
                }
            }), Object.defineProperty(t, "createBankAminoConverters", {
                enumerable: !0,
                get: function() {
                    return l.createBankAminoConverters
                }
            }), Object.defineProperty(t, "createCrysisAminoConverters", {
                enumerable: !0,
                get: function() {
                    return l.createCrysisAminoConverters
                }
            }), Object.defineProperty(t, "createDistributionAminoConverters", {
                enumerable: !0,
                get: function() {
                    return l.createDistributionAminoConverters
                }
            }), Object.defineProperty(t, "createEvidenceAminoConverters", {
                enumerable: !0,
                get: function() {
                    return l.createEvidenceAminoConverters
                }
            }), Object.defineProperty(t, "createFeegrantAminoConverters", {
                enumerable: !0,
                get: function() {
                    return l.createFeegrantAminoConverters
                }
            }), Object.defineProperty(t, "createGovAminoConverters", {
                enumerable: !0,
                get: function() {
                    return l.createGovAminoConverters
                }
            }), Object.defineProperty(t, "createGroupAminoConverters", {
                enumerable: !0,
                get: function() {
                    return l.createGroupAminoConverters
                }
            }), Object.defineProperty(t, "createIbcAminoConverters", {
                enumerable: !0,
                get: function() {
                    return l.createIbcAminoConverters
                }
            }), Object.defineProperty(t, "createSlashingAminoConverters", {
                enumerable: !0,
                get: function() {
                    return l.createSlashingAminoConverters
                }
            }), Object.defineProperty(t, "createStakingAminoConverters", {
                enumerable: !0,
                get: function() {
                    return l.createStakingAminoConverters
                }
            }), Object.defineProperty(t, "createVestingAminoConverters", {
                enumerable: !0,
                get: function() {
                    return l.createVestingAminoConverters
                }
            }), Object.defineProperty(t, "isAminoMsgBeginRedelegate", {
                enumerable: !0,
                get: function() {
                    return l.isAminoMsgBeginRedelegate
                }
            }), Object.defineProperty(t, "isAminoMsgCreateValidator", {
                enumerable: !0,
                get: function() {
                    return l.isAminoMsgCreateValidator
                }
            }), Object.defineProperty(t, "isAminoMsgCreateVestingAccount", {
                enumerable: !0,
                get: function() {
                    return l.isAminoMsgCreateVestingAccount
                }
            }), Object.defineProperty(t, "isAminoMsgDelegate", {
                enumerable: !0,
                get: function() {
                    return l.isAminoMsgDelegate
                }
            }), Object.defineProperty(t, "isAminoMsgDeposit", {
                enumerable: !0,
                get: function() {
                    return l.isAminoMsgDeposit
                }
            }), Object.defineProperty(t, "isAminoMsgEditValidator", {
                enumerable: !0,
                get: function() {
                    return l.isAminoMsgEditValidator
                }
            }), Object.defineProperty(t, "isAminoMsgFundCommunityPool", {
                enumerable: !0,
                get: function() {
                    return l.isAminoMsgFundCommunityPool
                }
            }), Object.defineProperty(t, "isAminoMsgMultiSend", {
                enumerable: !0,
                get: function() {
                    return l.isAminoMsgMultiSend
                }
            }), Object.defineProperty(t, "isAminoMsgSend", {
                enumerable: !0,
                get: function() {
                    return l.isAminoMsgSend
                }
            }), Object.defineProperty(t, "isAminoMsgSetWithdrawAddress", {
                enumerable: !0,
                get: function() {
                    return l.isAminoMsgSetWithdrawAddress
                }
            }), Object.defineProperty(t, "isAminoMsgSubmitEvidence", {
                enumerable: !0,
                get: function() {
                    return l.isAminoMsgSubmitEvidence
                }
            }), Object.defineProperty(t, "isAminoMsgSubmitProposal", {
                enumerable: !0,
                get: function() {
                    return l.isAminoMsgSubmitProposal
                }
            }), Object.defineProperty(t, "isAminoMsgTransfer", {
                enumerable: !0,
                get: function() {
                    return l.isAminoMsgTransfer
                }
            }), Object.defineProperty(t, "isAminoMsgUndelegate", {
                enumerable: !0,
                get: function() {
                    return l.isAminoMsgUndelegate
                }
            }), Object.defineProperty(t, "isAminoMsgUnjail", {
                enumerable: !0,
                get: function() {
                    return l.isAminoMsgUnjail
                }
            }), Object.defineProperty(t, "isAminoMsgVerifyInvariant", {
                enumerable: !0,
                get: function() {
                    return l.isAminoMsgVerifyInvariant
                }
            }), Object.defineProperty(t, "isAminoMsgVote", {
                enumerable: !0,
                get: function() {
                    return l.isAminoMsgVote
                }
            }), Object.defineProperty(t, "isAminoMsgVoteWeighted", {
                enumerable: !0,
                get: function() {
                    return l.isAminoMsgVoteWeighted
                }
            }), Object.defineProperty(t, "isAminoMsgWithdrawDelegatorReward", {
                enumerable: !0,
                get: function() {
                    return l.isAminoMsgWithdrawDelegatorReward
                }
            }), Object.defineProperty(t, "isAminoMsgWithdrawValidatorCommission", {
                enumerable: !0,
                get: function() {
                    return l.isAminoMsgWithdrawValidatorCommission
                }
            }), Object.defineProperty(t, "isMsgBeginRedelegateEncodeObject", {
                enumerable: !0,
                get: function() {
                    return l.isMsgBeginRedelegateEncodeObject
                }
            }), Object.defineProperty(t, "isMsgCreateValidatorEncodeObject", {
                enumerable: !0,
                get: function() {
                    return l.isMsgCreateValidatorEncodeObject
                }
            }), Object.defineProperty(t, "isMsgDelegateEncodeObject", {
                enumerable: !0,
                get: function() {
                    return l.isMsgDelegateEncodeObject
                }
            }), Object.defineProperty(t, "isMsgDepositEncodeObject", {
                enumerable: !0,
                get: function() {
                    return l.isMsgDepositEncodeObject
                }
            }), Object.defineProperty(t, "isMsgEditValidatorEncodeObject", {
                enumerable: !0,
                get: function() {
                    return l.isMsgEditValidatorEncodeObject
                }
            }), Object.defineProperty(t, "isMsgSendEncodeObject", {
                enumerable: !0,
                get: function() {
                    return l.isMsgSendEncodeObject
                }
            }), Object.defineProperty(t, "isMsgSubmitProposalEncodeObject", {
                enumerable: !0,
                get: function() {
                    return l.isMsgSubmitProposalEncodeObject
                }
            }), Object.defineProperty(t, "isMsgTransferEncodeObject", {
                enumerable: !0,
                get: function() {
                    return l.isMsgTransferEncodeObject
                }
            }), Object.defineProperty(t, "isMsgUndelegateEncodeObject", {
                enumerable: !0,
                get: function() {
                    return l.isMsgUndelegateEncodeObject
                }
            }), Object.defineProperty(t, "isMsgVoteEncodeObject", {
                enumerable: !0,
                get: function() {
                    return l.isMsgVoteEncodeObject
                }
            }), Object.defineProperty(t, "isMsgVoteWeightedEncodeObject", {
                enumerable: !0,
                get: function() {
                    return l.isMsgVoteWeightedEncodeObject
                }
            }), Object.defineProperty(t, "isMsgWithdrawDelegatorRewardEncodeObject", {
                enumerable: !0,
                get: function() {
                    return l.isMsgWithdrawDelegatorRewardEncodeObject
                }
            }), Object.defineProperty(t, "setupAuthExtension", {
                enumerable: !0,
                get: function() {
                    return l.setupAuthExtension
                }
            }), Object.defineProperty(t, "setupAuthzExtension", {
                enumerable: !0,
                get: function() {
                    return l.setupAuthzExtension
                }
            }), Object.defineProperty(t, "setupBankExtension", {
                enumerable: !0,
                get: function() {
                    return l.setupBankExtension
                }
            }), Object.defineProperty(t, "setupDistributionExtension", {
                enumerable: !0,
                get: function() {
                    return l.setupDistributionExtension
                }
            }), Object.defineProperty(t, "setupFeegrantExtension", {
                enumerable: !0,
                get: function() {
                    return l.setupFeegrantExtension
                }
            }), Object.defineProperty(t, "setupGovExtension", {
                enumerable: !0,
                get: function() {
                    return l.setupGovExtension
                }
            }), Object.defineProperty(t, "setupIbcExtension", {
                enumerable: !0,
                get: function() {
                    return l.setupIbcExtension
                }
            }), Object.defineProperty(t, "setupMintExtension", {
                enumerable: !0,
                get: function() {
                    return l.setupMintExtension
                }
            }), Object.defineProperty(t, "setupSlashingExtension", {
                enumerable: !0,
                get: function() {
                    return l.setupSlashingExtension
                }
            }), Object.defineProperty(t, "setupStakingExtension", {
                enumerable: !0,
                get: function() {
                    return l.setupStakingExtension
                }
            }), Object.defineProperty(t, "setupTxExtension", {
                enumerable: !0,
                get: function() {
                    return l.setupTxExtension
                }
            });
            var u = r(19625);
            Object.defineProperty(t, "makeMultisignedTx", {
                enumerable: !0,
                get: function() {
                    return u.makeMultisignedTx
                }
            }), Object.defineProperty(t, "makeMultisignedTxBytes", {
                enumerable: !0,
                get: function() {
                    return u.makeMultisignedTxBytes
                }
            });
            var p = r(45504);
            Object.defineProperty(t, "createPagination", {
                enumerable: !0,
                get: function() {
                    return p.createPagination
                }
            }), Object.defineProperty(t, "createProtobufRpcClient", {
                enumerable: !0,
                get: function() {
                    return p.createProtobufRpcClient
                }
            }), Object.defineProperty(t, "decodeCosmosSdkDecFromProto", {
                enumerable: !0,
                get: function() {
                    return p.decodeCosmosSdkDecFromProto
                }
            }), Object.defineProperty(t, "QueryClient", {
                enumerable: !0,
                get: function() {
                    return p.QueryClient
                }
            });
            var m = r(50494);
            Object.defineProperty(t, "isSearchTxQueryArray", {
                enumerable: !0,
                get: function() {
                    return m.isSearchTxQueryArray
                }
            });
            var g = r(59438);
            Object.defineProperty(t, "createDefaultAminoConverters", {
                enumerable: !0,
                get: function() {
                    return g.createDefaultAminoConverters
                }
            }), Object.defineProperty(t, "defaultRegistryTypes", {
                enumerable: !0,
                get: function() {
                    return g.defaultRegistryTypes
                }
            }), Object.defineProperty(t, "SigningStargateClient", {
                enumerable: !0,
                get: function() {
                    return g.SigningStargateClient
                }
            });
            var f = r(16499);
            Object.defineProperty(t, "assertIsDeliverTxFailure", {
                enumerable: !0,
                get: function() {
                    return f.assertIsDeliverTxFailure
                }
            }), Object.defineProperty(t, "assertIsDeliverTxSuccess", {
                enumerable: !0,
                get: function() {
                    return f.assertIsDeliverTxSuccess
                }
            }), Object.defineProperty(t, "BroadcastTxError", {
                enumerable: !0,
                get: function() {
                    return f.BroadcastTxError
                }
            }), Object.defineProperty(t, "isDeliverTxFailure", {
                enumerable: !0,
                get: function() {
                    return f.isDeliverTxFailure
                }
            }), Object.defineProperty(t, "isDeliverTxSuccess", {
                enumerable: !0,
                get: function() {
                    return f.isDeliverTxSuccess
                }
            }), Object.defineProperty(t, "StargateClient", {
                enumerable: !0,
                get: function() {
                    return f.StargateClient
                }
            }), Object.defineProperty(t, "TimeoutError", {
                enumerable: !0,
                get: function() {
                    return f.TimeoutError
                }
            });
            var y = r(39712);
            Object.defineProperty(t, "coin", {
                enumerable: !0,
                get: function() {
                    return y.coin
                }
            }), Object.defineProperty(t, "coins", {
                enumerable: !0,
                get: function() {
                    return y.coins
                }
            }), Object.defineProperty(t, "makeCosmoshubPath", {
                enumerable: !0,
                get: function() {
                    return y.makeCosmoshubPath
                }
            }), Object.defineProperty(t, "parseCoins", {
                enumerable: !0,
                get: function() {
                    return y.parseCoins
                }
            })
        },
        52082: function(e, t, r) {
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: !0
            }), t.findAttribute = t.parseRawLog = t.parseLogs = t.parseLog = t.parseEvent = t.parseAttribute = void 0;
            let n = r(93337);

            function o(e) {
                if (!(0, n.isNonNullObject)(e)) throw Error("Attribute must be a non-null object");
                let {
                    key: t,
                    value: r
                } = e;
                if ("string" != typeof t || !t) throw Error("Attribute's key must be a non-empty string");
                if ("string" != typeof r && void 0 !== r) throw Error("Attribute's value must be a string or unset");
                return {
                    key: t,
                    value: r || ""
                }
            }

            function i(e) {
                if (!(0, n.isNonNullObject)(e)) throw Error("Event must be a non-null object");
                let {
                    type: t,
                    attributes: r
                } = e;
                if ("string" != typeof t || "" === t) throw Error("Event type must be a non-empty string");
                if (!Array.isArray(r)) throw Error("Event's attributes must be an array");
                return {
                    type: t,
                    attributes: r.map(o)
                }
            }

            function a(e) {
                if (!(0, n.isNonNullObject)(e)) throw Error("Log must be a non-null object");
                let {
                    msg_index: t,
                    log: r,
                    events: o
                } = e;
                if ("number" != typeof t) throw Error("Log's msg_index must be a number");
                if ("string" != typeof r) throw Error("Log's log must be a string");
                if (!Array.isArray(o)) throw Error("Log's events must be an array");
                return {
                    msg_index: t,
                    log: r,
                    events: o.map(i)
                }
            }

            function s(e) {
                if (!Array.isArray(e)) throw Error("Logs must be an array");
                return e.map(a)
            }
            t.parseAttribute = o, t.parseEvent = i, t.parseLog = a, t.parseLogs = s, t.parseRawLog = function(e = "[]") {
                return s(JSON.parse(e).map(({
                    events: e
                }, t) => ({
                    msg_index: t,
                    events: e,
                    log: ""
                })))
            }, t.findAttribute = function(e, t, r) {
                let n = e.find(() => !0),
                    o = n ? .events.find(e => e.type === t) ? .attributes.find(e => e.key === r);
                if (!o) throw Error(`Could not find attribute '${r}' in first event of type '${t}' in first log.`);
                return o
            }
        },
        78288: function(e, t, r) {
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: !0
            }), t.setupAuthExtension = void 0;
            let n = r(25517),
                o = r(45504);
            t.setupAuthExtension = function(e) {
                let t = (0, o.createProtobufRpcClient)(e),
                    r = new n.QueryClientImpl(t);
                return {
                    auth: {
                        account: async e => {
                            let {
                                account: t
                            } = await r.Account({
                                address: e
                            });
                            return t ? ? null
                        }
                    }
                }
            }
        },
        44357: function(e, t) {
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: !0
            }), t.createAuthzAminoConverters = void 0, t.createAuthzAminoConverters = function() {
                return {}
            }
        },
        59829: function(e, t, r) {
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: !0
            }), t.authzTypes = void 0;
            let n = r(72060);
            t.authzTypes = [
                ["/cosmos.authz.v1beta1.MsgExec", n.MsgExec],
                ["/cosmos.authz.v1beta1.MsgGrant", n.MsgGrant],
                ["/cosmos.authz.v1beta1.MsgRevoke", n.MsgRevoke]
            ]
        },
        27960: function(e, t, r) {
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: !0
            }), t.setupAuthzExtension = void 0;
            let n = r(6034),
                o = r(45504);
            t.setupAuthzExtension = function(e) {
                let t = (0, o.createProtobufRpcClient)(e),
                    r = new n.QueryClientImpl(t);
                return {
                    authz: {
                        grants: async (e, t, n, i) => await r.Grants({
                            granter: e,
                            grantee: t,
                            msgTypeUrl: n,
                            pagination: (0, o.createPagination)(i)
                        }),
                        granteeGrants: async (e, t) => await r.GranteeGrants({
                            grantee: e,
                            pagination: (0, o.createPagination)(t)
                        }),
                        granterGrants: async (e, t) => await r.GranterGrants({
                            granter: e,
                            pagination: (0, o.createPagination)(t)
                        })
                    }
                }
            }
        },
        61531: function(e, t) {
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: !0
            }), t.createBankAminoConverters = t.isAminoMsgMultiSend = t.isAminoMsgSend = void 0, t.isAminoMsgSend = function(e) {
                return "cosmos-sdk/MsgSend" === e.type
            }, t.isAminoMsgMultiSend = function(e) {
                return "cosmos-sdk/MsgMultiSend" === e.type
            }, t.createBankAminoConverters = function() {
                return {
                    "/cosmos.bank.v1beta1.MsgSend": {
                        aminoType: "cosmos-sdk/MsgSend",
                        toAmino: ({
                            fromAddress: e,
                            toAddress: t,
                            amount: r
                        }) => ({
                            from_address: e,
                            to_address: t,
                            amount: [...r]
                        }),
                        fromAmino: ({
                            from_address: e,
                            to_address: t,
                            amount: r
                        }) => ({
                            fromAddress: e,
                            toAddress: t,
                            amount: [...r]
                        })
                    },
                    "/cosmos.bank.v1beta1.MsgMultiSend": {
                        aminoType: "cosmos-sdk/MsgMultiSend",
                        toAmino: ({
                            inputs: e,
                            outputs: t
                        }) => ({
                            inputs: e.map(e => ({
                                address: e.address,
                                coins: [...e.coins]
                            })),
                            outputs: t.map(e => ({
                                address: e.address,
                                coins: [...e.coins]
                            }))
                        }),
                        fromAmino: ({
                            inputs: e,
                            outputs: t
                        }) => ({
                            inputs: e.map(e => ({
                                address: e.address,
                                coins: [...e.coins]
                            })),
                            outputs: t.map(e => ({
                                address: e.address,
                                coins: [...e.coins]
                            }))
                        })
                    }
                }
            }
        },
        40010: function(e, t, r) {
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: !0
            }), t.isMsgSendEncodeObject = t.bankTypes = void 0;
            let n = r(64395);
            t.bankTypes = [
                ["/cosmos.bank.v1beta1.MsgMultiSend", n.MsgMultiSend],
                ["/cosmos.bank.v1beta1.MsgSend", n.MsgSend]
            ], t.isMsgSendEncodeObject = function(e) {
                return "/cosmos.bank.v1beta1.MsgSend" === e.typeUrl
            }
        },
        19012: function(e, t, r) {
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: !0
            }), t.setupBankExtension = void 0;
            let n = r(93337),
                o = r(53659),
                i = r(45504);
            t.setupBankExtension = function(e) {
                let t = (0, i.createProtobufRpcClient)(e),
                    r = new o.QueryClientImpl(t);
                return {
                    bank: {
                        balance: async (e, t) => {
                            let {
                                balance: o
                            } = await r.Balance({
                                address: e,
                                denom: t
                            });
                            return (0, n.assert)(o), o
                        },
                        allBalances: async e => {
                            let {
                                balances: t
                            } = await r.AllBalances(o.QueryAllBalancesRequest.fromPartial({
                                address: e
                            }));
                            return t
                        },
                        totalSupply: async e => await r.TotalSupply({
                            pagination: (0, i.createPagination)(e)
                        }),
                        supplyOf: async e => {
                            let {
                                amount: t
                            } = await r.SupplyOf({
                                denom: e
                            });
                            return (0, n.assert)(t), t
                        },
                        denomMetadata: async e => {
                            let {
                                metadata: t
                            } = await r.DenomMetadata({
                                denom: e
                            });
                            return (0, n.assert)(t), t
                        },
                        denomsMetadata: async () => {
                            let {
                                metadatas: e
                            } = await r.DenomsMetadata(o.QueryDenomsMetadataRequest.fromPartial({
                                pagination: void 0
                            }));
                            return e
                        }
                    }
                }
            }
        },
        30269: function(e, t) {
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: !0
            }), t.createCrysisAminoConverters = t.isAminoMsgVerifyInvariant = void 0, t.isAminoMsgVerifyInvariant = function(e) {
                return "cosmos-sdk/MsgVerifyInvariant" === e.type
            }, t.createCrysisAminoConverters = function() {
                throw Error("Not implemented")
            }
        },
        46992: function(e, t) {
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: !0
            }), t.createDistributionAminoConverters = t.isAminoMsgFundCommunityPool = t.isAminoMsgWithdrawValidatorCommission = t.isAminoMsgWithdrawDelegatorReward = t.isAminoMsgSetWithdrawAddress = void 0, t.isAminoMsgSetWithdrawAddress = function(e) {
                return "cosmos-sdk/MsgModifyWithdrawAddress" === e.type
            }, t.isAminoMsgWithdrawDelegatorReward = function(e) {
                return "cosmos-sdk/MsgWithdrawDelegationReward" === e.type
            }, t.isAminoMsgWithdrawValidatorCommission = function(e) {
                return "cosmos-sdk/MsgWithdrawValidatorCommission" === e.type
            }, t.isAminoMsgFundCommunityPool = function(e) {
                return "cosmos-sdk/MsgFundCommunityPool" === e.type
            }, t.createDistributionAminoConverters = function() {
                return {
                    "/cosmos.distribution.v1beta1.MsgFundCommunityPool": {
                        aminoType: "cosmos-sdk/MsgFundCommunityPool",
                        toAmino: ({
                            amount: e,
                            depositor: t
                        }) => ({
                            amount: [...e],
                            depositor: t
                        }),
                        fromAmino: ({
                            amount: e,
                            depositor: t
                        }) => ({
                            amount: [...e],
                            depositor: t
                        })
                    },
                    "/cosmos.distribution.v1beta1.MsgSetWithdrawAddress": {
                        aminoType: "cosmos-sdk/MsgModifyWithdrawAddress",
                        toAmino: ({
                            delegatorAddress: e,
                            withdrawAddress: t
                        }) => ({
                            delegator_address: e,
                            withdraw_address: t
                        }),
                        fromAmino: ({
                            delegator_address: e,
                            withdraw_address: t
                        }) => ({
                            delegatorAddress: e,
                            withdrawAddress: t
                        })
                    },
                    "/cosmos.distribution.v1beta1.MsgWithdrawDelegatorReward": {
                        aminoType: "cosmos-sdk/MsgWithdrawDelegationReward",
                        toAmino: ({
                            delegatorAddress: e,
                            validatorAddress: t
                        }) => ({
                            delegator_address: e,
                            validator_address: t
                        }),
                        fromAmino: ({
                            delegator_address: e,
                            validator_address: t
                        }) => ({
                            delegatorAddress: e,
                            validatorAddress: t
                        })
                    },
                    "/cosmos.distribution.v1beta1.MsgWithdrawValidatorCommission": {
                        aminoType: "cosmos-sdk/MsgWithdrawValidatorCommission",
                        toAmino: ({
                            validatorAddress: e
                        }) => ({
                            validator_address: e
                        }),
                        fromAmino: ({
                            validator_address: e
                        }) => ({
                            validatorAddress: e
                        })
                    }
                }
            }
        },
        22320: function(e, t, r) {
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: !0
            }), t.isMsgWithdrawDelegatorRewardEncodeObject = t.distributionTypes = void 0;
            let n = r(3877);
            t.distributionTypes = [
                ["/cosmos.distribution.v1beta1.MsgFundCommunityPool", n.MsgFundCommunityPool],
                ["/cosmos.distribution.v1beta1.MsgSetWithdrawAddress", n.MsgSetWithdrawAddress],
                ["/cosmos.distribution.v1beta1.MsgWithdrawDelegatorReward", n.MsgWithdrawDelegatorReward],
                ["/cosmos.distribution.v1beta1.MsgWithdrawValidatorCommission", n.MsgWithdrawValidatorCommission]
            ], t.isMsgWithdrawDelegatorRewardEncodeObject = function(e) {
                return "/cosmos.distribution.v1beta1.MsgWithdrawDelegatorReward" === e.typeUrl
            }
        },
        16561: function(e, t, r) {
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: !0
            }), t.setupDistributionExtension = void 0;
            let n = r(43085),
                o = r(45504);
            t.setupDistributionExtension = function(e) {
                let t = (0, o.createProtobufRpcClient)(e),
                    r = new n.QueryClientImpl(t);
                return {
                    distribution: {
                        communityPool: async () => await r.CommunityPool({}),
                        delegationRewards: async (e, t) => await r.DelegationRewards({
                            delegatorAddress: e,
                            validatorAddress: t
                        }),
                        delegationTotalRewards: async e => await r.DelegationTotalRewards({
                            delegatorAddress: e
                        }),
                        delegatorValidators: async e => await r.DelegatorValidators({
                            delegatorAddress: e
                        }),
                        delegatorWithdrawAddress: async e => await r.DelegatorWithdrawAddress({
                            delegatorAddress: e
                        }),
                        params: async () => await r.Params({}),
                        validatorCommission: async e => await r.ValidatorCommission({
                            validatorAddress: e
                        }),
                        validatorOutstandingRewards: async e => await r.ValidatorOutstandingRewards({
                            validatorAddress: e
                        }),
                        validatorSlashes: async (e, t, n, i) => await r.ValidatorSlashes({
                            validatorAddress: e,
                            startingHeight: BigInt(t),
                            endingHeight: BigInt(n),
                            pagination: (0, o.createPagination)(i)
                        })
                    }
                }
            }
        },
        56275: function(e, t) {
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: !0
            }), t.createEvidenceAminoConverters = t.isAminoMsgSubmitEvidence = void 0, t.isAminoMsgSubmitEvidence = function(e) {
                return "cosmos-sdk/MsgSubmitEvidence" === e.type
            }, t.createEvidenceAminoConverters = function() {
                throw Error("Not implemented")
            }
        },
        66651: function(e, t) {
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: !0
            }), t.createFeegrantAminoConverters = void 0, t.createFeegrantAminoConverters = function() {
                return {}
            }
        },
        26324: function(e, t, r) {
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: !0
            }), t.feegrantTypes = void 0;
            let n = r(71882);
            t.feegrantTypes = [
                ["/cosmos.feegrant.v1beta1.MsgGrantAllowance", n.MsgGrantAllowance],
                ["/cosmos.feegrant.v1beta1.MsgRevokeAllowance", n.MsgRevokeAllowance]
            ]
        },
        72940: function(e, t, r) {
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: !0
            }), t.setupFeegrantExtension = void 0;
            let n = r(79749),
                o = r(45504);
            t.setupFeegrantExtension = function(e) {
                let t = (0, o.createProtobufRpcClient)(e),
                    r = new n.QueryClientImpl(t);
                return {
                    feegrant: {
                        allowance: async (e, t) => await r.Allowance({
                            granter: e,
                            grantee: t
                        }),
                        allowances: async (e, t) => await r.Allowances({
                            grantee: e,
                            pagination: (0, o.createPagination)(t)
                        })
                    }
                }
            }
        },
        57280: function(e, t, r) {
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: !0
            }), t.createGovAminoConverters = t.isAminoMsgDeposit = t.isAminoMsgVoteWeighted = t.isAminoMsgVote = t.isAminoMsgSubmitProposal = void 0;
            let n = r(38051),
                o = r(93337),
                i = r(62455),
                a = r(65676),
                s = r(45504);
            t.isAminoMsgSubmitProposal = function(e) {
                return "cosmos-sdk/MsgSubmitProposal" === e.type
            }, t.isAminoMsgVote = function(e) {
                return "cosmos-sdk/MsgVote" === e.type
            }, t.isAminoMsgVoteWeighted = function(e) {
                return "cosmos-sdk/MsgVoteWeighted" === e.type
            }, t.isAminoMsgDeposit = function(e) {
                return "cosmos-sdk/MsgDeposit" === e.type
            }, t.createGovAminoConverters = function() {
                return {
                    "/cosmos.gov.v1beta1.MsgDeposit": {
                        aminoType: "cosmos-sdk/MsgDeposit",
                        toAmino: ({
                            amount: e,
                            depositor: t,
                            proposalId: r
                        }) => ({
                            amount: e,
                            depositor: t,
                            proposal_id: r.toString()
                        }),
                        fromAmino: ({
                            amount: e,
                            depositor: t,
                            proposal_id: r
                        }) => ({
                            amount: Array.from(e),
                            depositor: t,
                            proposalId: BigInt(r)
                        })
                    },
                    "/cosmos.gov.v1beta1.MsgVote": {
                        aminoType: "cosmos-sdk/MsgVote",
                        toAmino: ({
                            option: e,
                            proposalId: t,
                            voter: r
                        }) => ({
                            option: e,
                            proposal_id: t.toString(),
                            voter: r
                        }),
                        fromAmino: ({
                            option: e,
                            proposal_id: t,
                            voter: r
                        }) => ({
                            option: (0, i.voteOptionFromJSON)(e),
                            proposalId: BigInt(t),
                            voter: r
                        })
                    },
                    "/cosmos.gov.v1beta1.MsgVoteWeighted": {
                        aminoType: "cosmos-sdk/MsgVoteWeighted",
                        toAmino: ({
                            options: e,
                            proposalId: t,
                            voter: r
                        }) => ({
                            options: e.map(e => ({
                                option: e.option,
                                weight: (0, s.decodeCosmosSdkDecFromProto)(e.weight).toString().padEnd(20, "0")
                            })),
                            proposal_id: t.toString(),
                            voter: r
                        }),
                        fromAmino: ({
                            options: e,
                            proposal_id: t,
                            voter: r
                        }) => ({
                            proposalId: BigInt(t),
                            voter: r,
                            options: e.map(e => ({
                                option: (0, i.voteOptionFromJSON)(e.option),
                                weight: n.Decimal.fromUserInput(e.weight, 18).atomics
                            }))
                        })
                    },
                    "/cosmos.gov.v1beta1.MsgSubmitProposal": {
                        aminoType: "cosmos-sdk/MsgSubmitProposal",
                        toAmino: ({
                            initialDeposit: e,
                            proposer: t,
                            content: r
                        }) => {
                            let n;
                            if ((0, o.assertDefinedAndNotNull)(r), "/cosmos.gov.v1beta1.TextProposal" === r.typeUrl) {
                                let e = i.TextProposal.decode(r.value);
                                n = {
                                    type: "cosmos-sdk/TextProposal",
                                    value: {
                                        description: e.description,
                                        title: e.title
                                    }
                                }
                            } else throw Error(`Unsupported proposal type: '${r.typeUrl}'`);
                            return {
                                initial_deposit: e,
                                proposer: t,
                                content: n
                            }
                        },
                        fromAmino: ({
                            initial_deposit: e,
                            proposer: t,
                            content: r
                        }) => {
                            let n;
                            if ("cosmos-sdk/TextProposal" === r.type) {
                                let {
                                    value: e
                                } = r;
                                (0, o.assert)((0, o.isNonNullObject)(e));
                                let {
                                    title: t,
                                    description: s
                                } = e;
                                (0, o.assert)("string" == typeof t), (0, o.assert)("string" == typeof s), n = a.Any.fromPartial({
                                    typeUrl: "/cosmos.gov.v1beta1.TextProposal",
                                    value: i.TextProposal.encode(i.TextProposal.fromPartial({
                                        title: t,
                                        description: s
                                    })).finish()
                                })
                            } else throw Error(`Unsupported proposal type: '${r.type}'`);
                            return {
                                initialDeposit: Array.from(e),
                                proposer: t,
                                content: n
                            }
                        }
                    }
                }
            }
        },
        47184: function(e, t, r) {
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: !0
            }), t.isMsgVoteWeightedEncodeObject = t.isMsgVoteEncodeObject = t.isMsgSubmitProposalEncodeObject = t.isMsgDepositEncodeObject = t.govTypes = void 0;
            let n = r(63406),
                o = r(26183);
            t.govTypes = [
                ["/cosmos.gov.v1.MsgDeposit", n.MsgDeposit],
                ["/cosmos.gov.v1.MsgSubmitProposal", n.MsgSubmitProposal],
                ["/cosmos.gov.v1.MsgUpdateParams", n.MsgUpdateParams],
                ["/cosmos.gov.v1.MsgVote", n.MsgVote],
                ["/cosmos.gov.v1.MsgVoteWeighted", n.MsgVoteWeighted],
                ["/cosmos.gov.v1beta1.MsgDeposit", o.MsgDeposit],
                ["/cosmos.gov.v1beta1.MsgSubmitProposal", o.MsgSubmitProposal],
                ["/cosmos.gov.v1beta1.MsgVote", o.MsgVote],
                ["/cosmos.gov.v1beta1.MsgVoteWeighted", o.MsgVoteWeighted]
            ], t.isMsgDepositEncodeObject = function(e) {
                return "/cosmos.gov.v1beta1.MsgDeposit" === e.typeUrl
            }, t.isMsgSubmitProposalEncodeObject = function(e) {
                return "/cosmos.gov.v1beta1.MsgSubmitProposal" === e.typeUrl
            }, t.isMsgVoteEncodeObject = function(e) {
                return "/cosmos.gov.v1beta1.MsgVote" === e.typeUrl
            }, t.isMsgVoteWeightedEncodeObject = function(e) {
                return "/cosmos.gov.v1beta1.MsgVoteWeighted" === e.typeUrl
            }
        },
        31306: function(e, t, r) {
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: !0
            }), t.setupGovExtension = void 0;
            let n = r(58043),
                o = r(45504);
            t.setupGovExtension = function(e) {
                let t = (0, o.createProtobufRpcClient)(e),
                    r = new n.QueryClientImpl(t);
                return {
                    gov: {
                        params: async e => await r.Params({
                            paramsType: e
                        }),
                        proposals: async (e, t, n, i) => await r.Proposals({
                            proposalStatus: e,
                            depositor: t,
                            voter: n,
                            pagination: (0, o.createPagination)(i)
                        }),
                        proposal: async e => await r.Proposal({
                            proposalId: (0, o.longify)(e)
                        }),
                        deposits: async (e, t) => await r.Deposits({
                            proposalId: (0, o.longify)(e),
                            pagination: (0, o.createPagination)(t)
                        }),
                        deposit: async (e, t) => await r.Deposit({
                            proposalId: (0, o.longify)(e),
                            depositor: t
                        }),
                        tally: async e => await r.TallyResult({
                            proposalId: (0, o.longify)(e)
                        }),
                        votes: async (e, t) => await r.Votes({
                            proposalId: (0, o.longify)(e),
                            pagination: (0, o.createPagination)(t)
                        }),
                        vote: async (e, t) => await r.Vote({
                            proposalId: (0, o.longify)(e),
                            voter: t
                        })
                    }
                }
            }
        },
        4902: function(e, t) {
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: !0
            }), t.createGroupAminoConverters = void 0, t.createGroupAminoConverters = function() {
                return {}
            }
        },
        11288: function(e, t, r) {
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: !0
            }), t.groupTypes = void 0;
            let n = r(91640);
            t.groupTypes = [
                ["/cosmos.group.v1.MsgCreateGroup", n.MsgCreateGroup],
                ["/cosmos.group.v1.MsgCreateGroupPolicy", n.MsgCreateGroupPolicy],
                ["/cosmos.group.v1.MsgCreateGroupWithPolicy", n.MsgCreateGroupWithPolicy],
                ["/cosmos.group.v1.MsgExec", n.MsgExec],
                ["/cosmos.group.v1.MsgLeaveGroup", n.MsgLeaveGroup],
                ["/cosmos.group.v1.MsgSubmitProposal", n.MsgSubmitProposal],
                ["/cosmos.group.v1.MsgUpdateGroupAdmin", n.MsgUpdateGroupAdmin],
                ["/cosmos.group.v1.MsgUpdateGroupMembers", n.MsgUpdateGroupMembers],
                ["/cosmos.group.v1.MsgUpdateGroupMetadata", n.MsgUpdateGroupMetadata],
                ["/cosmos.group.v1.MsgUpdateGroupPolicyAdmin", n.MsgUpdateGroupPolicyAdmin],
                ["/cosmos.group.v1.MsgUpdateGroupPolicyDecisionPolicy", n.MsgUpdateGroupPolicyDecisionPolicy],
                ["/cosmos.group.v1.MsgUpdateGroupPolicyMetadata", n.MsgUpdateGroupPolicyMetadata],
                ["/cosmos.group.v1.MsgVote", n.MsgVote],
                ["/cosmos.group.v1.MsgWithdrawProposal", n.MsgWithdrawProposal]
            ]
        },
        85744: function(e, t, r) {
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: !0
            }), t.createIbcAminoConverters = t.isAminoMsgTransfer = void 0;
            let n = r(68683),
                o = r(37762);
            t.isAminoMsgTransfer = function(e) {
                return "cosmos-sdk/MsgTransfer" === e.type
            }, t.createIbcAminoConverters = function() {
                return {
                    "/ibc.applications.transfer.v1.MsgTransfer": {
                        aminoType: "cosmos-sdk/MsgTransfer",
                        toAmino: ({
                            sourcePort: e,
                            sourceChannel: t,
                            token: r,
                            sender: o,
                            receiver: i,
                            timeoutHeight: a,
                            timeoutTimestamp: s,
                            memo: d
                        }) => ({
                            source_port: e,
                            source_channel: t,
                            token: r,
                            sender: o,
                            receiver: i,
                            timeout_height: a ? {
                                revision_height: n.omitDefault(a.revisionHeight) ? .toString(),
                                revision_number: n.omitDefault(a.revisionNumber) ? .toString()
                            } : {},
                            timeout_timestamp: n.omitDefault(s) ? .toString(),
                            memo: (0, n.omitDefault)(d)
                        }),
                        fromAmino: ({
                            source_port: e,
                            source_channel: t,
                            token: r,
                            sender: n,
                            receiver: i,
                            timeout_height: a,
                            timeout_timestamp: s,
                            memo: d
                        }) => o.MsgTransfer.fromPartial({
                            sourcePort: e,
                            sourceChannel: t,
                            token: r,
                            sender: n,
                            receiver: i,
                            timeoutHeight: a ? {
                                revisionHeight: BigInt(a.revision_height || "0"),
                                revisionNumber: BigInt(a.revision_number || "0")
                            } : void 0,
                            timeoutTimestamp: BigInt(s || "0"),
                            memo: d ? ? ""
                        })
                    }
                }
            }
        },
        90536: function(e, t, r) {
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: !0
            }), t.isMsgTransferEncodeObject = t.ibcTypes = void 0;
            let n = r(37762),
                o = r(90268),
                i = r(29040),
                a = r(71031);
            t.ibcTypes = [
                ["/ibc.applications.transfer.v1.MsgTransfer", n.MsgTransfer],
                ["/ibc.core.channel.v1.MsgAcknowledgement", o.MsgAcknowledgement],
                ["/ibc.core.channel.v1.MsgChannelCloseConfirm", o.MsgChannelCloseConfirm],
                ["/ibc.core.channel.v1.MsgChannelCloseInit", o.MsgChannelCloseInit],
                ["/ibc.core.channel.v1.MsgChannelOpenAck", o.MsgChannelOpenAck],
                ["/ibc.core.channel.v1.MsgChannelOpenConfirm", o.MsgChannelOpenConfirm],
                ["/ibc.core.channel.v1.MsgChannelOpenInit", o.MsgChannelOpenInit],
                ["/ibc.core.channel.v1.MsgChannelOpenTry", o.MsgChannelOpenTry],
                ["/ibc.core.channel.v1.MsgRecvPacket", o.MsgRecvPacket],
                ["/ibc.core.channel.v1.MsgTimeout", o.MsgTimeout],
                ["/ibc.core.channel.v1.MsgTimeoutOnClose", o.MsgTimeoutOnClose],
                ["/ibc.core.client.v1.MsgCreateClient", i.MsgCreateClient],
                ["/ibc.core.client.v1.MsgSubmitMisbehaviour", i.MsgSubmitMisbehaviour],
                ["/ibc.core.client.v1.MsgUpdateClient", i.MsgUpdateClient],
                ["/ibc.core.client.v1.MsgUpgradeClient", i.MsgUpgradeClient],
                ["/ibc.core.connection.v1.MsgConnectionOpenAck", a.MsgConnectionOpenAck],
                ["/ibc.core.connection.v1.MsgConnectionOpenConfirm", a.MsgConnectionOpenConfirm],
                ["/ibc.core.connection.v1.MsgConnectionOpenInit", a.MsgConnectionOpenInit],
                ["/ibc.core.connection.v1.MsgConnectionOpenTry", a.MsgConnectionOpenTry]
            ], t.isMsgTransferEncodeObject = function(e) {
                return "/ibc.applications.transfer.v1.MsgTransfer" === e.typeUrl
            }
        },
        20794: function(e, t, r) {
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: !0
            }), t.setupIbcExtension = void 0;
            let n = r(15050),
                o = r(38051),
                i = r(54480),
                a = r(98287),
                s = r(50549),
                d = r(59046),
                c = r(36754),
                l = r(99665),
                u = r(45504);

            function p(e) {
                if (e ? .typeUrl !== "/ibc.lightclients.tendermint.v1.ClientState") throw Error(`Unexpected client state type: ${e?.typeUrl}`);
                return l.ClientState.decode(e.value)
            }
            t.setupIbcExtension = function(e) {
                let t = (0, u.createProtobufRpcClient)(e),
                    r = new s.QueryClientImpl(t),
                    m = new d.QueryClientImpl(t),
                    g = new c.QueryClientImpl(t),
                    f = new i.QueryClientImpl(t);
                return {
                    ibc: {
                        channel: {
                            channel: async (e, t) => r.Channel({
                                portId: e,
                                channelId: t
                            }),
                            channels: async e => r.Channels({
                                pagination: (0, u.createPagination)(e)
                            }),
                            allChannels: async () => {
                                let e, t;
                                let n = [];
                                do e = await r.Channels({
                                    pagination: (0, u.createPagination)(t)
                                }), n.push(...e.channels), t = e.pagination ? .nextKey; while (t && t.length);
                                return s.QueryChannelsResponse.fromPartial({
                                    channels: n,
                                    height: e.height
                                })
                            },
                            connectionChannels: async (e, t) => r.ConnectionChannels({
                                connection: e,
                                pagination: (0, u.createPagination)(t)
                            }),
                            allConnectionChannels: async e => {
                                let t, n;
                                let o = [];
                                do t = await r.ConnectionChannels({
                                    connection: e,
                                    pagination: (0, u.createPagination)(n)
                                }), o.push(...t.channels), n = t.pagination ? .nextKey; while (n && n.length);
                                return s.QueryConnectionChannelsResponse.fromPartial({
                                    channels: o,
                                    height: t.height
                                })
                            },
                            clientState: async (e, t) => r.ChannelClientState({
                                portId: e,
                                channelId: t
                            }),
                            consensusState: async (e, t, n, o) => r.ChannelConsensusState({
                                portId: e,
                                channelId: t,
                                revisionNumber: BigInt(n),
                                revisionHeight: BigInt(o)
                            }),
                            packetCommitment: async (e, t, n) => r.PacketCommitment({
                                portId: e,
                                channelId: t,
                                sequence: (0, u.longify)(n)
                            }),
                            packetCommitments: async (e, t, n) => r.PacketCommitments({
                                channelId: t,
                                portId: e,
                                pagination: (0, u.createPagination)(n)
                            }),
                            allPacketCommitments: async (e, t) => {
                                let n, o;
                                let i = [];
                                do n = await r.PacketCommitments({
                                    channelId: t,
                                    portId: e,
                                    pagination: (0, u.createPagination)(o)
                                }), i.push(...n.commitments), o = n.pagination ? .nextKey; while (o && o.length);
                                return s.QueryPacketCommitmentsResponse.fromPartial({
                                    commitments: i,
                                    height: n.height
                                })
                            },
                            packetReceipt: async (e, t, n) => r.PacketReceipt({
                                portId: e,
                                channelId: t,
                                sequence: (0, u.longify)(n)
                            }),
                            packetAcknowledgement: async (e, t, n) => r.PacketAcknowledgement({
                                portId: e,
                                channelId: t,
                                sequence: (0, u.longify)(n)
                            }),
                            packetAcknowledgements: async (e, t, n) => {
                                let o = s.QueryPacketAcknowledgementsRequest.fromPartial({
                                    portId: e,
                                    channelId: t,
                                    pagination: (0, u.createPagination)(n)
                                });
                                return r.PacketAcknowledgements(o)
                            },
                            allPacketAcknowledgements: async (e, t) => {
                                let n, o;
                                let i = [];
                                do {
                                    let a = s.QueryPacketAcknowledgementsRequest.fromPartial({
                                        channelId: t,
                                        portId: e,
                                        pagination: (0, u.createPagination)(o)
                                    });
                                    n = await r.PacketAcknowledgements(a), i.push(...n.acknowledgements), o = n.pagination ? .nextKey
                                } while (o && o.length);
                                return s.QueryPacketAcknowledgementsResponse.fromPartial({
                                    acknowledgements: i,
                                    height: n.height
                                })
                            },
                            unreceivedPackets: async (e, t, n) => r.UnreceivedPackets({
                                portId: e,
                                channelId: t,
                                packetCommitmentSequences: n.map(e => BigInt(e))
                            }),
                            unreceivedAcks: async (e, t, n) => r.UnreceivedAcks({
                                portId: e,
                                channelId: t,
                                packetAckSequences: n.map(e => BigInt(e))
                            }),
                            nextSequenceReceive: async (e, t) => r.NextSequenceReceive({
                                portId: e,
                                channelId: t
                            })
                        },
                        client: {
                            state: async e => m.ClientState({
                                clientId: e
                            }),
                            states: async e => m.ClientStates({
                                pagination: (0, u.createPagination)(e)
                            }),
                            allStates: async () => {
                                let e, t;
                                let r = [];
                                do e = await m.ClientStates({
                                    pagination: (0, u.createPagination)(t)
                                }), r.push(...e.clientStates), t = e.pagination ? .nextKey; while (t && t.length);
                                return d.QueryClientStatesResponse.fromPartial({
                                    clientStates: r
                                })
                            },
                            consensusState: async (e, t) => m.ConsensusState(d.QueryConsensusStateRequest.fromPartial({
                                clientId: e,
                                revisionHeight: void 0 !== t ? BigInt(t) : void 0,
                                latestHeight: void 0 === t
                            })),
                            consensusStates: async (e, t) => m.ConsensusStates({
                                clientId: e,
                                pagination: (0, u.createPagination)(t)
                            }),
                            allConsensusStates: async e => {
                                let t, r;
                                let n = [];
                                do t = await m.ConsensusStates({
                                    clientId: e,
                                    pagination: (0, u.createPagination)(r)
                                }), n.push(...t.consensusStates), r = t.pagination ? .nextKey; while (r && r.length);
                                return d.QueryConsensusStatesResponse.fromPartial({
                                    consensusStates: n
                                })
                            },
                            params: async () => m.ClientParams({}),
                            stateTm: async e => p((await m.ClientState({
                                clientId: e
                            })).clientState),
                            statesTm: async e => {
                                let {
                                    clientStates: t
                                } = await m.ClientStates({
                                    pagination: (0, u.createPagination)(e)
                                });
                                return t.map(({
                                    clientState: e
                                }) => p(e))
                            },
                            allStatesTm: async () => {
                                let e, t;
                                let r = [];
                                do r.push(...(e = await m.ClientStates({
                                    pagination: (0, u.createPagination)(t)
                                })).clientStates), t = e.pagination ? .nextKey; while (t && t.length);
                                return r.map(({
                                    clientState: e
                                }) => p(e))
                            },
                            consensusStateTm: async (e, t) => (function(e) {
                                if (e ? .typeUrl !== "/ibc.lightclients.tendermint.v1.ConsensusState") throw Error(`Unexpected client state type: ${e?.typeUrl}`);
                                return l.ConsensusState.decode(e.value)
                            })((await m.ConsensusState(d.QueryConsensusStateRequest.fromPartial({
                                clientId: e,
                                revisionHeight: t ? .revisionHeight,
                                revisionNumber: t ? .revisionNumber,
                                latestHeight: void 0 === t
                            }))).consensusState)
                        },
                        connection: {
                            connection: async e => g.Connection({
                                connectionId: e
                            }),
                            connections: async e => g.Connections({
                                pagination: (0, u.createPagination)(e)
                            }),
                            allConnections: async () => {
                                let e, t;
                                let r = [];
                                do e = await g.Connections({
                                    pagination: (0, u.createPagination)(t)
                                }), r.push(...e.connections), t = e.pagination ? .nextKey; while (t && t.length);
                                return c.QueryConnectionsResponse.fromPartial({
                                    connections: r,
                                    height: e.height
                                })
                            },
                            clientConnections: async e => g.ClientConnections({
                                clientId: e
                            }),
                            clientState: async e => g.ConnectionClientState({
                                connectionId: e
                            }),
                            consensusState: async (e, t) => g.ConnectionConsensusState(c.QueryConnectionConsensusStateRequest.fromPartial({
                                connectionId: e,
                                revisionHeight: BigInt(t)
                            }))
                        },
                        transfer: {
                            denomTrace: async e => f.DenomTrace({
                                hash: e
                            }),
                            denomTraces: async e => f.DenomTraces({
                                pagination: (0, u.createPagination)(e)
                            }),
                            allDenomTraces: async () => {
                                let e, t;
                                let r = [];
                                do e = await f.DenomTraces({
                                    pagination: (0, u.createPagination)(t)
                                }), r.push(...e.denomTraces), t = e.pagination ? .nextKey; while (t && t.length);
                                return i.QueryDenomTracesResponse.fromPartial({
                                    denomTraces: r
                                })
                            },
                            params: async () => f.Params({})
                        },
                        verified: {
                            channel: {
                                channel: async (t, r) => {
                                    let o = (0, n.toAscii)(`channelEnds/ports/${t}/channels/${r}`),
                                        {
                                            value: i
                                        } = await e.queryStoreVerified("ibc", o);
                                    return i.length ? a.Channel.decode(i) : null
                                },
                                packetCommitment: async (t, r, o) => {
                                    let i = (0, n.toAscii)(`commitments/ports/${t}/channels/${r}/packets/${o}`),
                                        {
                                            value: a
                                        } = await e.queryStoreVerified("ibc", i);
                                    return a
                                },
                                packetAcknowledgement: async (t, r, o) => {
                                    let i = (0, n.toAscii)(`acks/ports/${t}/channels/${r}/acknowledgements/${o}`),
                                        {
                                            value: a
                                        } = await e.queryStoreVerified("ibc", i);
                                    return a
                                },
                                nextSequenceReceive: async (t, r) => {
                                    let i = (0, n.toAscii)(`seqAcks/ports/${t}/channels/${r}/nextSequenceAck`),
                                        {
                                            value: a
                                        } = await e.queryStoreVerified("ibc", i);
                                    return a.length ? o.Uint64.fromBytes(a).toNumber() : null
                                }
                            }
                        }
                    }
                }
            }
        },
        27393: function(e, t, r) {
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: !0
            }), t.isAminoMsgCreateValidator = t.isAminoMsgBeginRedelegate = t.createStakingAminoConverters = t.setupSlashingExtension = t.isAminoMsgUnjail = t.createSlashingAminoConverters = t.setupMintExtension = t.setupIbcExtension = t.isMsgTransferEncodeObject = t.ibcTypes = t.isAminoMsgTransfer = t.createIbcAminoConverters = t.groupTypes = t.createGroupAminoConverters = t.setupGovExtension = t.isMsgVoteWeightedEncodeObject = t.isMsgVoteEncodeObject = t.isMsgSubmitProposalEncodeObject = t.isMsgDepositEncodeObject = t.govTypes = t.isAminoMsgVoteWeighted = t.isAminoMsgVote = t.isAminoMsgSubmitProposal = t.isAminoMsgDeposit = t.createGovAminoConverters = t.setupFeegrantExtension = t.feegrantTypes = t.createFeegrantAminoConverters = t.isAminoMsgSubmitEvidence = t.createEvidenceAminoConverters = t.setupDistributionExtension = t.isMsgWithdrawDelegatorRewardEncodeObject = t.distributionTypes = t.isAminoMsgWithdrawValidatorCommission = t.isAminoMsgWithdrawDelegatorReward = t.isAminoMsgSetWithdrawAddress = t.isAminoMsgFundCommunityPool = t.createDistributionAminoConverters = t.isAminoMsgVerifyInvariant = t.createCrysisAminoConverters = t.setupBankExtension = t.isMsgSendEncodeObject = t.bankTypes = t.isAminoMsgSend = t.isAminoMsgMultiSend = t.createBankAminoConverters = t.setupAuthzExtension = t.authzTypes = t.createAuthzAminoConverters = t.setupAuthExtension = void 0, t.vestingTypes = t.isAminoMsgCreateVestingAccount = t.createVestingAminoConverters = t.setupTxExtension = t.setupStakingExtension = t.stakingTypes = t.isMsgUndelegateEncodeObject = t.isMsgEditValidatorEncodeObject = t.isMsgDelegateEncodeObject = t.isMsgCreateValidatorEncodeObject = t.isMsgBeginRedelegateEncodeObject = t.isAminoMsgUndelegate = t.isAminoMsgEditValidator = t.isAminoMsgDelegate = void 0;
            var n = r(78288);
            Object.defineProperty(t, "setupAuthExtension", {
                enumerable: !0,
                get: function() {
                    return n.setupAuthExtension
                }
            });
            var o = r(44357);
            Object.defineProperty(t, "createAuthzAminoConverters", {
                enumerable: !0,
                get: function() {
                    return o.createAuthzAminoConverters
                }
            });
            var i = r(59829);
            Object.defineProperty(t, "authzTypes", {
                enumerable: !0,
                get: function() {
                    return i.authzTypes
                }
            });
            var a = r(27960);
            Object.defineProperty(t, "setupAuthzExtension", {
                enumerable: !0,
                get: function() {
                    return a.setupAuthzExtension
                }
            });
            var s = r(61531);
            Object.defineProperty(t, "createBankAminoConverters", {
                enumerable: !0,
                get: function() {
                    return s.createBankAminoConverters
                }
            }), Object.defineProperty(t, "isAminoMsgMultiSend", {
                enumerable: !0,
                get: function() {
                    return s.isAminoMsgMultiSend
                }
            }), Object.defineProperty(t, "isAminoMsgSend", {
                enumerable: !0,
                get: function() {
                    return s.isAminoMsgSend
                }
            });
            var d = r(40010);
            Object.defineProperty(t, "bankTypes", {
                enumerable: !0,
                get: function() {
                    return d.bankTypes
                }
            }), Object.defineProperty(t, "isMsgSendEncodeObject", {
                enumerable: !0,
                get: function() {
                    return d.isMsgSendEncodeObject
                }
            });
            var c = r(19012);
            Object.defineProperty(t, "setupBankExtension", {
                enumerable: !0,
                get: function() {
                    return c.setupBankExtension
                }
            });
            var l = r(30269);
            Object.defineProperty(t, "createCrysisAminoConverters", {
                enumerable: !0,
                get: function() {
                    return l.createCrysisAminoConverters
                }
            }), Object.defineProperty(t, "isAminoMsgVerifyInvariant", {
                enumerable: !0,
                get: function() {
                    return l.isAminoMsgVerifyInvariant
                }
            });
            var u = r(46992);
            Object.defineProperty(t, "createDistributionAminoConverters", {
                enumerable: !0,
                get: function() {
                    return u.createDistributionAminoConverters
                }
            }), Object.defineProperty(t, "isAminoMsgFundCommunityPool", {
                enumerable: !0,
                get: function() {
                    return u.isAminoMsgFundCommunityPool
                }
            }), Object.defineProperty(t, "isAminoMsgSetWithdrawAddress", {
                enumerable: !0,
                get: function() {
                    return u.isAminoMsgSetWithdrawAddress
                }
            }), Object.defineProperty(t, "isAminoMsgWithdrawDelegatorReward", {
                enumerable: !0,
                get: function() {
                    return u.isAminoMsgWithdrawDelegatorReward
                }
            }), Object.defineProperty(t, "isAminoMsgWithdrawValidatorCommission", {
                enumerable: !0,
                get: function() {
                    return u.isAminoMsgWithdrawValidatorCommission
                }
            });
            var p = r(22320);
            Object.defineProperty(t, "distributionTypes", {
                enumerable: !0,
                get: function() {
                    return p.distributionTypes
                }
            }), Object.defineProperty(t, "isMsgWithdrawDelegatorRewardEncodeObject", {
                enumerable: !0,
                get: function() {
                    return p.isMsgWithdrawDelegatorRewardEncodeObject
                }
            });
            var m = r(16561);
            Object.defineProperty(t, "setupDistributionExtension", {
                enumerable: !0,
                get: function() {
                    return m.setupDistributionExtension
                }
            });
            var g = r(56275);
            Object.defineProperty(t, "createEvidenceAminoConverters", {
                enumerable: !0,
                get: function() {
                    return g.createEvidenceAminoConverters
                }
            }), Object.defineProperty(t, "isAminoMsgSubmitEvidence", {
                enumerable: !0,
                get: function() {
                    return g.isAminoMsgSubmitEvidence
                }
            });
            var f = r(66651);
            Object.defineProperty(t, "createFeegrantAminoConverters", {
                enumerable: !0,
                get: function() {
                    return f.createFeegrantAminoConverters
                }
            });
            var y = r(26324);
            Object.defineProperty(t, "feegrantTypes", {
                enumerable: !0,
                get: function() {
                    return y.feegrantTypes
                }
            });
            var h = r(72940);
            Object.defineProperty(t, "setupFeegrantExtension", {
                enumerable: !0,
                get: function() {
                    return h.setupFeegrantExtension
                }
            });
            var v = r(57280);
            Object.defineProperty(t, "createGovAminoConverters", {
                enumerable: !0,
                get: function() {
                    return v.createGovAminoConverters
                }
            }), Object.defineProperty(t, "isAminoMsgDeposit", {
                enumerable: !0,
                get: function() {
                    return v.isAminoMsgDeposit
                }
            }), Object.defineProperty(t, "isAminoMsgSubmitProposal", {
                enumerable: !0,
                get: function() {
                    return v.isAminoMsgSubmitProposal
                }
            }), Object.defineProperty(t, "isAminoMsgVote", {
                enumerable: !0,
                get: function() {
                    return v.isAminoMsgVote
                }
            }), Object.defineProperty(t, "isAminoMsgVoteWeighted", {
                enumerable: !0,
                get: function() {
                    return v.isAminoMsgVoteWeighted
                }
            });
            var b = r(47184);
            Object.defineProperty(t, "govTypes", {
                enumerable: !0,
                get: function() {
                    return b.govTypes
                }
            }), Object.defineProperty(t, "isMsgDepositEncodeObject", {
                enumerable: !0,
                get: function() {
                    return b.isMsgDepositEncodeObject
                }
            }), Object.defineProperty(t, "isMsgSubmitProposalEncodeObject", {
                enumerable: !0,
                get: function() {
                    return b.isMsgSubmitProposalEncodeObject
                }
            }), Object.defineProperty(t, "isMsgVoteEncodeObject", {
                enumerable: !0,
                get: function() {
                    return b.isMsgVoteEncodeObject
                }
            }), Object.defineProperty(t, "isMsgVoteWeightedEncodeObject", {
                enumerable: !0,
                get: function() {
                    return b.isMsgVoteWeightedEncodeObject
                }
            });
            var S = r(31306);
            Object.defineProperty(t, "setupGovExtension", {
                enumerable: !0,
                get: function() {
                    return S.setupGovExtension
                }
            });
            var k = r(4902);
            Object.defineProperty(t, "createGroupAminoConverters", {
                enumerable: !0,
                get: function() {
                    return k.createGroupAminoConverters
                }
            });
            var P = r(11288);
            Object.defineProperty(t, "groupTypes", {
                enumerable: !0,
                get: function() {
                    return P.groupTypes
                }
            });
            var _ = r(85744);
            Object.defineProperty(t, "createIbcAminoConverters", {
                enumerable: !0,
                get: function() {
                    return _.createIbcAminoConverters
                }
            }), Object.defineProperty(t, "isAminoMsgTransfer", {
                enumerable: !0,
                get: function() {
                    return _.isAminoMsgTransfer
                }
            });
            var B = r(90536);
            Object.defineProperty(t, "ibcTypes", {
                enumerable: !0,
                get: function() {
                    return B.ibcTypes
                }
            }), Object.defineProperty(t, "isMsgTransferEncodeObject", {
                enumerable: !0,
                get: function() {
                    return B.isMsgTransferEncodeObject
                }
            });
            var O = r(20794);
            Object.defineProperty(t, "setupIbcExtension", {
                enumerable: !0,
                get: function() {
                    return O.setupIbcExtension
                }
            });
            var R = r(84170);
            Object.defineProperty(t, "setupMintExtension", {
                enumerable: !0,
                get: function() {
                    return R.setupMintExtension
                }
            });
            var A = r(77013);
            Object.defineProperty(t, "createSlashingAminoConverters", {
                enumerable: !0,
                get: function() {
                    return A.createSlashingAminoConverters
                }
            }), Object.defineProperty(t, "isAminoMsgUnjail", {
                enumerable: !0,
                get: function() {
                    return A.isAminoMsgUnjail
                }
            });
            var I = r(5774);
            Object.defineProperty(t, "setupSlashingExtension", {
                enumerable: !0,
                get: function() {
                    return I.setupSlashingExtension
                }
            });
            var w = r(64151);
            Object.defineProperty(t, "createStakingAminoConverters", {
                enumerable: !0,
                get: function() {
                    return w.createStakingAminoConverters
                }
            }), Object.defineProperty(t, "isAminoMsgBeginRedelegate", {
                enumerable: !0,
                get: function() {
                    return w.isAminoMsgBeginRedelegate
                }
            }), Object.defineProperty(t, "isAminoMsgCreateValidator", {
                enumerable: !0,
                get: function() {
                    return w.isAminoMsgCreateValidator
                }
            }), Object.defineProperty(t, "isAminoMsgDelegate", {
                enumerable: !0,
                get: function() {
                    return w.isAminoMsgDelegate
                }
            }), Object.defineProperty(t, "isAminoMsgEditValidator", {
                enumerable: !0,
                get: function() {
                    return w.isAminoMsgEditValidator
                }
            }), Object.defineProperty(t, "isAminoMsgUndelegate", {
                enumerable: !0,
                get: function() {
                    return w.isAminoMsgUndelegate
                }
            });
            var T = r(12453);
            Object.defineProperty(t, "isMsgBeginRedelegateEncodeObject", {
                enumerable: !0,
                get: function() {
                    return T.isMsgBeginRedelegateEncodeObject
                }
            }), Object.defineProperty(t, "isMsgCreateValidatorEncodeObject", {
                enumerable: !0,
                get: function() {
                    return T.isMsgCreateValidatorEncodeObject
                }
            }), Object.defineProperty(t, "isMsgDelegateEncodeObject", {
                enumerable: !0,
                get: function() {
                    return T.isMsgDelegateEncodeObject
                }
            }), Object.defineProperty(t, "isMsgEditValidatorEncodeObject", {
                enumerable: !0,
                get: function() {
                    return T.isMsgEditValidatorEncodeObject
                }
            }), Object.defineProperty(t, "isMsgUndelegateEncodeObject", {
                enumerable: !0,
                get: function() {
                    return T.isMsgUndelegateEncodeObject
                }
            }), Object.defineProperty(t, "stakingTypes", {
                enumerable: !0,
                get: function() {
                    return T.stakingTypes
                }
            });
            var N = r(5608);
            Object.defineProperty(t, "setupStakingExtension", {
                enumerable: !0,
                get: function() {
                    return N.setupStakingExtension
                }
            });
            var C = r(39704);
            Object.defineProperty(t, "setupTxExtension", {
                enumerable: !0,
                get: function() {
                    return C.setupTxExtension
                }
            });
            var E = r(48605);
            Object.defineProperty(t, "createVestingAminoConverters", {
                enumerable: !0,
                get: function() {
                    return E.createVestingAminoConverters
                }
            }), Object.defineProperty(t, "isAminoMsgCreateVestingAccount", {
                enumerable: !0,
                get: function() {
                    return E.isAminoMsgCreateVestingAccount
                }
            });
            var x = r(43907);
            Object.defineProperty(t, "vestingTypes", {
                enumerable: !0,
                get: function() {
                    return x.vestingTypes
                }
            })
        },
        84170: function(e, t, r) {
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: !0
            }), t.setupMintExtension = void 0;
            let n = r(93337),
                o = r(79375),
                i = r(45504);
            t.setupMintExtension = function(e) {
                let t = (0, i.createProtobufRpcClient)(e),
                    r = new o.QueryClientImpl(t);
                return {
                    mint: {
                        params: async () => {
                            let {
                                params: e
                            } = await r.Params({});
                            return (0, n.assert)(e), {
                                blocksPerYear: e.blocksPerYear,
                                goalBonded: (0, i.decodeCosmosSdkDecFromProto)(e.goalBonded),
                                inflationMin: (0, i.decodeCosmosSdkDecFromProto)(e.inflationMin),
                                inflationMax: (0, i.decodeCosmosSdkDecFromProto)(e.inflationMax),
                                inflationRateChange: (0, i.decodeCosmosSdkDecFromProto)(e.inflationRateChange),
                                mintDenom: e.mintDenom
                            }
                        },
                        inflation: async () => {
                            let {
                                inflation: e
                            } = await r.Inflation({});
                            return (0, i.decodeCosmosSdkDecFromProto)(e)
                        },
                        annualProvisions: async () => {
                            let {
                                annualProvisions: e
                            } = await r.AnnualProvisions({});
                            return (0, i.decodeCosmosSdkDecFromProto)(e)
                        }
                    }
                }
            }
        },
        77013: function(e, t) {
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: !0
            }), t.createSlashingAminoConverters = t.isAminoMsgUnjail = void 0, t.isAminoMsgUnjail = function(e) {
                return "cosmos-sdk/MsgUnjail" === e.type
            }, t.createSlashingAminoConverters = function() {
                throw Error("Not implemented")
            }
        },
        5774: function(e, t, r) {
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: !0
            }), t.setupSlashingExtension = void 0;
            let n = r(75591),
                o = r(45504);
            t.setupSlashingExtension = function(e) {
                let t = (0, o.createProtobufRpcClient)(e),
                    r = new n.QueryClientImpl(t);
                return {
                    slashing: {
                        signingInfo: async e => await r.SigningInfo({
                            consAddress: e
                        }),
                        signingInfos: async e => await r.SigningInfos({
                            pagination: (0, o.createPagination)(e)
                        }),
                        params: async () => await r.Params({})
                    }
                }
            }
        },
        64151: function(e, t, r) {
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: !0
            }), t.createStakingAminoConverters = t.isAminoMsgUndelegate = t.isAminoMsgBeginRedelegate = t.isAminoMsgDelegate = t.isAminoMsgEditValidator = t.isAminoMsgCreateValidator = t.protoDecimalToJson = void 0;
            let n = r(38051),
                o = r(39712),
                i = r(93337);

            function a(e) {
                let [t, r] = n.Decimal.fromAtomics(e, 18).toString().split(".");
                return `${t}.${(r??"").padEnd(18,"0")}`
            }

            function s(e) {
                return n.Decimal.fromUserInput(e, 18).atomics
            }
            t.protoDecimalToJson = a, t.isAminoMsgCreateValidator = function(e) {
                return "cosmos-sdk/MsgCreateValidator" === e.type
            }, t.isAminoMsgEditValidator = function(e) {
                return "cosmos-sdk/MsgEditValidator" === e.type
            }, t.isAminoMsgDelegate = function(e) {
                return "cosmos-sdk/MsgDelegate" === e.type
            }, t.isAminoMsgBeginRedelegate = function(e) {
                return "cosmos-sdk/MsgBeginRedelegate" === e.type
            }, t.isAminoMsgUndelegate = function(e) {
                return "cosmos-sdk/MsgUndelegate" === e.type
            }, t.createStakingAminoConverters = function() {
                return {
                    "/cosmos.staking.v1beta1.MsgBeginRedelegate": {
                        aminoType: "cosmos-sdk/MsgBeginRedelegate",
                        toAmino: ({
                            delegatorAddress: e,
                            validatorSrcAddress: t,
                            validatorDstAddress: r,
                            amount: n
                        }) => ((0, i.assertDefinedAndNotNull)(n, "missing amount"), {
                            delegator_address: e,
                            validator_src_address: t,
                            validator_dst_address: r,
                            amount: n
                        }),
                        fromAmino: ({
                            delegator_address: e,
                            validator_src_address: t,
                            validator_dst_address: r,
                            amount: n
                        }) => ({
                            delegatorAddress: e,
                            validatorSrcAddress: t,
                            validatorDstAddress: r,
                            amount: n
                        })
                    },
                    "/cosmos.staking.v1beta1.MsgCreateValidator": {
                        aminoType: "cosmos-sdk/MsgCreateValidator",
                        toAmino: ({
                            description: e,
                            commission: t,
                            minSelfDelegation: r,
                            delegatorAddress: n,
                            validatorAddress: s,
                            pubkey: d,
                            value: c
                        }) => ((0, i.assertDefinedAndNotNull)(e, "missing description"), (0, i.assertDefinedAndNotNull)(t, "missing commission"), (0, i.assertDefinedAndNotNull)(d, "missing pubkey"), (0, i.assertDefinedAndNotNull)(c, "missing value"), {
                            description: {
                                moniker: e.moniker,
                                identity: e.identity,
                                website: e.website,
                                security_contact: e.securityContact,
                                details: e.details
                            },
                            commission: {
                                rate: a(t.rate),
                                max_rate: a(t.maxRate),
                                max_change_rate: a(t.maxChangeRate)
                            },
                            min_self_delegation: r,
                            delegator_address: n,
                            validator_address: s,
                            pubkey: (0, o.decodePubkey)(d),
                            value: c
                        }),
                        fromAmino: ({
                            description: e,
                            commission: t,
                            min_self_delegation: r,
                            delegator_address: n,
                            validator_address: i,
                            pubkey: a,
                            value: d
                        }) => ({
                            description: {
                                moniker: e.moniker,
                                identity: e.identity,
                                website: e.website,
                                securityContact: e.security_contact,
                                details: e.details
                            },
                            commission: {
                                rate: s(t.rate),
                                maxRate: s(t.max_rate),
                                maxChangeRate: s(t.max_change_rate)
                            },
                            minSelfDelegation: r,
                            delegatorAddress: n,
                            validatorAddress: i,
                            pubkey: (0, o.encodePubkey)(a),
                            value: d
                        })
                    },
                    "/cosmos.staking.v1beta1.MsgDelegate": {
                        aminoType: "cosmos-sdk/MsgDelegate",
                        toAmino: ({
                            delegatorAddress: e,
                            validatorAddress: t,
                            amount: r
                        }) => ((0, i.assertDefinedAndNotNull)(r, "missing amount"), {
                            delegator_address: e,
                            validator_address: t,
                            amount: r
                        }),
                        fromAmino: ({
                            delegator_address: e,
                            validator_address: t,
                            amount: r
                        }) => ({
                            delegatorAddress: e,
                            validatorAddress: t,
                            amount: r
                        })
                    },
                    "/cosmos.staking.v1beta1.MsgEditValidator": {
                        aminoType: "cosmos-sdk/MsgEditValidator",
                        toAmino: ({
                            description: e,
                            commissionRate: t,
                            minSelfDelegation: r,
                            validatorAddress: n
                        }) => ((0, i.assertDefinedAndNotNull)(e, "missing description"), {
                            description: {
                                moniker: e.moniker,
                                identity: e.identity,
                                website: e.website,
                                security_contact: e.securityContact,
                                details: e.details
                            },
                            commission_rate: t ? a(t) : void 0,
                            min_self_delegation: r || void 0,
                            validator_address: n
                        }),
                        fromAmino: ({
                            description: e,
                            commission_rate: t,
                            min_self_delegation: r,
                            validator_address: n
                        }) => ({
                            description: {
                                moniker: e.moniker,
                                identity: e.identity,
                                website: e.website,
                                securityContact: e.security_contact,
                                details: e.details
                            },
                            commissionRate: t ? s(t) : "",
                            minSelfDelegation: r ? ? "",
                            validatorAddress: n
                        })
                    },
                    "/cosmos.staking.v1beta1.MsgUndelegate": {
                        aminoType: "cosmos-sdk/MsgUndelegate",
                        toAmino: ({
                            delegatorAddress: e,
                            validatorAddress: t,
                            amount: r
                        }) => ((0, i.assertDefinedAndNotNull)(r, "missing amount"), {
                            delegator_address: e,
                            validator_address: t,
                            amount: r
                        }),
                        fromAmino: ({
                            delegator_address: e,
                            validator_address: t,
                            amount: r
                        }) => ({
                            delegatorAddress: e,
                            validatorAddress: t,
                            amount: r
                        })
                    }
                }
            }
        },
        12453: function(e, t, r) {
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: !0
            }), t.isMsgUndelegateEncodeObject = t.isMsgEditValidatorEncodeObject = t.isMsgDelegateEncodeObject = t.isMsgCreateValidatorEncodeObject = t.isMsgBeginRedelegateEncodeObject = t.stakingTypes = void 0;
            let n = r(7897);
            t.stakingTypes = [
                ["/cosmos.staking.v1beta1.MsgBeginRedelegate", n.MsgBeginRedelegate],
                ["/cosmos.staking.v1beta1.MsgCreateValidator", n.MsgCreateValidator],
                ["/cosmos.staking.v1beta1.MsgDelegate", n.MsgDelegate],
                ["/cosmos.staking.v1beta1.MsgEditValidator", n.MsgEditValidator],
                ["/cosmos.staking.v1beta1.MsgUndelegate", n.MsgUndelegate]
            ], t.isMsgBeginRedelegateEncodeObject = function(e) {
                return "/cosmos.staking.v1beta1.MsgBeginRedelegate" === e.typeUrl
            }, t.isMsgCreateValidatorEncodeObject = function(e) {
                return "/cosmos.staking.v1beta1.MsgCreateValidator" === e.typeUrl
            }, t.isMsgDelegateEncodeObject = function(e) {
                return "/cosmos.staking.v1beta1.MsgDelegate" === e.typeUrl
            }, t.isMsgEditValidatorEncodeObject = function(e) {
                return "/cosmos.staking.v1beta1.MsgEditValidator" === e.typeUrl
            }, t.isMsgUndelegateEncodeObject = function(e) {
                return "/cosmos.staking.v1beta1.MsgUndelegate" === e.typeUrl
            }
        },
        5608: function(e, t, r) {
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: !0
            }), t.setupStakingExtension = void 0;
            let n = r(4642),
                o = r(45504);
            t.setupStakingExtension = function(e) {
                let t = (0, o.createProtobufRpcClient)(e),
                    r = new n.QueryClientImpl(t);
                return {
                    staking: {
                        delegation: async (e, t) => await r.Delegation({
                            delegatorAddr: e,
                            validatorAddr: t
                        }),
                        delegatorDelegations: async (e, t) => await r.DelegatorDelegations({
                            delegatorAddr: e,
                            pagination: (0, o.createPagination)(t)
                        }),
                        delegatorUnbondingDelegations: async (e, t) => await r.DelegatorUnbondingDelegations({
                            delegatorAddr: e,
                            pagination: (0, o.createPagination)(t)
                        }),
                        delegatorValidator: async (e, t) => await r.DelegatorValidator({
                            delegatorAddr: e,
                            validatorAddr: t
                        }),
                        delegatorValidators: async (e, t) => await r.DelegatorValidators({
                            delegatorAddr: e,
                            pagination: (0, o.createPagination)(t)
                        }),
                        historicalInfo: async e => await r.HistoricalInfo({
                            height: BigInt(e)
                        }),
                        params: async () => await r.Params({}),
                        pool: async () => await r.Pool({}),
                        redelegations: async (e, t, n, i) => await r.Redelegations({
                            delegatorAddr: e,
                            srcValidatorAddr: t,
                            dstValidatorAddr: n,
                            pagination: (0, o.createPagination)(i)
                        }),
                        unbondingDelegation: async (e, t) => await r.UnbondingDelegation({
                            delegatorAddr: e,
                            validatorAddr: t
                        }),
                        validator: async e => await r.Validator({
                            validatorAddr: e
                        }),
                        validatorDelegations: async (e, t) => await r.ValidatorDelegations({
                            validatorAddr: e,
                            pagination: (0, o.createPagination)(t)
                        }),
                        validators: async (e, t) => await r.Validators({
                            status: e,
                            pagination: (0, o.createPagination)(t)
                        }),
                        validatorUnbondingDelegations: async (e, t) => await r.ValidatorUnbondingDelegations({
                            validatorAddr: e,
                            pagination: (0, o.createPagination)(t)
                        })
                    }
                }
            }
        },
        39704: function(e, t, r) {
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: !0
            }), t.setupTxExtension = void 0;
            let n = r(39712),
                o = r(43062),
                i = r(3639),
                a = r(93739),
                s = r(45504);
            t.setupTxExtension = function(e) {
                let t = (0, s.createProtobufRpcClient)(e),
                    r = new i.ServiceClientImpl(t);
                return {
                    tx: {
                        getTx: async e => await r.GetTx({
                            hash: e
                        }),
                        simulate: async (e, t, s, d) => {
                            let c = a.Tx.fromPartial({
                                    authInfo: a.AuthInfo.fromPartial({
                                        fee: a.Fee.fromPartial({}),
                                        signerInfos: [{
                                            publicKey: (0, n.encodePubkey)(s),
                                            sequence: BigInt(d),
                                            modeInfo: {
                                                single: {
                                                    mode: o.SignMode.SIGN_MODE_UNSPECIFIED
                                                }
                                            }
                                        }]
                                    }),
                                    body: a.TxBody.fromPartial({
                                        messages: Array.from(e),
                                        memo: t
                                    }),
                                    signatures: [new Uint8Array]
                                }),
                                l = i.SimulateRequest.fromPartial({
                                    txBytes: a.Tx.encode(c).finish()
                                });
                            return await r.Simulate(l)
                        }
                    }
                }
            }
        },
        48605: function(e, t) {
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: !0
            }), t.createVestingAminoConverters = t.isAminoMsgCreateVestingAccount = void 0, t.isAminoMsgCreateVestingAccount = function(e) {
                return "cosmos-sdk/MsgCreateVestingAccount" === e.type
            }, t.createVestingAminoConverters = function() {
                return {
                    "/cosmos.vesting.v1beta1.MsgCreateVestingAccount": {
                        aminoType: "cosmos-sdk/MsgCreateVestingAccount",
                        toAmino: ({
                            fromAddress: e,
                            toAddress: t,
                            amount: r,
                            endTime: n,
                            delayed: o
                        }) => ({
                            from_address: e,
                            to_address: t,
                            amount: [...r],
                            end_time: n.toString(),
                            delayed: o
                        }),
                        fromAmino: ({
                            from_address: e,
                            to_address: t,
                            amount: r,
                            end_time: n,
                            delayed: o
                        }) => ({
                            fromAddress: e,
                            toAddress: t,
                            amount: [...r],
                            endTime: BigInt(n),
                            delayed: o
                        })
                    }
                }
            }
        },
        43907: function(e, t, r) {
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: !0
            }), t.vestingTypes = void 0;
            let n = r(51402);
            t.vestingTypes = [
                ["/cosmos.vesting.v1beta1.MsgCreateVestingAccount", n.MsgCreateVestingAccount]
            ]
        },
        19625: function(e, t, r) {
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: !0
            }), t.makeMultisignedTxBytes = t.makeMultisignedTx = t.makeCompactBitArray = void 0;
            let n = r(68683),
                o = r(15050),
                i = r(39712),
                a = r(96947),
                s = r(43062),
                d = r(93739),
                c = r(93739);

            function l(e) {
                let t = Math.ceil(e.length / 8),
                    r = e.length - 8 * Math.floor(e.length / 8),
                    n = new Uint8Array(t);
                return e.forEach((e, t) => {
                    e && (n[Math.floor(t / 8)] |= 1 << 7 - t % 8)
                }), a.CompactBitArray.fromPartial({
                    elems: n,
                    extraBitsStored: r
                })
            }

            function u(e, t, r, u, p) {
                let m = Array.from(p.keys()),
                    g = (0, o.fromBech32)(m[0]).prefix,
                    f = Array(e.value.pubkeys.length).fill(!1),
                    y = [];
                for (let t = 0; t < e.value.pubkeys.length; t++) {
                    let r = (0, n.pubkeyToAddress)(e.value.pubkeys[t], g),
                        o = p.get(r);
                    o && (f[t] = !0, y.push(o))
                }
                let h = {
                        publicKey: (0, i.encodePubkey)(e),
                        modeInfo: {
                            multi: {
                                bitarray: l(f),
                                modeInfos: y.map(e => ({
                                    single: {
                                        mode: s.SignMode.SIGN_MODE_LEGACY_AMINO_JSON
                                    }
                                }))
                            }
                        },
                        sequence: BigInt(t)
                    },
                    v = d.AuthInfo.fromPartial({
                        signerInfos: [h],
                        fee: {
                            amount: [...r.amount],
                            gasLimit: BigInt(r.gas)
                        }
                    }),
                    b = d.AuthInfo.encode(v).finish();
                return c.TxRaw.fromPartial({
                    bodyBytes: u,
                    authInfoBytes: b,
                    signatures: [a.MultiSignature.encode(a.MultiSignature.fromPartial({
                        signatures: y
                    })).finish()]
                })
            }
            t.makeCompactBitArray = l, t.makeMultisignedTx = u, t.makeMultisignedTxBytes = function(e, t, r, n, o) {
                let i = u(e, t, r, n, o);
                return Uint8Array.from(c.TxRaw.encode(i).finish())
            }
        },
        45504: function(e, t, r) {
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: !0
            }), t.longify = t.decodeCosmosSdkDecFromProto = t.createProtobufRpcClient = t.createPagination = t.QueryClient = void 0;
            var n = r(35814);
            Object.defineProperty(t, "QueryClient", {
                enumerable: !0,
                get: function() {
                    return n.QueryClient
                }
            });
            var o = r(14145);
            Object.defineProperty(t, "createPagination", {
                enumerable: !0,
                get: function() {
                    return o.createPagination
                }
            }), Object.defineProperty(t, "createProtobufRpcClient", {
                enumerable: !0,
                get: function() {
                    return o.createProtobufRpcClient
                }
            }), Object.defineProperty(t, "decodeCosmosSdkDecFromProto", {
                enumerable: !0,
                get: function() {
                    return o.decodeCosmosSdkDecFromProto
                }
            }), Object.defineProperty(t, "longify", {
                enumerable: !0,
                get: function() {
                    return o.longify
                }
            })
        },
        35814: function(e, t, r) {
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: !0
            }), t.QueryClient = void 0;
            let n = r(55201),
                o = r(15050),
                i = r(67298),
                a = r(93337);

            function s(e, t, r) {
                if (e.type !== t) throw Error(`Op expected to be ${t}, got "${e.type}`);
                if (!(0, a.arrayContentEquals)(r, e.key)) throw Error(`Proven key different than queried key.
Query: ${(0,o.toHex)(r)}
Proven: ${(0,o.toHex)(e.key)}`);
                return n.ics23.CommitmentProof.decode(e.data)
            }
            class d {
                static withExtensions(e, ...t) {
                    let r = new d(e);
                    for (let e of t.map(e => e(r)))
                        for (let [t, n] of ((0, a.assert)((0, a.isNonNullObject)(e), "Extension must be a non-null object"), Object.entries(e))) {
                            (0, a.assert)((0, a.isNonNullObject)(n), `Module must be a non-null object. Found type ${typeof n} for module "${t}".`);
                            let e = r[t] || {};
                            r[t] = { ...e,
                                ...n
                            }
                        }
                    return r
                }
                constructor(e) {
                    this.cometClient = e
                }
                async queryStoreVerified(e, t, r) {
                    let {
                        height: i,
                        proof: d,
                        key: c,
                        value: l
                    } = await this.queryRawProof(e, t, r), u = s(d.ops[0], "ics23:iavl", t), p = s(d.ops[1], "ics23:simple", (0, o.toAscii)(e));
                    (0, a.assert)(p.exist), (0, a.assert)(p.exist.value), l && 0 !== l.length ? ((0, a.assert)(u.exist), (0, a.assert)(u.exist.value), (0, n.verifyExistence)(u.exist, n.iavlSpec, p.exist.value, t, l)) : ((0, a.assert)(u.nonexist), (0, n.verifyNonExistence)(u.nonexist, n.iavlSpec, p.exist.value, t));
                    let m = await this.getNextHeader(i);
                    return (0, n.verifyExistence)(p.exist, n.tendermintSpec, m.appHash, (0, o.toAscii)(e), p.exist.value), {
                        key: c,
                        value: l,
                        height: i
                    }
                }
                async queryRawProof(e, t, r) {
                    let {
                        key: n,
                        value: i,
                        height: d,
                        proof: c,
                        code: l,
                        log: u
                    } = await this.cometClient.abciQuery({
                        path: `/store/${e}/key`,
                        data: t,
                        prove: !0,
                        height: r
                    });
                    if (l) throw Error(`Query failed with (${l}): ${u}`);
                    if (!(0, a.arrayContentEquals)(t, n)) throw Error(`Response key ${(0,o.toHex)(n)} doesn't match query key ${(0,o.toHex)(t)}`);
                    if (!d) throw Error("No query height returned");
                    if (!c || 2 !== c.ops.length) throw Error(`Expected 2 proof ops, got ${c?.ops.length??0}. Are you using stargate?`);
                    return s(c.ops[0], "ics23:iavl", n), s(c.ops[1], "ics23:simple", (0, o.toAscii)(e)), {
                        key: n,
                        value: i,
                        height: d,
                        proof: {
                            ops: [...c.ops]
                        }
                    }
                }
                async queryAbci(e, t, r) {
                    let n = await this.cometClient.abciQuery({
                        path: e,
                        data: t,
                        prove: !1,
                        height: r
                    });
                    if (n.code) throw Error(`Query failed with (${n.code}): ${n.log}`);
                    if (!n.height) throw Error("No query height returned");
                    return {
                        value: n.value,
                        height: n.height
                    }
                }
                async getNextHeader(e) {
                    let t, r;
                    if ((0, a.assertDefined)(e), 0 === e) throw Error("Query returned height 0, cannot prove it");
                    let n = e + 1;
                    try {
                        r = this.cometClient.subscribeNewBlockHeader()
                    } catch {}
                    if (r) {
                        let e = await (0, i.firstEvent)(r);
                        e.height === n && (t = e)
                    }
                    for (; !t;) {
                        let r = (await this.cometClient.blockchain(e, n)).blockMetas.map(e => e.header).find(e => e.height === n);
                        r ? t = r : await (0, a.sleep)(1e3)
                    }
                    return (0, a.assert)(t.height === n, "Got wrong header. This is a bug in the logic above."), t
                }
            }
            t.QueryClient = d
        },
        14145: function(e, t, r) {
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: !0
            }), t.decodeCosmosSdkDecFromProto = t.longify = t.createProtobufRpcClient = t.createPagination = t.toAccAddress = void 0;
            let n = r(15050),
                o = r(38051),
                i = r(38792);
            t.toAccAddress = function(e) {
                return (0, n.fromBech32)(e).data
            }, t.createPagination = function(e) {
                return e ? i.PageRequest.fromPartial({
                    key: e
                }) : i.PageRequest.fromPartial({})
            }, t.createProtobufRpcClient = function(e) {
                return {
                    request: async (t, r, n) => {
                        let o = `/${t}/${r}`;
                        return (await e.queryAbci(o, n, void 0)).value
                    }
                }
            }, t.longify = function(e) {
                return BigInt(o.Uint64.fromString(e.toString()).toString())
            }, t.decodeCosmosSdkDecFromProto = function(e) {
                let t = "string" == typeof e ? e : (0, n.fromAscii)(e);
                return o.Decimal.fromAtomics(t, 18)
            }
        },
        50494: function(e, t) {
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: !0
            }), t.isSearchTxQueryArray = void 0, t.isSearchTxQueryArray = function(e) {
                return Array.isArray(e)
            }
        },
        59438: function(e, t, r) {
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: !0
            }), t.SigningStargateClient = t.createDefaultAminoConverters = t.defaultRegistryTypes = void 0;
            let n = r(68683),
                o = r(15050),
                i = r(38051),
                a = r(39712),
                s = r(23628),
                d = r(93337),
                c = r(62809),
                l = r(3877),
                u = r(7897),
                p = r(43062),
                m = r(93739),
                g = r(37762),
                f = r(86111),
                y = r(91371),
                h = r(27393),
                v = r(27393),
                b = r(16499);

            function S() {
                return { ...(0, v.createAuthzAminoConverters)(),
                    ...(0, v.createBankAminoConverters)(),
                    ...(0, v.createDistributionAminoConverters)(),
                    ...(0, v.createGovAminoConverters)(),
                    ...(0, v.createStakingAminoConverters)(),
                    ...(0, v.createIbcAminoConverters)(),
                    ...(0, v.createFeegrantAminoConverters)(),
                    ...(0, v.createVestingAminoConverters)()
                }
            }
            t.defaultRegistryTypes = [
                ["/cosmos.base.v1beta1.Coin", c.Coin], ...h.authzTypes, ...h.bankTypes, ...h.distributionTypes, ...h.feegrantTypes, ...h.govTypes, ...h.groupTypes, ...h.stakingTypes, ...h.ibcTypes, ...h.vestingTypes
            ], t.createDefaultAminoConverters = S;
            class k extends b.StargateClient {
                static async connectWithSigner(e, t, r = {}) {
                    let n = await (0, s.connectComet)(e);
                    return k.createWithSigner(n, t, r)
                }
                static async createWithSigner(e, t, r = {}) {
                    return new k(e, t, r)
                }
                static async offline(e, t = {}) {
                    return new k(void 0, e, t)
                }
                constructor(e, r, n) {
                    super(e, n);
                    let {
                        registry: o = new a.Registry(t.defaultRegistryTypes),
                        aminoTypes: i = new f.AminoTypes(S())
                    } = n;
                    this.registry = o, this.aminoTypes = i, this.signer = r, this.broadcastTimeoutMs = n.broadcastTimeoutMs, this.broadcastPollIntervalMs = n.broadcastPollIntervalMs, this.gasPrice = n.gasPrice
                }
                async simulate(e, t, r) {
                    let o = t.map(e => this.registry.encodeAsAny(e)),
                        a = (await this.signer.getAccounts()).find(t => t.address === e);
                    if (!a) throw Error("Failed to retrieve account from signer");
                    let s = (0, n.encodeSecp256k1Pubkey)(a.pubkey),
                        {
                            sequence: c
                        } = await this.getSequence(e),
                        {
                            gasInfo: l
                        } = await this.forceGetQueryClient().tx.simulate(o, r, s, c);
                    return (0, d.assertDefined)(l), i.Uint53.fromString(l.gasUsed.toString()).toNumber()
                }
                async sendTokens(e, t, r, n, o = "") {
                    let i = {
                        typeUrl: "/cosmos.bank.v1beta1.MsgSend",
                        value: {
                            fromAddress: e,
                            toAddress: t,
                            amount: [...r]
                        }
                    };
                    return this.signAndBroadcast(e, [i], n, o)
                }
                async delegateTokens(e, t, r, n, o = "") {
                    let i = {
                        typeUrl: "/cosmos.staking.v1beta1.MsgDelegate",
                        value: u.MsgDelegate.fromPartial({
                            delegatorAddress: e,
                            validatorAddress: t,
                            amount: r
                        })
                    };
                    return this.signAndBroadcast(e, [i], n, o)
                }
                async undelegateTokens(e, t, r, n, o = "") {
                    let i = {
                        typeUrl: "/cosmos.staking.v1beta1.MsgUndelegate",
                        value: u.MsgUndelegate.fromPartial({
                            delegatorAddress: e,
                            validatorAddress: t,
                            amount: r
                        })
                    };
                    return this.signAndBroadcast(e, [i], n, o)
                }
                async withdrawRewards(e, t, r, n = "") {
                    let o = {
                        typeUrl: "/cosmos.distribution.v1beta1.MsgWithdrawDelegatorReward",
                        value: l.MsgWithdrawDelegatorReward.fromPartial({
                            delegatorAddress: e,
                            validatorAddress: t
                        })
                    };
                    return this.signAndBroadcast(e, [o], r, n)
                }
                async sendIbcTokens(e, t, r, n, o, i, a, s, d = "") {
                    let c = a ? BigInt(a) * BigInt(1e9) : void 0,
                        l = {
                            typeUrl: "/ibc.applications.transfer.v1.MsgTransfer",
                            value: g.MsgTransfer.fromPartial({
                                sourcePort: n,
                                sourceChannel: o,
                                sender: e,
                                receiver: t,
                                token: r,
                                timeoutHeight: i,
                                timeoutTimestamp: c
                            })
                        };
                    return this.signAndBroadcast(e, [l], s, d)
                }
                async signAndBroadcast(e, t, r, n = "", o) {
                    let i;
                    if ("auto" == r || "number" == typeof r) {
                        (0, d.assertDefined)(this.gasPrice, "Gas price must be set in the client options when auto gas is used.");
                        let o = await this.simulate(e, t, n),
                            a = "number" == typeof r ? r : 1.4;
                        i = (0, y.calculateFee)(Math.round(o * a), this.gasPrice)
                    } else i = r;
                    let a = await this.sign(e, t, i, n, void 0, o),
                        s = m.TxRaw.encode(a).finish();
                    return this.broadcastTx(s, this.broadcastTimeoutMs, this.broadcastPollIntervalMs)
                }
                async signAndBroadcastSync(e, t, r, n = "", o) {
                    let i;
                    if ("auto" == r || "number" == typeof r) {
                        (0, d.assertDefined)(this.gasPrice, "Gas price must be set in the client options when auto gas is used.");
                        let o = await this.simulate(e, t, n),
                            a = "number" == typeof r ? r : 1.3;
                        i = (0, y.calculateFee)(Math.round(o * a), this.gasPrice)
                    } else i = r;
                    let a = await this.sign(e, t, i, n, void 0, o),
                        s = m.TxRaw.encode(a).finish();
                    return this.broadcastTxSync(s)
                }
                async sign(e, t, r, n, o, i) {
                    let s;
                    if (o) s = o;
                    else {
                        let {
                            accountNumber: t,
                            sequence: r
                        } = await this.getSequence(e);
                        s = {
                            accountNumber: t,
                            sequence: r,
                            chainId: await this.getChainId()
                        }
                    }
                    return (0, a.isOfflineDirectSigner)(this.signer) ? this.signDirect(e, t, r, n, s, i) : this.signAmino(e, t, r, n, s, i)
                }
                async signAmino(e, t, r, s, {
                    accountNumber: c,
                    sequence: l,
                    chainId: u
                }, g) {
                    (0, d.assert)(!(0, a.isOfflineDirectSigner)(this.signer));
                    let f = (await this.signer.getAccounts()).find(t => t.address === e);
                    if (!f) throw Error("Failed to retrieve account from signer");
                    let y = (0, a.encodePubkey)((0, n.encodeSecp256k1Pubkey)(f.pubkey)),
                        h = p.SignMode.SIGN_MODE_LEGACY_AMINO_JSON,
                        v = t.map(e => this.aminoTypes.toAmino(e)),
                        b = (0, n.makeSignDoc)(v, r, u, s, c, l, g),
                        {
                            signature: S,
                            signed: k
                        } = await this.signer.signAmino(e, b),
                        P = {
                            messages: k.msgs.map(e => this.aminoTypes.fromAmino(e)),
                            memo: k.memo,
                            timeoutHeight: g
                        },
                        _ = this.registry.encode({
                            typeUrl: "/cosmos.tx.v1beta1.TxBody",
                            value: P
                        }),
                        B = i.Int53.fromString(k.fee.gas).toNumber(),
                        O = i.Int53.fromString(k.sequence).toNumber(),
                        R = (0, a.makeAuthInfoBytes)([{
                            pubkey: y,
                            sequence: O
                        }], k.fee.amount, B, k.fee.granter, k.fee.payer, h);
                    return m.TxRaw.fromPartial({
                        bodyBytes: _,
                        authInfoBytes: R,
                        signatures: [(0, o.fromBase64)(S.signature)]
                    })
                }
                async signDirect(e, t, r, s, {
                    accountNumber: c,
                    sequence: l,
                    chainId: u
                }, p) {
                    (0, d.assert)((0, a.isOfflineDirectSigner)(this.signer));
                    let g = (await this.signer.getAccounts()).find(t => t.address === e);
                    if (!g) throw Error("Failed to retrieve account from signer");
                    let f = (0, a.encodePubkey)((0, n.encodeSecp256k1Pubkey)(g.pubkey)),
                        y = this.registry.encode({
                            typeUrl: "/cosmos.tx.v1beta1.TxBody",
                            value: {
                                messages: t,
                                memo: s,
                                timeoutHeight: p
                            }
                        }),
                        h = i.Int53.fromString(r.gas).toNumber(),
                        v = (0, a.makeAuthInfoBytes)([{
                            pubkey: f,
                            sequence: l
                        }], r.amount, h, r.granter, r.payer),
                        b = (0, a.makeSignDoc)(y, v, u, c),
                        {
                            signature: S,
                            signed: k
                        } = await this.signer.signDirect(e, b);
                    return m.TxRaw.fromPartial({
                        bodyBytes: k.bodyBytes,
                        authInfoBytes: k.authInfoBytes,
                        signatures: [(0, o.fromBase64)(S.signature)]
                    })
                }
            }
            t.SigningStargateClient = k
        },
        16499: function(e, t, r) {
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: !0
            }), t.StargateClient = t.BroadcastTxError = t.assertIsDeliverTxFailure = t.assertIsDeliverTxSuccess = t.isDeliverTxSuccess = t.isDeliverTxFailure = t.TimeoutError = void 0;
            let n = r(68683),
                o = r(15050),
                i = r(38051),
                a = r(23628),
                s = r(93337),
                d = r(6916),
                c = r(92538),
                l = r(76615),
                u = r(27393),
                p = r(45504),
                m = r(50494);
            class g extends Error {
                constructor(e, t) {
                    super(e), this.txId = t
                }
            }

            function f(e) {
                return !!e.code
            }

            function y(e) {
                return !f(e)
            }
            t.TimeoutError = g, t.isDeliverTxFailure = f, t.isDeliverTxSuccess = y, t.assertIsDeliverTxSuccess = function(e) {
                if (f(e)) throw Error(`Error when broadcasting tx ${e.transactionHash} at height ${e.height}. Code: ${e.code}; Raw log: ${e.rawLog}`)
            }, t.assertIsDeliverTxFailure = function(e) {
                if (y(e)) throw Error(`Transaction ${e.transactionHash} did not fail at height ${e.height}. Code: ${e.code}; Raw log: ${e.rawLog}`)
            };
            class h extends Error {
                constructor(e, t, r) {
                    super(`Broadcasting transaction failed with code ${e} (codespace: ${t}). Log: ${r}`), this.code = e, this.codespace = t, this.log = r
                }
            }
            t.BroadcastTxError = h;
            class v {
                static async connect(e, t = {}) {
                    let r = await (0, a.connectComet)(e);
                    return v.create(r, t)
                }
                static async create(e, t = {}) {
                    return new v(e, t)
                }
                constructor(e, t) {
                    e && (this.cometClient = e, this.queryClient = p.QueryClient.withExtensions(e, u.setupAuthExtension, u.setupBankExtension, u.setupStakingExtension, u.setupTxExtension));
                    let {
                        accountParser: r = c.accountFromAny
                    } = t;
                    this.accountParser = r
                }
                getCometClient() {
                    return this.cometClient
                }
                forceGetCometClient() {
                    if (!this.cometClient) throw Error("Comet client not available. You cannot use online functionality in offline mode.");
                    return this.cometClient
                }
                getQueryClient() {
                    return this.queryClient
                }
                forceGetQueryClient() {
                    if (!this.queryClient) throw Error("Query client not available. You cannot use online functionality in offline mode.");
                    return this.queryClient
                }
                async getChainId() {
                    if (!this.chainId) {
                        let e = (await this.forceGetCometClient().status()).nodeInfo.network;
                        if (!e) throw Error("Chain ID must not be empty");
                        this.chainId = e
                    }
                    return this.chainId
                }
                async getHeight() {
                    return (await this.forceGetCometClient().status()).syncInfo.latestBlockHeight
                }
                async getAccount(e) {
                    try {
                        let t = await this.forceGetQueryClient().auth.account(e);
                        return t ? this.accountParser(t) : null
                    } catch (e) {
                        if (/rpc error: code = NotFound/i.test(e.toString())) return null;
                        throw e
                    }
                }
                async getSequence(e) {
                    let t = await this.getAccount(e);
                    if (!t) throw Error(`Account '${e}' does not exist on chain. Send some tokens there before trying to query sequence.`);
                    return {
                        accountNumber: t.accountNumber,
                        sequence: t.sequence
                    }
                }
                async getBlock(e) {
                    let t = await this.forceGetCometClient().block(e);
                    return {
                        id: (0, o.toHex)(t.blockId.hash).toUpperCase(),
                        header: {
                            version: {
                                block: new i.Uint53(t.block.header.version.block).toString(),
                                app: new i.Uint53(t.block.header.version.app).toString()
                            },
                            height: t.block.header.height,
                            chainId: t.block.header.chainId,
                            time: (0, a.toRfc3339WithNanoseconds)(t.block.header.time)
                        },
                        txs: t.block.txs
                    }
                }
                async getBalance(e, t) {
                    return this.forceGetQueryClient().bank.balance(e, t)
                }
                async getAllBalances(e) {
                    return this.forceGetQueryClient().bank.allBalances(e)
                }
                async getBalanceStaked(e) {
                    let t;
                    let r = [];
                    do {
                        let {
                            delegationResponses: n,
                            pagination: o
                        } = await this.forceGetQueryClient().staking.delegatorDelegations(e, t), i = n || [];
                        r.push(...i), t = o ? .nextKey
                    } while (void 0 !== t && 0 !== t.length);
                    return r.reduce((e, t) => ((0, s.assert)(t.balance), null !== e ? (0, n.addCoins)(e, t.balance) : t.balance), null)
                }
                async getDelegation(e, t) {
                    let r;
                    try {
                        r = (await this.forceGetQueryClient().staking.delegation(e, t)).delegationResponse ? .balance
                    } catch (e) {
                        if (e.toString().includes("key not found"));
                        else throw e
                    }
                    return r || null
                }
                async getTx(e) {
                    return (await this.txsQuery(`tx.hash='${e}'`))[0] ? ? null
                }
                async searchTx(e) {
                    let t;
                    if ("string" == typeof e) t = e;
                    else if ((0, m.isSearchTxQueryArray)(e)) t = e.map(e => "string" == typeof e.value ? `${e.key}='${e.value}'` : `${e.key}=${e.value}`).join(" AND ");
                    else throw Error("Got unsupported query type. See CosmJS 0.31 CHANGELOG for API breaking changes here.");
                    return this.txsQuery(t)
                }
                disconnect() {
                    this.cometClient && this.cometClient.disconnect()
                }
                async broadcastTx(e, t = 6e4, r = 3e3) {
                    let n = !1,
                        o = setTimeout(() => {
                            n = !0
                        }, t),
                        i = async e => {
                            if (n) throw new g(`Transaction with ID ${e} was submitted but was not yet found on the chain. You might want to check later. There was a wait of ${t/1e3} seconds.`, e);
                            await (0, s.sleep)(r);
                            let o = await this.getTx(e);
                            return o ? {
                                code: o.code,
                                height: o.height,
                                txIndex: o.txIndex,
                                events: o.events,
                                rawLog: o.rawLog,
                                transactionHash: e,
                                msgResponses: o.msgResponses,
                                gasUsed: o.gasUsed,
                                gasWanted: o.gasWanted
                            } : i(e)
                        },
                        a = await this.broadcastTxSync(e);
                    return new Promise((e, t) => i(a).then(t => {
                        clearTimeout(o), e(t)
                    }, e => {
                        clearTimeout(o), t(e)
                    }))
                }
                async broadcastTxSync(e) {
                    let t = await this.forceGetCometClient().broadcastTxSync({
                        tx: e
                    });
                    return t.code ? Promise.reject(new h(t.code, t.codespace ? ? "", t.log)) : (0, o.toHex)(t.hash).toUpperCase()
                }
                async txsQuery(e) {
                    return (await this.forceGetCometClient().txSearchAll({
                        query: e
                    })).txs.map(e => {
                        let t = d.TxMsgData.decode(e.result.data ? ? new Uint8Array);
                        return {
                            height: e.height,
                            txIndex: e.index,
                            hash: (0, o.toHex)(e.hash).toUpperCase(),
                            code: e.result.code,
                            events: e.result.events.map(l.fromTendermintEvent),
                            rawLog: e.result.log || "",
                            tx: e.tx,
                            msgResponses: t.msgResponses,
                            gasUsed: e.result.gasUsed,
                            gasWanted: e.result.gasWanted
                        }
                    })
                }
            }
            t.StargateClient = v
        },
        43393: function(e, t, r) {
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: !0
            }), t.pubkeyToAddress = t.pubkeyToRawAddress = t.rawSecp256k1PubkeyToRawAddress = t.rawEd25519PubkeyToRawAddress = void 0;
            let n = r(56257),
                o = r(15050),
                i = r(68906),
                a = r(82949);

            function s(e) {
                if (32 !== e.length) throw Error(`Invalid Ed25519 pubkey length: ${e.length}`);
                return (0, n.sha256)(e).slice(0, 20)
            }

            function d(e) {
                if (33 !== e.length) throw Error(`Invalid Secp256k1 pubkey length (compressed): ${e.length}`);
                return (0, n.ripemd160)((0, n.sha256)(e))
            }

            function c(e) {
                if ((0, a.isSecp256k1Pubkey)(e)) return d((0, o.fromBase64)(e.value));
                if ((0, a.isEd25519Pubkey)(e)) return s((0, o.fromBase64)(e.value));
                if ((0, a.isMultisigThresholdPubkey)(e)) {
                    let t = (0, i.encodeAminoPubkey)(e);
                    return (0, n.sha256)(t).slice(0, 20)
                }
                throw Error("Unsupported public key type")
            }
            t.rawEd25519PubkeyToRawAddress = s, t.rawSecp256k1PubkeyToRawAddress = d, t.pubkeyToRawAddress = c, t.pubkeyToAddress = function(e, t) {
                return (0, o.toBech32)(t, c(e))
            }
        },
        72983: function(e, t, r) {
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: !0
            }), t.addCoins = t.parseCoins = t.coins = t.coin = void 0;
            let n = r(38051);

            function o(e, t) {
                let r;
                if ("number" == typeof e) try {
                    r = new n.Uint53(e).toString()
                } catch (e) {
                    throw Error("Given amount is not a safe integer. Consider using a string instead to overcome the limitations of JS numbers.")
                } else {
                    if (!e.match(/^[0-9]+$/)) throw Error("Invalid unsigned integer string format");
                    r = e.replace(/^0*/, "") || "0"
                }
                return {
                    amount: r,
                    denom: t
                }
            }
            t.coin = o, t.coins = function(e, t) {
                return [o(e, t)]
            }, t.parseCoins = function(e) {
                return e.replace(/\s/g, "").split(",").filter(Boolean).map(e => {
                    let t = e.match(/^([0-9]+)([a-zA-Z]+)/);
                    if (!t) throw Error("Got an invalid coin string");
                    return {
                        amount: t[1].replace(/^0+/, "") || "0",
                        denom: t[2]
                    }
                })
            }, t.addCoins = function(e, t) {
                if (e.denom !== t.denom) throw Error("Trying to add two coins with different denoms");
                return {
                    amount: n.Decimal.fromAtomics(e.amount, 0).plus(n.Decimal.fromAtomics(t.amount, 0)).atomics,
                    denom: e.denom
                }
            }
        },
        68906: function(e, t, r) {
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: !0
            }), t.encodeBech32Pubkey = t.encodeAminoPubkey = t.decodeBech32Pubkey = t.decodeAminoPubkey = t.encodeEd25519Pubkey = t.encodeSecp256k1Pubkey = void 0;
            let n = r(15050),
                o = r(38051),
                i = r(93337),
                a = r(82949);
            t.encodeSecp256k1Pubkey = function(e) {
                if (33 !== e.length || 2 !== e[0] && 3 !== e[0]) throw Error("Public key must be compressed secp256k1, i.e. 33 bytes starting with 0x02 or 0x03");
                return {
                    type: a.pubkeyType.secp256k1,
                    value: (0, n.toBase64)(e)
                }
            }, t.encodeEd25519Pubkey = function(e) {
                if (32 !== e.length) throw Error("Ed25519 public key must be 32 bytes long");
                return {
                    type: a.pubkeyType.ed25519,
                    value: (0, n.toBase64)(e)
                }
            };
            let s = (0, n.fromHex)("eb5ae98721"),
                d = (0, n.fromHex)("1624de6420"),
                c = (0, n.fromHex)("0dfb100520"),
                l = (0, n.fromHex)("22c1f7e2");

            function u(e) {
                if ((0, i.arrayContentStartsWith)(e, s)) {
                    let t = e.slice(s.length);
                    if (33 !== t.length) throw Error("Invalid rest data length. Expected 33 bytes (compressed secp256k1 pubkey).");
                    return {
                        type: a.pubkeyType.secp256k1,
                        value: (0, n.toBase64)(t)
                    }
                }
                if ((0, i.arrayContentStartsWith)(e, d)) {
                    let t = e.slice(d.length);
                    if (32 !== t.length) throw Error("Invalid rest data length. Expected 32 bytes (Ed25519 pubkey).");
                    return {
                        type: a.pubkeyType.ed25519,
                        value: (0, n.toBase64)(t)
                    }
                }
                if ((0, i.arrayContentStartsWith)(e, c)) {
                    let t = e.slice(c.length);
                    if (32 !== t.length) throw Error("Invalid rest data length. Expected 32 bytes (Sr25519 pubkey).");
                    return {
                        type: a.pubkeyType.sr25519,
                        value: (0, n.toBase64)(t)
                    }
                }
                if ((0, i.arrayContentStartsWith)(e, l)) return function(e) {
                    let t = Array.from(e),
                        r = t.splice(0, l.length);
                    if (!(0, i.arrayContentStartsWith)(r, l)) throw Error("Invalid multisig prefix.");
                    if (8 != t.shift()) throw Error("Invalid multisig data. Expecting 0x08 prefix before threshold.");
                    let [n, o] = p(t);
                    t.splice(0, o);
                    let s = [];
                    for (; t.length > 0;) {
                        if (18 != t.shift()) throw Error("Invalid multisig data. Expecting 0x12 prefix before participant pubkey length.");
                        let [e, r] = p(t);
                        if (t.splice(0, r), t.length < e) throw Error("Invalid multisig data length.");
                        let n = t.splice(0, e),
                            o = u(Uint8Array.from(n));
                        s.push(o)
                    }
                    return {
                        type: a.pubkeyType.multisigThreshold,
                        value: {
                            threshold: n.toString(),
                            pubkeys: s
                        }
                    }
                }(e);
                throw Error("Unsupported public key type. Amino data starts with: " + (0, n.toHex)(e.slice(0, 5)))
            }

            function p(e) {
                if (e.length < 1) throw Error("Can't decode varint. EOF");
                if (e[0] > 127) throw Error("Decoding numbers > 127 is not supported here. Please tell those lazy CosmJS maintainers to port the binary.Varint implementation from the Go standard library and write some tests.");
                return [e[0], 1]
            }

            function m(e) {
                let t = o.Uint53.fromString(e.toString()).toNumber();
                if (t > 127) throw Error("Encoding numbers > 127 is not supported here. Please tell those lazy CosmJS maintainers to port the binary.PutUvarint implementation from the Go standard library and write some tests.");
                return [t]
            }

            function g(e) {
                if ((0, a.isMultisigThresholdPubkey)(e)) {
                    let t = Array.from(l);
                    for (let r of (t.push(8), t.push(...m(e.value.threshold)), e.value.pubkeys.map(e => g(e)))) t.push(18), t.push(...m(r.length)), t.push(...r);
                    return new Uint8Array(t)
                }
                if ((0, a.isEd25519Pubkey)(e)) return new Uint8Array([...d, ...(0, n.fromBase64)(e.value)]);
                if ((0, a.isSecp256k1Pubkey)(e)) return new Uint8Array([...s, ...(0, n.fromBase64)(e.value)]);
                throw Error("Unsupported pubkey type")
            }
            t.decodeAminoPubkey = u, t.decodeBech32Pubkey = function(e) {
                let {
                    data: t
                } = (0, n.fromBech32)(e);
                return u(t)
            }, t.encodeAminoPubkey = g, t.encodeBech32Pubkey = function(e, t) {
                return (0, n.toBech32)(t, g(e))
            }
        },
        68683: function(e, t, r) {
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: !0
            }), t.executeKdf = t.makeStdTx = t.isStdTx = t.serializeSignDoc = t.makeSignDoc = t.encodeSecp256k1Signature = t.decodeSignature = t.Secp256k1Wallet = t.Secp256k1HdWallet = t.extractKdfConfiguration = t.pubkeyType = t.isSinglePubkey = t.isSecp256k1Pubkey = t.isMultisigThresholdPubkey = t.isEd25519Pubkey = t.makeCosmoshubPath = t.omitDefault = t.createMultisigThresholdPubkey = t.encodeSecp256k1Pubkey = t.encodeEd25519Pubkey = t.encodeBech32Pubkey = t.encodeAminoPubkey = t.decodeBech32Pubkey = t.decodeAminoPubkey = t.parseCoins = t.coins = t.coin = t.addCoins = t.rawSecp256k1PubkeyToRawAddress = t.rawEd25519PubkeyToRawAddress = t.pubkeyToRawAddress = t.pubkeyToAddress = void 0;
            var n = r(43393);
            Object.defineProperty(t, "pubkeyToAddress", {
                enumerable: !0,
                get: function() {
                    return n.pubkeyToAddress
                }
            }), Object.defineProperty(t, "pubkeyToRawAddress", {
                enumerable: !0,
                get: function() {
                    return n.pubkeyToRawAddress
                }
            }), Object.defineProperty(t, "rawEd25519PubkeyToRawAddress", {
                enumerable: !0,
                get: function() {
                    return n.rawEd25519PubkeyToRawAddress
                }
            }), Object.defineProperty(t, "rawSecp256k1PubkeyToRawAddress", {
                enumerable: !0,
                get: function() {
                    return n.rawSecp256k1PubkeyToRawAddress
                }
            });
            var o = r(72983);
            Object.defineProperty(t, "addCoins", {
                enumerable: !0,
                get: function() {
                    return o.addCoins
                }
            }), Object.defineProperty(t, "coin", {
                enumerable: !0,
                get: function() {
                    return o.coin
                }
            }), Object.defineProperty(t, "coins", {
                enumerable: !0,
                get: function() {
                    return o.coins
                }
            }), Object.defineProperty(t, "parseCoins", {
                enumerable: !0,
                get: function() {
                    return o.parseCoins
                }
            });
            var i = r(68906);
            Object.defineProperty(t, "decodeAminoPubkey", {
                enumerable: !0,
                get: function() {
                    return i.decodeAminoPubkey
                }
            }), Object.defineProperty(t, "decodeBech32Pubkey", {
                enumerable: !0,
                get: function() {
                    return i.decodeBech32Pubkey
                }
            }), Object.defineProperty(t, "encodeAminoPubkey", {
                enumerable: !0,
                get: function() {
                    return i.encodeAminoPubkey
                }
            }), Object.defineProperty(t, "encodeBech32Pubkey", {
                enumerable: !0,
                get: function() {
                    return i.encodeBech32Pubkey
                }
            }), Object.defineProperty(t, "encodeEd25519Pubkey", {
                enumerable: !0,
                get: function() {
                    return i.encodeEd25519Pubkey
                }
            }), Object.defineProperty(t, "encodeSecp256k1Pubkey", {
                enumerable: !0,
                get: function() {
                    return i.encodeSecp256k1Pubkey
                }
            });
            var a = r(24108);
            Object.defineProperty(t, "createMultisigThresholdPubkey", {
                enumerable: !0,
                get: function() {
                    return a.createMultisigThresholdPubkey
                }
            });
            var s = r(92017);
            Object.defineProperty(t, "omitDefault", {
                enumerable: !0,
                get: function() {
                    return s.omitDefault
                }
            });
            var d = r(84210);
            Object.defineProperty(t, "makeCosmoshubPath", {
                enumerable: !0,
                get: function() {
                    return d.makeCosmoshubPath
                }
            });
            var c = r(82949);
            Object.defineProperty(t, "isEd25519Pubkey", {
                enumerable: !0,
                get: function() {
                    return c.isEd25519Pubkey
                }
            }), Object.defineProperty(t, "isMultisigThresholdPubkey", {
                enumerable: !0,
                get: function() {
                    return c.isMultisigThresholdPubkey
                }
            }), Object.defineProperty(t, "isSecp256k1Pubkey", {
                enumerable: !0,
                get: function() {
                    return c.isSecp256k1Pubkey
                }
            }), Object.defineProperty(t, "isSinglePubkey", {
                enumerable: !0,
                get: function() {
                    return c.isSinglePubkey
                }
            }), Object.defineProperty(t, "pubkeyType", {
                enumerable: !0,
                get: function() {
                    return c.pubkeyType
                }
            });
            var l = r(12861);
            Object.defineProperty(t, "extractKdfConfiguration", {
                enumerable: !0,
                get: function() {
                    return l.extractKdfConfiguration
                }
            }), Object.defineProperty(t, "Secp256k1HdWallet", {
                enumerable: !0,
                get: function() {
                    return l.Secp256k1HdWallet
                }
            });
            var u = r(22821);
            Object.defineProperty(t, "Secp256k1Wallet", {
                enumerable: !0,
                get: function() {
                    return u.Secp256k1Wallet
                }
            });
            var p = r(67992);
            Object.defineProperty(t, "decodeSignature", {
                enumerable: !0,
                get: function() {
                    return p.decodeSignature
                }
            }), Object.defineProperty(t, "encodeSecp256k1Signature", {
                enumerable: !0,
                get: function() {
                    return p.encodeSecp256k1Signature
                }
            });
            var m = r(58610);
            Object.defineProperty(t, "makeSignDoc", {
                enumerable: !0,
                get: function() {
                    return m.makeSignDoc
                }
            }), Object.defineProperty(t, "serializeSignDoc", {
                enumerable: !0,
                get: function() {
                    return m.serializeSignDoc
                }
            });
            var g = r(2559);
            Object.defineProperty(t, "isStdTx", {
                enumerable: !0,
                get: function() {
                    return g.isStdTx
                }
            }), Object.defineProperty(t, "makeStdTx", {
                enumerable: !0,
                get: function() {
                    return g.makeStdTx
                }
            });
            var f = r(63079);
            Object.defineProperty(t, "executeKdf", {
                enumerable: !0,
                get: function() {
                    return f.executeKdf
                }
            })
        },
        24108: function(e, t, r) {
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: !0
            }), t.createMultisigThresholdPubkey = t.compareArrays = void 0;
            let n = r(15050),
                o = r(38051),
                i = r(43393);

            function a(e, t) {
                let r = (0, n.toHex)(e),
                    o = (0, n.toHex)(t);
                return r === o ? 0 : r < o ? -1 : 1
            }
            t.compareArrays = a, t.createMultisigThresholdPubkey = function(e, t, r = !1) {
                let n = new o.Uint53(t);
                if (n.toNumber() > e.length) throw Error(`Threshold k = ${n.toNumber()} exceeds number of keys n = ${e.length}`);
                let s = r ? e : Array.from(e).sort((e, t) => a((0, i.pubkeyToRawAddress)(e), (0, i.pubkeyToRawAddress)(t)));
                return {
                    type: "tendermint/PubKeyMultisigThreshold",
                    value: {
                        threshold: n.toString(),
                        pubkeys: s
                    }
                }
            }
        },
        92017: function(e, t) {
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: !0
            }), t.omitDefault = void 0, t.omitDefault = function(e) {
                switch (typeof e) {
                    case "string":
                        return "" === e ? void 0 : e;
                    case "number":
                        return 0 === e ? void 0 : e;
                    case "bigint":
                        return e === BigInt(0) ? void 0 : e;
                    case "boolean":
                        return e || void 0;
                    default:
                        throw Error(`Got unsupported type '${typeof e}'`)
                }
            }
        },
        84210: function(e, t, r) {
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: !0
            }), t.makeCosmoshubPath = void 0;
            let n = r(56257);
            t.makeCosmoshubPath = function(e) {
                return [n.Slip10RawIndex.hardened(44), n.Slip10RawIndex.hardened(118), n.Slip10RawIndex.hardened(0), n.Slip10RawIndex.normal(0), n.Slip10RawIndex.normal(e)]
            }
        },
        82949: function(e, t) {
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: !0
            }), t.isMultisigThresholdPubkey = t.isSinglePubkey = t.pubkeyType = t.isSecp256k1Pubkey = t.isEd25519Pubkey = void 0, t.isEd25519Pubkey = function(e) {
                return "tendermint/PubKeyEd25519" === e.type
            }, t.isSecp256k1Pubkey = function(e) {
                return "tendermint/PubKeySecp256k1" === e.type
            }, t.pubkeyType = {
                secp256k1: "tendermint/PubKeySecp256k1",
                ed25519: "tendermint/PubKeyEd25519",
                sr25519: "tendermint/PubKeySr25519",
                multisigThreshold: "tendermint/PubKeyMultisigThreshold"
            }, t.isSinglePubkey = function(e) {
                return [t.pubkeyType.ed25519, t.pubkeyType.secp256k1, t.pubkeyType.sr25519].includes(e.type)
            }, t.isMultisigThresholdPubkey = function(e) {
                return "tendermint/PubKeyMultisigThreshold" === e.type
            }
        },
        12861: function(e, t, r) {
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: !0
            }), t.Secp256k1HdWallet = t.extractKdfConfiguration = void 0;
            let n = r(56257),
                o = r(15050),
                i = r(93337),
                a = r(43393),
                s = r(84210),
                d = r(67992),
                c = r(58610),
                l = r(63079),
                u = "secp256k1wallet-v1",
                p = {
                    algorithm: "argon2id",
                    params: {
                        outputLength: 32,
                        opsLimit: 24,
                        memLimitKib: 12288
                    }
                };
            t.extractKdfConfiguration = function(e) {
                let t = JSON.parse(e);
                if (!(0, i.isNonNullObject)(t)) throw Error("Root document is not an object.");
                if (t.type === u) return t.kdf;
                throw Error("Unsupported serialization type")
            };
            let m = {
                bip39Password: "",
                hdPaths: [(0, s.makeCosmoshubPath)(0)],
                prefix: "cosmos"
            };
            class g {
                static async fromMnemonic(e, t = {}) {
                    let r = new n.EnglishMnemonic(e),
                        o = await n.Bip39.mnemonicToSeed(r, t.bip39Password);
                    return new g(r, { ...t,
                        seed: o
                    })
                }
                static async generate(e = 12, t = {}) {
                    let r = n.Random.getBytes(4 * Math.floor(11 * e / 33)),
                        o = n.Bip39.encode(r);
                    return g.fromMnemonic(o.toString(), t)
                }
                static async deserialize(e, t) {
                    let r = JSON.parse(e);
                    if (!(0, i.isNonNullObject)(r)) throw Error("Root document is not an object.");
                    if (r.type === u) return g.deserializeTypeV1(e, t);
                    throw Error("Unsupported serialization type")
                }
                static async deserializeWithEncryptionKey(e, t) {
                    let r = JSON.parse(e);
                    if (!(0, i.isNonNullObject)(r)) throw Error("Root document is not an object.");
                    if (r.type === u) {
                        let e = await (0, l.decrypt)((0, o.fromBase64)(r.data), t, r.encryption),
                            {
                                mnemonic: a,
                                accounts: s
                            } = JSON.parse((0, o.fromUtf8)(e));
                        if ((0, i.assert)("string" == typeof a), !Array.isArray(s)) throw Error("Property 'accounts' is not an array");
                        if (!s.every(e => !!(0, i.isNonNullObject)(e) && "string" == typeof e.hdPath && "string" == typeof e.prefix)) throw Error("Account is not in the correct format.");
                        let d = s[0].prefix;
                        if (!s.every(({
                                prefix: e
                            }) => e === d)) throw Error("Accounts do not all have the same prefix");
                        let c = s.map(({
                            hdPath: e
                        }) => (0, n.stringToPath)(e));
                        return g.fromMnemonic(a, {
                            hdPaths: c,
                            prefix: d
                        })
                    }
                    throw Error("Unsupported serialization type")
                }
                static async deserializeTypeV1(e, t) {
                    let r = JSON.parse(e);
                    if (!(0, i.isNonNullObject)(r)) throw Error("Root document is not an object.");
                    let n = await (0, l.executeKdf)(t, r.kdf);
                    return g.deserializeWithEncryptionKey(e, n)
                }
                constructor(e, t) {
                    let r = t.hdPaths ? ? m.hdPaths,
                        n = t.prefix ? ? m.prefix;
                    this.secret = e, this.seed = t.seed, this.accounts = r.map(e => ({
                        hdPath: e,
                        prefix: n
                    }))
                }
                get mnemonic() {
                    return this.secret.toString()
                }
                async getAccounts() {
                    return (await this.getAccountsWithPrivkeys()).map(({
                        algo: e,
                        pubkey: t,
                        address: r
                    }) => ({
                        algo: e,
                        pubkey: t,
                        address: r
                    }))
                }
                async signAmino(e, t) {
                    let r = (await this.getAccountsWithPrivkeys()).find(({
                        address: t
                    }) => t === e);
                    if (void 0 === r) throw Error(`Address ${e} not found in wallet`);
                    let {
                        privkey: o,
                        pubkey: i
                    } = r, a = (0, n.sha256)((0, c.serializeSignDoc)(t)), s = await n.Secp256k1.createSignature(a, o), l = new Uint8Array([...s.r(32), ...s.s(32)]);
                    return {
                        signed: t,
                        signature: (0, d.encodeSecp256k1Signature)(i, l)
                    }
                }
                async serialize(e) {
                    let t = await (0, l.executeKdf)(e, p);
                    return this.serializeWithEncryptionKey(t, p)
                }
                async serializeWithEncryptionKey(e, t) {
                    let r = {
                            mnemonic: this.mnemonic,
                            accounts: this.accounts.map(({
                                hdPath: e,
                                prefix: t
                            }) => ({
                                hdPath: (0, n.pathToString)(e),
                                prefix: t
                            }))
                        },
                        i = (0, o.toUtf8)(JSON.stringify(r)),
                        a = {
                            algorithm: l.supportedAlgorithms.xchacha20poly1305Ietf
                        },
                        s = await (0, l.encrypt)(i, e, a);
                    return JSON.stringify({
                        type: u,
                        kdf: t,
                        encryption: a,
                        data: (0, o.toBase64)(s)
                    })
                }
                async getKeyPair(e) {
                    let {
                        privkey: t
                    } = n.Slip10.derivePath(n.Slip10Curve.Secp256k1, this.seed, e), {
                        pubkey: r
                    } = await n.Secp256k1.makeKeypair(t);
                    return {
                        privkey: t,
                        pubkey: n.Secp256k1.compressPubkey(r)
                    }
                }
                async getAccountsWithPrivkeys() {
                    return Promise.all(this.accounts.map(async ({
                        hdPath: e,
                        prefix: t
                    }) => {
                        let {
                            privkey: r,
                            pubkey: n
                        } = await this.getKeyPair(e), i = (0, o.toBech32)(t, (0, a.rawSecp256k1PubkeyToRawAddress)(n));
                        return {
                            algo: "secp256k1",
                            privkey: r,
                            pubkey: n,
                            address: i
                        }
                    }))
                }
            }
            t.Secp256k1HdWallet = g
        },
        22821: function(e, t, r) {
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: !0
            }), t.Secp256k1Wallet = void 0;
            let n = r(56257),
                o = r(15050),
                i = r(43393),
                a = r(67992),
                s = r(58610);
            class d {
                static async fromKey(e, t = "cosmos") {
                    let r = (await n.Secp256k1.makeKeypair(e)).pubkey;
                    return new d(e, n.Secp256k1.compressPubkey(r), t)
                }
                constructor(e, t, r) {
                    this.privkey = e, this.pubkey = t, this.prefix = r
                }
                get address() {
                    return (0, o.toBech32)(this.prefix, (0, i.rawSecp256k1PubkeyToRawAddress)(this.pubkey))
                }
                async getAccounts() {
                    return [{
                        algo: "secp256k1",
                        address: this.address,
                        pubkey: this.pubkey
                    }]
                }
                async signAmino(e, t) {
                    if (e !== this.address) throw Error(`Address ${e} not found in wallet`);
                    let r = new n.Sha256((0, s.serializeSignDoc)(t)).digest(),
                        o = await n.Secp256k1.createSignature(r, this.privkey),
                        i = new Uint8Array([...o.r(32), ...o.s(32)]);
                    return {
                        signed: t,
                        signature: (0, a.encodeSecp256k1Signature)(this.pubkey, i)
                    }
                }
            }
            t.Secp256k1Wallet = d
        },
        67992: function(e, t, r) {
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: !0
            }), t.decodeSignature = t.encodeSecp256k1Signature = void 0;
            let n = r(15050),
                o = r(68906),
                i = r(82949);
            t.encodeSecp256k1Signature = function(e, t) {
                if (64 !== t.length) throw Error("Signature must be 64 bytes long. Cosmos SDK uses a 2x32 byte fixed length encoding for the secp256k1 signature integers r and s.");
                return {
                    pub_key: (0, o.encodeSecp256k1Pubkey)(e),
                    signature: (0, n.toBase64)(t)
                }
            }, t.decodeSignature = function(e) {
                if (e.pub_key.type === i.pubkeyType.secp256k1) return {
                    pubkey: (0, n.fromBase64)(e.pub_key.value),
                    signature: (0, n.fromBase64)(e.signature)
                };
                throw Error("Unsupported pubkey type")
            }
        },
        58610: function(e, t, r) {
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: !0
            }), t.serializeSignDoc = t.escapeCharacters = t.makeSignDoc = t.sortedJsonStringify = void 0;
            let n = r(15050),
                o = r(38051);

            function i(e) {
                return JSON.stringify(function e(t) {
                    if ("object" != typeof t || null === t) return t;
                    if (Array.isArray(t)) return t.map(e);
                    let r = Object.keys(t).sort(),
                        n = {};
                    return r.forEach(r => {
                        n[r] = e(t[r])
                    }), n
                }(e))
            }

            function a(e) {
                return e.replace(/&/g, "\\u0026").replace(/</g, "\\u003c").replace(/>/g, "\\u003e")
            }
            t.sortedJsonStringify = i, t.makeSignDoc = function(e, t, r, n, i, a, s) {
                return {
                    chain_id: r,
                    account_number: o.Uint53.fromString(i.toString()).toString(),
                    sequence: o.Uint53.fromString(a.toString()).toString(),
                    fee: t,
                    msgs: e,
                    memo: n || "",
                    ...s && {
                        timeout_height: s.toString()
                    }
                }
            }, t.escapeCharacters = a, t.serializeSignDoc = function(e) {
                let t = a(i(e));
                return (0, n.toUtf8)(t)
            }
        },
        2559: function(e, t) {
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: !0
            }), t.makeStdTx = t.isStdTx = void 0, t.isStdTx = function(e) {
                let {
                    memo: t,
                    msg: r,
                    fee: n,
                    signatures: o
                } = e;
                return "string" == typeof t && Array.isArray(r) && "object" == typeof n && Array.isArray(o)
            }, t.makeStdTx = function(e, t) {
                return {
                    msg: e.msgs,
                    fee: e.fee,
                    memo: e.memo,
                    signatures: Array.isArray(t) ? t : [t]
                }
            }
        },
        63079: function(e, t, r) {
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: !0
            }), t.decrypt = t.encrypt = t.supportedAlgorithms = t.executeKdf = t.cosmjsSalt = void 0;
            let n = r(56257),
                o = r(15050);
            async function i(e, r) {
                if ("argon2id" === r.algorithm) {
                    let o = r.params;
                    if (!(0, n.isArgon2idOptions)(o)) throw Error("Invalid format of argon2id params");
                    return n.Argon2id.execute(e, t.cosmjsSalt, o)
                }
                throw Error("Unsupported KDF algorithm")
            }
            async function a(e, r, o) {
                if (o.algorithm === t.supportedAlgorithms.xchacha20poly1305Ietf) {
                    let t = n.Random.getBytes(n.xchacha20NonceLength);
                    return new Uint8Array([...t, ...await n.Xchacha20poly1305Ietf.encrypt(e, r, t)])
                }
                throw Error(`Unsupported encryption algorithm: '${o.algorithm}'`)
            }
            async function s(e, r, o) {
                if (o.algorithm === t.supportedAlgorithms.xchacha20poly1305Ietf) {
                    let t = e.slice(0, n.xchacha20NonceLength);
                    return n.Xchacha20poly1305Ietf.decrypt(e.slice(n.xchacha20NonceLength), r, t)
                }
                throw Error(`Unsupported encryption algorithm: '${o.algorithm}'`)
            }
            t.cosmjsSalt = (0, o.toAscii)("The CosmJS salt."), t.executeKdf = i, t.supportedAlgorithms = {
                xchacha20poly1305Ietf: "xchacha20poly1305-ietf"
            }, t.encrypt = a, t.decrypt = s
        },
        55767: function(e, t, r) {
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: !0
            }), t.Bip39 = t.EnglishMnemonic = t.mnemonicToEntropy = t.entropyToMnemonic = void 0;
            let n = r(15050),
                o = r(49705),
                i = r(52275),
                a = ["abandon", "ability", "able", "about", "above", "absent", "absorb", "abstract", "absurd", "abuse", "access", "accident", "account", "accuse", "achieve", "acid", "acoustic", "acquire", "across", "act", "action", "actor", "actress", "actual", "adapt", "add", "addict", "address", "adjust", "admit", "adult", "advance", "advice", "aerobic", "affair", "afford", "afraid", "again", "age", "agent", "agree", "ahead", "aim", "air", "airport", "aisle", "alarm", "album", "alcohol", "alert", "alien", "all", "alley", "allow", "almost", "alone", "alpha", "already", "also", "alter", "always", "amateur", "amazing", "among", "amount", "amused", "analyst", "anchor", "ancient", "anger", "angle", "angry", "animal", "ankle", "announce", "annual", "another", "answer", "antenna", "antique", "anxiety", "any", "apart", "apology", "appear", "apple", "approve", "april", "arch", "arctic", "area", "arena", "argue", "arm", "armed", "armor", "army", "around", "arrange", "arrest", "arrive", "arrow", "art", "artefact", "artist", "artwork", "ask", "aspect", "assault", "asset", "assist", "assume", "asthma", "athlete", "atom", "attack", "attend", "attitude", "attract", "auction", "audit", "august", "aunt", "author", "auto", "autumn", "average", "avocado", "avoid", "awake", "aware", "away", "awesome", "awful", "awkward", "axis", "baby", "bachelor", "bacon", "badge", "bag", "balance", "balcony", "ball", "bamboo", "banana", "banner", "bar", "barely", "bargain", "barrel", "base", "basic", "basket", "battle", "beach", "bean", "beauty", "because", "become", "beef", "before", "begin", "behave", "behind", "believe", "below", "belt", "bench", "benefit", "best", "betray", "better", "between", "beyond", "bicycle", "bid", "bike", "bind", "biology", "bird", "birth", "bitter", "black", "blade", "blame", "blanket", "blast", "bleak", "bless", "blind", "blood", "blossom", "blouse", "blue", "blur", "blush", "board", "boat", "body", "boil", "bomb", "bone", "bonus", "book", "boost", "border", "boring", "borrow", "boss", "bottom", "bounce", "box", "boy", "bracket", "brain", "brand", "brass", "brave", "bread", "breeze", "brick", "bridge", "brief", "bright", "bring", "brisk", "broccoli", "broken", "bronze", "broom", "brother", "brown", "brush", "bubble", "buddy", "budget", "buffalo", "build", "bulb", "bulk", "bullet", "bundle", "bunker", "burden", "burger", "burst", "bus", "business", "busy", "butter", "buyer", "buzz", "cabbage", "cabin", "cable", "cactus", "cage", "cake", "call", "calm", "camera", "camp", "can", "canal", "cancel", "candy", "cannon", "canoe", "canvas", "canyon", "capable", "capital", "captain", "car", "carbon", "card", "cargo", "carpet", "carry", "cart", "case", "cash", "casino", "castle", "casual", "cat", "catalog", "catch", "category", "cattle", "caught", "cause", "caution", "cave", "ceiling", "celery", "cement", "census", "century", "cereal", "certain", "chair", "chalk", "champion", "change", "chaos", "chapter", "charge", "chase", "chat", "cheap", "check", "cheese", "chef", "cherry", "chest", "chicken", "chief", "child", "chimney", "choice", "choose", "chronic", "chuckle", "chunk", "churn", "cigar", "cinnamon", "circle", "citizen", "city", "civil", "claim", "clap", "clarify", "claw", "clay", "clean", "clerk", "clever", "click", "client", "cliff", "climb", "clinic", "clip", "clock", "clog", "close", "cloth", "cloud", "clown", "club", "clump", "cluster", "clutch", "coach", "coast", "coconut", "code", "coffee", "coil", "coin", "collect", "color", "column", "combine", "come", "comfort", "comic", "common", "company", "concert", "conduct", "confirm", "congress", "connect", "consider", "control", "convince", "cook", "cool", "copper", "copy", "coral", "core", "corn", "correct", "cost", "cotton", "couch", "country", "couple", "course", "cousin", "cover", "coyote", "crack", "cradle", "craft", "cram", "crane", "crash", "crater", "crawl", "crazy", "cream", "credit", "creek", "crew", "cricket", "crime", "crisp", "critic", "crop", "cross", "crouch", "crowd", "crucial", "cruel", "cruise", "crumble", "crunch", "crush", "cry", "crystal", "cube", "culture", "cup", "cupboard", "curious", "current", "curtain", "curve", "cushion", "custom", "cute", "cycle", "dad", "damage", "damp", "dance", "danger", "daring", "dash", "daughter", "dawn", "day", "deal", "debate", "debris", "decade", "december", "decide", "decline", "decorate", "decrease", "deer", "defense", "define", "defy", "degree", "delay", "deliver", "demand", "demise", "denial", "dentist", "deny", "depart", "depend", "deposit", "depth", "deputy", "derive", "describe", "desert", "design", "desk", "despair", "destroy", "detail", "detect", "develop", "device", "devote", "diagram", "dial", "diamond", "diary", "dice", "diesel", "diet", "differ", "digital", "dignity", "dilemma", "dinner", "dinosaur", "direct", "dirt", "disagree", "discover", "disease", "dish", "dismiss", "disorder", "display", "distance", "divert", "divide", "divorce", "dizzy", "doctor", "document", "dog", "doll", "dolphin", "domain", "donate", "donkey", "donor", "door", "dose", "double", "dove", "draft", "dragon", "drama", "drastic", "draw", "dream", "dress", "drift", "drill", "drink", "drip", "drive", "drop", "drum", "dry", "duck", "dumb", "dune", "during", "dust", "dutch", "duty", "dwarf", "dynamic", "eager", "eagle", "early", "earn", "earth", "easily", "east", "easy", "echo", "ecology", "economy", "edge", "edit", "educate", "effort", "egg", "eight", "either", "elbow", "elder", "electric", "elegant", "element", "elephant", "elevator", "elite", "else", "embark", "embody", "embrace", "emerge", "emotion", "employ", "empower", "empty", "enable", "enact", "end", "endless", "endorse", "enemy", "energy", "enforce", "engage", "engine", "enhance", "enjoy", "enlist", "enough", "enrich", "enroll", "ensure", "enter", "entire", "entry", "envelope", "episode", "equal", "equip", "era", "erase", "erode", "erosion", "error", "erupt", "escape", "essay", "essence", "estate", "eternal", "ethics", "evidence", "evil", "evoke", "evolve", "exact", "example", "excess", "exchange", "excite", "exclude", "excuse", "execute", "exercise", "exhaust", "exhibit", "exile", "exist", "exit", "exotic", "expand", "expect", "expire", "explain", "expose", "express", "extend", "extra", "eye", "eyebrow", "fabric", "face", "faculty", "fade", "faint", "faith", "fall", "false", "fame", "family", "famous", "fan", "fancy", "fantasy", "farm", "fashion", "fat", "fatal", "father", "fatigue", "fault", "favorite", "feature", "february", "federal", "fee", "feed", "feel", "female", "fence", "festival", "fetch", "fever", "few", "fiber", "fiction", "field", "figure", "file", "film", "filter", "final", "find", "fine", "finger", "finish", "fire", "firm", "first", "fiscal", "fish", "fit", "fitness", "fix", "flag", "flame", "flash", "flat", "flavor", "flee", "flight", "flip", "float", "flock", "floor", "flower", "fluid", "flush", "fly", "foam", "focus", "fog", "foil", "fold", "follow", "food", "foot", "force", "forest", "forget", "fork", "fortune", "forum", "forward", "fossil", "foster", "found", "fox", "fragile", "frame", "frequent", "fresh", "friend", "fringe", "frog", "front", "frost", "frown", "frozen", "fruit", "fuel", "fun", "funny", "furnace", "fury", "future", "gadget", "gain", "galaxy", "gallery", "game", "gap", "garage", "garbage", "garden", "garlic", "garment", "gas", "gasp", "gate", "gather", "gauge", "gaze", "general", "genius", "genre", "gentle", "genuine", "gesture", "ghost", "giant", "gift", "giggle", "ginger", "giraffe", "girl", "give", "glad", "glance", "glare", "glass", "glide", "glimpse", "globe", "gloom", "glory", "glove", "glow", "glue", "goat", "goddess", "gold", "good", "goose", "gorilla", "gospel", "gossip", "govern", "gown", "grab", "grace", "grain", "grant", "grape", "grass", "gravity", "great", "green", "grid", "grief", "grit", "grocery", "group", "grow", "grunt", "guard", "guess", "guide", "guilt", "guitar", "gun", "gym", "habit", "hair", "half", "hammer", "hamster", "hand", "happy", "harbor", "hard", "harsh", "harvest", "hat", "have", "hawk", "hazard", "head", "health", "heart", "heavy", "hedgehog", "height", "hello", "helmet", "help", "hen", "hero", "hidden", "high", "hill", "hint", "hip", "hire", "history", "hobby", "hockey", "hold", "hole", "holiday", "hollow", "home", "honey", "hood", "hope", "horn", "horror", "horse", "hospital", "host", "hotel", "hour", "hover", "hub", "huge", "human", "humble", "humor", "hundred", "hungry", "hunt", "hurdle", "hurry", "hurt", "husband", "hybrid", "ice", "icon", "idea", "identify", "idle", "ignore", "ill", "illegal", "illness", "image", "imitate", "immense", "immune", "impact", "impose", "improve", "impulse", "inch", "include", "income", "increase", "index", "indicate", "indoor", "industry", "infant", "inflict", "inform", "inhale", "inherit", "initial", "inject", "injury", "inmate", "inner", "innocent", "input", "inquiry", "insane", "insect", "inside", "inspire", "install", "intact", "interest", "into", "invest", "invite", "involve", "iron", "island", "isolate", "issue", "item", "ivory", "jacket", "jaguar", "jar", "jazz", "jealous", "jeans", "jelly", "jewel", "job", "join", "joke", "journey", "joy", "judge", "juice", "jump", "jungle", "junior", "junk", "just", "kangaroo", "keen", "keep", "ketchup", "key", "kick", "kid", "kidney", "kind", "kingdom", "kiss", "kit", "kitchen", "kite", "kitten", "kiwi", "knee", "knife", "knock", "know", "lab", "label", "labor", "ladder", "lady", "lake", "lamp", "language", "laptop", "large", "later", "latin", "laugh", "laundry", "lava", "law", "lawn", "lawsuit", "layer", "lazy", "leader", "leaf", "learn", "leave", "lecture", "left", "leg", "legal", "legend", "leisure", "lemon", "lend", "length", "lens", "leopard", "lesson", "letter", "level", "liar", "liberty", "library", "license", "life", "lift", "light", "like", "limb", "limit", "link", "lion", "liquid", "list", "little", "live", "lizard", "load", "loan", "lobster", "local", "lock", "logic", "lonely", "long", "loop", "lottery", "loud", "lounge", "love", "loyal", "lucky", "luggage", "lumber", "lunar", "lunch", "luxury", "lyrics", "machine", "mad", "magic", "magnet", "maid", "mail", "main", "major", "make", "mammal", "man", "manage", "mandate", "mango", "mansion", "manual", "maple", "marble", "march", "margin", "marine", "market", "marriage", "mask", "mass", "master", "match", "material", "math", "matrix", "matter", "maximum", "maze", "meadow", "mean", "measure", "meat", "mechanic", "medal", "media", "melody", "melt", "member", "memory", "mention", "menu", "mercy", "merge", "merit", "merry", "mesh", "message", "metal", "method", "middle", "midnight", "milk", "million", "mimic", "mind", "minimum", "minor", "minute", "miracle", "mirror", "misery", "miss", "mistake", "mix", "mixed", "mixture", "mobile", "model", "modify", "mom", "moment", "monitor", "monkey", "monster", "month", "moon", "moral", "more", "morning", "mosquito", "mother", "motion", "motor", "mountain", "mouse", "move", "movie", "much", "muffin", "mule", "multiply", "muscle", "museum", "mushroom", "music", "must", "mutual", "myself", "mystery", "myth", "naive", "name", "napkin", "narrow", "nasty", "nation", "nature", "near", "neck", "need", "negative", "neglect", "neither", "nephew", "nerve", "nest", "net", "network", "neutral", "never", "news", "next", "nice", "night", "noble", "noise", "nominee", "noodle", "normal", "north", "nose", "notable", "note", "nothing", "notice", "novel", "now", "nuclear", "number", "nurse", "nut", "oak", "obey", "object", "oblige", "obscure", "observe", "obtain", "obvious", "occur", "ocean", "october", "odor", "off", "offer", "office", "often", "oil", "okay", "old", "olive", "olympic", "omit", "once", "one", "onion", "online", "only", "open", "opera", "opinion", "oppose", "option", "orange", "orbit", "orchard", "order", "ordinary", "organ", "orient", "original", "orphan", "ostrich", "other", "outdoor", "outer", "output", "outside", "oval", "oven", "over", "own", "owner", "oxygen", "oyster", "ozone", "pact", "paddle", "page", "pair", "palace", "palm", "panda", "panel", "panic", "panther", "paper", "parade", "parent", "park", "parrot", "party", "pass", "patch", "path", "patient", "patrol", "pattern", "pause", "pave", "payment", "peace", "peanut", "pear", "peasant", "pelican", "pen", "penalty", "pencil", "people", "pepper", "perfect", "permit", "person", "pet", "phone", "photo", "phrase", "physical", "piano", "picnic", "picture", "piece", "pig", "pigeon", "pill", "pilot", "pink", "pioneer", "pipe", "pistol", "pitch", "pizza", "place", "planet", "plastic", "plate", "play", "please", "pledge", "pluck", "plug", "plunge", "poem", "poet", "point", "polar", "pole", "police", "pond", "pony", "pool", "popular", "portion", "position", "possible", "post", "potato", "pottery", "poverty", "powder", "power", "practice", "praise", "predict", "prefer", "prepare", "present", "pretty", "prevent", "price", "pride", "primary", "print", "priority", "prison", "private", "prize", "problem", "process", "produce", "profit", "program", "project", "promote", "proof", "property", "prosper", "protect", "proud", "provide", "public", "pudding", "pull", "pulp", "pulse", "pumpkin", "punch", "pupil", "puppy", "purchase", "purity", "purpose", "purse", "push", "put", "puzzle", "pyramid", "quality", "quantum", "quarter", "question", "quick", "quit", "quiz", "quote", "rabbit", "raccoon", "race", "rack", "radar", "radio", "rail", "rain", "raise", "rally", "ramp", "ranch", "random", "range", "rapid", "rare", "rate", "rather", "raven", "raw", "razor", "ready", "real", "reason", "rebel", "rebuild", "recall", "receive", "recipe", "record", "recycle", "reduce", "reflect", "reform", "refuse", "region", "regret", "regular", "reject", "relax", "release", "relief", "rely", "remain", "remember", "remind", "remove", "render", "renew", "rent", "reopen", "repair", "repeat", "replace", "report", "require", "rescue", "resemble", "resist", "resource", "response", "result", "retire", "retreat", "return", "reunion", "reveal", "review", "reward", "rhythm", "rib", "ribbon", "rice", "rich", "ride", "ridge", "rifle", "right", "rigid", "ring", "riot", "ripple", "risk", "ritual", "rival", "river", "road", "roast", "robot", "robust", "rocket", "romance", "roof", "rookie", "room", "rose", "rotate", "rough", "round", "route", "royal", "rubber", "rude", "rug", "rule", "run", "runway", "rural", "sad", "saddle", "sadness", "safe", "sail", "salad", "salmon", "salon", "salt", "salute", "same", "sample", "sand", "satisfy", "satoshi", "sauce", "sausage", "save", "say", "scale", "scan", "scare", "scatter", "scene", "scheme", "school", "science", "scissors", "scorpion", "scout", "scrap", "screen", "script", "scrub", "sea", "search", "season", "seat", "second", "secret", "section", "security", "seed", "seek", "segment", "select", "sell", "seminar", "senior", "sense", "sentence", "series", "service", "session", "settle", "setup", "seven", "shadow", "shaft", "shallow", "share", "shed", "shell", "sheriff", "shield", "shift", "shine", "ship", "shiver", "shock", "shoe", "shoot", "shop", "short", "shoulder", "shove", "shrimp", "shrug", "shuffle", "shy", "sibling", "sick", "side", "siege", "sight", "sign", "silent", "silk", "silly", "silver", "similar", "simple", "since", "sing", "siren", "sister", "situate", "six", "size", "skate", "sketch", "ski", "skill", "skin", "skirt", "skull", "slab", "slam", "sleep", "slender", "slice", "slide", "slight", "slim", "slogan", "slot", "slow", "slush", "small", "smart", "smile", "smoke", "smooth", "snack", "snake", "snap", "sniff", "snow", "soap", "soccer", "social", "sock", "soda", "soft", "solar", "soldier", "solid", "solution", "solve", "someone", "song", "soon", "sorry", "sort", "soul", "sound", "soup", "source", "south", "space", "spare", "spatial", "spawn", "speak", "special", "speed", "spell", "spend", "sphere", "spice", "spider", "spike", "spin", "spirit", "split", "spoil", "sponsor", "spoon", "sport", "spot", "spray", "spread", "spring", "spy", "square", "squeeze", "squirrel", "stable", "stadium", "staff", "stage", "stairs", "stamp", "stand", "start", "state", "stay", "steak", "steel", "stem", "step", "stereo", "stick", "still", "sting", "stock", "stomach", "stone", "stool", "story", "stove", "strategy", "street", "strike", "strong", "struggle", "student", "stuff", "stumble", "style", "subject", "submit", "subway", "success", "such", "sudden", "suffer", "sugar", "suggest", "suit", "summer", "sun", "sunny", "sunset", "super", "supply", "supreme", "sure", "surface", "surge", "surprise", "surround", "survey", "suspect", "sustain", "swallow", "swamp", "swap", "swarm", "swear", "sweet", "swift", "swim", "swing", "switch", "sword", "symbol", "symptom", "syrup", "system", "table", "tackle", "tag", "tail", "talent", "talk", "tank", "tape", "target", "task", "taste", "tattoo", "taxi", "teach", "team", "tell", "ten", "tenant", "tennis", "tent", "term", "test", "text", "thank", "that", "theme", "then", "theory", "there", "they", "thing", "this", "thought", "three", "thrive", "throw", "thumb", "thunder", "ticket", "tide", "tiger", "tilt", "timber", "time", "tiny", "tip", "tired", "tissue", "title", "toast", "tobacco", "today", "toddler", "toe", "together", "toilet", "token", "tomato", "tomorrow", "tone", "tongue", "tonight", "tool", "tooth", "top", "topic", "topple", "torch", "tornado", "tortoise", "toss", "total", "tourist", "toward", "tower", "town", "toy", "track", "trade", "traffic", "tragic", "train", "transfer", "trap", "trash", "travel", "tray", "treat", "tree", "trend", "trial", "tribe", "trick", "trigger", "trim", "trip", "trophy", "trouble", "truck", "true", "truly", "trumpet", "trust", "truth", "try", "tube", "tuition", "tumble", "tuna", "tunnel", "turkey", "turn", "turtle", "twelve", "twenty", "twice", "twin", "twist", "two", "type", "typical", "ugly", "umbrella", "unable", "unaware", "uncle", "uncover", "under", "undo", "unfair", "unfold", "unhappy", "uniform", "unique", "unit", "universe", "unknown", "unlock", "until", "unusual", "unveil", "update", "upgrade", "uphold", "upon", "upper", "upset", "urban", "urge", "usage", "use", "used", "useful", "useless", "usual", "utility", "vacant", "vacuum", "vague", "valid", "valley", "valve", "van", "vanish", "vapor", "various", "vast", "vault", "vehicle", "velvet", "vendor", "venture", "venue", "verb", "verify", "version", "very", "vessel", "veteran", "viable", "vibrant", "vicious", "victory", "video", "view", "village", "vintage", "violin", "virtual", "virus", "visa", "visit", "visual", "vital", "vivid", "vocal", "voice", "void", "volcano", "volume", "vote", "voyage", "wage", "wagon", "wait", "walk", "wall", "walnut", "want", "warfare", "warm", "warrior", "wash", "wasp", "waste", "water", "wave", "way", "wealth", "weapon", "wear", "weasel", "weather", "web", "wedding", "weekend", "weird", "welcome", "west", "wet", "whale", "what", "wheat", "wheel", "when", "where", "whip", "whisper", "wide", "width", "wife", "wild", "will", "win", "window", "wine", "wing", "wink", "winner", "winter", "wire", "wisdom", "wise", "wish", "witness", "wolf", "woman", "wonder", "wood", "wool", "word", "work", "world", "worry", "worth", "wrap", "wreck", "wrestle", "wrist", "write", "wrong", "yard", "year", "yellow", "you", "young", "youth", "zebra", "zero", "zone", "zoo"];

            function s(e) {
                return Array.from(e).map(e => e.toString(2).padStart(8, "0")).join("")
            }

            function d(e) {
                let t = 8 * e.length;
                return s((0, i.sha256)(e)).slice(0, t / 32)
            }

            function c(e) {
                return parseInt(e, 2)
            }
            let l = [16, 20, 24, 28, 32],
                u = [12, 15, 18, 21, 24];

            function p(e) {
                if (-1 === l.indexOf(e.length)) throw Error("invalid input length");
                return (s(e) + d(e)).match(/(.{11})/g).map(e => a[c(e)]).join(" ")
            }

            function m(e) {
                return e.normalize("NFKD")
            }

            function g(e) {
                let t = m(e).split(" ");
                if (!u.includes(t.length)) throw Error("Invalid number of words");
                let r = t.map(e => {
                        let t = a.indexOf(e);
                        if (-1 === t) throw Error("Found word that is not in the wordlist");
                        return t.toString(2).padStart(11, "0")
                    }).join(""),
                    n = 32 * Math.floor(r.length / 33),
                    o = r.slice(0, n),
                    i = r.slice(n),
                    s = o.match(/(.{1,8})/g).map(c);
                if (s.length < 16 || s.length > 32 || s.length % 4 != 0) throw Error("Invalid entropy");
                let l = Uint8Array.from(s);
                if (d(l) !== i) throw Error("Invalid mnemonic checksum");
                return l
            }
            t.entropyToMnemonic = p, t.mnemonicToEntropy = g;
            class f {
                constructor(e) {
                    if (!f.mnemonicMatcher.test(e)) throw Error("Invalid mnemonic format");
                    let t = e.split(" "),
                        r = [12, 15, 18, 21, 24];
                    if (-1 === r.indexOf(t.length)) throw Error(`Invalid word count in mnemonic (allowed: ${r} got: ${t.length})`);
                    for (let e of t)
                        if (-1 === f.wordlist.indexOf(e)) throw Error("Mnemonic contains invalid word");
                    g(e), this.data = e
                }
                toString() {
                    return this.data
                }
            }
            t.EnglishMnemonic = f, f.wordlist = a, f.mnemonicMatcher = /^[a-z]+( [a-z]+)*$/;
            class y {
                static encode(e) {
                    return new f(p(e))
                }
                static decode(e) {
                    return g(e.toString())
                }
                static async mnemonicToSeed(e, t) {
                    let r = (0, n.toUtf8)(m(e.toString())),
                        i = "mnemonic" + (t ? m(t) : ""),
                        a = (0, n.toUtf8)(i);
                    return (0, o.pbkdf2Sha512)(r, a, 2048, 64)
                }
            }
            t.Bip39 = y
        },
        81435: function(e, t) {
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: !0
            }), t.Hmac = void 0;
            class r {
                constructor(e, t) {
                    let r = new e().blockSize;
                    this.hash = t => new e().update(t).digest();
                    let n = t;
                    if (n.length > r && (n = this.hash(n)), n.length < r) {
                        let e = new Uint8Array(r - n.length);
                        n = new Uint8Array([...n, ...e])
                    }
                    this.oKeyPad = n.map(e => 92 ^ e), this.iKeyPad = n.map(e => 54 ^ e), this.messageHasher = new e, this.blockSize = r, this.update(this.iKeyPad)
                }
                update(e) {
                    return this.messageHasher.update(e), this
                }
                digest() {
                    let e = this.messageHasher.digest();
                    return this.hash(new Uint8Array([...this.oKeyPad, ...e]))
                }
            }
            t.Hmac = r
        },
        56257: function(e, t, r) {
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: !0
            }), t.stringToPath = t.Slip10RawIndex = t.slip10CurveFromString = t.Slip10Curve = t.Slip10 = t.pathToString = t.sha512 = t.Sha512 = t.sha256 = t.Sha256 = t.Secp256k1Signature = t.ExtendedSecp256k1Signature = t.Secp256k1 = t.ripemd160 = t.Ripemd160 = t.Random = t.Xchacha20poly1305Ietf = t.xchacha20NonceLength = t.isArgon2idOptions = t.Ed25519Keypair = t.Ed25519 = t.Argon2id = t.keccak256 = t.Keccak256 = t.Hmac = t.EnglishMnemonic = t.Bip39 = void 0;
            var n = r(55767);
            Object.defineProperty(t, "Bip39", {
                enumerable: !0,
                get: function() {
                    return n.Bip39
                }
            }), Object.defineProperty(t, "EnglishMnemonic", {
                enumerable: !0,
                get: function() {
                    return n.EnglishMnemonic
                }
            });
            var o = r(81435);
            Object.defineProperty(t, "Hmac", {
                enumerable: !0,
                get: function() {
                    return o.Hmac
                }
            });
            var i = r(15437);
            Object.defineProperty(t, "Keccak256", {
                enumerable: !0,
                get: function() {
                    return i.Keccak256
                }
            }), Object.defineProperty(t, "keccak256", {
                enumerable: !0,
                get: function() {
                    return i.keccak256
                }
            });
            var a = r(69028);
            Object.defineProperty(t, "Argon2id", {
                enumerable: !0,
                get: function() {
                    return a.Argon2id
                }
            }), Object.defineProperty(t, "Ed25519", {
                enumerable: !0,
                get: function() {
                    return a.Ed25519
                }
            }), Object.defineProperty(t, "Ed25519Keypair", {
                enumerable: !0,
                get: function() {
                    return a.Ed25519Keypair
                }
            }), Object.defineProperty(t, "isArgon2idOptions", {
                enumerable: !0,
                get: function() {
                    return a.isArgon2idOptions
                }
            }), Object.defineProperty(t, "xchacha20NonceLength", {
                enumerable: !0,
                get: function() {
                    return a.xchacha20NonceLength
                }
            }), Object.defineProperty(t, "Xchacha20poly1305Ietf", {
                enumerable: !0,
                get: function() {
                    return a.Xchacha20poly1305Ietf
                }
            });
            var s = r(86312);
            Object.defineProperty(t, "Random", {
                enumerable: !0,
                get: function() {
                    return s.Random
                }
            });
            var d = r(45543);
            Object.defineProperty(t, "Ripemd160", {
                enumerable: !0,
                get: function() {
                    return d.Ripemd160
                }
            }), Object.defineProperty(t, "ripemd160", {
                enumerable: !0,
                get: function() {
                    return d.ripemd160
                }
            });
            var c = r(62833);
            Object.defineProperty(t, "Secp256k1", {
                enumerable: !0,
                get: function() {
                    return c.Secp256k1
                }
            });
            var l = r(21653);
            Object.defineProperty(t, "ExtendedSecp256k1Signature", {
                enumerable: !0,
                get: function() {
                    return l.ExtendedSecp256k1Signature
                }
            }), Object.defineProperty(t, "Secp256k1Signature", {
                enumerable: !0,
                get: function() {
                    return l.Secp256k1Signature
                }
            });
            var u = r(52275);
            Object.defineProperty(t, "Sha256", {
                enumerable: !0,
                get: function() {
                    return u.Sha256
                }
            }), Object.defineProperty(t, "sha256", {
                enumerable: !0,
                get: function() {
                    return u.sha256
                }
            }), Object.defineProperty(t, "Sha512", {
                enumerable: !0,
                get: function() {
                    return u.Sha512
                }
            }), Object.defineProperty(t, "sha512", {
                enumerable: !0,
                get: function() {
                    return u.sha512
                }
            });
            var p = r(65875);
            Object.defineProperty(t, "pathToString", {
                enumerable: !0,
                get: function() {
                    return p.pathToString
                }
            }), Object.defineProperty(t, "Slip10", {
                enumerable: !0,
                get: function() {
                    return p.Slip10
                }
            }), Object.defineProperty(t, "Slip10Curve", {
                enumerable: !0,
                get: function() {
                    return p.Slip10Curve
                }
            }), Object.defineProperty(t, "slip10CurveFromString", {
                enumerable: !0,
                get: function() {
                    return p.slip10CurveFromString
                }
            }), Object.defineProperty(t, "Slip10RawIndex", {
                enumerable: !0,
                get: function() {
                    return p.Slip10RawIndex
                }
            }), Object.defineProperty(t, "stringToPath", {
                enumerable: !0,
                get: function() {
                    return p.stringToPath
                }
            })
        },
        15437: function(e, t, r) {
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: !0
            }), t.keccak256 = t.Keccak256 = void 0;
            let n = r(85426),
                o = r(70817);
            class i {
                constructor(e) {
                    this.blockSize = 64, this.impl = n.keccak_256.create(), e && this.update(e)
                }
                update(e) {
                    return this.impl.update((0, o.toRealUint8Array)(e)), this
                }
                digest() {
                    return this.impl.digest()
                }
            }
            t.Keccak256 = i, t.keccak256 = function(e) {
                return new i(e).digest()
            }
        },
        69028: function(e, t, r) {
            "use strict";
            var n = this && this.__importDefault || function(e) {
                return e && e.__esModule ? e : {
                    default: e
                }
            };
            Object.defineProperty(t, "__esModule", {
                value: !0
            }), t.Xchacha20poly1305Ietf = t.xchacha20NonceLength = t.Ed25519 = t.Ed25519Keypair = t.Argon2id = t.isArgon2idOptions = void 0;
            let o = r(93337),
                i = n(r(98948));
            t.isArgon2idOptions = function(e) {
                return !!(0, o.isNonNullObject)(e) && "number" == typeof e.outputLength && "number" == typeof e.opsLimit && "number" == typeof e.memLimitKib
            };
            class a {
                static async execute(e, t, r) {
                    return await i.default.ready, i.default.crypto_pwhash(r.outputLength, e, t, r.opsLimit, 1024 * r.memLimitKib, i.default.crypto_pwhash_ALG_ARGON2ID13)
                }
            }
            t.Argon2id = a;
            class s {
                static fromLibsodiumPrivkey(e) {
                    if (64 !== e.length) throw Error(`Unexpected key length ${e.length}. Must be 64.`);
                    return new s(e.slice(0, 32), e.slice(32, 64))
                }
                constructor(e, t) {
                    this.privkey = e, this.pubkey = t
                }
                toLibsodiumPrivkey() {
                    return new Uint8Array([...this.privkey, ...this.pubkey])
                }
            }
            t.Ed25519Keypair = s;
            class d {
                static async makeKeypair(e) {
                    await i.default.ready;
                    let t = i.default.crypto_sign_seed_keypair(e);
                    return s.fromLibsodiumPrivkey(t.privateKey)
                }
                static async createSignature(e, t) {
                    return await i.default.ready, i.default.crypto_sign_detached(e, t.toLibsodiumPrivkey())
                }
                static async verifySignature(e, t, r) {
                    return await i.default.ready, i.default.crypto_sign_verify_detached(e, t, r)
                }
            }
            t.Ed25519 = d, t.xchacha20NonceLength = 24;
            class c {
                static async encrypt(e, t, r) {
                    return await i.default.ready, i.default.crypto_aead_xchacha20poly1305_ietf_encrypt(e, null, null, r, t)
                }
                static async decrypt(e, t, r) {
                    return await i.default.ready, i.default.crypto_aead_xchacha20poly1305_ietf_decrypt(null, e, null, r, t)
                }
            }
            t.Xchacha20poly1305Ietf = c
        },
        49705: function(e, t, r) {
            "use strict";
            var n = this && this.__createBinding || (Object.create ? function(e, t, r, n) {
                    void 0 === n && (n = r);
                    var o = Object.getOwnPropertyDescriptor(t, r);
                    (!o || ("get" in o ? !t.__esModule : o.writable || o.configurable)) && (o = {
                        enumerable: !0,
                        get: function() {
                            return t[r]
                        }
                    }), Object.defineProperty(e, n, o)
                } : function(e, t, r, n) {
                    void 0 === n && (n = r), e[n] = t[r]
                }),
                o = this && this.__setModuleDefault || (Object.create ? function(e, t) {
                    Object.defineProperty(e, "default", {
                        enumerable: !0,
                        value: t
                    })
                } : function(e, t) {
                    e.default = t
                }),
                i = this && this.__importStar || function(e) {
                    if (e && e.__esModule) return e;
                    var t = {};
                    if (null != e)
                        for (var r in e) "default" !== r && Object.prototype.hasOwnProperty.call(e, r) && n(t, e, r);
                    return o(t, e), t
                };
            Object.defineProperty(t, "__esModule", {
                value: !0
            }), t.pbkdf2Sha512 = t.pbkdf2Sha512Noble = t.pbkdf2Sha512NodeCrypto = t.pbkdf2Sha512Subtle = t.getSubtle = t.getNodeCrypto = void 0;
            let a = r(93337),
                s = r(29023),
                d = r(86262);
            async function c() {
                try {
                    let e = await Promise.resolve().then(() => i(r(42474)));
                    if ("object" == typeof e && Object.keys(e).length <= 1) return;
                    return e
                } catch {
                    return
                }
            }
            async function l() {
                let e = globalThis ? .crypto ? .subtle;
                return e || (e = globalThis ? .crypto ? .webcrypto ? .subtle), e
            }
            async function u(e, t, r, n, o) {
                return (0, a.assert)(e, "Argument subtle is falsy"), (0, a.assert)("object" == typeof e, "Argument subtle is not of type object"), (0, a.assert)("function" == typeof e.importKey, "subtle.importKey is not a function"), (0, a.assert)("function" == typeof e.deriveBits, "subtle.deriveBits is not a function"), e.importKey("raw", t, {
                    name: "PBKDF2"
                }, !1, ["deriveBits"]).then(t => e.deriveBits({
                    name: "PBKDF2",
                    salt: r,
                    iterations: n,
                    hash: {
                        name: "SHA-512"
                    }
                }, t, 8 * o).then(e => new Uint8Array(e)))
            }
            async function p(e, t, r, n, o) {
                return (0, a.assert)(e, "Argument nodeCrypto is falsy"), (0, a.assert)("object" == typeof e, "Argument nodeCrypto is not of type object"), (0, a.assert)("function" == typeof e.pbkdf2, "nodeCrypto.pbkdf2 is not a function"), new Promise((i, a) => {
                    e.pbkdf2(t, r, n, o, "sha512", (e, t) => {
                        e ? a(e) : i(Uint8Array.from(t))
                    })
                })
            }
            async function m(e, t, r, n) {
                return (0, s.pbkdf2Async)(d.sha512, e, t, {
                    c: r,
                    dkLen: n
                })
            }
            async function g(e, t, r, n) {
                let o = await l();
                if (o) return u(o, e, t, r, n); {
                    let o = await c();
                    return o ? p(o, e, t, r, n) : m(e, t, r, n)
                }
            }
            t.getNodeCrypto = c, t.getSubtle = l, t.pbkdf2Sha512Subtle = u, t.pbkdf2Sha512NodeCrypto = p, t.pbkdf2Sha512Noble = m, t.pbkdf2Sha512 = g
        },
        86312: function(e, t, r) {
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: !0
            }), t.Random = void 0;
            class n {
                static getBytes(e) {
                    try {
                        let t = "object" == typeof window ? window : self,
                            r = void 0 !== t.crypto ? t.crypto : t.msCrypto,
                            n = new Uint8Array(e);
                        return r.getRandomValues(n), n
                    } catch {
                        try {
                            let t = r(42474);
                            return new Uint8Array([...t.randomBytes(e)])
                        } catch {
                            throw Error("No secure random number generator found")
                        }
                    }
                }
            }
            t.Random = n
        },
        45543: function(e, t, r) {
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: !0
            }), t.ripemd160 = t.Ripemd160 = void 0;
            let n = r(70830),
                o = r(70817);
            class i {
                constructor(e) {
                    this.blockSize = 64, this.impl = n.ripemd160.create(), e && this.update(e)
                }
                update(e) {
                    return this.impl.update((0, o.toRealUint8Array)(e)), this
                }
                digest() {
                    return this.impl.digest()
                }
            }
            t.Ripemd160 = i, t.ripemd160 = function(e) {
                return new i(e).digest()
            }
        },
        62833: function(e, t, r) {
            "use strict";
            var n = this && this.__importDefault || function(e) {
                return e && e.__esModule ? e : {
                    default: e
                }
            };
            Object.defineProperty(t, "__esModule", {
                value: !0
            }), t.Secp256k1 = void 0;
            let o = r(15050),
                i = n(r(13550)),
                a = n(r(86266)),
                s = r(21653),
                d = new a.default.ec("secp256k1"),
                c = new i.default("FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141", "hex");
            class l {
                static async makeKeypair(e) {
                    if (32 !== e.length) throw Error("input data is not a valid secp256k1 private key");
                    let t = d.keyFromPrivate(e);
                    if (!0 !== t.validate().result || new i.default(e).gte(c)) throw Error("input data is not a valid secp256k1 private key");
                    return {
                        privkey: (0, o.fromHex)(t.getPrivate("hex")),
                        pubkey: Uint8Array.from(t.getPublic("array"))
                    }
                }
                static async createSignature(e, t) {
                    if (0 === e.length) throw Error("Message hash must not be empty");
                    if (e.length > 32) throw Error("Message hash length must not exceed 32 bytes");
                    let {
                        r,
                        s: n,
                        recoveryParam: o
                    } = d.keyFromPrivate(t).sign(e, {
                        canonical: !0
                    });
                    if ("number" != typeof o) throw Error("Recovery param missing");
                    return new s.ExtendedSecp256k1Signature(Uint8Array.from(r.toArray()), Uint8Array.from(n.toArray()), o)
                }
                static async verifySignature(e, t, r) {
                    if (0 === t.length) throw Error("Message hash must not be empty");
                    if (t.length > 32) throw Error("Message hash length must not exceed 32 bytes");
                    let n = d.keyFromPublic(r);
                    try {
                        return n.verify(t, e.toDer())
                    } catch (e) {
                        return !1
                    }
                }
                static recoverPubkey(e, t) {
                    let r = {
                            r: (0, o.toHex)(e.r()),
                            s: (0, o.toHex)(e.s())
                        },
                        n = d.recoverPubKey(t, r, e.recovery),
                        i = d.keyFromPublic(n);
                    return (0, o.fromHex)(i.getPublic(!1, "hex"))
                }
                static compressPubkey(e) {
                    switch (e.length) {
                        case 33:
                            return e;
                        case 65:
                            return Uint8Array.from(d.keyFromPublic(e).getPublic(!0, "array"));
                        default:
                            throw Error("Invalid pubkey length")
                    }
                }
                static uncompressPubkey(e) {
                    switch (e.length) {
                        case 33:
                            return Uint8Array.from(d.keyFromPublic(e).getPublic(!1, "array"));
                        case 65:
                            return e;
                        default:
                            throw Error("Invalid pubkey length")
                    }
                }
                static trimRecoveryByte(e) {
                    switch (e.length) {
                        case 64:
                            return e;
                        case 65:
                            return e.slice(0, 64);
                        default:
                            throw Error("Invalid signature length")
                    }
                }
            }
            t.Secp256k1 = l
        },
        21653: function(e, t) {
            "use strict";

            function r(e) {
                let t = 0;
                for (let r of e)
                    if (0 === r) t++;
                    else break;
                return e.slice(t)
            }
            Object.defineProperty(t, "__esModule", {
                value: !0
            }), t.ExtendedSecp256k1Signature = t.Secp256k1Signature = void 0;
            class n {
                static fromFixedLength(e) {
                    if (64 !== e.length) throw Error(`Got invalid data length: ${e.length}. Expected 2x 32 bytes for the pair (r, s)`);
                    return new n(r(e.slice(0, 32)), r(e.slice(32, 64)))
                }
                static fromDer(e) {
                    let t = 0;
                    if (48 !== e[t++]) throw Error("Prefix 0x30 expected");
                    let o = e[t++];
                    if (e.length - t !== o) throw Error("Data length mismatch detected");
                    if (2 !== e[t++]) throw Error("INTEGER tag expected");
                    let i = e[t++];
                    if (i >= 128) throw Error("Decoding length values above 127 not supported");
                    let a = e.slice(t, t + i);
                    if (t += i, 2 !== e[t++]) throw Error("INTEGER tag expected");
                    let s = e[t++];
                    if (s >= 128) throw Error("Decoding length values above 127 not supported");
                    let d = e.slice(t, t + s);
                    return t += s, new n(r(a), r(d))
                }
                constructor(e, t) {
                    if (e.length > 32 || 0 === e.length || 0 === e[0]) throw Error("Unsigned integer r must be encoded as unpadded big endian.");
                    if (t.length > 32 || 0 === t.length || 0 === t[0]) throw Error("Unsigned integer s must be encoded as unpadded big endian.");
                    this.data = {
                        r: e,
                        s: t
                    }
                }
                r(e) {
                    if (void 0 === e) return this.data.r; {
                        let t = e - this.data.r.length;
                        if (t < 0) throw Error("Length too small to hold parameter r");
                        let r = new Uint8Array(t);
                        return new Uint8Array([...r, ...this.data.r])
                    }
                }
                s(e) {
                    if (void 0 === e) return this.data.s; {
                        let t = e - this.data.s.length;
                        if (t < 0) throw Error("Length too small to hold parameter s");
                        let r = new Uint8Array(t);
                        return new Uint8Array([...r, ...this.data.s])
                    }
                }
                toFixedLength() {
                    return new Uint8Array([...this.r(32), ...this.s(32)])
                }
                toDer() {
                    let e = this.data.r[0] >= 128 ? new Uint8Array([0, ...this.data.r]) : this.data.r,
                        t = this.data.s[0] >= 128 ? new Uint8Array([0, ...this.data.s]) : this.data.s,
                        r = e.length,
                        n = t.length,
                        o = new Uint8Array([2, r, ...e, 2, n, ...t]);
                    return new Uint8Array([48, o.length, ...o])
                }
            }
            t.Secp256k1Signature = n;
            class o extends n {
                static fromFixedLength(e) {
                    if (65 !== e.length) throw Error(`Got invalid data length ${e.length}. Expected 32 + 32 + 1`);
                    return new o(r(e.slice(0, 32)), r(e.slice(32, 64)), e[64])
                }
                constructor(e, t, r) {
                    if (super(e, t), !Number.isInteger(r)) throw Error("The recovery parameter must be an integer.");
                    if (r < 0 || r > 4) throw Error("The recovery parameter must be one of 0, 1, 2, 3.");
                    this.recovery = r
                }
                toFixedLength() {
                    return new Uint8Array([...this.r(32), ...this.s(32), this.recovery])
                }
            }
            t.ExtendedSecp256k1Signature = o
        },
        52275: function(e, t, r) {
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: !0
            }), t.sha512 = t.Sha512 = t.sha256 = t.Sha256 = void 0;
            let n = r(23061),
                o = r(86262),
                i = r(70817);
            class a {
                constructor(e) {
                    this.blockSize = 64, this.impl = n.sha256.create(), e && this.update(e)
                }
                update(e) {
                    return this.impl.update((0, i.toRealUint8Array)(e)), this
                }
                digest() {
                    return this.impl.digest()
                }
            }
            t.Sha256 = a, t.sha256 = function(e) {
                return new a(e).digest()
            };
            class s {
                constructor(e) {
                    this.blockSize = 128, this.impl = o.sha512.create(), e && this.update(e)
                }
                update(e) {
                    return this.impl.update((0, i.toRealUint8Array)(e)), this
                }
                digest() {
                    return this.impl.digest()
                }
            }
            t.Sha512 = s, t.sha512 = function(e) {
                return new s(e).digest()
            }
        },
        65875: function(e, t, r) {
            "use strict";
            var n, o, i = this && this.__importDefault || function(e) {
                return e && e.__esModule ? e : {
                    default: e
                }
            };
            Object.defineProperty(t, "__esModule", {
                value: !0
            }), t.stringToPath = t.pathToString = t.Slip10 = t.Slip10RawIndex = t.slip10CurveFromString = t.Slip10Curve = void 0;
            let a = r(15050),
                s = r(38051),
                d = i(r(13550)),
                c = i(r(86266)),
                l = r(81435),
                u = r(52275);
            (n = o = t.Slip10Curve || (t.Slip10Curve = {})).Secp256k1 = "Bitcoin seed", n.Ed25519 = "ed25519 seed", t.slip10CurveFromString = function(e) {
                switch (e) {
                    case o.Ed25519:
                        return o.Ed25519;
                    case o.Secp256k1:
                        return o.Secp256k1;
                    default:
                        throw Error(`Unknown curve string: '${e}'`)
                }
            };
            class p extends s.Uint32 {
                static hardened(e) {
                    return new p(e + 2147483648)
                }
                static normal(e) {
                    return new p(e)
                }
                isHardened() {
                    return this.data >= 2147483648
                }
            }
            t.Slip10RawIndex = p;
            let m = new c.default.ec("secp256k1");
            class g {
                static derivePath(e, t, r) {
                    let n = this.master(e, t);
                    for (let t of r) n = this.child(e, n.privkey, n.chainCode, t);
                    return n
                }
                static master(e, t) {
                    let r = new l.Hmac(u.Sha512, (0, a.toAscii)(e)).update(t).digest(),
                        n = r.slice(0, 32),
                        i = r.slice(32, 64);
                    return e !== o.Ed25519 && (this.isZero(n) || this.isGteN(e, n)) ? this.master(e, r) : {
                        chainCode: i,
                        privkey: n
                    }
                }
                static child(e, t, r, n) {
                    let i;
                    if (n.isHardened()) {
                        let e = new Uint8Array([0, ...t, ...n.toBytesBigEndian()]);
                        i = new l.Hmac(u.Sha512, r).update(e).digest()
                    } else {
                        if (e === o.Ed25519) throw Error("Normal keys are not allowed with ed25519"); {
                            let o = new Uint8Array([...g.serializedPoint(e, new d.default(t)), ...n.toBytesBigEndian()]);
                            i = new l.Hmac(u.Sha512, r).update(o).digest()
                        }
                    }
                    return this.childImpl(e, t, r, n, i)
                }
                static serializedPoint(e, t) {
                    if (e === o.Secp256k1) return (0, a.fromHex)(m.g.mul(t).encodeCompressed("hex"));
                    throw Error("curve not supported")
                }
                static childImpl(e, t, r, n, i) {
                    let a = i.slice(0, 32),
                        s = i.slice(32, 64);
                    if (e === o.Ed25519) return {
                        chainCode: s,
                        privkey: a
                    };
                    let c = this.n(e),
                        p = new d.default(a).add(new d.default(t)).mod(c),
                        m = Uint8Array.from(p.toArray("be", 32));
                    if (this.isGteN(e, a) || this.isZero(m)) {
                        let o = new l.Hmac(u.Sha512, r).update(new Uint8Array([1, ...s, ...n.toBytesBigEndian()])).digest();
                        return this.childImpl(e, t, r, n, o)
                    }
                    return {
                        chainCode: s,
                        privkey: m
                    }
                }
                static isZero(e) {
                    return e.every(e => 0 === e)
                }
                static isGteN(e, t) {
                    return new d.default(t).gte(this.n(e))
                }
                static n(e) {
                    if (e === o.Secp256k1) return new d.default("FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141", 16);
                    throw Error("curve not supported")
                }
            }
            t.Slip10 = g, t.pathToString = function(e) {
                return e.reduce((e, t) => e + "/" + (t.isHardened() ? `${t.toNumber()-2147483648}'` : t.toString()), "m")
            }, t.stringToPath = function(e) {
                if (!e.startsWith("m")) throw Error("Path string must start with 'm'");
                let t = e.slice(1),
                    r = [];
                for (; t;) {
                    let e = t.match(/^\/([0-9]+)('?)/);
                    if (!e) throw Error("Syntax error while reading path component");
                    let [n, o, i] = e, a = s.Uint53.fromString(o).toNumber();
                    if (a >= 2147483648) throw Error("Component value too high. Must not exceed 2**31-1.");
                    i ? r.push(p.hardened(a)) : r.push(p.normal(a)), t = t.slice(n.length)
                }
                return r
            }
        },
        70817: function(e, t) {
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: !0
            }), t.toRealUint8Array = void 0, t.toRealUint8Array = function(e) {
                return e instanceof Uint8Array ? e : Uint8Array.from(e)
            }
        },
        71984: function(e, t) {
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: !0
            }), t.fromAscii = t.toAscii = void 0, t.toAscii = function(e) {
                return Uint8Array.from(e.split("").map(e => {
                    let t = e.charCodeAt(0);
                    if (t < 32 || t > 126) throw Error("Cannot encode character that is out of printable ASCII range: " + t);
                    return t
                }))
            }, t.fromAscii = function(e) {
                return Array.from(e).map(e => {
                    if (e < 32 || e > 126) throw Error("Cannot decode character that is out of printable ASCII range: " + e);
                    return String.fromCharCode(e)
                }).join("")
            }
        },
        11567: function(e, t, r) {
            "use strict";
            var n = this && this.__createBinding || (Object.create ? function(e, t, r, n) {
                    void 0 === n && (n = r);
                    var o = Object.getOwnPropertyDescriptor(t, r);
                    (!o || ("get" in o ? !t.__esModule : o.writable || o.configurable)) && (o = {
                        enumerable: !0,
                        get: function() {
                            return t[r]
                        }
                    }), Object.defineProperty(e, n, o)
                } : function(e, t, r, n) {
                    void 0 === n && (n = r), e[n] = t[r]
                }),
                o = this && this.__setModuleDefault || (Object.create ? function(e, t) {
                    Object.defineProperty(e, "default", {
                        enumerable: !0,
                        value: t
                    })
                } : function(e, t) {
                    e.default = t
                }),
                i = this && this.__importStar || function(e) {
                    if (e && e.__esModule) return e;
                    var t = {};
                    if (null != e)
                        for (var r in e) "default" !== r && Object.prototype.hasOwnProperty.call(e, r) && n(t, e, r);
                    return o(t, e), t
                };
            Object.defineProperty(t, "__esModule", {
                value: !0
            }), t.fromBase64 = t.toBase64 = void 0;
            let a = i(r(79742));
            t.toBase64 = function(e) {
                return a.fromByteArray(e)
            }, t.fromBase64 = function(e) {
                if (!e.match(/^[a-zA-Z0-9+/]*={0,2}$/)) throw Error("Invalid base64 string format");
                return a.toByteArray(e)
            }
        },
        54899: function(e, t, r) {
            "use strict";
            var n = this && this.__createBinding || (Object.create ? function(e, t, r, n) {
                    void 0 === n && (n = r);
                    var o = Object.getOwnPropertyDescriptor(t, r);
                    (!o || ("get" in o ? !t.__esModule : o.writable || o.configurable)) && (o = {
                        enumerable: !0,
                        get: function() {
                            return t[r]
                        }
                    }), Object.defineProperty(e, n, o)
                } : function(e, t, r, n) {
                    void 0 === n && (n = r), e[n] = t[r]
                }),
                o = this && this.__setModuleDefault || (Object.create ? function(e, t) {
                    Object.defineProperty(e, "default", {
                        enumerable: !0,
                        value: t
                    })
                } : function(e, t) {
                    e.default = t
                }),
                i = this && this.__importStar || function(e) {
                    if (e && e.__esModule) return e;
                    var t = {};
                    if (null != e)
                        for (var r in e) "default" !== r && Object.prototype.hasOwnProperty.call(e, r) && n(t, e, r);
                    return o(t, e), t
                };
            Object.defineProperty(t, "__esModule", {
                value: !0
            }), t.normalizeBech32 = t.fromBech32 = t.toBech32 = void 0;
            let a = i(r(90093));

            function s(e, t, r) {
                return a.encode(e, a.toWords(t), r)
            }

            function d(e, t = 1 / 0) {
                let r = a.decode(e, t);
                return {
                    prefix: r.prefix,
                    data: new Uint8Array(a.fromWords(r.words))
                }
            }
            t.toBech32 = s, t.fromBech32 = d, t.normalizeBech32 = function(e) {
                let {
                    prefix: t,
                    data: r
                } = d(e);
                return s(t, r)
            }
        },
        7699: function(e, t) {
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: !0
            }), t.fromHex = t.toHex = void 0, t.toHex = function(e) {
                let t = "";
                for (let r of e) t += ("0" + r.toString(16)).slice(-2);
                return t
            }, t.fromHex = function(e) {
                if (e.length % 2 != 0) throw Error("hex string length must be a multiple of 2");
                let t = new Uint8Array(e.length / 2);
                for (let r = 0; r < t.length; r++) {
                    let n = 2 * r,
                        o = e.slice(n, n + 2);
                    if (!o.match(/[0-9a-f]{2}/i)) throw Error("hex string contains invalid characters");
                    t[r] = parseInt(o, 16)
                }
                return t
            }
        },
        15050: function(e, t, r) {
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: !0
            }), t.toUtf8 = t.fromUtf8 = t.toRfc3339 = t.fromRfc3339 = t.toHex = t.fromHex = t.toBech32 = t.normalizeBech32 = t.fromBech32 = t.toBase64 = t.fromBase64 = t.toAscii = t.fromAscii = void 0;
            var n = r(71984);
            Object.defineProperty(t, "fromAscii", {
                enumerable: !0,
                get: function() {
                    return n.fromAscii
                }
            }), Object.defineProperty(t, "toAscii", {
                enumerable: !0,
                get: function() {
                    return n.toAscii
                }
            });
            var o = r(11567);
            Object.defineProperty(t, "fromBase64", {
                enumerable: !0,
                get: function() {
                    return o.fromBase64
                }
            }), Object.defineProperty(t, "toBase64", {
                enumerable: !0,
                get: function() {
                    return o.toBase64
                }
            });
            var i = r(54899);
            Object.defineProperty(t, "fromBech32", {
                enumerable: !0,
                get: function() {
                    return i.fromBech32
                }
            }), Object.defineProperty(t, "normalizeBech32", {
                enumerable: !0,
                get: function() {
                    return i.normalizeBech32
                }
            }), Object.defineProperty(t, "toBech32", {
                enumerable: !0,
                get: function() {
                    return i.toBech32
                }
            });
            var a = r(7699);
            Object.defineProperty(t, "fromHex", {
                enumerable: !0,
                get: function() {
                    return a.fromHex
                }
            }), Object.defineProperty(t, "toHex", {
                enumerable: !0,
                get: function() {
                    return a.toHex
                }
            });
            var s = r(56424);
            Object.defineProperty(t, "fromRfc3339", {
                enumerable: !0,
                get: function() {
                    return s.fromRfc3339
                }
            }), Object.defineProperty(t, "toRfc3339", {
                enumerable: !0,
                get: function() {
                    return s.toRfc3339
                }
            });
            var d = r(54862);
            Object.defineProperty(t, "fromUtf8", {
                enumerable: !0,
                get: function() {
                    return d.fromUtf8
                }
            }), Object.defineProperty(t, "toUtf8", {
                enumerable: !0,
                get: function() {
                    return d.toUtf8
                }
            })
        },
        56424: function(e, t) {
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: !0
            }), t.toRfc3339 = t.fromRfc3339 = void 0;
            let r = /^(\d{4})-(\d{2})-(\d{2})[T ](\d{2}):(\d{2}):(\d{2})(\.\d{1,9})?((?:[+-]\d{2}:\d{2})|Z)$/;

            function n(e, t = 2) {
                return e.toString().padStart(t, "0")
            }
            t.fromRfc3339 = function(e) {
                let t, n, o;
                let i = r.exec(e);
                if (!i) throw Error("Date string is not in RFC3339 format");
                let a = +i[1],
                    s = +i[2],
                    d = +i[3],
                    c = +i[4],
                    l = +i[5],
                    u = +i[6],
                    p = i[7] ? Math.floor(1e3 * +i[7]) : 0;
                "Z" === i[8] ? (t = 1, n = 0, o = 0) : (t = "-" === i[8].substring(0, 1) ? -1 : 1, n = +i[8].substring(1, 3), o = +i[8].substring(4, 6));
                let m = t * (60 * n + o) * 60,
                    g = new Date;
                return g.setUTCFullYear(a, s - 1, d), g.setUTCHours(c, l, u, p), new Date(g.getTime() - 1e3 * m)
            }, t.toRfc3339 = function(e) {
                let t = e.getUTCFullYear(),
                    r = n(e.getUTCMonth() + 1),
                    o = n(e.getUTCDate()),
                    i = n(e.getUTCHours()),
                    a = n(e.getUTCMinutes()),
                    s = n(e.getUTCSeconds()),
                    d = n(e.getUTCMilliseconds(), 3);
                return `${t}-${r}-${o}T${i}:${a}:${s}.${d}Z`
            }
        },
        54862: function(e, t) {
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: !0
            }), t.fromUtf8 = t.toUtf8 = void 0, t.toUtf8 = function(e) {
                return new TextEncoder().encode(e)
            }, t.fromUtf8 = function(e, t = !1) {
                return new TextDecoder("utf-8", {
                    fatal: !t
                }).decode(e)
            }
        },
        80712: function(e, t) {
            "use strict";

            function r(e) {
                return !!("string" == typeof e || "number" == typeof e || "boolean" == typeof e || null === e || n(e) || o(e))
            }

            function n(e) {
                if (!Array.isArray(e)) return !1;
                for (let t of e)
                    if (!r(t)) return !1;
                return !0
            }

            function o(e) {
                return "object" == typeof e && null !== e && "[object Object]" === Object.prototype.toString.call(e) && Object.values(e).every(r)
            }
            Object.defineProperty(t, "__esModule", {
                value: !0
            }), t.isJsonCompatibleDictionary = t.isJsonCompatibleArray = t.isJsonCompatibleValue = void 0, t.isJsonCompatibleValue = r, t.isJsonCompatibleArray = n, t.isJsonCompatibleDictionary = o
        },
        706: function(e, t) {
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: !0
            }), t.makeJsonRpcId = void 0;
            let r = 1e4;
            t.makeJsonRpcId = function() {
                return r += 1
            }
        },
        47207: function(e, t, r) {
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: !0
            }), t.jsonRpcCode = t.isJsonRpcSuccessResponse = t.isJsonRpcErrorResponse = t.parseJsonRpcSuccessResponse = t.parseJsonRpcResponse = t.parseJsonRpcRequest = t.parseJsonRpcId = t.parseJsonRpcErrorResponse = t.JsonRpcClient = t.makeJsonRpcId = void 0;
            var n = r(706);
            Object.defineProperty(t, "makeJsonRpcId", {
                enumerable: !0,
                get: function() {
                    return n.makeJsonRpcId
                }
            });
            var o = r(46387);
            Object.defineProperty(t, "JsonRpcClient", {
                enumerable: !0,
                get: function() {
                    return o.JsonRpcClient
                }
            });
            var i = r(17825);
            Object.defineProperty(t, "parseJsonRpcErrorResponse", {
                enumerable: !0,
                get: function() {
                    return i.parseJsonRpcErrorResponse
                }
            }), Object.defineProperty(t, "parseJsonRpcId", {
                enumerable: !0,
                get: function() {
                    return i.parseJsonRpcId
                }
            }), Object.defineProperty(t, "parseJsonRpcRequest", {
                enumerable: !0,
                get: function() {
                    return i.parseJsonRpcRequest
                }
            }), Object.defineProperty(t, "parseJsonRpcResponse", {
                enumerable: !0,
                get: function() {
                    return i.parseJsonRpcResponse
                }
            }), Object.defineProperty(t, "parseJsonRpcSuccessResponse", {
                enumerable: !0,
                get: function() {
                    return i.parseJsonRpcSuccessResponse
                }
            });
            var a = r(14893);
            Object.defineProperty(t, "isJsonRpcErrorResponse", {
                enumerable: !0,
                get: function() {
                    return a.isJsonRpcErrorResponse
                }
            }), Object.defineProperty(t, "isJsonRpcSuccessResponse", {
                enumerable: !0,
                get: function() {
                    return a.isJsonRpcSuccessResponse
                }
            }), Object.defineProperty(t, "jsonRpcCode", {
                enumerable: !0,
                get: function() {
                    return a.jsonRpcCode
                }
            })
        },
        46387: function(e, t, r) {
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: !0
            }), t.JsonRpcClient = void 0;
            let n = r(67298),
                o = r(14893);
            class i {
                constructor(e) {
                    this.connection = e
                }
                async run(e) {
                    let t = this.connection.responseStream.filter(t => t.id === e.id),
                        r = (0, n.firstEvent)(t);
                    this.connection.sendRequest(e);
                    let i = await r;
                    if ((0, o.isJsonRpcErrorResponse)(i)) {
                        let e = i.error;
                        throw Error(`JSON RPC error: code=${e.code}; message='${e.message}'`)
                    }
                    return i
                }
            }
            t.JsonRpcClient = i
        },
        17825: function(e, t, r) {
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: !0
            }), t.parseJsonRpcResponse = t.parseJsonRpcSuccessResponse = t.parseJsonRpcErrorResponse = t.parseJsonRpcRequest = t.parseJsonRpcId = void 0;
            let n = r(80712);

            function o(e) {
                if (!(0, n.isJsonCompatibleDictionary)(e)) throw Error("Data must be JSON compatible dictionary");
                let t = e.id;
                return "number" != typeof t && "string" != typeof t ? null : t
            }

            function i(e) {
                if (!(0, n.isJsonCompatibleDictionary)(e)) throw Error("Data must be JSON compatible dictionary");
                if ("2.0" !== e.jsonrpc) throw Error(`Got unexpected jsonrpc version: ${JSON.stringify(e)}`);
                let t = e.id;
                if ("number" != typeof t && "string" != typeof t && null !== t) throw Error("Invalid id field");
                if (void 0 === e.error || !(0, n.isJsonCompatibleDictionary)(e.error)) throw Error("Invalid error field");
                return {
                    jsonrpc: "2.0",
                    id: t,
                    error: function(e) {
                        let t;
                        if ("number" != typeof e.code) throw Error("Error property 'code' is not a number");
                        if ("string" != typeof e.message) throw Error("Error property 'message' is not a string");
                        if (void 0 === e.data) t = void 0;
                        else if ((0, n.isJsonCompatibleValue)(e.data)) t = e.data;
                        else throw Error("Error property 'data' is defined but not a JSON compatible value.");
                        return {
                            code: e.code,
                            message: e.message,
                            ...void 0 !== t ? {
                                data: t
                            } : {}
                        }
                    }(e.error)
                }
            }

            function a(e) {
                if (!(0, n.isJsonCompatibleDictionary)(e)) throw Error("Data must be JSON compatible dictionary");
                if ("2.0" !== e.jsonrpc) throw Error(`Got unexpected jsonrpc version: ${JSON.stringify(e)}`);
                let t = e.id;
                if ("number" != typeof t && "string" != typeof t) throw Error("Invalid id field");
                if (void 0 === e.result) throw Error("Invalid result field");
                return {
                    jsonrpc: "2.0",
                    id: t,
                    result: e.result
                }
            }
            t.parseJsonRpcId = o, t.parseJsonRpcRequest = function(e) {
                if (!(0, n.isJsonCompatibleDictionary)(e)) throw Error("Data must be JSON compatible dictionary");
                if ("2.0" !== e.jsonrpc) throw Error(`Got unexpected jsonrpc version: ${e.jsonrpc}`);
                let t = o(e);
                if (null === t) throw Error("Invalid id field");
                let r = e.method;
                if ("string" != typeof r) throw Error("Invalid method field");
                if (!(0, n.isJsonCompatibleArray)(e.params) && !(0, n.isJsonCompatibleDictionary)(e.params)) throw Error("Invalid params field");
                return {
                    jsonrpc: "2.0",
                    id: t,
                    method: r,
                    params: e.params
                }
            }, t.parseJsonRpcErrorResponse = i, t.parseJsonRpcSuccessResponse = a, t.parseJsonRpcResponse = function(e) {
                let t;
                try {
                    t = i(e)
                } catch (r) {
                    t = a(e)
                }
                return t
            }
        },
        14893: function(e, t) {
            "use strict";

            function r(e) {
                return "object" == typeof e.error
            }
            Object.defineProperty(t, "__esModule", {
                value: !0
            }), t.jsonRpcCode = t.isJsonRpcSuccessResponse = t.isJsonRpcErrorResponse = void 0, t.isJsonRpcErrorResponse = r, t.isJsonRpcSuccessResponse = function(e) {
                return !r(e)
            }, t.jsonRpcCode = {
                parseError: -32700,
                invalidRequest: -32600,
                methodNotFound: -32601,
                invalidParams: -32602,
                internalError: -32603,
                serverError: {
                    default: -32e3
                }
            }
        },
        77827: function(e, t, r) {
            "use strict";
            var n = this && this.__importDefault || function(e) {
                return e && e.__esModule ? e : {
                    default: e
                }
            };
            Object.defineProperty(t, "__esModule", {
                value: !0
            }), t.Decimal = void 0;
            let o = n(r(13550));
            class i {
                static fromUserInput(e, t) {
                    let r, n;
                    i.verifyFractionalDigits(t);
                    let o = e.match(/[^0-9.]/);
                    if (o) throw Error(`Invalid character at position ${o.index+1}`);
                    if ("" === e) r = "0", n = "";
                    else if (-1 === e.search(/\./)) r = e, n = "";
                    else {
                        let t = e.split(".");
                        switch (t.length) {
                            case 0:
                            case 1:
                                throw Error("Fewer than two elements in split result. This must not happen here.");
                            case 2:
                                if (!t[1]) throw Error("Fractional part missing");
                                r = t[0], n = t[1].replace(/0+$/, "");
                                break;
                            default:
                                throw Error("More than one separator found")
                        }
                    }
                    if (n.length > t) throw Error("Got more fractional digits than supported");
                    return new i(`${r}${n.padEnd(t,"0")}`, t)
                }
                static fromAtomics(e, t) {
                    return i.verifyFractionalDigits(t), new i(e, t)
                }
                static zero(e) {
                    return i.verifyFractionalDigits(e), new i("0", e)
                }
                static one(e) {
                    return i.verifyFractionalDigits(e), new i("1" + "0".repeat(e), e)
                }
                static verifyFractionalDigits(e) {
                    if (!Number.isInteger(e)) throw Error("Fractional digits is not an integer");
                    if (e < 0) throw Error("Fractional digits must not be negative");
                    if (e > 100) throw Error("Fractional digits must not exceed 100")
                }
                static compare(e, t) {
                    if (e.fractionalDigits !== t.fractionalDigits) throw Error("Fractional digits do not match");
                    return e.data.atomics.cmp(new o.default(t.atomics))
                }
                get atomics() {
                    return this.data.atomics.toString()
                }
                get fractionalDigits() {
                    return this.data.fractionalDigits
                }
                constructor(e, t) {
                    if (!e.match(/^[0-9]+$/)) throw Error("Invalid string format. Only non-negative integers in decimal representation supported.");
                    this.data = {
                        atomics: new o.default(e),
                        fractionalDigits: t
                    }
                }
                clone() {
                    return new i(this.atomics, this.fractionalDigits)
                }
                floor() {
                    let e = new o.default(10).pow(new o.default(this.data.fractionalDigits)),
                        t = this.data.atomics.div(e);
                    return this.data.atomics.mod(e).isZero() ? this.clone() : i.fromAtomics(t.mul(e).toString(), this.fractionalDigits)
                }
                ceil() {
                    let e = new o.default(10).pow(new o.default(this.data.fractionalDigits)),
                        t = this.data.atomics.div(e);
                    return this.data.atomics.mod(e).isZero() ? this.clone() : i.fromAtomics(t.addn(1).mul(e).toString(), this.fractionalDigits)
                }
                toString() {
                    let e = new o.default(10).pow(new o.default(this.data.fractionalDigits)),
                        t = this.data.atomics.div(e),
                        r = this.data.atomics.mod(e);
                    if (r.isZero()) return t.toString(); {
                        let e = r.toString().padStart(this.data.fractionalDigits, "0").replace(/0+$/, "");
                        return `${t.toString()}.${e}`
                    }
                }
                toFloatApproximation() {
                    let e = Number(this.toString());
                    if (Number.isNaN(e)) throw Error("Conversion to number failed");
                    return e
                }
                plus(e) {
                    if (this.fractionalDigits !== e.fractionalDigits) throw Error("Fractional digits do not match");
                    return new i(this.data.atomics.add(new o.default(e.atomics)).toString(), this.fractionalDigits)
                }
                minus(e) {
                    if (this.fractionalDigits !== e.fractionalDigits) throw Error("Fractional digits do not match");
                    let t = this.data.atomics.sub(new o.default(e.atomics));
                    if (t.ltn(0)) throw Error("Difference must not be negative");
                    return new i(t.toString(), this.fractionalDigits)
                }
                multiply(e) {
                    return new i(this.data.atomics.mul(new o.default(e.toString())).toString(), this.fractionalDigits)
                }
                equals(e) {
                    return 0 === i.compare(this, e)
                }
                isLessThan(e) {
                    return 0 > i.compare(this, e)
                }
                isLessThanOrEqual(e) {
                    return 0 >= i.compare(this, e)
                }
                isGreaterThan(e) {
                    return i.compare(this, e) > 0
                }
                isGreaterThanOrEqual(e) {
                    return i.compare(this, e) >= 0
                }
            }
            t.Decimal = i
        },
        38051: function(e, t, r) {
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: !0
            }), t.Uint64 = t.Uint53 = t.Uint32 = t.Int53 = t.Decimal = void 0;
            var n = r(77827);
            Object.defineProperty(t, "Decimal", {
                enumerable: !0,
                get: function() {
                    return n.Decimal
                }
            });
            var o = r(30011);
            Object.defineProperty(t, "Int53", {
                enumerable: !0,
                get: function() {
                    return o.Int53
                }
            }), Object.defineProperty(t, "Uint32", {
                enumerable: !0,
                get: function() {
                    return o.Uint32
                }
            }), Object.defineProperty(t, "Uint53", {
                enumerable: !0,
                get: function() {
                    return o.Uint53
                }
            }), Object.defineProperty(t, "Uint64", {
                enumerable: !0,
                get: function() {
                    return o.Uint64
                }
            })
        },
        30011: function(e, t, r) {
            "use strict";
            var n = this && this.__importDefault || function(e) {
                return e && e.__esModule ? e : {
                    default: e
                }
            };
            Object.defineProperty(t, "__esModule", {
                value: !0
            }), t.Uint64 = t.Uint53 = t.Int53 = t.Uint32 = void 0;
            let o = n(r(13550)),
                i = new o.default("18446744073709551615", 10, "be");
            class a {
                static fromBigEndianBytes(e) {
                    return a.fromBytes(e)
                }
                static fromBytes(e, t = "be") {
                    if (4 !== e.length) throw Error("Invalid input length. Expected 4 bytes.");
                    for (let t = 0; t < e.length; ++t)
                        if (!Number.isInteger(e[t]) || e[t] > 255 || e[t] < 0) throw Error("Invalid value in byte. Found: " + e[t]);
                    let r = "be" === t ? e : Array.from(e).reverse();
                    return new a(16777216 * r[0] + 65536 * r[1] + 256 * r[2] + r[3])
                }
                static fromString(e) {
                    if (!e.match(/^[0-9]+$/)) throw Error("Invalid string format");
                    return new a(Number.parseInt(e, 10))
                }
                constructor(e) {
                    if (Number.isNaN(e)) throw Error("Input is not a number");
                    if (!Number.isInteger(e)) throw Error("Input is not an integer");
                    if (e < 0 || e > 4294967295) throw Error("Input not in uint32 range: " + e.toString());
                    this.data = e
                }
                toBytesBigEndian() {
                    return new Uint8Array([255 & Math.floor(this.data / 16777216), 255 & Math.floor(this.data / 65536), 255 & Math.floor(this.data / 256), 255 & Math.floor(this.data / 1)])
                }
                toBytesLittleEndian() {
                    return new Uint8Array([255 & Math.floor(this.data / 1), 255 & Math.floor(this.data / 256), 255 & Math.floor(this.data / 65536), 255 & Math.floor(this.data / 16777216)])
                }
                toNumber() {
                    return this.data
                }
                toBigInt() {
                    return BigInt(this.toNumber())
                }
                toString() {
                    return this.data.toString()
                }
            }
            t.Uint32 = a;
            class s {
                static fromString(e) {
                    if (!e.match(/^-?[0-9]+$/)) throw Error("Invalid string format");
                    return new s(Number.parseInt(e, 10))
                }
                constructor(e) {
                    if (Number.isNaN(e)) throw Error("Input is not a number");
                    if (!Number.isInteger(e)) throw Error("Input is not an integer");
                    if (e < Number.MIN_SAFE_INTEGER || e > Number.MAX_SAFE_INTEGER) throw Error("Input not in int53 range: " + e.toString());
                    this.data = e
                }
                toNumber() {
                    return this.data
                }
                toBigInt() {
                    return BigInt(this.toNumber())
                }
                toString() {
                    return this.data.toString()
                }
            }
            t.Int53 = s;
            class d {
                static fromString(e) {
                    return new d(s.fromString(e).toNumber())
                }
                constructor(e) {
                    let t = new s(e);
                    if (0 > t.toNumber()) throw Error("Input is negative");
                    this.data = t
                }
                toNumber() {
                    return this.data.toNumber()
                }
                toBigInt() {
                    return BigInt(this.toNumber())
                }
                toString() {
                    return this.data.toString()
                }
            }
            t.Uint53 = d;
            class c {
                static fromBytesBigEndian(e) {
                    return c.fromBytes(e)
                }
                static fromBytes(e, t = "be") {
                    if (8 !== e.length) throw Error("Invalid input length. Expected 8 bytes.");
                    for (let t = 0; t < e.length; ++t)
                        if (!Number.isInteger(e[t]) || e[t] > 255 || e[t] < 0) throw Error("Invalid value in byte. Found: " + e[t]);
                    let r = "be" === t ? Array.from(e) : Array.from(e).reverse();
                    return new c(new o.default(r))
                }
                static fromString(e) {
                    if (!e.match(/^[0-9]+$/)) throw Error("Invalid string format");
                    return new c(new o.default(e, 10, "be"))
                }
                static fromNumber(e) {
                    let t;
                    if (Number.isNaN(e)) throw Error("Input is not a number");
                    if (!Number.isInteger(e)) throw Error("Input is not an integer");
                    try {
                        t = new o.default(e)
                    } catch {
                        throw Error("Input is not a safe integer")
                    }
                    return new c(t)
                }
                constructor(e) {
                    if (e.isNeg()) throw Error("Input is negative");
                    if (e.gt(i)) throw Error("Input exceeds uint64 range");
                    this.data = e
                }
                toBytesBigEndian() {
                    return Uint8Array.from(this.data.toArray("be", 8))
                }
                toBytesLittleEndian() {
                    return Uint8Array.from(this.data.toArray("le", 8))
                }
                toString() {
                    return this.data.toString(10)
                }
                toBigInt() {
                    return BigInt(this.toString())
                }
                toNumber() {
                    return this.data.toNumber()
                }
            }
            t.Uint64 = c
        },
        13073: function(e, t) {
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: !0
            }), t.parseCoins = void 0, t.parseCoins = function(e) {
                return e.replace(/\s/g, "").split(",").filter(Boolean).map(e => {
                    let t = e.match(/^([0-9]+)([a-zA-Z][a-zA-Z0-9/]{2,127})$/);
                    if (!t) throw Error("Got an invalid coin string");
                    return {
                        amount: t[1].replace(/^0+/, "") || "0",
                        denom: t[2]
                    }
                })
            }
        },
        38123: function(e, t, r) {
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: !0
            }), t.decodeTxRaw = void 0;
            let n = r(93739);
            t.decodeTxRaw = function(e) {
                let t = n.TxRaw.decode(e);
                return {
                    authInfo: n.AuthInfo.decode(t.authInfoBytes),
                    body: n.TxBody.decode(t.bodyBytes),
                    signatures: t.signatures
                }
            }
        },
        22467: function(e, t, r) {
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: !0
            }), t.DirectSecp256k1HdWallet = t.extractKdfConfiguration = void 0;
            let n = r(68683),
                o = r(56257),
                i = r(15050),
                a = r(93337),
                s = r(72126),
                d = r(79667),
                c = "directsecp256k1hdwallet-v1",
                l = {
                    algorithm: "argon2id",
                    params: {
                        outputLength: 32,
                        opsLimit: 24,
                        memLimitKib: 12288
                    }
                };
            t.extractKdfConfiguration = function(e) {
                let t = JSON.parse(e);
                if (!(0, a.isNonNullObject)(t)) throw Error("Root document is not an object.");
                if (t.type === c) return t.kdf;
                throw Error("Unsupported serialization type")
            };
            let u = {
                bip39Password: "",
                hdPaths: [(0, n.makeCosmoshubPath)(0)],
                prefix: "cosmos"
            };
            class p {
                static async fromMnemonic(e, t = {}) {
                    let r = new o.EnglishMnemonic(e),
                        n = await o.Bip39.mnemonicToSeed(r, t.bip39Password);
                    return new p(r, { ...t,
                        seed: n
                    })
                }
                static async generate(e = 12, t = {}) {
                    let r = o.Random.getBytes(4 * Math.floor(11 * e / 33)),
                        n = o.Bip39.encode(r);
                    return p.fromMnemonic(n.toString(), t)
                }
                static async deserialize(e, t) {
                    let r = JSON.parse(e);
                    if (!(0, a.isNonNullObject)(r)) throw Error("Root document is not an object.");
                    if (r.type === c) return p.deserializeTypeV1(e, t);
                    throw Error("Unsupported serialization type")
                }
                static async deserializeWithEncryptionKey(e, t) {
                    let r = JSON.parse(e);
                    if (!(0, a.isNonNullObject)(r)) throw Error("Root document is not an object.");
                    if (r.type === c) {
                        let e = await (0, d.decrypt)((0, i.fromBase64)(r.data), t, r.encryption),
                            {
                                mnemonic: n,
                                accounts: s
                            } = JSON.parse((0, i.fromUtf8)(e));
                        if ((0, a.assert)("string" == typeof n), !Array.isArray(s)) throw Error("Property 'accounts' is not an array");
                        if (!s.every(e => !!(0, a.isNonNullObject)(e) && "string" == typeof e.hdPath && "string" == typeof e.prefix)) throw Error("Account is not in the correct format.");
                        let c = s[0].prefix;
                        if (!s.every(({
                                prefix: e
                            }) => e === c)) throw Error("Accounts do not all have the same prefix");
                        let l = s.map(({
                            hdPath: e
                        }) => (0, o.stringToPath)(e));
                        return p.fromMnemonic(n, {
                            hdPaths: l,
                            prefix: c
                        })
                    }
                    throw Error("Unsupported serialization type")
                }
                static async deserializeTypeV1(e, t) {
                    let r = JSON.parse(e);
                    if (!(0, a.isNonNullObject)(r)) throw Error("Root document is not an object.");
                    let n = await (0, d.executeKdf)(t, r.kdf);
                    return p.deserializeWithEncryptionKey(e, n)
                }
                constructor(e, t) {
                    let r = t.prefix ? ? u.prefix,
                        n = t.hdPaths ? ? u.hdPaths;
                    this.secret = e, this.seed = t.seed, this.accounts = n.map(e => ({
                        hdPath: e,
                        prefix: r
                    }))
                }
                get mnemonic() {
                    return this.secret.toString()
                }
                async getAccounts() {
                    return (await this.getAccountsWithPrivkeys()).map(({
                        algo: e,
                        pubkey: t,
                        address: r
                    }) => ({
                        algo: e,
                        pubkey: t,
                        address: r
                    }))
                }
                async signDirect(e, t) {
                    let r = (await this.getAccountsWithPrivkeys()).find(({
                        address: t
                    }) => t === e);
                    if (void 0 === r) throw Error(`Address ${e} not found in wallet`);
                    let {
                        privkey: i,
                        pubkey: a
                    } = r, d = (0, s.makeSignBytes)(t), c = (0, o.sha256)(d), l = await o.Secp256k1.createSignature(c, i), u = new Uint8Array([...l.r(32), ...l.s(32)]);
                    return {
                        signed: t,
                        signature: (0, n.encodeSecp256k1Signature)(a, u)
                    }
                }
                async serialize(e) {
                    let t = await (0, d.executeKdf)(e, l);
                    return this.serializeWithEncryptionKey(t, l)
                }
                async serializeWithEncryptionKey(e, t) {
                    let r = {
                            mnemonic: this.mnemonic,
                            accounts: this.accounts.map(({
                                hdPath: e,
                                prefix: t
                            }) => ({
                                hdPath: (0, o.pathToString)(e),
                                prefix: t
                            }))
                        },
                        n = (0, i.toUtf8)(JSON.stringify(r)),
                        a = {
                            algorithm: d.supportedAlgorithms.xchacha20poly1305Ietf
                        },
                        s = await (0, d.encrypt)(n, e, a);
                    return JSON.stringify({
                        type: c,
                        kdf: t,
                        encryption: a,
                        data: (0, i.toBase64)(s)
                    })
                }
                async getKeyPair(e) {
                    let {
                        privkey: t
                    } = o.Slip10.derivePath(o.Slip10Curve.Secp256k1, this.seed, e), {
                        pubkey: r
                    } = await o.Secp256k1.makeKeypair(t);
                    return {
                        privkey: t,
                        pubkey: o.Secp256k1.compressPubkey(r)
                    }
                }
                async getAccountsWithPrivkeys() {
                    return Promise.all(this.accounts.map(async ({
                        hdPath: e,
                        prefix: t
                    }) => {
                        let {
                            privkey: r,
                            pubkey: o
                        } = await this.getKeyPair(e), a = (0, i.toBech32)(t, (0, n.rawSecp256k1PubkeyToRawAddress)(o));
                        return {
                            algo: "secp256k1",
                            privkey: r,
                            pubkey: o,
                            address: a
                        }
                    }))
                }
            }
            t.DirectSecp256k1HdWallet = p
        },
        38910: function(e, t, r) {
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: !0
            }), t.DirectSecp256k1Wallet = void 0;
            let n = r(68683),
                o = r(56257),
                i = r(15050),
                a = r(72126);
            class s {
                static async fromKey(e, t = "cosmos") {
                    let r = (await o.Secp256k1.makeKeypair(e)).pubkey;
                    return new s(e, o.Secp256k1.compressPubkey(r), t)
                }
                constructor(e, t, r) {
                    this.privkey = e, this.pubkey = t, this.prefix = r
                }
                get address() {
                    return (0, i.toBech32)(this.prefix, (0, n.rawSecp256k1PubkeyToRawAddress)(this.pubkey))
                }
                async getAccounts() {
                    return [{
                        algo: "secp256k1",
                        address: this.address,
                        pubkey: this.pubkey
                    }]
                }
                async signDirect(e, t) {
                    let r = (0, a.makeSignBytes)(t);
                    if (e !== this.address) throw Error(`Address ${e} not found in wallet`);
                    let i = (0, o.sha256)(r),
                        s = await o.Secp256k1.createSignature(i, this.privkey),
                        d = new Uint8Array([...s.r(32), ...s.s(32)]);
                    return {
                        signed: t,
                        signature: (0, n.encodeSecp256k1Signature)(this.pubkey, d)
                    }
                }
            }
            t.DirectSecp256k1Wallet = s
        },
        39712: function(e, t, r) {
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: !0
            }), t.coins = t.coin = t.executeKdf = t.makeSignDoc = t.makeSignBytes = t.makeAuthInfoBytes = t.isOfflineDirectSigner = t.Registry = t.isTxBodyEncodeObject = t.isTsProtoGeneratedType = t.isPbjsGeneratedType = t.encodePubkey = t.decodePubkey = t.decodeOptionalPubkey = t.anyToSinglePubkey = t.makeCosmoshubPath = t.DirectSecp256k1Wallet = t.extractKdfConfiguration = t.DirectSecp256k1HdWallet = t.decodeTxRaw = t.parseCoins = void 0;
            var n = r(13073);
            Object.defineProperty(t, "parseCoins", {
                enumerable: !0,
                get: function() {
                    return n.parseCoins
                }
            });
            var o = r(38123);
            Object.defineProperty(t, "decodeTxRaw", {
                enumerable: !0,
                get: function() {
                    return o.decodeTxRaw
                }
            });
            var i = r(22467);
            Object.defineProperty(t, "DirectSecp256k1HdWallet", {
                enumerable: !0,
                get: function() {
                    return i.DirectSecp256k1HdWallet
                }
            }), Object.defineProperty(t, "extractKdfConfiguration", {
                enumerable: !0,
                get: function() {
                    return i.extractKdfConfiguration
                }
            });
            var a = r(38910);
            Object.defineProperty(t, "DirectSecp256k1Wallet", {
                enumerable: !0,
                get: function() {
                    return a.DirectSecp256k1Wallet
                }
            });
            var s = r(41790);
            Object.defineProperty(t, "makeCosmoshubPath", {
                enumerable: !0,
                get: function() {
                    return s.makeCosmoshubPath
                }
            });
            var d = r(77743);
            Object.defineProperty(t, "anyToSinglePubkey", {
                enumerable: !0,
                get: function() {
                    return d.anyToSinglePubkey
                }
            }), Object.defineProperty(t, "decodeOptionalPubkey", {
                enumerable: !0,
                get: function() {
                    return d.decodeOptionalPubkey
                }
            }), Object.defineProperty(t, "decodePubkey", {
                enumerable: !0,
                get: function() {
                    return d.decodePubkey
                }
            }), Object.defineProperty(t, "encodePubkey", {
                enumerable: !0,
                get: function() {
                    return d.encodePubkey
                }
            });
            var c = r(64555);
            Object.defineProperty(t, "isPbjsGeneratedType", {
                enumerable: !0,
                get: function() {
                    return c.isPbjsGeneratedType
                }
            }), Object.defineProperty(t, "isTsProtoGeneratedType", {
                enumerable: !0,
                get: function() {
                    return c.isTsProtoGeneratedType
                }
            }), Object.defineProperty(t, "isTxBodyEncodeObject", {
                enumerable: !0,
                get: function() {
                    return c.isTxBodyEncodeObject
                }
            }), Object.defineProperty(t, "Registry", {
                enumerable: !0,
                get: function() {
                    return c.Registry
                }
            });
            var l = r(30192);
            Object.defineProperty(t, "isOfflineDirectSigner", {
                enumerable: !0,
                get: function() {
                    return l.isOfflineDirectSigner
                }
            });
            var u = r(72126);
            Object.defineProperty(t, "makeAuthInfoBytes", {
                enumerable: !0,
                get: function() {
                    return u.makeAuthInfoBytes
                }
            }), Object.defineProperty(t, "makeSignBytes", {
                enumerable: !0,
                get: function() {
                    return u.makeSignBytes
                }
            }), Object.defineProperty(t, "makeSignDoc", {
                enumerable: !0,
                get: function() {
                    return u.makeSignDoc
                }
            });
            var p = r(79667);
            Object.defineProperty(t, "executeKdf", {
                enumerable: !0,
                get: function() {
                    return p.executeKdf
                }
            });
            var m = r(68683);
            Object.defineProperty(t, "coin", {
                enumerable: !0,
                get: function() {
                    return m.coin
                }
            }), Object.defineProperty(t, "coins", {
                enumerable: !0,
                get: function() {
                    return m.coins
                }
            })
        },
        41790: function(e, t, r) {
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: !0
            }), t.makeCosmoshubPath = void 0;
            let n = r(56257);
            t.makeCosmoshubPath = function(e) {
                return [n.Slip10RawIndex.hardened(44), n.Slip10RawIndex.hardened(118), n.Slip10RawIndex.hardened(0), n.Slip10RawIndex.normal(0), n.Slip10RawIndex.normal(e)]
            }
        },
        77743: function(e, t, r) {
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: !0
            }), t.decodeOptionalPubkey = t.decodePubkey = t.anyToSinglePubkey = t.encodePubkey = void 0;
            let n = r(68683),
                o = r(15050),
                i = r(38051),
                a = r(8196),
                s = r(99679),
                d = r(27918),
                c = r(65676);

            function l(e) {
                switch (e.typeUrl) {
                    case "/cosmos.crypto.secp256k1.PubKey":
                        {
                            let {
                                key: t
                            } = d.PubKey.decode(e.value);
                            return (0, n.encodeSecp256k1Pubkey)(t)
                        }
                    case "/cosmos.crypto.ed25519.PubKey":
                        {
                            let {
                                key: t
                            } = a.PubKey.decode(e.value);
                            return (0, n.encodeEd25519Pubkey)(t)
                        }
                    default:
                        throw Error(`Pubkey type_url ${e.typeUrl} not recognized as single public key type`)
                }
            }

            function u(e) {
                switch (e.typeUrl) {
                    case "/cosmos.crypto.secp256k1.PubKey":
                    case "/cosmos.crypto.ed25519.PubKey":
                        return l(e);
                    case "/cosmos.crypto.multisig.LegacyAminoPubKey":
                        {
                            let {
                                threshold: t,
                                publicKeys: r
                            } = s.LegacyAminoPubKey.decode(e.value);
                            return {
                                type: "tendermint/PubKeyMultisigThreshold",
                                value: {
                                    threshold: t.toString(),
                                    pubkeys: r.map(l)
                                }
                            }
                        }
                    default:
                        throw Error(`Pubkey type URL '${e.typeUrl}' not recognized`)
                }
            }
            t.encodePubkey = function e(t) {
                if ((0, n.isSecp256k1Pubkey)(t)) {
                    let e = d.PubKey.fromPartial({
                        key: (0, o.fromBase64)(t.value)
                    });
                    return c.Any.fromPartial({
                        typeUrl: "/cosmos.crypto.secp256k1.PubKey",
                        value: Uint8Array.from(d.PubKey.encode(e).finish())
                    })
                }
                if ((0, n.isEd25519Pubkey)(t)) {
                    let e = a.PubKey.fromPartial({
                        key: (0, o.fromBase64)(t.value)
                    });
                    return c.Any.fromPartial({
                        typeUrl: "/cosmos.crypto.ed25519.PubKey",
                        value: Uint8Array.from(a.PubKey.encode(e).finish())
                    })
                }
                if ((0, n.isMultisigThresholdPubkey)(t)) {
                    let r = s.LegacyAminoPubKey.fromPartial({
                        threshold: i.Uint53.fromString(t.value.threshold).toNumber(),
                        publicKeys: t.value.pubkeys.map(e)
                    });
                    return c.Any.fromPartial({
                        typeUrl: "/cosmos.crypto.multisig.LegacyAminoPubKey",
                        value: Uint8Array.from(s.LegacyAminoPubKey.encode(r).finish())
                    })
                }
                throw Error(`Pubkey type ${t.type} not recognized`)
            }, t.anyToSinglePubkey = l, t.decodePubkey = u, t.decodeOptionalPubkey = function(e) {
                if (!e) return null;
                if (e.typeUrl) {
                    if (e.value.length) return u(e);
                    throw Error(`Pubkey is an Any with type URL '${e.typeUrl}' but an empty value`)
                }
                if (!e.value.length) return null;
                throw Error("Pubkey is an Any with an empty type URL but a value set")
            }
        },
        64555: function(e, t, r) {
            "use strict";
            var n = r(48764).Buffer;
            Object.defineProperty(t, "__esModule", {
                value: !0
            }), t.Registry = t.isTxBodyEncodeObject = t.isPbjsGeneratedType = t.isTsProtoGeneratedType = t.isTelescopeGeneratedType = void 0;
            let o = r(64395),
                i = r(62809),
                a = r(93739),
                s = r(65676);

            function d(e) {
                return "function" == typeof e.fromPartial && "string" == typeof e.typeUrl
            }

            function c(e) {
                return "function" == typeof e.fromPartial
            }
            t.isTelescopeGeneratedType = d, t.isTsProtoGeneratedType = c, t.isPbjsGeneratedType = function(e) {
                return !c(e)
            };
            let l = {
                cosmosCoin: "/cosmos.base.v1beta1.Coin",
                cosmosMsgSend: "/cosmos.bank.v1beta1.MsgSend",
                cosmosTxBody: "/cosmos.tx.v1beta1.TxBody",
                googleAny: "/google.protobuf.Any"
            };

            function u(e) {
                return "/cosmos.tx.v1beta1.TxBody" === e.typeUrl
            }
            t.isTxBodyEncodeObject = u;
            class p {
                constructor(e) {
                    let {
                        cosmosCoin: t,
                        cosmosMsgSend: r
                    } = l;
                    this.types = new Map(e ? [...e] : [
                        [t, i.Coin],
                        [r, o.MsgSend]
                    ])
                }
                register(e, t) {
                    this.types.set(e, t)
                }
                lookupType(e) {
                    return this.types.get(e)
                }
                lookupTypeWithError(e) {
                    let t = this.lookupType(e);
                    if (!t) throw Error(`Unregistered type url: ${e}`);
                    return t
                }
                encode(e) {
                    let {
                        value: t,
                        typeUrl: r
                    } = e;
                    if (u(e)) return this.encodeTxBody(t);
                    let n = this.lookupTypeWithError(r),
                        o = d(n) || c(n) ? n.fromPartial(t) : n.create(t);
                    return n.encode(o).finish()
                }
                encodeAsAny(e) {
                    let t = this.encode(e);
                    return s.Any.fromPartial({
                        typeUrl: e.typeUrl,
                        value: t
                    })
                }
                encodeTxBody(e) {
                    let t = e.messages.map(e => this.encodeAsAny(e)),
                        r = a.TxBody.fromPartial({ ...e,
                            timeoutHeight: BigInt(e.timeoutHeight ? .toString() ? ? "0"),
                            messages: t
                        });
                    return a.TxBody.encode(r).finish()
                }
                decode({
                    typeUrl: e,
                    value: t
                }) {
                    if (e === l.cosmosTxBody) return this.decodeTxBody(t);
                    let r = this.lookupTypeWithError(e).decode(t);
                    return Object.entries(r).forEach(([e, t]) => {
                        void 0 !== n && void 0 !== n.isBuffer && n.isBuffer(t) && (r[e] = Uint8Array.from(t))
                    }), r
                }
                decodeTxBody(e) {
                    let t = a.TxBody.decode(e);
                    return { ...t,
                        messages: t.messages.map(({
                            typeUrl: e,
                            value: t
                        }) => {
                            if (!e) throw Error("Missing type_url in Any");
                            if (!t) throw Error("Missing value in Any");
                            return this.decode({
                                typeUrl: e,
                                value: t
                            })
                        })
                    }
                }
            }
            t.Registry = p
        },
        30192: function(e, t) {
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: !0
            }), t.isOfflineDirectSigner = void 0, t.isOfflineDirectSigner = function(e) {
                return void 0 !== e.signDirect
            }
        },
        72126: function(e, t, r) {
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: !0
            }), t.makeSignBytes = t.makeSignDoc = t.makeAuthInfoBytes = void 0;
            let n = r(93337),
                o = r(43062),
                i = r(93739);
            t.makeAuthInfoBytes = function(e, t, r, a, s, d = o.SignMode.SIGN_MODE_DIRECT) {
                (0, n.assert)(void 0 === a || "string" == typeof a, "feeGranter must be undefined or string"), (0, n.assert)(void 0 === s || "string" == typeof s, "feePayer must be undefined or string");
                let c = i.AuthInfo.fromPartial({
                    signerInfos: e.map(({
                        pubkey: e,
                        sequence: t
                    }) => ({
                        publicKey: e,
                        modeInfo: {
                            single: {
                                mode: d
                            }
                        },
                        sequence: BigInt(t)
                    })),
                    fee: {
                        amount: [...t],
                        gasLimit: BigInt(r),
                        granter: a,
                        payer: s
                    }
                });
                return i.AuthInfo.encode(c).finish()
            }, t.makeSignDoc = function(e, t, r, n) {
                return {
                    bodyBytes: e,
                    authInfoBytes: t,
                    chainId: r,
                    accountNumber: BigInt(n)
                }
            }, t.makeSignBytes = function({
                accountNumber: e,
                authInfoBytes: t,
                bodyBytes: r,
                chainId: n
            }) {
                let o = i.SignDoc.fromPartial({
                    accountNumber: e,
                    authInfoBytes: t,
                    bodyBytes: r,
                    chainId: n
                });
                return i.SignDoc.encode(o).finish()
            }
        },
        79667: function(e, t, r) {
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: !0
            }), t.decrypt = t.encrypt = t.supportedAlgorithms = t.executeKdf = t.cosmjsSalt = void 0;
            let n = r(56257),
                o = r(15050);
            async function i(e, r) {
                if ("argon2id" === r.algorithm) {
                    let o = r.params;
                    if (!(0, n.isArgon2idOptions)(o)) throw Error("Invalid format of argon2id params");
                    return n.Argon2id.execute(e, t.cosmjsSalt, o)
                }
                throw Error("Unsupported KDF algorithm")
            }
            async function a(e, r, o) {
                if (o.algorithm === t.supportedAlgorithms.xchacha20poly1305Ietf) {
                    let t = n.Random.getBytes(n.xchacha20NonceLength);
                    return new Uint8Array([...t, ...await n.Xchacha20poly1305Ietf.encrypt(e, r, t)])
                }
                throw Error(`Unsupported encryption algorithm: '${o.algorithm}'`)
            }
            async function s(e, r, o) {
                if (o.algorithm === t.supportedAlgorithms.xchacha20poly1305Ietf) {
                    let t = e.slice(0, n.xchacha20NonceLength);
                    return n.Xchacha20poly1305Ietf.decrypt(e.slice(n.xchacha20NonceLength), r, t)
                }
                throw Error(`Unsupported encryption algorithm: '${o.algorithm}'`)
            }
            t.cosmjsSalt = (0, o.toAscii)("The CosmJS salt."), t.executeKdf = i, t.supportedAlgorithms = {
                xchacha20poly1305Ietf: "xchacha20poly1305-ietf"
            }, t.encrypt = a, t.decrypt = s
        },
        19998: function(e, t, r) {
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: !0
            }), t.StreamingSocket = t.SocketWrapper = t.ReconnectingSocket = t.QueueingStreamingSocket = t.ConnectionStatus = void 0;
            var n = r(55720);
            Object.defineProperty(t, "ConnectionStatus", {
                enumerable: !0,
                get: function() {
                    return n.ConnectionStatus
                }
            }), Object.defineProperty(t, "QueueingStreamingSocket", {
                enumerable: !0,
                get: function() {
                    return n.QueueingStreamingSocket
                }
            });
            var o = r(71174);
            Object.defineProperty(t, "ReconnectingSocket", {
                enumerable: !0,
                get: function() {
                    return o.ReconnectingSocket
                }
            });
            var i = r(68919);
            Object.defineProperty(t, "SocketWrapper", {
                enumerable: !0,
                get: function() {
                    return i.SocketWrapper
                }
            });
            var a = r(44207);
            Object.defineProperty(t, "StreamingSocket", {
                enumerable: !0,
                get: function() {
                    return a.StreamingSocket
                }
            })
        },
        55720: function(e, t, r) {
            "use strict";
            var n, o;
            Object.defineProperty(t, "__esModule", {
                value: !0
            }), t.QueueingStreamingSocket = t.ConnectionStatus = void 0;
            let i = r(67298),
                a = r(43813),
                s = r(44207);
            (o = n = t.ConnectionStatus || (t.ConnectionStatus = {}))[o.Unconnected = 0] = "Unconnected", o[o.Connecting = 1] = "Connecting", o[o.Connected = 2] = "Connected", o[o.Disconnected = 3] = "Disconnected";
            class d {
                constructor(e, t = 1e4, r) {
                    this.queue = [], this.isProcessingQueue = !1, this.url = e, this.timeout = t, this.reconnectedHandler = r, this.events = a.Stream.create({
                        start: e => this.eventProducerListener = e,
                        stop: () => this.eventProducerListener = void 0
                    }), this.connectionStatusProducer = new i.DefaultValueProducer(n.Unconnected), this.connectionStatus = new i.ValueAndUpdates(this.connectionStatusProducer), this.socket = new s.StreamingSocket(this.url, this.timeout), this.socket.events.subscribe({
                        next: e => {
                            if (!this.eventProducerListener) throw Error("No event producer listener set");
                            this.eventProducerListener.next(e)
                        },
                        error: () => this.connectionStatusProducer.update(n.Disconnected)
                    })
                }
                connect() {
                    this.connectionStatusProducer.update(n.Connecting), this.socket.connected.then(async () => (this.connectionStatusProducer.update(n.Connected), this.processQueue()), () => this.connectionStatusProducer.update(n.Disconnected)), this.socket.connect()
                }
                disconnect() {
                    this.connectionStatusProducer.update(n.Disconnected), this.socket.disconnect()
                }
                reconnect() {
                    this.socket = new s.StreamingSocket(this.url, this.timeout), this.socket.events.subscribe({
                        next: e => {
                            if (!this.eventProducerListener) throw Error("No event producer listener set");
                            this.eventProducerListener.next(e)
                        },
                        error: () => this.connectionStatusProducer.update(n.Disconnected)
                    }), this.socket.connected.then(() => {
                        this.reconnectedHandler && this.reconnectedHandler()
                    }), this.connect()
                }
                getQueueLength() {
                    return this.queue.length
                }
                queueRequest(e) {
                    this.queue.push(e), this.processQueue()
                }
                async processQueue() {
                    let e;
                    if (!this.isProcessingQueue && this.connectionStatus.value === n.Connected)
                        for (this.isProcessingQueue = !0; e = this.queue.shift();) try {
                            await this.socket.send(e), this.isProcessingQueue = !1
                        } catch (t) {
                            this.queue.unshift(e), this.isProcessingQueue = !1;
                            return
                        }
                }
            }
            t.QueueingStreamingSocket = d
        },
        71174: function(e, t, r) {
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: !0
            }), t.ReconnectingSocket = void 0;
            let n = r(43813),
                o = r(55720);
            class i {
                static calculateTimeout(e) {
                    return Math.min(2 ** e * 100, 5e3)
                }
                constructor(e, t = 1e4, r) {
                    this.unconnected = !0, this.disconnected = !1, this.timeoutIndex = 0, this.reconnectTimeout = null, this.events = n.Stream.create({
                        start: e => this.eventProducerListener = e,
                        stop: () => this.eventProducerListener = void 0
                    }), this.socket = new o.QueueingStreamingSocket(e, t, r), this.socket.events.subscribe({
                        next: e => {
                            this.eventProducerListener && this.eventProducerListener.next(e)
                        },
                        error: e => {
                            this.eventProducerListener && this.eventProducerListener.error(e)
                        }
                    }), this.connectionStatus = this.socket.connectionStatus, this.connectionStatus.updates.subscribe({
                        next: e => {
                            e === o.ConnectionStatus.Connected && (this.timeoutIndex = 0), e === o.ConnectionStatus.Disconnected && (this.reconnectTimeout && (clearTimeout(this.reconnectTimeout), this.reconnectTimeout = null), this.reconnectTimeout = setTimeout(() => this.socket.reconnect(), i.calculateTimeout(this.timeoutIndex++)))
                        }
                    })
                }
                connect() {
                    if (!this.unconnected) throw Error("Cannot connect: socket has already connected");
                    this.socket.connect(), this.unconnected = !1
                }
                disconnect() {
                    if (this.unconnected) throw Error("Cannot disconnect: socket has not yet connected");
                    this.socket.disconnect(), this.eventProducerListener && this.eventProducerListener.complete(), this.disconnected = !0
                }
                queueRequest(e) {
                    if (this.disconnected) throw Error("Cannot queue request: socket has disconnected");
                    this.socket.queueRequest(e)
                }
            }
            t.ReconnectingSocket = i
        },
        68919: function(e, t, r) {
            "use strict";
            var n = r(34155),
                o = this && this.__importDefault || function(e) {
                    return e && e.__esModule ? e : {
                        default: e
                    }
                };
            Object.defineProperty(t, "__esModule", {
                value: !0
            }), t.SocketWrapper = void 0;
            let i = o(r(46792));
            class a {
                constructor(e, t, r, n, o, i = 1e4) {
                    this.closed = !1, this.connected = new Promise((e, t) => {
                        this.connectedResolver = e, this.connectedRejecter = t
                    }), this.url = e, this.messageHandler = t, this.errorHandler = r, this.openHandler = n, this.closeHandler = o, this.timeout = i
                }
                connect() {
                    let e = new i.default(this.url);
                    e.onerror = e => {
                        this.clearTimeout(), this.errorHandler && this.errorHandler(e)
                    }, e.onmessage = e => {
                        this.messageHandler({
                            type: e.type,
                            data: e.data
                        })
                    }, e.onopen = e => {
                        this.clearTimeout(), this.connectedResolver(), this.openHandler && this.openHandler()
                    }, e.onclose = e => {
                        this.closed = !0, this.closeHandler && this.closeHandler(e)
                    };
                    let t = Date.now();
                    this.timeoutId = setTimeout(() => {
                        e.onmessage = () => 0, e.onerror = () => 0, e.onopen = () => 0, e.onclose = () => 0, e.close(), this.socket = void 0;
                        let r = Math.floor(Date.now() - t);
                        this.connectedRejecter(`Connection attempt timed out after ${r} ms`)
                    }, this.timeout), this.socket = e
                }
                disconnect() {
                    if (!this.socket) throw Error("Socket undefined. This must be called after connecting.");
                    switch (this.clearTimeout(), this.socket.readyState) {
                        case i.default.OPEN:
                            this.socket.close(1e3);
                            break;
                        case i.default.CLOSED:
                            break;
                        case i.default.CONNECTING:
                            this.socket.onopen = () => 0, this.socket.onclose = () => 0, this.socket.onerror = () => 0, this.socket.onmessage = () => 0, this.socket = void 0, this.closeHandler && this.closeHandler({
                                wasClean: !1,
                                code: 4001
                            });
                            break;
                        case i.default.CLOSING:
                            break;
                        default:
                            throw Error(`Unknown readyState: ${this.socket.readyState}`)
                    }
                }
                async send(e) {
                    return new Promise((t, r) => {
                        if (!this.socket) throw Error("Socket undefined. This must be called after connecting.");
                        if (this.closed) throw Error("Socket was closed, so no data can be sent anymore.");
                        if (this.socket.readyState !== i.default.OPEN) throw Error("Websocket is not open");
                        void 0 !== n && void 0 !== n.versions && void 0 !== n.versions.node ? this.socket.send(e, e => e ? r(e) : t()) : (this.socket.send(e), t())
                    })
                }
                clearTimeout() {
                    if (!this.timeoutId) throw Error("Timeout ID not set. This should not happen and usually means connect() was not called.");
                    clearTimeout(this.timeoutId)
                }
            }
            t.SocketWrapper = a
        },
        44207: function(e, t, r) {
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: !0
            }), t.StreamingSocket = void 0;
            let n = r(43813),
                o = r(68919);
            class i {
                constructor(e, t = 1e4) {
                    this.socket = new o.SocketWrapper(e, e => {
                        this.eventProducerListener && this.eventProducerListener.next(e)
                    }, e => {
                        this.eventProducerListener && this.eventProducerListener.error(e)
                    }, () => {}, e => {
                        this.eventProducerListener && (e.wasClean ? this.eventProducerListener.complete() : this.eventProducerListener.error("Socket was closed unclean"))
                    }, t), this.connected = this.socket.connected, this.events = n.Stream.create({
                        start: e => this.eventProducerListener = e,
                        stop: () => this.eventProducerListener = void 0
                    })
                }
                connect() {
                    this.socket.connect()
                }
                disconnect() {
                    this.socket.disconnect()
                }
                async send(e) {
                    return this.socket.send(e)
                }
            }
            t.StreamingSocket = i
        },
        87626: function(e, t, r) {
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: !0
            }), t.concat = void 0;
            let n = r(43813);
            t.concat = function(...e) {
                let t = [],
                    r = [],
                    o = new Set,
                    i = 0;

                function a() {
                    for (; t.length > 0;) t.shift().unsubscribe();
                    r.length = 0, o.clear(), i = 0
                }
                return n.Stream.create({
                    start: n => {
                        function s(e) {
                            for (;;) {
                                let t = r[e].shift();
                                if (void 0 === t) return;
                                n.next(t)
                            }
                        }

                        function d() {
                            return i >= e.length
                        }
                        if (e.forEach(e => r.push([])), d()) {
                            n.complete();
                            return
                        }
                        e.forEach((e, c) => {
                            t.push(e.subscribe({
                                next: e => {
                                    c === i ? n.next(e) : r[c].push(e)
                                },
                                complete: () => {
                                    for (o.add(c); o.has(i);) s(i), i++;
                                    d() ? n.complete() : s(i)
                                },
                                error: e => {
                                    n.error(e), a()
                                }
                            }))
                        })
                    },
                    stop: () => {
                        a()
                    }
                })
            }
        },
        69226: function(e, t) {
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: !0
            }), t.DefaultValueProducer = void 0;
            class r {
                get value() {
                    return this.internalValue
                }
                constructor(e, t) {
                    this.callbacks = t, this.internalValue = e
                }
                update(e) {
                    this.internalValue = e, this.listener && this.listener.next(e)
                }
                error(e) {
                    this.listener && this.listener.error(e)
                }
                start(e) {
                    this.listener = e, e.next(this.internalValue), this.callbacks && this.callbacks.onStarted()
                }
                stop() {
                    this.callbacks && this.callbacks.onStop(), this.listener = void 0
                }
            }
            t.DefaultValueProducer = r
        },
        69043: function(e, t) {
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: !0
            }), t.dropDuplicates = void 0, t.dropDuplicates = function(e) {
                return t => {
                    let r = new Set;
                    return t.filter(t => !r.has(e(t))).debug(t => r.add(e(t)))
                }
            }
        },
        67298: function(e, t, r) {
            "use strict";
            var n = this && this.__createBinding || (Object.create ? function(e, t, r, n) {
                    void 0 === n && (n = r);
                    var o = Object.getOwnPropertyDescriptor(t, r);
                    (!o || ("get" in o ? !t.__esModule : o.writable || o.configurable)) && (o = {
                        enumerable: !0,
                        get: function() {
                            return t[r]
                        }
                    }), Object.defineProperty(e, n, o)
                } : function(e, t, r, n) {
                    void 0 === n && (n = r), e[n] = t[r]
                }),
                o = this && this.__exportStar || function(e, t) {
                    for (var r in e) "default" === r || Object.prototype.hasOwnProperty.call(t, r) || n(t, e, r)
                };
            Object.defineProperty(t, "__esModule", {
                value: !0
            }), t.ValueAndUpdates = t.toListPromise = t.fromListPromise = t.firstEvent = t.dropDuplicates = t.DefaultValueProducer = t.concat = void 0;
            var i = r(87626);
            Object.defineProperty(t, "concat", {
                enumerable: !0,
                get: function() {
                    return i.concat
                }
            });
            var a = r(69226);
            Object.defineProperty(t, "DefaultValueProducer", {
                enumerable: !0,
                get: function() {
                    return a.DefaultValueProducer
                }
            });
            var s = r(69043);
            Object.defineProperty(t, "dropDuplicates", {
                enumerable: !0,
                get: function() {
                    return s.dropDuplicates
                }
            });
            var d = r(99511);
            Object.defineProperty(t, "firstEvent", {
                enumerable: !0,
                get: function() {
                    return d.firstEvent
                }
            }), Object.defineProperty(t, "fromListPromise", {
                enumerable: !0,
                get: function() {
                    return d.fromListPromise
                }
            }), Object.defineProperty(t, "toListPromise", {
                enumerable: !0,
                get: function() {
                    return d.toListPromise
                }
            }), o(r(40721), t);
            var c = r(89780);
            Object.defineProperty(t, "ValueAndUpdates", {
                enumerable: !0,
                get: function() {
                    return c.ValueAndUpdates
                }
            })
        },
        99511: function(e, t, r) {
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: !0
            }), t.firstEvent = t.toListPromise = t.fromListPromise = void 0;
            let n = r(43813);
            async function o(e, t) {
                return new Promise((r, n) => {
                    if (0 === t) {
                        r([]);
                        return
                    }
                    let o = [];
                    e.take(t).subscribe({
                        next: e => {
                            o.push(e), o.length === t && r(o)
                        },
                        complete: () => {
                            n(`Stream completed before all events could be collected. Collected ${o.length}, expected ${t}`)
                        },
                        error: e => n(e)
                    })
                })
            }
            async function i(e) {
                return (await o(e, 1))[0]
            }
            t.fromListPromise = function(e) {
                return n.Stream.create({
                    start: t => {
                        e.then(e => {
                            for (let r of e) t.next(r);
                            t.complete()
                        }).catch(e => t.error(e))
                    },
                    stop: () => {}
                })
            }, t.toListPromise = o, t.firstEvent = i
        },
        40721: function(e, t) {
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: !0
            }), t.lastValue = t.asArray = t.countStream = t.Reducer = void 0;
            class r {
                constructor(e, t, r) {
                    this.stream = e, this.reducer = t, this.state = r, this.completed = new Promise((e, t) => {
                        let r = this.stream.subscribe({
                            next: e => {
                                this.state = this.reducer(this.state, e)
                            },
                            complete: () => {
                                e(), r.unsubscribe()
                            },
                            error: e => {
                                t(e), r.unsubscribe()
                            }
                        })
                    })
                }
                value() {
                    return this.state
                }
                async finished() {
                    return this.completed
                }
            }

            function n(e, t) {
                return e + 1
            }

            function o(e, t) {
                return [...e, t]
            }

            function i(e, t) {
                return t
            }
            t.Reducer = r, t.countStream = function(e) {
                return new r(e, n, 0)
            }, t.asArray = function(e) {
                return new r(e, o, [])
            }, t.lastValue = function(e) {
                return new r(e, i, void 0)
            }
        },
        89780: function(e, t, r) {
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: !0
            }), t.ValueAndUpdates = void 0;
            let n = r(43813);
            class o {
                get value() {
                    return this.producer.value
                }
                constructor(e) {
                    this.producer = e, this.updates = n.MemoryStream.createWithMemory(this.producer)
                }
                async waitFor(e) {
                    let t = "function" == typeof e ? e : t => t === e;
                    return new Promise((e, r) => {
                        let n = this.updates.subscribe({
                            next: r => {
                                t(r) && (e(r), setTimeout(() => n.unsubscribe(), 0))
                            },
                            complete: () => {
                                n.unsubscribe(), r("Update stream completed without expected value")
                            },
                            error: e => {
                                r(e)
                            }
                        })
                    })
                }
            }
            t.ValueAndUpdates = o
        },
        75932: function(e, t, r) {
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: !0
            }), t.pubkeyToAddress = t.pubkeyToRawAddress = t.rawSecp256k1PubkeyToRawAddress = t.rawEd25519PubkeyToRawAddress = void 0;
            let n = r(56257),
                o = r(15050);

            function i(e) {
                if (32 !== e.length) throw Error(`Invalid Ed25519 pubkey length: ${e.length}`);
                return (0, n.sha256)(e).slice(0, 20)
            }

            function a(e) {
                if (33 !== e.length) throw Error(`Invalid Secp256k1 pubkey length (compressed): ${e.length}`);
                return (0, n.ripemd160)((0, n.sha256)(e))
            }

            function s(e, t) {
                switch (e) {
                    case "ed25519":
                        return i(t);
                    case "secp256k1":
                        return a(t);
                    default:
                        throw Error(`Pubkey type ${e} not supported`)
                }
            }
            t.rawEd25519PubkeyToRawAddress = i, t.rawSecp256k1PubkeyToRawAddress = a, t.pubkeyToRawAddress = s, t.pubkeyToAddress = function(e, t) {
                return (0, o.toHex)(s(e, t)).toUpperCase()
            }
        },
        52515: function(e, t, r) {
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: !0
            }), t.Responses = t.Params = void 0;
            var n = r(36590);
            Object.defineProperty(t, "Params", {
                enumerable: !0,
                get: function() {
                    return n.Params
                }
            });
            var o = r(50314);
            Object.defineProperty(t, "Responses", {
                enumerable: !0,
                get: function() {
                    return o.Responses
                }
            })
        },
        36590: function(e, t, r) {
            "use strict";
            var n = this && this.__createBinding || (Object.create ? function(e, t, r, n) {
                    void 0 === n && (n = r);
                    var o = Object.getOwnPropertyDescriptor(t, r);
                    (!o || ("get" in o ? !t.__esModule : o.writable || o.configurable)) && (o = {
                        enumerable: !0,
                        get: function() {
                            return t[r]
                        }
                    }), Object.defineProperty(e, n, o)
                } : function(e, t, r, n) {
                    void 0 === n && (n = r), e[n] = t[r]
                }),
                o = this && this.__setModuleDefault || (Object.create ? function(e, t) {
                    Object.defineProperty(e, "default", {
                        enumerable: !0,
                        value: t
                    })
                } : function(e, t) {
                    e.default = t
                }),
                i = this && this.__importStar || function(e) {
                    if (e && e.__esModule) return e;
                    var t = {};
                    if (null != e)
                        for (var r in e) "default" !== r && Object.prototype.hasOwnProperty.call(e, r) && n(t, e, r);
                    return o(t, e), t
                };
            Object.defineProperty(t, "__esModule", {
                value: !0
            }), t.Params = void 0;
            let a = r(15050),
                s = r(62882),
                d = r(53609),
                c = r(48143),
                l = i(r(84027));

            function u(e) {
                return {
                    height: (0, c.may)(s.smallIntToApi, e.height)
                }
            }
            class p {
                static encodeAbciInfo(e) {
                    return (0, d.createJsonRpcRequest)(e.method)
                }
                static encodeAbciQuery(e) {
                    var t;
                    return (0, d.createJsonRpcRequest)(e.method, (t = e.params, {
                        path: (0, c.assertNotEmpty)(t.path),
                        data: (0, a.toHex)(t.data),
                        height: (0, c.may)(s.smallIntToApi, t.height),
                        prove: t.prove
                    }))
                }
                static encodeBlock(e) {
                    return (0, d.createJsonRpcRequest)(e.method, u(e.params))
                }
                static encodeBlockchain(e) {
                    var t;
                    return (0, d.createJsonRpcRequest)(e.method, (t = e.params, {
                        minHeight: (0, c.may)(s.smallIntToApi, t.minHeight),
                        maxHeight: (0, c.may)(s.smallIntToApi, t.maxHeight)
                    }))
                }
                static encodeBlockResults(e) {
                    return (0, d.createJsonRpcRequest)(e.method, u(e.params))
                }
                static encodeBlockSearch(e) {
                    var t;
                    return (0, d.createJsonRpcRequest)(e.method, {
                        query: (t = e.params).query,
                        page: (0, c.may)(s.smallIntToApi, t.page),
                        per_page: (0, c.may)(s.smallIntToApi, t.per_page),
                        order_by: t.order_by
                    })
                }
                static encodeBroadcastTx(e) {
                    var t;
                    return (0, d.createJsonRpcRequest)(e.method, (t = e.params, {
                        tx: (0, a.toBase64)((0, c.assertNotEmpty)(t.tx))
                    }))
                }
                static encodeCommit(e) {
                    return (0, d.createJsonRpcRequest)(e.method, u(e.params))
                }
                static encodeGenesis(e) {
                    return (0, d.createJsonRpcRequest)(e.method)
                }
                static encodeHealth(e) {
                    return (0, d.createJsonRpcRequest)(e.method)
                }
                static encodeNumUnconfirmedTxs(e) {
                    return (0, d.createJsonRpcRequest)(e.method)
                }
                static encodeStatus(e) {
                    return (0, d.createJsonRpcRequest)(e.method)
                }
                static encodeSubscribe(e) {
                    let t = {
                            key: "tm.event",
                            value: e.query.type
                        },
                        r = l.buildQuery({
                            tags: [t],
                            raw: e.query.raw
                        });
                    return (0, d.createJsonRpcRequest)("subscribe", {
                        query: r
                    })
                }
                static encodeTx(e) {
                    var t;
                    return (0, d.createJsonRpcRequest)(e.method, (t = e.params, {
                        hash: (0, a.toBase64)((0, c.assertNotEmpty)(t.hash)),
                        prove: t.prove
                    }))
                }
                static encodeTxSearch(e) {
                    var t;
                    return (0, d.createJsonRpcRequest)(e.method, {
                        query: (t = e.params).query,
                        prove: t.prove,
                        page: (0, c.may)(s.smallIntToApi, t.page),
                        per_page: (0, c.may)(s.smallIntToApi, t.per_page),
                        order_by: t.order_by
                    })
                }
                static encodeValidators(e) {
                    var t;
                    return (0, d.createJsonRpcRequest)(e.method, (t = e.params, {
                        height: (0, c.may)(s.smallIntToApi, t.height),
                        page: (0, c.may)(s.smallIntToApi, t.page),
                        per_page: (0, c.may)(s.smallIntToApi, t.per_page)
                    }))
                }
            }
            t.Params = p
        },
        50314: function(e, t, r) {
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: !0
            }), t.Responses = t.decodeValidatorInfo = t.decodeValidatorGenesis = t.decodeValidatorUpdate = t.decodeEvent = void 0;
            let n = r(15050),
                o = r(93337),
                i = r(9448),
                a = r(62882),
                s = r(32196),
                d = r(48143),
                c = r(52780);

            function l(e) {
                return {
                    ops: e.ops.map(e => ({
                        type: e.type,
                        key: (0, n.fromBase64)(e.key),
                        data: (0, n.fromBase64)(e.data)
                    }))
                }
            }

            function u(e) {
                return {
                    key: (0, d.assertNotEmpty)(e.key),
                    value: e.value ? ? ""
                }
            }

            function p(e) {
                var t;
                return {
                    type: e.type,
                    attributes: e.attributes ? (t = e.attributes, (0, d.assertArray)(t).map(u)) : []
                }
            }

            function m(e) {
                return (0, d.assertArray)(e).map(p)
            }

            function g(e) {
                return {
                    code: (0, a.apiToSmallInt)((0, d.assertNumber)(e.code ? ? 0)),
                    codespace: e.codespace,
                    log: e.log,
                    data: (0, d.may)(n.fromBase64, e.data),
                    events: e.events ? m(e.events) : [],
                    gasWanted: (0, a.apiToBigInt)(e.gas_wanted ? ? "0"),
                    gasUsed: (0, a.apiToBigInt)(e.gas_used ? ? "0")
                }
            }

            function f(e) {
                if ("Sum" in e) {
                    let [
                        [t, r]
                    ] = Object.entries(e.Sum.value);
                    return (0, o.assert)("ed25519" === t || "secp256k1" === t, `unknown pubkey type: ${t}`), {
                        algorithm: t,
                        data: (0, n.fromBase64)((0, d.assertNotEmpty)(r))
                    }
                }
                switch (e.type) {
                    case "tendermint/PubKeyEd25519":
                        return {
                            algorithm: "ed25519",
                            data: (0, n.fromBase64)((0, d.assertNotEmpty)(e.value))
                        };
                    case "tendermint/PubKeySecp256k1":
                        return {
                            algorithm: "secp256k1",
                            data: (0, n.fromBase64)((0, d.assertNotEmpty)(e.value))
                        };
                    default:
                        throw Error(`unknown pubkey type: ${e.type}`)
                }
            }

            function y(e) {
                var t, r;
                return {
                    block: (t = (0, d.assertObject)(e.block), {
                        maxBytes: (0, a.apiToSmallInt)((0, d.assertNotEmpty)(t.max_bytes)),
                        maxGas: (0, a.apiToSmallInt)((0, d.assertNotEmpty)(t.max_gas))
                    }),
                    evidence: (r = (0, d.assertObject)(e.evidence), {
                        maxAgeNumBlocks: (0, a.apiToSmallInt)((0, d.assertNotEmpty)(r.max_age_num_blocks)),
                        maxAgeDuration: (0, a.apiToSmallInt)((0, d.assertNotEmpty)(r.max_age_duration))
                    })
                }
            }

            function h(e) {
                return {
                    pubkey: f((0, d.assertObject)(e.pub_key)),
                    votingPower: (0, a.apiToBigInt)(e.power ? ? "0")
                }
            }

            function v(e) {
                return {
                    hash: (0, n.fromHex)((0, d.assertNotEmpty)(e.hash)),
                    parts: {
                        total: (0, d.assertNotEmpty)(e.parts.total),
                        hash: (0, n.fromHex)((0, d.assertNotEmpty)(e.parts.hash))
                    }
                }
            }

            function b(e) {
                var t;
                return {
                    version: (t = e.version, {
                        block: (0, a.apiToSmallInt)(t.block),
                        app: (0, a.apiToSmallInt)(t.app ? ? 0)
                    }),
                    chainId: (0, d.assertNotEmpty)(e.chain_id),
                    height: (0, a.apiToSmallInt)((0, d.assertNotEmpty)(e.height)),
                    time: (0, i.fromRfc3339WithNanoseconds)((0, d.assertNotEmpty)(e.time)),
                    lastBlockId: e.last_block_id.hash ? v(e.last_block_id) : null,
                    lastCommitHash: (0, n.fromHex)((0, d.assertSet)(e.last_commit_hash)),
                    dataHash: (0, n.fromHex)((0, d.assertSet)(e.data_hash)),
                    validatorsHash: (0, n.fromHex)((0, d.assertSet)(e.validators_hash)),
                    nextValidatorsHash: (0, n.fromHex)((0, d.assertSet)(e.next_validators_hash)),
                    consensusHash: (0, n.fromHex)((0, d.assertSet)(e.consensus_hash)),
                    appHash: (0, n.fromHex)((0, d.assertSet)(e.app_hash)),
                    lastResultsHash: (0, n.fromHex)((0, d.assertSet)(e.last_results_hash)),
                    evidenceHash: (0, n.fromHex)((0, d.assertSet)(e.evidence_hash)),
                    proposerAddress: (0, n.fromHex)((0, d.assertNotEmpty)(e.proposer_address))
                }
            }

            function S(e) {
                return {
                    blockId: v(e.block_id),
                    blockSize: (0, a.apiToSmallInt)((0, d.assertNotEmpty)(e.block_size)),
                    header: b(e.header),
                    numTxs: (0, a.apiToSmallInt)((0, d.assertNotEmpty)(e.num_txs))
                }
            }

            function k(e) {
                var t;
                return {
                    blockIdFlag: (t = e.block_id_flag, (0, o.assert)(t in s.BlockIdFlag), t),
                    validatorAddress: e.validator_address ? (0, n.fromHex)(e.validator_address) : void 0,
                    timestamp: e.timestamp ? (0, i.fromRfc3339WithNanoseconds)(e.timestamp) : void 0,
                    signature: e.signature ? (0, n.fromBase64)(e.signature) : void 0
                }
            }

            function P(e) {
                return {
                    blockId: v((0, d.assertObject)(e.block_id)),
                    height: (0, a.apiToSmallInt)((0, d.assertNotEmpty)(e.height)),
                    round: (0, a.apiToSmallInt)(e.round),
                    signatures: (0, d.assertArray)(e.signatures).map(k)
                }
            }

            function _(e) {
                return {
                    address: (0, n.fromHex)((0, d.assertNotEmpty)(e.address)),
                    pubkey: f((0, d.assertObject)(e.pub_key)),
                    votingPower: (0, a.apiToBigInt)((0, d.assertNotEmpty)(e.power))
                }
            }

            function B(e) {
                return {
                    pubkey: f((0, d.assertObject)(e.pub_key)),
                    votingPower: (0, a.apiToBigInt)((0, d.assertNotEmpty)(e.voting_power)),
                    address: (0, n.fromHex)((0, d.assertNotEmpty)(e.address)),
                    proposerPriority: e.proposer_priority ? (0, a.apiToSmallInt)(e.proposer_priority) : void 0
                }
            }

            function O(e) {
                return {
                    data: (0, n.fromBase64)((0, d.assertNotEmpty)(e.data)),
                    rootHash: (0, n.fromHex)((0, d.assertNotEmpty)(e.root_hash)),
                    proof: {
                        total: (0, a.apiToSmallInt)((0, d.assertNotEmpty)(e.proof.total)),
                        index: (0, a.apiToSmallInt)((0, d.assertNotEmpty)(e.proof.index)),
                        leafHash: (0, n.fromBase64)((0, d.assertNotEmpty)(e.proof.leaf_hash)),
                        aunts: (0, d.assertArray)(e.proof.aunts).map(n.fromBase64)
                    }
                }
            }

            function R(e) {
                return {
                    tx: (0, n.fromBase64)((0, d.assertNotEmpty)(e.tx)),
                    result: g((0, d.assertObject)(e.tx_result)),
                    height: (0, a.apiToSmallInt)((0, d.assertNotEmpty)(e.height)),
                    index: (0, a.apiToSmallInt)((0, d.assertNumber)(e.index)),
                    hash: (0, n.fromHex)((0, d.assertNotEmpty)(e.hash)),
                    proof: (0, d.may)(O, e.proof)
                }
            }

            function A(e) {
                return {
                    header: b((0, d.assertObject)(e.header)),
                    lastCommit: e.last_commit.block_id.hash ? P((0, d.assertObject)(e.last_commit)) : null,
                    txs: e.data.txs ? (0, d.assertArray)(e.data.txs).map(n.fromBase64) : [],
                    evidence: e.evidence ? .evidence ? ? []
                }
            }

            function I(e) {
                return {
                    blockId: v(e.block_id),
                    block: A(e.block)
                }
            }
            t.decodeEvent = p, t.decodeValidatorUpdate = h, t.decodeValidatorGenesis = _, t.decodeValidatorInfo = B;
            class w {
                static decodeAbciInfo(e) {
                    var t;
                    return {
                        data: (t = (0, d.assertObject)(e.result.response)).data,
                        lastBlockHeight: (0, d.may)(a.apiToSmallInt, t.last_block_height),
                        lastBlockAppHash: (0, d.may)(n.fromBase64, t.last_block_app_hash)
                    }
                }
                static decodeAbciQuery(e) {
                    var t;
                    return t = (0, d.assertObject)(e.result.response), {
                        key: (0, n.fromBase64)((0, d.assertString)(t.key ? ? "")),
                        value: (0, n.fromBase64)((0, d.assertString)(t.value ? ? "")),
                        proof: (0, d.may)(l, t.proofOps),
                        height: (0, d.may)(a.apiToSmallInt, t.height),
                        code: (0, d.may)(a.apiToSmallInt, t.code),
                        codespace: (0, d.assertString)(t.codespace ? ? ""),
                        index: (0, d.may)(a.apiToSmallInt, t.index),
                        log: t.log,
                        info: (0, d.assertString)(t.info ? ? "")
                    }
                }
                static decodeBlock(e) {
                    return I(e.result)
                }
                static decodeBlockResults(e) {
                    var t;
                    return t = e.result, {
                        height: (0, a.apiToSmallInt)((0, d.assertNotEmpty)(t.height)),
                        results: (t.txs_results || []).map(g),
                        validatorUpdates: (t.validator_updates || []).map(h),
                        consensusUpdates: (0, d.may)(y, t.consensus_param_updates),
                        beginBlockEvents: m(t.begin_block_events || []),
                        endBlockEvents: m(t.end_block_events || [])
                    }
                }
                static decodeBlockSearch(e) {
                    var t;
                    return t = e.result, {
                        totalCount: (0, a.apiToSmallInt)((0, d.assertNotEmpty)(t.total_count)),
                        blocks: (0, d.assertArray)(t.blocks).map(I)
                    }
                }
                static decodeBlockchain(e) {
                    var t;
                    return t = e.result, {
                        lastHeight: (0, a.apiToSmallInt)((0, d.assertNotEmpty)(t.last_height)),
                        blockMetas: (0, d.assertArray)(t.block_metas).map(S)
                    }
                }
                static decodeBroadcastTxSync(e) {
                    var t;
                    return { ...g(t = e.result),
                        hash: (0, n.fromHex)((0, d.assertNotEmpty)(t.hash))
                    }
                }
                static decodeBroadcastTxAsync(e) {
                    return w.decodeBroadcastTxSync(e)
                }
                static decodeBroadcastTxCommit(e) {
                    return function(e) {
                        let t = e.tx_result ? g(e.tx_result) : void 0;
                        return {
                            height: (0, a.apiToSmallInt)(e.height),
                            hash: (0, n.fromHex)((0, d.assertNotEmpty)(e.hash)),
                            checkTx: g((0, d.assertObject)(e.check_tx)),
                            deliverTx: t,
                            txResult: t
                        }
                    }(e.result)
                }
                static decodeCommit(e) {
                    var t;
                    return t = e.result, {
                        canonical: (0, d.assertBoolean)(t.canonical),
                        header: b(t.signed_header.header),
                        commit: P(t.signed_header.commit)
                    }
                }
                static decodeGenesis(e) {
                    var t;
                    return t = (0, d.assertObject)(e.result.genesis), {
                        genesisTime: (0, i.fromRfc3339WithNanoseconds)((0, d.assertNotEmpty)(t.genesis_time)),
                        chainId: (0, d.assertNotEmpty)(t.chain_id),
                        consensusParams: y(t.consensus_params),
                        validators: t.validators ? (0, d.assertArray)(t.validators).map(_) : [],
                        appHash: (0, n.fromHex)((0, d.assertSet)(t.app_hash)),
                        appState: t.app_state
                    }
                }
                static decodeHealth() {
                    return null
                }
                static decodeNumUnconfirmedTxs(e) {
                    var t;
                    return t = e.result, {
                        total: (0, a.apiToSmallInt)((0, d.assertNotEmpty)(t.total)),
                        totalBytes: (0, a.apiToSmallInt)((0, d.assertNotEmpty)(t.total_bytes))
                    }
                }
                static decodeStatus(e) {
                    var t, r;
                    return {
                        nodeInfo: (r = (t = e.result).node_info, {
                            id: (0, n.fromHex)((0, d.assertNotEmpty)(r.id)),
                            listenAddr: (0, d.assertNotEmpty)(r.listen_addr),
                            network: (0, d.assertNotEmpty)(r.network),
                            version: (0, d.assertString)(r.version),
                            channels: (0, d.assertNotEmpty)(r.channels),
                            moniker: (0, d.assertNotEmpty)(r.moniker),
                            other: (0, d.dictionaryToStringMap)(r.other),
                            protocolVersion: {
                                app: (0, a.apiToSmallInt)((0, d.assertNotEmpty)(r.protocol_version.app)),
                                block: (0, a.apiToSmallInt)((0, d.assertNotEmpty)(r.protocol_version.block)),
                                p2p: (0, a.apiToSmallInt)((0, d.assertNotEmpty)(r.protocol_version.p2p))
                            }
                        }),
                        syncInfo: function(e) {
                            let t = e.earliest_block_height ? (0, a.apiToSmallInt)(e.earliest_block_height) : void 0,
                                r = e.earliest_block_time ? (0, i.fromRfc3339WithNanoseconds)(e.earliest_block_time) : void 0;
                            return {
                                earliestAppHash: e.earliest_app_hash ? (0, n.fromHex)(e.earliest_app_hash) : void 0,
                                earliestBlockHash: e.earliest_block_hash ? (0, n.fromHex)(e.earliest_block_hash) : void 0,
                                earliestBlockHeight: t || void 0,
                                earliestBlockTime: r ? .getTime() ? r : void 0,
                                latestBlockHash: (0, n.fromHex)((0, d.assertNotEmpty)(e.latest_block_hash)),
                                latestAppHash: (0, n.fromHex)((0, d.assertNotEmpty)(e.latest_app_hash)),
                                latestBlockTime: (0, i.fromRfc3339WithNanoseconds)((0, d.assertNotEmpty)(e.latest_block_time)),
                                latestBlockHeight: (0, a.apiToSmallInt)((0, d.assertNotEmpty)(e.latest_block_height)),
                                catchingUp: (0, d.assertBoolean)(e.catching_up)
                            }
                        }(t.sync_info),
                        validatorInfo: B(t.validator_info)
                    }
                }
                static decodeNewBlockEvent(e) {
                    return A(e.data.value.block)
                }
                static decodeNewBlockHeaderEvent(e) {
                    return b(e.data.value.header)
                }
                static decodeTxEvent(e) {
                    return function(e) {
                        let t = (0, n.fromBase64)((0, d.assertNotEmpty)(e.tx));
                        return {
                            tx: t,
                            hash: (0, c.hashTx)(t),
                            result: g(e.result),
                            height: (0, a.apiToSmallInt)((0, d.assertNotEmpty)(e.height))
                        }
                    }(e.data.value.TxResult)
                }
                static decodeTx(e) {
                    return R(e.result)
                }
                static decodeTxSearch(e) {
                    var t;
                    return t = e.result, {
                        totalCount: (0, a.apiToSmallInt)((0, d.assertNotEmpty)(t.total_count)),
                        txs: (0, d.assertArray)(t.txs).map(R)
                    }
                }
                static decodeValidators(e) {
                    var t;
                    return t = e.result, {
                        blockHeight: (0, a.apiToSmallInt)((0, d.assertNotEmpty)(t.block_height)),
                        validators: (0, d.assertArray)(t.validators).map(B),
                        count: (0, a.apiToSmallInt)((0, d.assertNotEmpty)(t.count)),
                        total: (0, a.apiToSmallInt)((0, d.assertNotEmpty)(t.total))
                    }
                }
            }
            t.Responses = w
        },
        46802: function(e, t, r) {
            "use strict";
            var n = this && this.__createBinding || (Object.create ? function(e, t, r, n) {
                    void 0 === n && (n = r);
                    var o = Object.getOwnPropertyDescriptor(t, r);
                    (!o || ("get" in o ? !t.__esModule : o.writable || o.configurable)) && (o = {
                        enumerable: !0,
                        get: function() {
                            return t[r]
                        }
                    }), Object.defineProperty(e, n, o)
                } : function(e, t, r, n) {
                    void 0 === n && (n = r), e[n] = t[r]
                }),
                o = this && this.__setModuleDefault || (Object.create ? function(e, t) {
                    Object.defineProperty(e, "default", {
                        enumerable: !0,
                        value: t
                    })
                } : function(e, t) {
                    e.default = t
                }),
                i = this && this.__importStar || function(e) {
                    if (e && e.__esModule) return e;
                    var t = {};
                    if (null != e)
                        for (var r in e) "default" !== r && Object.prototype.hasOwnProperty.call(e, r) && n(t, e, r);
                    return o(t, e), t
                };
            Object.defineProperty(t, "__esModule", {
                value: !0
            }), t.Comet38Client = void 0;
            let a = r(53609),
                s = r(81418),
                d = r(52515),
                c = i(r(84027));
            class l {
                static async connect(e) {
                    let t;
                    return t = "object" == typeof e ? new s.HttpClient(e) : e.startsWith("http://") || e.startsWith("https://") ? new s.HttpClient(e) : new s.WebsocketClient(e), await this.detectVersion(t), l.create(t)
                }
                static async create(e) {
                    return new l(e)
                }
                static async detectVersion(e) {
                    let t = (0, a.createJsonRpcRequest)(c.Method.Status),
                        r = (await e.execute(t)).result;
                    if (!r || !r.node_info) throw Error("Unrecognized format for status response");
                    let n = r.node_info.version;
                    if ("string" != typeof n) throw Error("Unrecognized version format: must be string");
                    return n
                }
                constructor(e) {
                    this.client = e
                }
                disconnect() {
                    this.client.disconnect()
                }
                async abciInfo() {
                    let e = {
                        method: c.Method.AbciInfo
                    };
                    return this.doCall(e, d.Params.encodeAbciInfo, d.Responses.decodeAbciInfo)
                }
                async abciQuery(e) {
                    let t = {
                        params: e,
                        method: c.Method.AbciQuery
                    };
                    return this.doCall(t, d.Params.encodeAbciQuery, d.Responses.decodeAbciQuery)
                }
                async block(e) {
                    let t = {
                        method: c.Method.Block,
                        params: {
                            height: e
                        }
                    };
                    return this.doCall(t, d.Params.encodeBlock, d.Responses.decodeBlock)
                }
                async blockResults(e) {
                    let t = {
                        method: c.Method.BlockResults,
                        params: {
                            height: e
                        }
                    };
                    return this.doCall(t, d.Params.encodeBlockResults, d.Responses.decodeBlockResults)
                }
                async blockSearch(e) {
                    let t = {
                            params: e,
                            method: c.Method.BlockSearch
                        },
                        r = await this.doCall(t, d.Params.encodeBlockSearch, d.Responses.decodeBlockSearch);
                    return { ...r,
                        blocks: [...r.blocks].sort((e, t) => e.block.header.height - t.block.header.height)
                    }
                }
                async blockSearchAll(e) {
                    let t = e.page || 1,
                        r = [],
                        n = !1;
                    for (; !n;) {
                        let o = await this.blockSearch({ ...e,
                            page: t
                        });
                        r.push(...o.blocks), r.length < o.totalCount ? t++ : n = !0
                    }
                    return r.sort((e, t) => e.block.header.height - t.block.header.height), {
                        totalCount: r.length,
                        blocks: r
                    }
                }
                async blockchain(e, t) {
                    let r = {
                        method: c.Method.Blockchain,
                        params: {
                            minHeight: e,
                            maxHeight: t
                        }
                    };
                    return this.doCall(r, d.Params.encodeBlockchain, d.Responses.decodeBlockchain)
                }
                async broadcastTxSync(e) {
                    let t = {
                        params: e,
                        method: c.Method.BroadcastTxSync
                    };
                    return this.doCall(t, d.Params.encodeBroadcastTx, d.Responses.decodeBroadcastTxSync)
                }
                async broadcastTxAsync(e) {
                    let t = {
                        params: e,
                        method: c.Method.BroadcastTxAsync
                    };
                    return this.doCall(t, d.Params.encodeBroadcastTx, d.Responses.decodeBroadcastTxAsync)
                }
                async broadcastTxCommit(e) {
                    let t = {
                        params: e,
                        method: c.Method.BroadcastTxCommit
                    };
                    return this.doCall(t, d.Params.encodeBroadcastTx, d.Responses.decodeBroadcastTxCommit)
                }
                async commit(e) {
                    let t = {
                        method: c.Method.Commit,
                        params: {
                            height: e
                        }
                    };
                    return this.doCall(t, d.Params.encodeCommit, d.Responses.decodeCommit)
                }
                async genesis() {
                    let e = {
                        method: c.Method.Genesis
                    };
                    return this.doCall(e, d.Params.encodeGenesis, d.Responses.decodeGenesis)
                }
                async health() {
                    let e = {
                        method: c.Method.Health
                    };
                    return this.doCall(e, d.Params.encodeHealth, d.Responses.decodeHealth)
                }
                async numUnconfirmedTxs() {
                    let e = {
                        method: c.Method.NumUnconfirmedTxs
                    };
                    return this.doCall(e, d.Params.encodeNumUnconfirmedTxs, d.Responses.decodeNumUnconfirmedTxs)
                }
                async status() {
                    let e = {
                        method: c.Method.Status
                    };
                    return this.doCall(e, d.Params.encodeStatus, d.Responses.decodeStatus)
                }
                subscribeNewBlock() {
                    let e = {
                        method: c.Method.Subscribe,
                        query: {
                            type: c.SubscriptionEventType.NewBlock
                        }
                    };
                    return this.subscribe(e, d.Responses.decodeNewBlockEvent)
                }
                subscribeNewBlockHeader() {
                    let e = {
                        method: c.Method.Subscribe,
                        query: {
                            type: c.SubscriptionEventType.NewBlockHeader
                        }
                    };
                    return this.subscribe(e, d.Responses.decodeNewBlockHeaderEvent)
                }
                subscribeTx(e) {
                    let t = {
                        method: c.Method.Subscribe,
                        query: {
                            type: c.SubscriptionEventType.Tx,
                            raw: e
                        }
                    };
                    return this.subscribe(t, d.Responses.decodeTxEvent)
                }
                async tx(e) {
                    let t = {
                        params: e,
                        method: c.Method.Tx
                    };
                    return this.doCall(t, d.Params.encodeTx, d.Responses.decodeTx)
                }
                async txSearch(e) {
                    let t = {
                        params: e,
                        method: c.Method.TxSearch
                    };
                    return this.doCall(t, d.Params.encodeTxSearch, d.Responses.decodeTxSearch)
                }
                async txSearchAll(e) {
                    let t = e.page || 1,
                        r = [],
                        n = !1;
                    for (; !n;) {
                        let o = await this.txSearch({ ...e,
                            page: t
                        });
                        r.push(...o.txs), r.length < o.totalCount ? t++ : n = !0
                    }
                    return {
                        totalCount: r.length,
                        txs: r
                    }
                }
                async validators(e) {
                    let t = {
                        method: c.Method.Validators,
                        params: e
                    };
                    return this.doCall(t, d.Params.encodeValidators, d.Responses.decodeValidators)
                }
                async validatorsAll(e) {
                    let t = [],
                        r = 1,
                        n = !1,
                        o = e;
                    for (; !n;) {
                        let e = await this.validators({
                            per_page: 50,
                            height: o,
                            page: r
                        });
                        t.push(...e.validators), o = o || e.blockHeight, t.length < e.total ? r++ : n = !0
                    }
                    return {
                        blockHeight: o ? ? 0,
                        count: t.length,
                        total: t.length,
                        validators: t
                    }
                }
                async doCall(e, t, r) {
                    let n = t(e);
                    return r(await this.client.execute(n))
                }
                subscribe(e, t) {
                    if (!(0, s.instanceOfRpcStreamingClient)(this.client)) throw Error("This RPC client type cannot subscribe to events");
                    let r = d.Params.encodeSubscribe(e);
                    return this.client.listen(r).map(e => t(e))
                }
            }
            t.Comet38Client = l
        },
        48143: function(e, t, r) {
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: !0
            }), t.encodeBlockId = t.encodeVersion = t.encodeBytes = t.encodeTime = t.encodeUvarint = t.encodeString = t.dictionaryToStringMap = t.may = t.assertNotEmpty = t.assertObject = t.assertArray = t.assertNumber = t.assertString = t.assertBoolean = t.assertSet = void 0;
            let n = r(15050);

            function o(e) {
                if (void 0 === e) throw Error("Value must not be undefined");
                if (null === e) throw Error("Value must not be null");
                return e
            }

            function i(e) {
                return e >= 128 ? Uint8Array.from([255 & e | 128, ...i(e >> 7)]) : Uint8Array.from([255 & e])
            }
            t.assertSet = o, t.assertBoolean = function(e) {
                if (o(e), "boolean" != typeof e) throw Error("Value must be a boolean");
                return e
            }, t.assertString = function(e) {
                if (o(e), "string" != typeof e) throw Error("Value must be a string");
                return e
            }, t.assertNumber = function(e) {
                if (o(e), "number" != typeof e) throw Error("Value must be a number");
                return e
            }, t.assertArray = function(e) {
                if (o(e), !Array.isArray(e)) throw Error("Value must be a an array");
                return e
            }, t.assertObject = function(e) {
                if (o(e), "object" != typeof e) throw Error("Value must be an object");
                if ("[object Object]" !== Object.prototype.toString.call(e)) throw Error("Value must be a simple object");
                return e
            }, t.assertNotEmpty = function(e) {
                if (o(e), "number" == typeof e && 0 === e) throw Error("must provide a non-zero value");
                if (0 === e.length) throw Error("must provide a non-empty value");
                return e
            }, t.may = function(e, t) {
                return null == t ? void 0 : e(t)
            }, t.dictionaryToStringMap = function(e) {
                let t = new Map;
                for (let r of Object.keys(e)) {
                    let n = e[r];
                    if ("string" != typeof n) throw Error("Found dictionary value of type other than string");
                    t.set(r, n)
                }
                return t
            }, t.encodeString = function(e) {
                let t = (0, n.toUtf8)(e);
                return Uint8Array.from([t.length, ...t])
            }, t.encodeUvarint = i, t.encodeTime = function(e) {
                let t = e.getTime(),
                    r = Math.floor(t / 1e3),
                    n = r ? [8, ...i(r)] : new Uint8Array,
                    o = (e.nanoseconds || 0) + t % 1e3 * 1e6,
                    a = o ? [16, ...i(o)] : new Uint8Array;
                return Uint8Array.from([...n, ...a])
            }, t.encodeBytes = function(e) {
                if (e.length >= 128) throw Error("Not implemented for byte arrays of length 128 or more");
                return e.length ? Uint8Array.from([e.length, ...e]) : new Uint8Array
            }, t.encodeVersion = function(e) {
                let t = e.block ? Uint8Array.from([8, ...i(e.block)]) : new Uint8Array,
                    r = e.app ? Uint8Array.from([16, ...i(e.app)]) : new Uint8Array;
                return Uint8Array.from([...t, ...r])
            }, t.encodeBlockId = function(e) {
                return Uint8Array.from([10, e.hash.length, ...e.hash, 18, e.parts.hash.length + 4, 8, e.parts.total, 18, e.parts.hash.length, ...e.parts.hash])
            }
        },
        52780: function(e, t, r) {
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: !0
            }), t.hashBlock = t.hashTx = void 0;
            let n = r(56257),
                o = r(48143);
            t.hashTx = function(e) {
                return (0, n.sha256)(e)
            }, t.hashBlock = function(e) {
                if (!e.lastBlockId) throw Error("Hashing a block header with no last block ID (i.e. header at height 1) is not supported. If you need this, contributions are welcome. Please add documentation and test vectors for this case.");
                return function e(t) {
                    switch (t.length) {
                        case 0:
                            throw Error("Cannot hash empty tree");
                        case 1:
                            return function(e) {
                                let t = new n.Sha256(Uint8Array.from([0]));
                                return t.update(e), t.digest()
                            }(t[0]);
                        default:
                            {
                                let r = function(e) {
                                    if (e < 1) throw Error("Cannot split an empty tree");
                                    let t = 2 ** Math.floor(Math.log2(e));
                                    return t < e ? t : t / 2
                                }(t.length);
                                return function(e, t) {
                                    let r = new n.Sha256(Uint8Array.from([1]));
                                    return r.update(e), r.update(t), r.digest()
                                }(e(t.slice(0, r)), e(t.slice(r)))
                            }
                    }
                }([(0, o.encodeVersion)(e.version), (0, o.encodeString)(e.chainId), (0, o.encodeUvarint)(e.height), (0, o.encodeTime)(e.time), (0, o.encodeBlockId)(e.lastBlockId), (0, o.encodeBytes)(e.lastCommitHash), (0, o.encodeBytes)(e.dataHash), (0, o.encodeBytes)(e.validatorsHash), (0, o.encodeBytes)(e.nextValidatorsHash), (0, o.encodeBytes)(e.consensusHash), (0, o.encodeBytes)(e.appHash), (0, o.encodeBytes)(e.lastResultsHash), (0, o.encodeBytes)(e.evidenceHash), (0, o.encodeBytes)(e.proposerAddress)])
            }
        },
        26069: function(e, t, r) {
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: !0
            }), t.VoteType = t.broadcastTxSyncSuccess = t.broadcastTxCommitSuccess = t.SubscriptionEventType = t.Method = t.Comet38Client = void 0;
            var n = r(46802);
            Object.defineProperty(t, "Comet38Client", {
                enumerable: !0,
                get: function() {
                    return n.Comet38Client
                }
            });
            var o = r(84027);
            Object.defineProperty(t, "Method", {
                enumerable: !0,
                get: function() {
                    return o.Method
                }
            }), Object.defineProperty(t, "SubscriptionEventType", {
                enumerable: !0,
                get: function() {
                    return o.SubscriptionEventType
                }
            });
            var i = r(64352);
            Object.defineProperty(t, "broadcastTxCommitSuccess", {
                enumerable: !0,
                get: function() {
                    return i.broadcastTxCommitSuccess
                }
            }), Object.defineProperty(t, "broadcastTxSyncSuccess", {
                enumerable: !0,
                get: function() {
                    return i.broadcastTxSyncSuccess
                }
            }), Object.defineProperty(t, "VoteType", {
                enumerable: !0,
                get: function() {
                    return i.VoteType
                }
            })
        },
        84027: function(e, t) {
            "use strict";
            var r, n;
            Object.defineProperty(t, "__esModule", {
                value: !0
            }), t.buildQuery = t.SubscriptionEventType = t.Method = void 0, (r = t.Method || (t.Method = {})).AbciInfo = "abci_info", r.AbciQuery = "abci_query", r.Block = "block", r.Blockchain = "blockchain", r.BlockResults = "block_results", r.BlockSearch = "block_search", r.BroadcastTxAsync = "broadcast_tx_async", r.BroadcastTxSync = "broadcast_tx_sync", r.BroadcastTxCommit = "broadcast_tx_commit", r.Commit = "commit", r.Genesis = "genesis", r.Health = "health", r.NumUnconfirmedTxs = "num_unconfirmed_txs", r.Status = "status", r.Subscribe = "subscribe", r.Tx = "tx", r.TxSearch = "tx_search", r.Validators = "validators", r.Unsubscribe = "unsubscribe", (n = t.SubscriptionEventType || (t.SubscriptionEventType = {})).NewBlock = "NewBlock", n.NewBlockHeader = "NewBlockHeader", n.Tx = "Tx", t.buildQuery = function(e) {
                return [...(e.tags ? e.tags : []).map(e => `${e.key}='${e.value}'`), ...e.raw ? [e.raw] : []].join(" AND ")
            }
        },
        64352: function(e, t) {
            "use strict";
            var r;
            Object.defineProperty(t, "__esModule", {
                value: !0
            }), t.VoteType = t.broadcastTxCommitSuccess = t.broadcastTxSyncSuccess = void 0, t.broadcastTxSyncSuccess = function(e) {
                return 0 === e.code
            }, t.broadcastTxCommitSuccess = function(e) {
                return 0 === e.checkTx.code && !!e.deliverTx && 0 === e.deliverTx.code
            }, (r = t.VoteType || (t.VoteType = {}))[r.PreVote = 1] = "PreVote", r[r.PreCommit = 2] = "PreCommit"
        },
        9448: function(e, t, r) {
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: !0
            }), t.DateTime = t.toSeconds = t.fromSeconds = t.toRfc3339WithNanoseconds = t.fromRfc3339WithNanoseconds = void 0;
            let n = r(15050),
                o = r(38051);

            function i(e) {
                let t = (0, n.fromRfc3339)(e),
                    r = e.match(/\.(\d+)Z$/),
                    o = r ? r[1].slice(3) : "";
                return t.nanoseconds = parseInt(o.padEnd(6, "0"), 10), t
            }

            function a(e) {
                let t = e.toISOString(),
                    r = e.nanoseconds ? .toString() ? ? "";
                return `${t.slice(0,-1)}${r.padStart(6,"0")}Z`
            }
            t.fromRfc3339WithNanoseconds = i, t.toRfc3339WithNanoseconds = a, t.fromSeconds = function(e, t = 0) {
                let r = new o.Uint32(t).toNumber();
                if (r > 999999999) throw Error("Nano seconds must not exceed 999999999");
                let n = new Date(1e3 * e + Math.floor(r / 1e6));
                return n.nanoseconds = r % 1e6, n
            }, t.toSeconds = function(e) {
                return {
                    seconds: Math.floor(e.getTime() / 1e3),
                    nanos: e.getTime() % 1e3 * 1e6 + (e.nanoseconds ? ? 0)
                }
            };
            class s {
                static decode(e) {
                    return i(e)
                }
                static encode(e) {
                    return a(e)
                }
            }
            t.DateTime = s
        },
        23628: function(e, t, r) {
            "use strict";
            var n = this && this.__createBinding || (Object.create ? function(e, t, r, n) {
                    void 0 === n && (n = r);
                    var o = Object.getOwnPropertyDescriptor(t, r);
                    (!o || ("get" in o ? !t.__esModule : o.writable || o.configurable)) && (o = {
                        enumerable: !0,
                        get: function() {
                            return t[r]
                        }
                    }), Object.defineProperty(e, n, o)
                } : function(e, t, r, n) {
                    void 0 === n && (n = r), e[n] = t[r]
                }),
                o = this && this.__setModuleDefault || (Object.create ? function(e, t) {
                    Object.defineProperty(e, "default", {
                        enumerable: !0,
                        value: t
                    })
                } : function(e, t) {
                    e.default = t
                }),
                i = this && this.__importStar || function(e) {
                    if (e && e.__esModule) return e;
                    var t = {};
                    if (null != e)
                        for (var r in e) "default" !== r && Object.prototype.hasOwnProperty.call(e, r) && n(t, e, r);
                    return o(t, e), t
                };
            Object.defineProperty(t, "__esModule", {
                value: !0
            }), t.BlockIdFlag = t.isTendermint37Client = t.isTendermint34Client = t.isComet38Client = t.connectComet = t.Tendermint37Client = t.tendermint37 = t.Tendermint34Client = t.tendermint34 = t.VoteType = t.SubscriptionEventType = t.Method = t.broadcastTxSyncSuccess = t.broadcastTxCommitSuccess = t.WebsocketClient = t.HttpClient = t.HttpBatchClient = t.Comet38Client = t.comet38 = t.toSeconds = t.toRfc3339WithNanoseconds = t.fromSeconds = t.fromRfc3339WithNanoseconds = t.DateTime = t.rawSecp256k1PubkeyToRawAddress = t.rawEd25519PubkeyToRawAddress = t.pubkeyToRawAddress = t.pubkeyToAddress = void 0;
            var a = r(75932);
            Object.defineProperty(t, "pubkeyToAddress", {
                enumerable: !0,
                get: function() {
                    return a.pubkeyToAddress
                }
            }), Object.defineProperty(t, "pubkeyToRawAddress", {
                enumerable: !0,
                get: function() {
                    return a.pubkeyToRawAddress
                }
            }), Object.defineProperty(t, "rawEd25519PubkeyToRawAddress", {
                enumerable: !0,
                get: function() {
                    return a.rawEd25519PubkeyToRawAddress
                }
            }), Object.defineProperty(t, "rawSecp256k1PubkeyToRawAddress", {
                enumerable: !0,
                get: function() {
                    return a.rawSecp256k1PubkeyToRawAddress
                }
            });
            var s = r(9448);
            Object.defineProperty(t, "DateTime", {
                enumerable: !0,
                get: function() {
                    return s.DateTime
                }
            }), Object.defineProperty(t, "fromRfc3339WithNanoseconds", {
                enumerable: !0,
                get: function() {
                    return s.fromRfc3339WithNanoseconds
                }
            }), Object.defineProperty(t, "fromSeconds", {
                enumerable: !0,
                get: function() {
                    return s.fromSeconds
                }
            }), Object.defineProperty(t, "toRfc3339WithNanoseconds", {
                enumerable: !0,
                get: function() {
                    return s.toRfc3339WithNanoseconds
                }
            }), Object.defineProperty(t, "toSeconds", {
                enumerable: !0,
                get: function() {
                    return s.toSeconds
                }
            }), t.comet38 = i(r(26069));
            var d = r(26069);
            Object.defineProperty(t, "Comet38Client", {
                enumerable: !0,
                get: function() {
                    return d.Comet38Client
                }
            });
            var c = r(81418);
            Object.defineProperty(t, "HttpBatchClient", {
                enumerable: !0,
                get: function() {
                    return c.HttpBatchClient
                }
            }), Object.defineProperty(t, "HttpClient", {
                enumerable: !0,
                get: function() {
                    return c.HttpClient
                }
            }), Object.defineProperty(t, "WebsocketClient", {
                enumerable: !0,
                get: function() {
                    return c.WebsocketClient
                }
            });
            var l = r(22682);
            Object.defineProperty(t, "broadcastTxCommitSuccess", {
                enumerable: !0,
                get: function() {
                    return l.broadcastTxCommitSuccess
                }
            }), Object.defineProperty(t, "broadcastTxSyncSuccess", {
                enumerable: !0,
                get: function() {
                    return l.broadcastTxSyncSuccess
                }
            }), Object.defineProperty(t, "Method", {
                enumerable: !0,
                get: function() {
                    return l.Method
                }
            }), Object.defineProperty(t, "SubscriptionEventType", {
                enumerable: !0,
                get: function() {
                    return l.SubscriptionEventType
                }
            }), Object.defineProperty(t, "VoteType", {
                enumerable: !0,
                get: function() {
                    return l.VoteType
                }
            }), t.tendermint34 = i(r(22682));
            var u = r(22682);
            Object.defineProperty(t, "Tendermint34Client", {
                enumerable: !0,
                get: function() {
                    return u.Tendermint34Client
                }
            }), t.tendermint37 = i(r(56491));
            var p = r(56491);
            Object.defineProperty(t, "Tendermint37Client", {
                enumerable: !0,
                get: function() {
                    return p.Tendermint37Client
                }
            });
            var m = r(34140);
            Object.defineProperty(t, "connectComet", {
                enumerable: !0,
                get: function() {
                    return m.connectComet
                }
            }), Object.defineProperty(t, "isComet38Client", {
                enumerable: !0,
                get: function() {
                    return m.isComet38Client
                }
            }), Object.defineProperty(t, "isTendermint34Client", {
                enumerable: !0,
                get: function() {
                    return m.isTendermint34Client
                }
            }), Object.defineProperty(t, "isTendermint37Client", {
                enumerable: !0,
                get: function() {
                    return m.isTendermint37Client
                }
            });
            var g = r(32196);
            Object.defineProperty(t, "BlockIdFlag", {
                enumerable: !0,
                get: function() {
                    return g.BlockIdFlag
                }
            })
        },
        62882: function(e, t, r) {
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: !0
            }), t.smallIntToApi = t.apiToBigInt = t.apiToSmallInt = void 0;
            let n = r(38051),
                o = r(16529);
            t.apiToSmallInt = function(e) {
                return ("number" == typeof e ? new n.Int53(e) : n.Int53.fromString(e)).toNumber()
            }, t.apiToBigInt = function(e) {
                if ((0, o.assertString)(e), !e.match(/^-?[0-9]+$/)) throw Error("Invalid string format");
                return BigInt(e)
            }, t.smallIntToApi = function(e) {
                return new n.Int53(e).toString()
            }
        },
        53609: function(e, t) {
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: !0
            }), t.createJsonRpcRequest = void 0;
            let r = "123456789";
            t.createJsonRpcRequest = function(e, t) {
                let n = t ? { ...t
                } : {};
                return {
                    jsonrpc: "2.0",
                    id: parseInt(Array.from({
                        length: 12
                    }).map(() => r[Math.floor(Math.random() * r.length)]).join(""), 10),
                    method: e,
                    params: n
                }
            }
        },
        78353: function(e, t, r) {
            "use strict";
            var n = this && this.__importDefault || function(e) {
                return e && e.__esModule ? e : {
                    default: e
                }
            };
            Object.defineProperty(t, "__esModule", {
                value: !0
            }), t.http = void 0;
            let o = n(r(41161));

            function i(e) {
                if (e.status >= 400) throw Error(`Bad status on response: ${e.status}`);
                return e
            }
            async function a(e, t, r, n) {
                if ("function" != typeof fetch || fetch.toString().includes("emitExperimentalWarning")) return o.default.request({
                    url: t,
                    method: e,
                    data: n,
                    headers: r
                }).then(e => e.data); {
                    let o = {
                        method: e,
                        body: n ? JSON.stringify(n) : void 0,
                        headers: {
                            "Content-Type": "application/json",
                            ...r
                        }
                    };
                    return fetch(t, o).then(i).then(e => e.json())
                }
            }
            t.http = a
        },
        68454: function(e, t, r) {
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: !0
            }), t.HttpBatchClient = void 0;
            let n = r(47207),
                o = r(78353),
                i = r(96731),
                a = {
                    dispatchInterval: 20,
                    batchSizeLimit: 20
                };
            class s {
                constructor(e, t = {}) {
                    if (this.queue = [], this.options = {
                            batchSizeLimit: t.batchSizeLimit ? ? a.batchSizeLimit,
                            dispatchInterval: t.dispatchInterval ? ? a.dispatchInterval
                        }, "string" == typeof e) {
                        if (!(0, i.hasProtocol)(e)) throw Error("Endpoint URL is missing a protocol. Expected 'https://' or 'http://'.");
                        this.url = e
                    } else this.url = e.url, this.headers = e.headers;
                    this.timer = setInterval(() => this.tick(), t.dispatchInterval), this.validate()
                }
                disconnect() {
                    this.timer && clearInterval(this.timer), this.timer = void 0
                }
                async execute(e) {
                    return new Promise((t, r) => {
                        this.queue.push({
                            request: e,
                            resolve: t,
                            reject: r
                        }), this.queue.length >= this.options.batchSizeLimit && this.tick()
                    })
                }
                validate() {
                    if (!this.options.batchSizeLimit || !Number.isSafeInteger(this.options.batchSizeLimit) || this.options.batchSizeLimit < 1) throw Error("batchSizeLimit must be a safe integer >= 1")
                }
                tick() {
                    let e = this.queue.splice(0, this.options.batchSizeLimit);
                    if (!e.length) return;
                    let t = e.map(e => e.request),
                        r = t.map(e => e.id);
                    (0, o.http)("POST", this.url, this.headers, t).then(t => {
                        (Array.isArray(t) ? t : [t]).forEach(t => {
                            let r = e.find(e => e.request.id === t.id);
                            if (!r) return;
                            let {
                                reject: o,
                                resolve: i
                            } = r, a = (0, n.parseJsonRpcResponse)(t);
                            (0, n.isJsonRpcErrorResponse)(a) ? o(Error(JSON.stringify(a.error))): i(a)
                        })
                    }, t => {
                        for (let n of r) {
                            let r = e.find(e => e.request.id === n);
                            if (!r) return;
                            r.reject(t)
                        }
                    })
                }
            }
            t.HttpBatchClient = s
        },
        56168: function(e, t, r) {
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: !0
            }), t.HttpClient = void 0;
            let n = r(47207),
                o = r(78353),
                i = r(96731);
            class a {
                constructor(e) {
                    if ("string" == typeof e) {
                        if (!(0, i.hasProtocol)(e)) throw Error("Endpoint URL is missing a protocol. Expected 'https://' or 'http://'.");
                        this.url = e
                    } else this.url = e.url, this.headers = e.headers
                }
                disconnect() {}
                async execute(e) {
                    let t = (0, n.parseJsonRpcResponse)(await (0, o.http)("POST", this.url, this.headers, e));
                    if ((0, n.isJsonRpcErrorResponse)(t)) throw Error(JSON.stringify(t.error));
                    return t
                }
            }
            t.HttpClient = a
        },
        81418: function(e, t, r) {
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: !0
            }), t.WebsocketClient = t.instanceOfRpcStreamingClient = t.HttpClient = t.HttpBatchClient = void 0;
            var n = r(68454);
            Object.defineProperty(t, "HttpBatchClient", {
                enumerable: !0,
                get: function() {
                    return n.HttpBatchClient
                }
            });
            var o = r(56168);
            Object.defineProperty(t, "HttpClient", {
                enumerable: !0,
                get: function() {
                    return o.HttpClient
                }
            });
            var i = r(96731);
            Object.defineProperty(t, "instanceOfRpcStreamingClient", {
                enumerable: !0,
                get: function() {
                    return i.instanceOfRpcStreamingClient
                }
            });
            var a = r(82607);
            Object.defineProperty(t, "WebsocketClient", {
                enumerable: !0,
                get: function() {
                    return a.WebsocketClient
                }
            })
        },
        96731: function(e, t) {
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: !0
            }), t.hasProtocol = t.instanceOfRpcStreamingClient = void 0, t.instanceOfRpcStreamingClient = function(e) {
                return "function" == typeof e.listen
            }, t.hasProtocol = function(e) {
                return -1 !== e.search("://")
            }
        },
        82607: function(e, t, r) {
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: !0
            }), t.WebsocketClient = void 0;
            let n = r(47207),
                o = r(19998),
                i = r(67298),
                a = r(43813),
                s = r(96731);

            function d(e) {
                throw e
            }

            function c(e) {
                if ("message" !== e.type) throw Error(`Unexcepted message type on websocket: ${e.type}`);
                return (0, n.parseJsonRpcResponse)(JSON.parse(e.data))
            }
            class l {
                constructor(e, t) {
                    this.running = !1, this.subscriptions = [], this.request = e, this.socket = t
                }
                start(e) {
                    if (this.running) throw Error("Already started. Please stop first before restarting.");
                    this.running = !0, this.connectToClient(e), this.socket.queueRequest(JSON.stringify(this.request))
                }
                stop() {
                    this.running = !1;
                    let e = { ...this.request,
                        method: "unsubscribe"
                    };
                    try {
                        this.socket.queueRequest(JSON.stringify(e))
                    } catch (e) {
                        if (e instanceof Error && e.message.match(/socket has disconnected/i));
                        else throw e
                    }
                }
                connectToClient(e) {
                    let t = this.socket.events.map(c),
                        r = t.filter(e => e.id === this.request.id).subscribe({
                            next: t => {
                                (0, n.isJsonRpcErrorResponse)(t) && (this.closeSubscriptions(), e.error(JSON.stringify(t.error))), r.unsubscribe()
                            }
                        }),
                        o = t.filter(e => e.id === this.request.id).subscribe({
                            next: t => {
                                (0, n.isJsonRpcErrorResponse)(t) ? (this.closeSubscriptions(), e.error(JSON.stringify(t.error))) : e.next(t.result)
                            }
                        }),
                        i = t.subscribe({
                            error: t => {
                                this.closeSubscriptions(), e.error(t)
                            },
                            complete: () => {
                                this.closeSubscriptions(), e.complete()
                            }
                        });
                    this.subscriptions.push(r, o, i)
                }
                closeSubscriptions() {
                    for (let e of this.subscriptions) e.unsubscribe();
                    this.subscriptions = []
                }
            }
            class u {
                constructor(e, t = d) {
                    if (this.subscriptionStreams = new Map, !(0, s.hasProtocol)(e)) throw Error("Base URL is missing a protocol. Expected 'ws://' or 'wss://'.");
                    let r = e.endsWith("/") ? "websocket" : "/websocket";
                    this.url = e + r, this.socket = new o.ReconnectingSocket(this.url);
                    let n = this.socket.events.subscribe({
                        error: e => {
                            t(e), n.unsubscribe()
                        }
                    });
                    this.jsonRpcResponseStream = this.socket.events.map(c), this.socket.connect()
                }
                async execute(e) {
                    let t = this.responseForRequestId(e.id);
                    this.socket.queueRequest(JSON.stringify(e));
                    let r = await t;
                    if ((0, n.isJsonRpcErrorResponse)(r)) throw Error(JSON.stringify(r.error));
                    return r
                }
                listen(e) {
                    if ("subscribe" !== e.method) throw Error('Request method must be "subscribe" to start event listening');
                    let t = e.params.query;
                    if ("string" != typeof t) throw Error("request.params.query must be a string");
                    if (!this.subscriptionStreams.has(t)) {
                        let r = new l(e, this.socket),
                            n = a.Stream.create(r);
                        this.subscriptionStreams.set(t, n)
                    }
                    return this.subscriptionStreams.get(t).filter(e => void 0 !== e.query)
                }
                async connected() {
                    await this.socket.connectionStatus.waitFor(o.ConnectionStatus.Connected)
                }
                disconnect() {
                    this.socket.disconnect()
                }
                async responseForRequestId(e) {
                    return (0, i.firstEvent)(this.jsonRpcResponseStream.filter(t => t.id === e))
                }
            }
            t.WebsocketClient = u
        },
        92692: function(e, t, r) {
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: !0
            }), t.Responses = t.Params = void 0;
            var n = r(84399);
            Object.defineProperty(t, "Params", {
                enumerable: !0,
                get: function() {
                    return n.Params
                }
            });
            var o = r(31368);
            Object.defineProperty(t, "Responses", {
                enumerable: !0,
                get: function() {
                    return o.Responses
                }
            })
        },
        84399: function(e, t, r) {
            "use strict";
            var n = this && this.__createBinding || (Object.create ? function(e, t, r, n) {
                    void 0 === n && (n = r);
                    var o = Object.getOwnPropertyDescriptor(t, r);
                    (!o || ("get" in o ? !t.__esModule : o.writable || o.configurable)) && (o = {
                        enumerable: !0,
                        get: function() {
                            return t[r]
                        }
                    }), Object.defineProperty(e, n, o)
                } : function(e, t, r, n) {
                    void 0 === n && (n = r), e[n] = t[r]
                }),
                o = this && this.__setModuleDefault || (Object.create ? function(e, t) {
                    Object.defineProperty(e, "default", {
                        enumerable: !0,
                        value: t
                    })
                } : function(e, t) {
                    e.default = t
                }),
                i = this && this.__importStar || function(e) {
                    if (e && e.__esModule) return e;
                    var t = {};
                    if (null != e)
                        for (var r in e) "default" !== r && Object.prototype.hasOwnProperty.call(e, r) && n(t, e, r);
                    return o(t, e), t
                };
            Object.defineProperty(t, "__esModule", {
                value: !0
            }), t.Params = void 0;
            let a = r(15050),
                s = r(62882),
                d = r(53609),
                c = r(16529),
                l = i(r(71345));

            function u(e) {
                return {
                    height: (0, c.may)(s.smallIntToApi, e.height)
                }
            }
            class p {
                static encodeAbciInfo(e) {
                    return (0, d.createJsonRpcRequest)(e.method)
                }
                static encodeAbciQuery(e) {
                    var t;
                    return (0, d.createJsonRpcRequest)(e.method, (t = e.params, {
                        path: (0, c.assertNotEmpty)(t.path),
                        data: (0, a.toHex)(t.data),
                        height: (0, c.may)(s.smallIntToApi, t.height),
                        prove: t.prove
                    }))
                }
                static encodeBlock(e) {
                    return (0, d.createJsonRpcRequest)(e.method, u(e.params))
                }
                static encodeBlockchain(e) {
                    var t;
                    return (0, d.createJsonRpcRequest)(e.method, (t = e.params, {
                        minHeight: (0, c.may)(s.smallIntToApi, t.minHeight),
                        maxHeight: (0, c.may)(s.smallIntToApi, t.maxHeight)
                    }))
                }
                static encodeBlockResults(e) {
                    return (0, d.createJsonRpcRequest)(e.method, u(e.params))
                }
                static encodeBlockSearch(e) {
                    var t;
                    return (0, d.createJsonRpcRequest)(e.method, {
                        query: (t = e.params).query,
                        page: (0, c.may)(s.smallIntToApi, t.page),
                        per_page: (0, c.may)(s.smallIntToApi, t.per_page),
                        order_by: t.order_by
                    })
                }
                static encodeBroadcastTx(e) {
                    var t;
                    return (0, d.createJsonRpcRequest)(e.method, (t = e.params, {
                        tx: (0, a.toBase64)((0, c.assertNotEmpty)(t.tx))
                    }))
                }
                static encodeCommit(e) {
                    return (0, d.createJsonRpcRequest)(e.method, u(e.params))
                }
                static encodeGenesis(e) {
                    return (0, d.createJsonRpcRequest)(e.method)
                }
                static encodeHealth(e) {
                    return (0, d.createJsonRpcRequest)(e.method)
                }
                static encodeNumUnconfirmedTxs(e) {
                    return (0, d.createJsonRpcRequest)(e.method)
                }
                static encodeStatus(e) {
                    return (0, d.createJsonRpcRequest)(e.method)
                }
                static encodeSubscribe(e) {
                    let t = {
                            key: "tm.event",
                            value: e.query.type
                        },
                        r = l.buildQuery({
                            tags: [t],
                            raw: e.query.raw
                        });
                    return (0, d.createJsonRpcRequest)("subscribe", {
                        query: r
                    })
                }
                static encodeTx(e) {
                    var t;
                    return (0, d.createJsonRpcRequest)(e.method, (t = e.params, {
                        hash: (0, a.toBase64)((0, c.assertNotEmpty)(t.hash)),
                        prove: t.prove
                    }))
                }
                static encodeTxSearch(e) {
                    var t;
                    return (0, d.createJsonRpcRequest)(e.method, {
                        query: (t = e.params).query,
                        prove: t.prove,
                        page: (0, c.may)(s.smallIntToApi, t.page),
                        per_page: (0, c.may)(s.smallIntToApi, t.per_page),
                        order_by: t.order_by
                    })
                }
                static encodeValidators(e) {
                    var t;
                    return (0, d.createJsonRpcRequest)(e.method, (t = e.params, {
                        height: (0, c.may)(s.smallIntToApi, t.height),
                        page: (0, c.may)(s.smallIntToApi, t.page),
                        per_page: (0, c.may)(s.smallIntToApi, t.per_page)
                    }))
                }
            }
            t.Params = p
        },
        31368: function(e, t, r) {
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: !0
            }), t.Responses = t.decodeValidatorInfo = t.decodeValidatorGenesis = t.decodeValidatorUpdate = t.decodeEvent = void 0;
            let n = r(15050),
                o = r(93337),
                i = r(9448),
                a = r(62882),
                s = r(32196),
                d = r(16529),
                c = r(22508);

            function l(e) {
                return {
                    ops: e.ops.map(e => ({
                        type: e.type,
                        key: (0, n.fromBase64)(e.key),
                        data: (0, n.fromBase64)(e.data)
                    }))
                }
            }

            function u(e) {
                return {
                    key: (0, n.fromBase64)((0, d.assertNotEmpty)(e.key)),
                    value: (0, n.fromBase64)((0, d.assertString)(e.value ? ? ""))
                }
            }

            function p(e) {
                var t;
                return {
                    type: e.type,
                    attributes: e.attributes ? (t = e.attributes, (0, d.assertArray)(t).map(u)) : []
                }
            }

            function m(e) {
                return (0, d.assertArray)(e).map(p)
            }

            function g(e) {
                return {
                    code: (0, a.apiToSmallInt)((0, d.assertNumber)(e.code ? ? 0)),
                    codespace: e.codespace,
                    log: e.log,
                    data: (0, d.may)(n.fromBase64, e.data),
                    events: e.events ? m(e.events) : [],
                    gasWanted: (0, a.apiToBigInt)(e.gas_wanted ? ? "0"),
                    gasUsed: (0, a.apiToBigInt)(e.gas_used ? ? "0")
                }
            }

            function f(e) {
                if ("Sum" in e) {
                    let [
                        [t, r]
                    ] = Object.entries(e.Sum.value);
                    return (0, o.assert)("ed25519" === t || "secp256k1" === t, `unknown pubkey type: ${t}`), {
                        algorithm: t,
                        data: (0, n.fromBase64)((0, d.assertNotEmpty)(r))
                    }
                }
                switch (e.type) {
                    case "tendermint/PubKeyEd25519":
                        return {
                            algorithm: "ed25519",
                            data: (0, n.fromBase64)((0, d.assertNotEmpty)(e.value))
                        };
                    case "tendermint/PubKeySecp256k1":
                        return {
                            algorithm: "secp256k1",
                            data: (0, n.fromBase64)((0, d.assertNotEmpty)(e.value))
                        };
                    default:
                        throw Error(`unknown pubkey type: ${e.type}`)
                }
            }

            function y(e) {
                var t, r;
                return {
                    block: (t = (0, d.assertObject)(e.block), {
                        maxBytes: (0, a.apiToSmallInt)((0, d.assertNotEmpty)(t.max_bytes)),
                        maxGas: (0, a.apiToSmallInt)((0, d.assertNotEmpty)(t.max_gas))
                    }),
                    evidence: (r = (0, d.assertObject)(e.evidence), {
                        maxAgeNumBlocks: (0, a.apiToSmallInt)((0, d.assertNotEmpty)(r.max_age_num_blocks)),
                        maxAgeDuration: (0, a.apiToSmallInt)((0, d.assertNotEmpty)(r.max_age_duration))
                    })
                }
            }

            function h(e) {
                return {
                    pubkey: f((0, d.assertObject)(e.pub_key)),
                    votingPower: (0, a.apiToBigInt)(e.power ? ? "0")
                }
            }

            function v(e) {
                return {
                    hash: (0, n.fromHex)((0, d.assertNotEmpty)(e.hash)),
                    parts: {
                        total: (0, d.assertNotEmpty)(e.parts.total),
                        hash: (0, n.fromHex)((0, d.assertNotEmpty)(e.parts.hash))
                    }
                }
            }

            function b(e) {
                var t;
                return {
                    version: (t = e.version, {
                        block: (0, a.apiToSmallInt)(t.block),
                        app: (0, a.apiToSmallInt)(t.app ? ? 0)
                    }),
                    chainId: (0, d.assertNotEmpty)(e.chain_id),
                    height: (0, a.apiToSmallInt)((0, d.assertNotEmpty)(e.height)),
                    time: (0, i.fromRfc3339WithNanoseconds)((0, d.assertNotEmpty)(e.time)),
                    lastBlockId: e.last_block_id.hash ? v(e.last_block_id) : null,
                    lastCommitHash: (0, n.fromHex)((0, d.assertSet)(e.last_commit_hash)),
                    dataHash: (0, n.fromHex)((0, d.assertSet)(e.data_hash)),
                    validatorsHash: (0, n.fromHex)((0, d.assertSet)(e.validators_hash)),
                    nextValidatorsHash: (0, n.fromHex)((0, d.assertSet)(e.next_validators_hash)),
                    consensusHash: (0, n.fromHex)((0, d.assertSet)(e.consensus_hash)),
                    appHash: (0, n.fromHex)((0, d.assertSet)(e.app_hash)),
                    lastResultsHash: (0, n.fromHex)((0, d.assertSet)(e.last_results_hash)),
                    evidenceHash: (0, n.fromHex)((0, d.assertSet)(e.evidence_hash)),
                    proposerAddress: (0, n.fromHex)((0, d.assertNotEmpty)(e.proposer_address))
                }
            }

            function S(e) {
                return {
                    blockId: v(e.block_id),
                    blockSize: (0, a.apiToSmallInt)((0, d.assertNotEmpty)(e.block_size)),
                    header: b(e.header),
                    numTxs: (0, a.apiToSmallInt)((0, d.assertNotEmpty)(e.num_txs))
                }
            }

            function k(e) {
                var t;
                return {
                    blockIdFlag: (t = e.block_id_flag, (0, o.assert)(t in s.BlockIdFlag), t),
                    validatorAddress: e.validator_address ? (0, n.fromHex)(e.validator_address) : void 0,
                    timestamp: e.timestamp ? (0, i.fromRfc3339WithNanoseconds)(e.timestamp) : void 0,
                    signature: e.signature ? (0, n.fromBase64)(e.signature) : void 0
                }
            }

            function P(e) {
                return {
                    blockId: v((0, d.assertObject)(e.block_id)),
                    height: (0, a.apiToSmallInt)((0, d.assertNotEmpty)(e.height)),
                    round: (0, a.apiToSmallInt)(e.round),
                    signatures: (0, d.assertArray)(e.signatures).map(k)
                }
            }

            function _(e) {
                return {
                    address: (0, n.fromHex)((0, d.assertNotEmpty)(e.address)),
                    pubkey: f((0, d.assertObject)(e.pub_key)),
                    votingPower: (0, a.apiToBigInt)((0, d.assertNotEmpty)(e.power))
                }
            }

            function B(e) {
                return {
                    pubkey: f((0, d.assertObject)(e.pub_key)),
                    votingPower: (0, a.apiToBigInt)((0, d.assertNotEmpty)(e.voting_power)),
                    address: (0, n.fromHex)((0, d.assertNotEmpty)(e.address)),
                    proposerPriority: e.proposer_priority ? (0, a.apiToSmallInt)(e.proposer_priority) : void 0
                }
            }

            function O(e) {
                return {
                    data: (0, n.fromBase64)((0, d.assertNotEmpty)(e.data)),
                    rootHash: (0, n.fromHex)((0, d.assertNotEmpty)(e.root_hash)),
                    proof: {
                        total: (0, a.apiToSmallInt)((0, d.assertNotEmpty)(e.proof.total)),
                        index: (0, a.apiToSmallInt)((0, d.assertNotEmpty)(e.proof.index)),
                        leafHash: (0, n.fromBase64)((0, d.assertNotEmpty)(e.proof.leaf_hash)),
                        aunts: (0, d.assertArray)(e.proof.aunts).map(n.fromBase64)
                    }
                }
            }

            function R(e) {
                return {
                    tx: (0, n.fromBase64)((0, d.assertNotEmpty)(e.tx)),
                    result: g((0, d.assertObject)(e.tx_result)),
                    height: (0, a.apiToSmallInt)((0, d.assertNotEmpty)(e.height)),
                    index: (0, a.apiToSmallInt)((0, d.assertNumber)(e.index)),
                    hash: (0, n.fromHex)((0, d.assertNotEmpty)(e.hash)),
                    proof: (0, d.may)(O, e.proof)
                }
            }

            function A(e) {
                return {
                    header: b((0, d.assertObject)(e.header)),
                    lastCommit: e.last_commit.block_id.hash ? P((0, d.assertObject)(e.last_commit)) : null,
                    txs: e.data.txs ? (0, d.assertArray)(e.data.txs).map(n.fromBase64) : [],
                    evidence: e.evidence ? .evidence ? ? []
                }
            }

            function I(e) {
                return {
                    blockId: v(e.block_id),
                    block: A(e.block)
                }
            }
            t.decodeEvent = p, t.decodeValidatorUpdate = h, t.decodeValidatorGenesis = _, t.decodeValidatorInfo = B;
            class w {
                static decodeAbciInfo(e) {
                    var t;
                    return {
                        data: (t = (0, d.assertObject)(e.result.response)).data,
                        lastBlockHeight: (0, d.may)(a.apiToSmallInt, t.last_block_height),
                        lastBlockAppHash: (0, d.may)(n.fromBase64, t.last_block_app_hash)
                    }
                }
                static decodeAbciQuery(e) {
                    var t;
                    return t = (0, d.assertObject)(e.result.response), {
                        key: (0, n.fromBase64)((0, d.assertString)(t.key ? ? "")),
                        value: (0, n.fromBase64)((0, d.assertString)(t.value ? ? "")),
                        proof: (0, d.may)(l, t.proofOps),
                        height: (0, d.may)(a.apiToSmallInt, t.height),
                        code: (0, d.may)(a.apiToSmallInt, t.code),
                        codespace: (0, d.assertString)(t.codespace ? ? ""),
                        index: (0, d.may)(a.apiToSmallInt, t.index),
                        log: t.log,
                        info: (0, d.assertString)(t.info ? ? "")
                    }
                }
                static decodeBlock(e) {
                    return I(e.result)
                }
                static decodeBlockResults(e) {
                    var t;
                    return t = e.result, {
                        height: (0, a.apiToSmallInt)((0, d.assertNotEmpty)(t.height)),
                        results: (t.txs_results || []).map(g),
                        validatorUpdates: (t.validator_updates || []).map(h),
                        consensusUpdates: (0, d.may)(y, t.consensus_param_updates),
                        beginBlockEvents: m(t.begin_block_events || []),
                        endBlockEvents: m(t.end_block_events || [])
                    }
                }
                static decodeBlockSearch(e) {
                    var t;
                    return t = e.result, {
                        totalCount: (0, a.apiToSmallInt)((0, d.assertNotEmpty)(t.total_count)),
                        blocks: (0, d.assertArray)(t.blocks).map(I)
                    }
                }
                static decodeBlockchain(e) {
                    var t;
                    return t = e.result, {
                        lastHeight: (0, a.apiToSmallInt)((0, d.assertNotEmpty)(t.last_height)),
                        blockMetas: (0, d.assertArray)(t.block_metas).map(S)
                    }
                }
                static decodeBroadcastTxSync(e) {
                    var t;
                    return { ...g(t = e.result),
                        hash: (0, n.fromHex)((0, d.assertNotEmpty)(t.hash))
                    }
                }
                static decodeBroadcastTxAsync(e) {
                    return w.decodeBroadcastTxSync(e)
                }
                static decodeBroadcastTxCommit(e) {
                    var t;
                    return t = e.result, {
                        height: (0, a.apiToSmallInt)(t.height),
                        hash: (0, n.fromHex)((0, d.assertNotEmpty)(t.hash)),
                        checkTx: g((0, d.assertObject)(t.check_tx)),
                        deliverTx: (0, d.may)(g, t.deliver_tx)
                    }
                }
                static decodeCommit(e) {
                    var t;
                    return t = e.result, {
                        canonical: (0, d.assertBoolean)(t.canonical),
                        header: b(t.signed_header.header),
                        commit: P(t.signed_header.commit)
                    }
                }
                static decodeGenesis(e) {
                    var t;
                    return t = (0, d.assertObject)(e.result.genesis), {
                        genesisTime: (0, i.fromRfc3339WithNanoseconds)((0, d.assertNotEmpty)(t.genesis_time)),
                        chainId: (0, d.assertNotEmpty)(t.chain_id),
                        consensusParams: y(t.consensus_params),
                        validators: t.validators ? (0, d.assertArray)(t.validators).map(_) : [],
                        appHash: (0, n.fromHex)((0, d.assertSet)(t.app_hash)),
                        appState: t.app_state
                    }
                }
                static decodeHealth() {
                    return null
                }
                static decodeNumUnconfirmedTxs(e) {
                    var t;
                    return t = e.result, {
                        total: (0, a.apiToSmallInt)((0, d.assertNotEmpty)(t.total)),
                        totalBytes: (0, a.apiToSmallInt)((0, d.assertNotEmpty)(t.total_bytes))
                    }
                }
                static decodeStatus(e) {
                    var t, r;
                    return {
                        nodeInfo: (r = (t = e.result).node_info, {
                            id: (0, n.fromHex)((0, d.assertNotEmpty)(r.id)),
                            listenAddr: (0, d.assertNotEmpty)(r.listen_addr),
                            network: (0, d.assertNotEmpty)(r.network),
                            version: (0, d.assertString)(r.version),
                            channels: (0, d.assertNotEmpty)(r.channels),
                            moniker: (0, d.assertNotEmpty)(r.moniker),
                            other: (0, d.dictionaryToStringMap)(r.other),
                            protocolVersion: {
                                app: (0, a.apiToSmallInt)((0, d.assertNotEmpty)(r.protocol_version.app)),
                                block: (0, a.apiToSmallInt)((0, d.assertNotEmpty)(r.protocol_version.block)),
                                p2p: (0, a.apiToSmallInt)((0, d.assertNotEmpty)(r.protocol_version.p2p))
                            }
                        }),
                        syncInfo: function(e) {
                            let t = e.earliest_block_height ? (0, a.apiToSmallInt)(e.earliest_block_height) : void 0,
                                r = e.earliest_block_time ? (0, i.fromRfc3339WithNanoseconds)(e.earliest_block_time) : void 0;
                            return {
                                earliestAppHash: e.earliest_app_hash ? (0, n.fromHex)(e.earliest_app_hash) : void 0,
                                earliestBlockHash: e.earliest_block_hash ? (0, n.fromHex)(e.earliest_block_hash) : void 0,
                                earliestBlockHeight: t || void 0,
                                earliestBlockTime: r ? .getTime() ? r : void 0,
                                latestBlockHash: (0, n.fromHex)((0, d.assertNotEmpty)(e.latest_block_hash)),
                                latestAppHash: (0, n.fromHex)((0, d.assertNotEmpty)(e.latest_app_hash)),
                                latestBlockTime: (0, i.fromRfc3339WithNanoseconds)((0, d.assertNotEmpty)(e.latest_block_time)),
                                latestBlockHeight: (0, a.apiToSmallInt)((0, d.assertNotEmpty)(e.latest_block_height)),
                                catchingUp: (0, d.assertBoolean)(e.catching_up)
                            }
                        }(t.sync_info),
                        validatorInfo: B(t.validator_info)
                    }
                }
                static decodeNewBlockEvent(e) {
                    return A(e.data.value.block)
                }
                static decodeNewBlockHeaderEvent(e) {
                    return b(e.data.value.header)
                }
                static decodeTxEvent(e) {
                    return function(e) {
                        let t = (0, n.fromBase64)((0, d.assertNotEmpty)(e.tx));
                        return {
                            tx: t,
                            hash: (0, c.hashTx)(t),
                            result: g(e.result),
                            height: (0, a.apiToSmallInt)((0, d.assertNotEmpty)(e.height))
                        }
                    }(e.data.value.TxResult)
                }
                static decodeTx(e) {
                    return R(e.result)
                }
                static decodeTxSearch(e) {
                    var t;
                    return t = e.result, {
                        totalCount: (0, a.apiToSmallInt)((0, d.assertNotEmpty)(t.total_count)),
                        txs: (0, d.assertArray)(t.txs).map(R)
                    }
                }
                static decodeValidators(e) {
                    var t;
                    return t = e.result, {
                        blockHeight: (0, a.apiToSmallInt)((0, d.assertNotEmpty)(t.block_height)),
                        validators: (0, d.assertArray)(t.validators).map(B),
                        count: (0, a.apiToSmallInt)((0, d.assertNotEmpty)(t.count)),
                        total: (0, a.apiToSmallInt)((0, d.assertNotEmpty)(t.total))
                    }
                }
            }
            t.Responses = w
        },
        16529: function(e, t, r) {
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: !0
            }), t.encodeBlockId = t.encodeVersion = t.encodeBytes = t.encodeTime = t.encodeUvarint = t.encodeString = t.dictionaryToStringMap = t.may = t.assertNotEmpty = t.assertObject = t.assertArray = t.assertNumber = t.assertString = t.assertBoolean = t.assertSet = void 0;
            let n = r(15050);

            function o(e) {
                if (void 0 === e) throw Error("Value must not be undefined");
                if (null === e) throw Error("Value must not be null");
                return e
            }

            function i(e) {
                return e >= 128 ? Uint8Array.from([255 & e | 128, ...i(e >> 7)]) : Uint8Array.from([255 & e])
            }
            t.assertSet = o, t.assertBoolean = function(e) {
                if (o(e), "boolean" != typeof e) throw Error("Value must be a boolean");
                return e
            }, t.assertString = function(e) {
                if (o(e), "string" != typeof e) throw Error("Value must be a string");
                return e
            }, t.assertNumber = function(e) {
                if (o(e), "number" != typeof e) throw Error("Value must be a number");
                return e
            }, t.assertArray = function(e) {
                if (o(e), !Array.isArray(e)) throw Error("Value must be a an array");
                return e
            }, t.assertObject = function(e) {
                if (o(e), "object" != typeof e) throw Error("Value must be an object");
                if ("[object Object]" !== Object.prototype.toString.call(e)) throw Error("Value must be a simple object");
                return e
            }, t.assertNotEmpty = function(e) {
                if (o(e), "number" == typeof e && 0 === e) throw Error("must provide a non-zero value");
                if (0 === e.length) throw Error("must provide a non-empty value");
                return e
            }, t.may = function(e, t) {
                return null == t ? void 0 : e(t)
            }, t.dictionaryToStringMap = function(e) {
                let t = new Map;
                for (let r of Object.keys(e)) {
                    let n = e[r];
                    if ("string" != typeof n) throw Error("Found dictionary value of type other than string");
                    t.set(r, n)
                }
                return t
            }, t.encodeString = function(e) {
                let t = (0, n.toUtf8)(e);
                return Uint8Array.from([t.length, ...t])
            }, t.encodeUvarint = i, t.encodeTime = function(e) {
                let t = e.getTime(),
                    r = Math.floor(t / 1e3),
                    n = r ? [8, ...i(r)] : new Uint8Array,
                    o = (e.nanoseconds || 0) + t % 1e3 * 1e6,
                    a = o ? [16, ...i(o)] : new Uint8Array;
                return Uint8Array.from([...n, ...a])
            }, t.encodeBytes = function(e) {
                if (e.length >= 128) throw Error("Not implemented for byte arrays of length 128 or more");
                return e.length ? Uint8Array.from([e.length, ...e]) : new Uint8Array
            }, t.encodeVersion = function(e) {
                let t = e.block ? Uint8Array.from([8, ...i(e.block)]) : new Uint8Array,
                    r = e.app ? Uint8Array.from([16, ...i(e.app)]) : new Uint8Array;
                return Uint8Array.from([...t, ...r])
            }, t.encodeBlockId = function(e) {
                return Uint8Array.from([10, e.hash.length, ...e.hash, 18, e.parts.hash.length + 4, 8, e.parts.total, 18, e.parts.hash.length, ...e.parts.hash])
            }
        },
        22508: function(e, t, r) {
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: !0
            }), t.hashBlock = t.hashTx = void 0;
            let n = r(56257),
                o = r(16529);
            t.hashTx = function(e) {
                return (0, n.sha256)(e)
            }, t.hashBlock = function(e) {
                if (!e.lastBlockId) throw Error("Hashing a block header with no last block ID (i.e. header at height 1) is not supported. If you need this, contributions are welcome. Please add documentation and test vectors for this case.");
                return function e(t) {
                    switch (t.length) {
                        case 0:
                            throw Error("Cannot hash empty tree");
                        case 1:
                            return function(e) {
                                let t = new n.Sha256(Uint8Array.from([0]));
                                return t.update(e), t.digest()
                            }(t[0]);
                        default:
                            {
                                let r = function(e) {
                                    if (e < 1) throw Error("Cannot split an empty tree");
                                    let t = 2 ** Math.floor(Math.log2(e));
                                    return t < e ? t : t / 2
                                }(t.length);
                                return function(e, t) {
                                    let r = new n.Sha256(Uint8Array.from([1]));
                                    return r.update(e), r.update(t), r.digest()
                                }(e(t.slice(0, r)), e(t.slice(r)))
                            }
                    }
                }([(0, o.encodeVersion)(e.version), (0, o.encodeString)(e.chainId), (0, o.encodeUvarint)(e.height), (0, o.encodeTime)(e.time), (0, o.encodeBlockId)(e.lastBlockId), (0, o.encodeBytes)(e.lastCommitHash), (0, o.encodeBytes)(e.dataHash), (0, o.encodeBytes)(e.validatorsHash), (0, o.encodeBytes)(e.nextValidatorsHash), (0, o.encodeBytes)(e.consensusHash), (0, o.encodeBytes)(e.appHash), (0, o.encodeBytes)(e.lastResultsHash), (0, o.encodeBytes)(e.evidenceHash), (0, o.encodeBytes)(e.proposerAddress)])
            }
        },
        22682: function(e, t, r) {
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: !0
            }), t.Tendermint34Client = t.VoteType = t.broadcastTxSyncSuccess = t.broadcastTxCommitSuccess = t.SubscriptionEventType = t.Method = void 0;
            var n = r(71345);
            Object.defineProperty(t, "Method", {
                enumerable: !0,
                get: function() {
                    return n.Method
                }
            }), Object.defineProperty(t, "SubscriptionEventType", {
                enumerable: !0,
                get: function() {
                    return n.SubscriptionEventType
                }
            });
            var o = r(53923);
            Object.defineProperty(t, "broadcastTxCommitSuccess", {
                enumerable: !0,
                get: function() {
                    return o.broadcastTxCommitSuccess
                }
            }), Object.defineProperty(t, "broadcastTxSyncSuccess", {
                enumerable: !0,
                get: function() {
                    return o.broadcastTxSyncSuccess
                }
            }), Object.defineProperty(t, "VoteType", {
                enumerable: !0,
                get: function() {
                    return o.VoteType
                }
            });
            var i = r(38381);
            Object.defineProperty(t, "Tendermint34Client", {
                enumerable: !0,
                get: function() {
                    return i.Tendermint34Client
                }
            })
        },
        71345: function(e, t) {
            "use strict";
            var r, n;
            Object.defineProperty(t, "__esModule", {
                value: !0
            }), t.buildQuery = t.SubscriptionEventType = t.Method = void 0, (r = t.Method || (t.Method = {})).AbciInfo = "abci_info", r.AbciQuery = "abci_query", r.Block = "block", r.Blockchain = "blockchain", r.BlockResults = "block_results", r.BlockSearch = "block_search", r.BroadcastTxAsync = "broadcast_tx_async", r.BroadcastTxSync = "broadcast_tx_sync", r.BroadcastTxCommit = "broadcast_tx_commit", r.Commit = "commit", r.Genesis = "genesis", r.Health = "health", r.NumUnconfirmedTxs = "num_unconfirmed_txs", r.Status = "status", r.Subscribe = "subscribe", r.Tx = "tx", r.TxSearch = "tx_search", r.Validators = "validators", r.Unsubscribe = "unsubscribe", (n = t.SubscriptionEventType || (t.SubscriptionEventType = {})).NewBlock = "NewBlock", n.NewBlockHeader = "NewBlockHeader", n.Tx = "Tx", t.buildQuery = function(e) {
                return [...(e.tags ? e.tags : []).map(e => `${e.key}='${e.value}'`), ...e.raw ? [e.raw] : []].join(" AND ")
            }
        },
        53923: function(e, t) {
            "use strict";
            var r;
            Object.defineProperty(t, "__esModule", {
                value: !0
            }), t.VoteType = t.broadcastTxCommitSuccess = t.broadcastTxSyncSuccess = void 0, t.broadcastTxSyncSuccess = function(e) {
                return 0 === e.code
            }, t.broadcastTxCommitSuccess = function(e) {
                return 0 === e.checkTx.code && !!e.deliverTx && 0 === e.deliverTx.code
            }, (r = t.VoteType || (t.VoteType = {}))[r.PreVote = 1] = "PreVote", r[r.PreCommit = 2] = "PreCommit"
        },
        38381: function(e, t, r) {
            "use strict";
            var n = this && this.__createBinding || (Object.create ? function(e, t, r, n) {
                    void 0 === n && (n = r);
                    var o = Object.getOwnPropertyDescriptor(t, r);
                    (!o || ("get" in o ? !t.__esModule : o.writable || o.configurable)) && (o = {
                        enumerable: !0,
                        get: function() {
                            return t[r]
                        }
                    }), Object.defineProperty(e, n, o)
                } : function(e, t, r, n) {
                    void 0 === n && (n = r), e[n] = t[r]
                }),
                o = this && this.__setModuleDefault || (Object.create ? function(e, t) {
                    Object.defineProperty(e, "default", {
                        enumerable: !0,
                        value: t
                    })
                } : function(e, t) {
                    e.default = t
                }),
                i = this && this.__importStar || function(e) {
                    if (e && e.__esModule) return e;
                    var t = {};
                    if (null != e)
                        for (var r in e) "default" !== r && Object.prototype.hasOwnProperty.call(e, r) && n(t, e, r);
                    return o(t, e), t
                };
            Object.defineProperty(t, "__esModule", {
                value: !0
            }), t.Tendermint34Client = void 0;
            let a = r(53609),
                s = r(81418),
                d = r(92692),
                c = i(r(71345));
            class l {
                static async connect(e) {
                    let t;
                    return t = "object" == typeof e ? new s.HttpClient(e) : e.startsWith("http://") || e.startsWith("https://") ? new s.HttpClient(e) : new s.WebsocketClient(e), await this.detectVersion(t), l.create(t)
                }
                static async create(e) {
                    return new l(e)
                }
                static async detectVersion(e) {
                    let t = (0, a.createJsonRpcRequest)(c.Method.Status),
                        r = (await e.execute(t)).result;
                    if (!r || !r.node_info) throw Error("Unrecognized format for status response");
                    let n = r.node_info.version;
                    if ("string" != typeof n) throw Error("Unrecognized version format: must be string");
                    return n
                }
                constructor(e) {
                    this.client = e
                }
                disconnect() {
                    this.client.disconnect()
                }
                async abciInfo() {
                    let e = {
                        method: c.Method.AbciInfo
                    };
                    return this.doCall(e, d.Params.encodeAbciInfo, d.Responses.decodeAbciInfo)
                }
                async abciQuery(e) {
                    let t = {
                        params: e,
                        method: c.Method.AbciQuery
                    };
                    return this.doCall(t, d.Params.encodeAbciQuery, d.Responses.decodeAbciQuery)
                }
                async block(e) {
                    let t = {
                        method: c.Method.Block,
                        params: {
                            height: e
                        }
                    };
                    return this.doCall(t, d.Params.encodeBlock, d.Responses.decodeBlock)
                }
                async blockResults(e) {
                    let t = {
                        method: c.Method.BlockResults,
                        params: {
                            height: e
                        }
                    };
                    return this.doCall(t, d.Params.encodeBlockResults, d.Responses.decodeBlockResults)
                }
                async blockSearch(e) {
                    let t = {
                            params: e,
                            method: c.Method.BlockSearch
                        },
                        r = await this.doCall(t, d.Params.encodeBlockSearch, d.Responses.decodeBlockSearch);
                    return { ...r,
                        blocks: [...r.blocks].sort((e, t) => e.block.header.height - t.block.header.height)
                    }
                }
                async blockSearchAll(e) {
                    let t = e.page || 1,
                        r = [],
                        n = !1;
                    for (; !n;) {
                        let o = await this.blockSearch({ ...e,
                            page: t
                        });
                        r.push(...o.blocks), r.length < o.totalCount ? t++ : n = !0
                    }
                    return r.sort((e, t) => e.block.header.height - t.block.header.height), {
                        totalCount: r.length,
                        blocks: r
                    }
                }
                async blockchain(e, t) {
                    let r = {
                        method: c.Method.Blockchain,
                        params: {
                            minHeight: e,
                            maxHeight: t
                        }
                    };
                    return this.doCall(r, d.Params.encodeBlockchain, d.Responses.decodeBlockchain)
                }
                async broadcastTxSync(e) {
                    let t = {
                        params: e,
                        method: c.Method.BroadcastTxSync
                    };
                    return this.doCall(t, d.Params.encodeBroadcastTx, d.Responses.decodeBroadcastTxSync)
                }
                async broadcastTxAsync(e) {
                    let t = {
                        params: e,
                        method: c.Method.BroadcastTxAsync
                    };
                    return this.doCall(t, d.Params.encodeBroadcastTx, d.Responses.decodeBroadcastTxAsync)
                }
                async broadcastTxCommit(e) {
                    let t = {
                        params: e,
                        method: c.Method.BroadcastTxCommit
                    };
                    return this.doCall(t, d.Params.encodeBroadcastTx, d.Responses.decodeBroadcastTxCommit)
                }
                async commit(e) {
                    let t = {
                        method: c.Method.Commit,
                        params: {
                            height: e
                        }
                    };
                    return this.doCall(t, d.Params.encodeCommit, d.Responses.decodeCommit)
                }
                async genesis() {
                    let e = {
                        method: c.Method.Genesis
                    };
                    return this.doCall(e, d.Params.encodeGenesis, d.Responses.decodeGenesis)
                }
                async health() {
                    let e = {
                        method: c.Method.Health
                    };
                    return this.doCall(e, d.Params.encodeHealth, d.Responses.decodeHealth)
                }
                async numUnconfirmedTxs() {
                    let e = {
                        method: c.Method.NumUnconfirmedTxs
                    };
                    return this.doCall(e, d.Params.encodeNumUnconfirmedTxs, d.Responses.decodeNumUnconfirmedTxs)
                }
                async status() {
                    let e = {
                        method: c.Method.Status
                    };
                    return this.doCall(e, d.Params.encodeStatus, d.Responses.decodeStatus)
                }
                subscribeNewBlock() {
                    let e = {
                        method: c.Method.Subscribe,
                        query: {
                            type: c.SubscriptionEventType.NewBlock
                        }
                    };
                    return this.subscribe(e, d.Responses.decodeNewBlockEvent)
                }
                subscribeNewBlockHeader() {
                    let e = {
                        method: c.Method.Subscribe,
                        query: {
                            type: c.SubscriptionEventType.NewBlockHeader
                        }
                    };
                    return this.subscribe(e, d.Responses.decodeNewBlockHeaderEvent)
                }
                subscribeTx(e) {
                    let t = {
                        method: c.Method.Subscribe,
                        query: {
                            type: c.SubscriptionEventType.Tx,
                            raw: e
                        }
                    };
                    return this.subscribe(t, d.Responses.decodeTxEvent)
                }
                async tx(e) {
                    let t = {
                        params: e,
                        method: c.Method.Tx
                    };
                    return this.doCall(t, d.Params.encodeTx, d.Responses.decodeTx)
                }
                async txSearch(e) {
                    let t = {
                        params: e,
                        method: c.Method.TxSearch
                    };
                    return this.doCall(t, d.Params.encodeTxSearch, d.Responses.decodeTxSearch)
                }
                async txSearchAll(e) {
                    let t = e.page || 1,
                        r = [],
                        n = !1;
                    for (; !n;) {
                        let o = await this.txSearch({ ...e,
                            page: t
                        });
                        r.push(...o.txs), r.length < o.totalCount ? t++ : n = !0
                    }
                    return {
                        totalCount: r.length,
                        txs: r
                    }
                }
                async validators(e) {
                    let t = {
                        method: c.Method.Validators,
                        params: e
                    };
                    return this.doCall(t, d.Params.encodeValidators, d.Responses.decodeValidators)
                }
                async validatorsAll(e) {
                    let t = [],
                        r = 1,
                        n = !1,
                        o = e;
                    for (; !n;) {
                        let e = await this.validators({
                            per_page: 50,
                            height: o,
                            page: r
                        });
                        t.push(...e.validators), o = o || e.blockHeight, t.length < e.total ? r++ : n = !0
                    }
                    return {
                        blockHeight: o ? ? 0,
                        count: t.length,
                        total: t.length,
                        validators: t
                    }
                }
                async doCall(e, t, r) {
                    let n = t(e);
                    return r(await this.client.execute(n))
                }
                subscribe(e, t) {
                    if (!(0, s.instanceOfRpcStreamingClient)(this.client)) throw Error("This RPC client type cannot subscribe to events");
                    let r = d.Params.encodeSubscribe(e);
                    return this.client.listen(r).map(e => t(e))
                }
            }
            t.Tendermint34Client = l
        },
        32936: function(e, t, r) {
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: !0
            }), t.Responses = t.Params = void 0;
            var n = r(43820);
            Object.defineProperty(t, "Params", {
                enumerable: !0,
                get: function() {
                    return n.Params
                }
            });
            var o = r(10203);
            Object.defineProperty(t, "Responses", {
                enumerable: !0,
                get: function() {
                    return o.Responses
                }
            })
        },
        43820: function(e, t, r) {
            "use strict";
            var n = this && this.__createBinding || (Object.create ? function(e, t, r, n) {
                    void 0 === n && (n = r);
                    var o = Object.getOwnPropertyDescriptor(t, r);
                    (!o || ("get" in o ? !t.__esModule : o.writable || o.configurable)) && (o = {
                        enumerable: !0,
                        get: function() {
                            return t[r]
                        }
                    }), Object.defineProperty(e, n, o)
                } : function(e, t, r, n) {
                    void 0 === n && (n = r), e[n] = t[r]
                }),
                o = this && this.__setModuleDefault || (Object.create ? function(e, t) {
                    Object.defineProperty(e, "default", {
                        enumerable: !0,
                        value: t
                    })
                } : function(e, t) {
                    e.default = t
                }),
                i = this && this.__importStar || function(e) {
                    if (e && e.__esModule) return e;
                    var t = {};
                    if (null != e)
                        for (var r in e) "default" !== r && Object.prototype.hasOwnProperty.call(e, r) && n(t, e, r);
                    return o(t, e), t
                };
            Object.defineProperty(t, "__esModule", {
                value: !0
            }), t.Params = void 0;
            let a = r(15050),
                s = r(62882),
                d = r(53609),
                c = r(26036),
                l = i(r(33174));

            function u(e) {
                return {
                    height: (0, c.may)(s.smallIntToApi, e.height)
                }
            }
            class p {
                static encodeAbciInfo(e) {
                    return (0, d.createJsonRpcRequest)(e.method)
                }
                static encodeAbciQuery(e) {
                    var t;
                    return (0, d.createJsonRpcRequest)(e.method, (t = e.params, {
                        path: (0, c.assertNotEmpty)(t.path),
                        data: (0, a.toHex)(t.data),
                        height: (0, c.may)(s.smallIntToApi, t.height),
                        prove: t.prove
                    }))
                }
                static encodeBlock(e) {
                    return (0, d.createJsonRpcRequest)(e.method, u(e.params))
                }
                static encodeBlockchain(e) {
                    var t;
                    return (0, d.createJsonRpcRequest)(e.method, (t = e.params, {
                        minHeight: (0, c.may)(s.smallIntToApi, t.minHeight),
                        maxHeight: (0, c.may)(s.smallIntToApi, t.maxHeight)
                    }))
                }
                static encodeBlockResults(e) {
                    return (0, d.createJsonRpcRequest)(e.method, u(e.params))
                }
                static encodeBlockSearch(e) {
                    var t;
                    return (0, d.createJsonRpcRequest)(e.method, {
                        query: (t = e.params).query,
                        page: (0, c.may)(s.smallIntToApi, t.page),
                        per_page: (0, c.may)(s.smallIntToApi, t.per_page),
                        order_by: t.order_by
                    })
                }
                static encodeBroadcastTx(e) {
                    var t;
                    return (0, d.createJsonRpcRequest)(e.method, (t = e.params, {
                        tx: (0, a.toBase64)((0, c.assertNotEmpty)(t.tx))
                    }))
                }
                static encodeCommit(e) {
                    return (0, d.createJsonRpcRequest)(e.method, u(e.params))
                }
                static encodeGenesis(e) {
                    return (0, d.createJsonRpcRequest)(e.method)
                }
                static encodeHealth(e) {
                    return (0, d.createJsonRpcRequest)(e.method)
                }
                static encodeNumUnconfirmedTxs(e) {
                    return (0, d.createJsonRpcRequest)(e.method)
                }
                static encodeStatus(e) {
                    return (0, d.createJsonRpcRequest)(e.method)
                }
                static encodeSubscribe(e) {
                    let t = {
                            key: "tm.event",
                            value: e.query.type
                        },
                        r = l.buildQuery({
                            tags: [t],
                            raw: e.query.raw
                        });
                    return (0, d.createJsonRpcRequest)("subscribe", {
                        query: r
                    })
                }
                static encodeTx(e) {
                    var t;
                    return (0, d.createJsonRpcRequest)(e.method, (t = e.params, {
                        hash: (0, a.toBase64)((0, c.assertNotEmpty)(t.hash)),
                        prove: t.prove
                    }))
                }
                static encodeTxSearch(e) {
                    var t;
                    return (0, d.createJsonRpcRequest)(e.method, {
                        query: (t = e.params).query,
                        prove: t.prove,
                        page: (0, c.may)(s.smallIntToApi, t.page),
                        per_page: (0, c.may)(s.smallIntToApi, t.per_page),
                        order_by: t.order_by
                    })
                }
                static encodeValidators(e) {
                    var t;
                    return (0, d.createJsonRpcRequest)(e.method, (t = e.params, {
                        height: (0, c.may)(s.smallIntToApi, t.height),
                        page: (0, c.may)(s.smallIntToApi, t.page),
                        per_page: (0, c.may)(s.smallIntToApi, t.per_page)
                    }))
                }
            }
            t.Params = p
        },
        10203: function(e, t, r) {
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: !0
            }), t.Responses = t.decodeValidatorInfo = t.decodeValidatorGenesis = t.decodeValidatorUpdate = t.decodeEvent = void 0;
            let n = r(15050),
                o = r(93337),
                i = r(9448),
                a = r(62882),
                s = r(32196),
                d = r(26036),
                c = r(52871);

            function l(e) {
                return {
                    ops: e.ops.map(e => ({
                        type: e.type,
                        key: (0, n.fromBase64)(e.key),
                        data: (0, n.fromBase64)(e.data)
                    }))
                }
            }

            function u(e) {
                return {
                    key: (0, d.assertNotEmpty)(e.key),
                    value: e.value ? ? ""
                }
            }

            function p(e) {
                var t;
                return {
                    type: e.type,
                    attributes: e.attributes ? (t = e.attributes, (0, d.assertArray)(t).map(u)) : []
                }
            }

            function m(e) {
                return (0, d.assertArray)(e).map(p)
            }

            function g(e) {
                return {
                    code: (0, a.apiToSmallInt)((0, d.assertNumber)(e.code ? ? 0)),
                    codespace: e.codespace,
                    log: e.log,
                    data: (0, d.may)(n.fromBase64, e.data),
                    events: e.events ? m(e.events) : [],
                    gasWanted: (0, a.apiToBigInt)(e.gas_wanted ? ? "0"),
                    gasUsed: (0, a.apiToBigInt)(e.gas_used ? ? "0")
                }
            }

            function f(e) {
                if ("Sum" in e) {
                    let [
                        [t, r]
                    ] = Object.entries(e.Sum.value);
                    return (0, o.assert)("ed25519" === t || "secp256k1" === t, `unknown pubkey type: ${t}`), {
                        algorithm: t,
                        data: (0, n.fromBase64)((0, d.assertNotEmpty)(r))
                    }
                }
                switch (e.type) {
                    case "tendermint/PubKeyEd25519":
                        return {
                            algorithm: "ed25519",
                            data: (0, n.fromBase64)((0, d.assertNotEmpty)(e.value))
                        };
                    case "tendermint/PubKeySecp256k1":
                        return {
                            algorithm: "secp256k1",
                            data: (0, n.fromBase64)((0, d.assertNotEmpty)(e.value))
                        };
                    default:
                        throw Error(`unknown pubkey type: ${e.type}`)
                }
            }

            function y(e) {
                var t, r;
                return {
                    block: (t = (0, d.assertObject)(e.block), {
                        maxBytes: (0, a.apiToSmallInt)((0, d.assertNotEmpty)(t.max_bytes)),
                        maxGas: (0, a.apiToSmallInt)((0, d.assertNotEmpty)(t.max_gas))
                    }),
                    evidence: (r = (0, d.assertObject)(e.evidence), {
                        maxAgeNumBlocks: (0, a.apiToSmallInt)((0, d.assertNotEmpty)(r.max_age_num_blocks)),
                        maxAgeDuration: (0, a.apiToSmallInt)((0, d.assertNotEmpty)(r.max_age_duration))
                    })
                }
            }

            function h(e) {
                return {
                    pubkey: f((0, d.assertObject)(e.pub_key)),
                    votingPower: (0, a.apiToBigInt)(e.power ? ? "0")
                }
            }

            function v(e) {
                return {
                    hash: (0, n.fromHex)((0, d.assertNotEmpty)(e.hash)),
                    parts: {
                        total: (0, d.assertNotEmpty)(e.parts.total),
                        hash: (0, n.fromHex)((0, d.assertNotEmpty)(e.parts.hash))
                    }
                }
            }

            function b(e) {
                var t;
                return {
                    version: (t = e.version, {
                        block: (0, a.apiToSmallInt)(t.block),
                        app: (0, a.apiToSmallInt)(t.app ? ? 0)
                    }),
                    chainId: (0, d.assertNotEmpty)(e.chain_id),
                    height: (0, a.apiToSmallInt)((0, d.assertNotEmpty)(e.height)),
                    time: (0, i.fromRfc3339WithNanoseconds)((0, d.assertNotEmpty)(e.time)),
                    lastBlockId: e.last_block_id.hash ? v(e.last_block_id) : null,
                    lastCommitHash: (0, n.fromHex)((0, d.assertSet)(e.last_commit_hash)),
                    dataHash: (0, n.fromHex)((0, d.assertSet)(e.data_hash)),
                    validatorsHash: (0, n.fromHex)((0, d.assertSet)(e.validators_hash)),
                    nextValidatorsHash: (0, n.fromHex)((0, d.assertSet)(e.next_validators_hash)),
                    consensusHash: (0, n.fromHex)((0, d.assertSet)(e.consensus_hash)),
                    appHash: (0, n.fromHex)((0, d.assertSet)(e.app_hash)),
                    lastResultsHash: (0, n.fromHex)((0, d.assertSet)(e.last_results_hash)),
                    evidenceHash: (0, n.fromHex)((0, d.assertSet)(e.evidence_hash)),
                    proposerAddress: (0, n.fromHex)((0, d.assertNotEmpty)(e.proposer_address))
                }
            }

            function S(e) {
                return {
                    blockId: v(e.block_id),
                    blockSize: (0, a.apiToSmallInt)((0, d.assertNotEmpty)(e.block_size)),
                    header: b(e.header),
                    numTxs: (0, a.apiToSmallInt)((0, d.assertNotEmpty)(e.num_txs))
                }
            }

            function k(e) {
                var t;
                return {
                    blockIdFlag: (t = e.block_id_flag, (0, o.assert)(t in s.BlockIdFlag), t),
                    validatorAddress: e.validator_address ? (0, n.fromHex)(e.validator_address) : void 0,
                    timestamp: e.timestamp ? (0, i.fromRfc3339WithNanoseconds)(e.timestamp) : void 0,
                    signature: e.signature ? (0, n.fromBase64)(e.signature) : void 0
                }
            }

            function P(e) {
                return {
                    blockId: v((0, d.assertObject)(e.block_id)),
                    height: (0, a.apiToSmallInt)((0, d.assertNotEmpty)(e.height)),
                    round: (0, a.apiToSmallInt)(e.round),
                    signatures: (0, d.assertArray)(e.signatures).map(k)
                }
            }

            function _(e) {
                return {
                    address: (0, n.fromHex)((0, d.assertNotEmpty)(e.address)),
                    pubkey: f((0, d.assertObject)(e.pub_key)),
                    votingPower: (0, a.apiToBigInt)((0, d.assertNotEmpty)(e.power))
                }
            }

            function B(e) {
                return {
                    pubkey: f((0, d.assertObject)(e.pub_key)),
                    votingPower: (0, a.apiToBigInt)((0, d.assertNotEmpty)(e.voting_power)),
                    address: (0, n.fromHex)((0, d.assertNotEmpty)(e.address)),
                    proposerPriority: e.proposer_priority ? (0, a.apiToSmallInt)(e.proposer_priority) : void 0
                }
            }

            function O(e) {
                return {
                    data: (0, n.fromBase64)((0, d.assertNotEmpty)(e.data)),
                    rootHash: (0, n.fromHex)((0, d.assertNotEmpty)(e.root_hash)),
                    proof: {
                        total: (0, a.apiToSmallInt)((0, d.assertNotEmpty)(e.proof.total)),
                        index: (0, a.apiToSmallInt)((0, d.assertNotEmpty)(e.proof.index)),
                        leafHash: (0, n.fromBase64)((0, d.assertNotEmpty)(e.proof.leaf_hash)),
                        aunts: (0, d.assertArray)(e.proof.aunts).map(n.fromBase64)
                    }
                }
            }

            function R(e) {
                return {
                    tx: (0, n.fromBase64)((0, d.assertNotEmpty)(e.tx)),
                    result: g((0, d.assertObject)(e.tx_result)),
                    height: (0, a.apiToSmallInt)((0, d.assertNotEmpty)(e.height)),
                    index: (0, a.apiToSmallInt)((0, d.assertNumber)(e.index)),
                    hash: (0, n.fromHex)((0, d.assertNotEmpty)(e.hash)),
                    proof: (0, d.may)(O, e.proof)
                }
            }

            function A(e) {
                return {
                    header: b((0, d.assertObject)(e.header)),
                    lastCommit: e.last_commit.block_id.hash ? P((0, d.assertObject)(e.last_commit)) : null,
                    txs: e.data.txs ? (0, d.assertArray)(e.data.txs).map(n.fromBase64) : [],
                    evidence: e.evidence ? .evidence ? ? []
                }
            }

            function I(e) {
                return {
                    blockId: v(e.block_id),
                    block: A(e.block)
                }
            }
            t.decodeEvent = p, t.decodeValidatorUpdate = h, t.decodeValidatorGenesis = _, t.decodeValidatorInfo = B;
            class w {
                static decodeAbciInfo(e) {
                    var t;
                    return {
                        data: (t = (0, d.assertObject)(e.result.response)).data,
                        lastBlockHeight: (0, d.may)(a.apiToSmallInt, t.last_block_height),
                        lastBlockAppHash: (0, d.may)(n.fromBase64, t.last_block_app_hash)
                    }
                }
                static decodeAbciQuery(e) {
                    var t;
                    return t = (0, d.assertObject)(e.result.response), {
                        key: (0, n.fromBase64)((0, d.assertString)(t.key ? ? "")),
                        value: (0, n.fromBase64)((0, d.assertString)(t.value ? ? "")),
                        proof: (0, d.may)(l, t.proofOps),
                        height: (0, d.may)(a.apiToSmallInt, t.height),
                        code: (0, d.may)(a.apiToSmallInt, t.code),
                        codespace: (0, d.assertString)(t.codespace ? ? ""),
                        index: (0, d.may)(a.apiToSmallInt, t.index),
                        log: t.log,
                        info: (0, d.assertString)(t.info ? ? "")
                    }
                }
                static decodeBlock(e) {
                    return I(e.result)
                }
                static decodeBlockResults(e) {
                    var t;
                    return t = e.result, {
                        height: (0, a.apiToSmallInt)((0, d.assertNotEmpty)(t.height)),
                        results: (t.txs_results || []).map(g),
                        validatorUpdates: (t.validator_updates || []).map(h),
                        consensusUpdates: (0, d.may)(y, t.consensus_param_updates),
                        beginBlockEvents: m(t.begin_block_events || []),
                        endBlockEvents: m(t.end_block_events || [])
                    }
                }
                static decodeBlockSearch(e) {
                    var t;
                    return t = e.result, {
                        totalCount: (0, a.apiToSmallInt)((0, d.assertNotEmpty)(t.total_count)),
                        blocks: (0, d.assertArray)(t.blocks).map(I)
                    }
                }
                static decodeBlockchain(e) {
                    var t;
                    return t = e.result, {
                        lastHeight: (0, a.apiToSmallInt)((0, d.assertNotEmpty)(t.last_height)),
                        blockMetas: (0, d.assertArray)(t.block_metas).map(S)
                    }
                }
                static decodeBroadcastTxSync(e) {
                    var t;
                    return { ...g(t = e.result),
                        hash: (0, n.fromHex)((0, d.assertNotEmpty)(t.hash))
                    }
                }
                static decodeBroadcastTxAsync(e) {
                    return w.decodeBroadcastTxSync(e)
                }
                static decodeBroadcastTxCommit(e) {
                    var t;
                    return t = e.result, {
                        height: (0, a.apiToSmallInt)(t.height),
                        hash: (0, n.fromHex)((0, d.assertNotEmpty)(t.hash)),
                        checkTx: g((0, d.assertObject)(t.check_tx)),
                        deliverTx: (0, d.may)(g, t.deliver_tx)
                    }
                }
                static decodeCommit(e) {
                    var t;
                    return t = e.result, {
                        canonical: (0, d.assertBoolean)(t.canonical),
                        header: b(t.signed_header.header),
                        commit: P(t.signed_header.commit)
                    }
                }
                static decodeGenesis(e) {
                    var t;
                    return t = (0, d.assertObject)(e.result.genesis), {
                        genesisTime: (0, i.fromRfc3339WithNanoseconds)((0, d.assertNotEmpty)(t.genesis_time)),
                        chainId: (0, d.assertNotEmpty)(t.chain_id),
                        consensusParams: y(t.consensus_params),
                        validators: t.validators ? (0, d.assertArray)(t.validators).map(_) : [],
                        appHash: (0, n.fromHex)((0, d.assertSet)(t.app_hash)),
                        appState: t.app_state
                    }
                }
                static decodeHealth() {
                    return null
                }
                static decodeNumUnconfirmedTxs(e) {
                    var t;
                    return t = e.result, {
                        total: (0, a.apiToSmallInt)((0, d.assertNotEmpty)(t.total)),
                        totalBytes: (0, a.apiToSmallInt)((0, d.assertNotEmpty)(t.total_bytes))
                    }
                }
                static decodeStatus(e) {
                    var t, r;
                    return {
                        nodeInfo: (r = (t = e.result).node_info, {
                            id: (0, n.fromHex)((0, d.assertNotEmpty)(r.id)),
                            listenAddr: (0, d.assertNotEmpty)(r.listen_addr),
                            network: (0, d.assertNotEmpty)(r.network),
                            version: (0, d.assertString)(r.version),
                            channels: (0, d.assertNotEmpty)(r.channels),
                            moniker: (0, d.assertNotEmpty)(r.moniker),
                            other: (0, d.dictionaryToStringMap)(r.other),
                            protocolVersion: {
                                app: (0, a.apiToSmallInt)((0, d.assertNotEmpty)(r.protocol_version.app)),
                                block: (0, a.apiToSmallInt)((0, d.assertNotEmpty)(r.protocol_version.block)),
                                p2p: (0, a.apiToSmallInt)((0, d.assertNotEmpty)(r.protocol_version.p2p))
                            }
                        }),
                        syncInfo: function(e) {
                            let t = e.earliest_block_height ? (0, a.apiToSmallInt)(e.earliest_block_height) : void 0,
                                r = e.earliest_block_time ? (0, i.fromRfc3339WithNanoseconds)(e.earliest_block_time) : void 0;
                            return {
                                earliestAppHash: e.earliest_app_hash ? (0, n.fromHex)(e.earliest_app_hash) : void 0,
                                earliestBlockHash: e.earliest_block_hash ? (0, n.fromHex)(e.earliest_block_hash) : void 0,
                                earliestBlockHeight: t || void 0,
                                earliestBlockTime: r ? .getTime() ? r : void 0,
                                latestBlockHash: (0, n.fromHex)((0, d.assertNotEmpty)(e.latest_block_hash)),
                                latestAppHash: (0, n.fromHex)((0, d.assertNotEmpty)(e.latest_app_hash)),
                                latestBlockTime: (0, i.fromRfc3339WithNanoseconds)((0, d.assertNotEmpty)(e.latest_block_time)),
                                latestBlockHeight: (0, a.apiToSmallInt)((0, d.assertNotEmpty)(e.latest_block_height)),
                                catchingUp: (0, d.assertBoolean)(e.catching_up)
                            }
                        }(t.sync_info),
                        validatorInfo: B(t.validator_info)
                    }
                }
                static decodeNewBlockEvent(e) {
                    return A(e.data.value.block)
                }
                static decodeNewBlockHeaderEvent(e) {
                    return b(e.data.value.header)
                }
                static decodeTxEvent(e) {
                    return function(e) {
                        let t = (0, n.fromBase64)((0, d.assertNotEmpty)(e.tx));
                        return {
                            tx: t,
                            hash: (0, c.hashTx)(t),
                            result: g(e.result),
                            height: (0, a.apiToSmallInt)((0, d.assertNotEmpty)(e.height))
                        }
                    }(e.data.value.TxResult)
                }
                static decodeTx(e) {
                    return R(e.result)
                }
                static decodeTxSearch(e) {
                    var t;
                    return t = e.result, {
                        totalCount: (0, a.apiToSmallInt)((0, d.assertNotEmpty)(t.total_count)),
                        txs: (0, d.assertArray)(t.txs).map(R)
                    }
                }
                static decodeValidators(e) {
                    var t;
                    return t = e.result, {
                        blockHeight: (0, a.apiToSmallInt)((0, d.assertNotEmpty)(t.block_height)),
                        validators: (0, d.assertArray)(t.validators).map(B),
                        count: (0, a.apiToSmallInt)((0, d.assertNotEmpty)(t.count)),
                        total: (0, a.apiToSmallInt)((0, d.assertNotEmpty)(t.total))
                    }
                }
            }
            t.Responses = w
        },
        26036: function(e, t, r) {
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: !0
            }), t.encodeBlockId = t.encodeVersion = t.encodeBytes = t.encodeTime = t.encodeUvarint = t.encodeString = t.dictionaryToStringMap = t.may = t.assertNotEmpty = t.assertObject = t.assertArray = t.assertNumber = t.assertString = t.assertBoolean = t.assertSet = void 0;
            let n = r(15050);

            function o(e) {
                if (void 0 === e) throw Error("Value must not be undefined");
                if (null === e) throw Error("Value must not be null");
                return e
            }

            function i(e) {
                return e >= 128 ? Uint8Array.from([255 & e | 128, ...i(e >> 7)]) : Uint8Array.from([255 & e])
            }
            t.assertSet = o, t.assertBoolean = function(e) {
                if (o(e), "boolean" != typeof e) throw Error("Value must be a boolean");
                return e
            }, t.assertString = function(e) {
                if (o(e), "string" != typeof e) throw Error("Value must be a string");
                return e
            }, t.assertNumber = function(e) {
                if (o(e), "number" != typeof e) throw Error("Value must be a number");
                return e
            }, t.assertArray = function(e) {
                if (o(e), !Array.isArray(e)) throw Error("Value must be a an array");
                return e
            }, t.assertObject = function(e) {
                if (o(e), "object" != typeof e) throw Error("Value must be an object");
                if ("[object Object]" !== Object.prototype.toString.call(e)) throw Error("Value must be a simple object");
                return e
            }, t.assertNotEmpty = function(e) {
                if (o(e), "number" == typeof e && 0 === e) throw Error("must provide a non-zero value");
                if (0 === e.length) throw Error("must provide a non-empty value");
                return e
            }, t.may = function(e, t) {
                return null == t ? void 0 : e(t)
            }, t.dictionaryToStringMap = function(e) {
                let t = new Map;
                for (let r of Object.keys(e)) {
                    let n = e[r];
                    if ("string" != typeof n) throw Error("Found dictionary value of type other than string");
                    t.set(r, n)
                }
                return t
            }, t.encodeString = function(e) {
                let t = (0, n.toUtf8)(e);
                return Uint8Array.from([t.length, ...t])
            }, t.encodeUvarint = i, t.encodeTime = function(e) {
                let t = e.getTime(),
                    r = Math.floor(t / 1e3),
                    n = r ? [8, ...i(r)] : new Uint8Array,
                    o = (e.nanoseconds || 0) + t % 1e3 * 1e6,
                    a = o ? [16, ...i(o)] : new Uint8Array;
                return Uint8Array.from([...n, ...a])
            }, t.encodeBytes = function(e) {
                if (e.length >= 128) throw Error("Not implemented for byte arrays of length 128 or more");
                return e.length ? Uint8Array.from([e.length, ...e]) : new Uint8Array
            }, t.encodeVersion = function(e) {
                let t = e.block ? Uint8Array.from([8, ...i(e.block)]) : new Uint8Array,
                    r = e.app ? Uint8Array.from([16, ...i(e.app)]) : new Uint8Array;
                return Uint8Array.from([...t, ...r])
            }, t.encodeBlockId = function(e) {
                return Uint8Array.from([10, e.hash.length, ...e.hash, 18, e.parts.hash.length + 4, 8, e.parts.total, 18, e.parts.hash.length, ...e.parts.hash])
            }
        },
        52871: function(e, t, r) {
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: !0
            }), t.hashBlock = t.hashTx = void 0;
            let n = r(56257),
                o = r(26036);
            t.hashTx = function(e) {
                return (0, n.sha256)(e)
            }, t.hashBlock = function(e) {
                if (!e.lastBlockId) throw Error("Hashing a block header with no last block ID (i.e. header at height 1) is not supported. If you need this, contributions are welcome. Please add documentation and test vectors for this case.");
                return function e(t) {
                    switch (t.length) {
                        case 0:
                            throw Error("Cannot hash empty tree");
                        case 1:
                            return function(e) {
                                let t = new n.Sha256(Uint8Array.from([0]));
                                return t.update(e), t.digest()
                            }(t[0]);
                        default:
                            {
                                let r = function(e) {
                                    if (e < 1) throw Error("Cannot split an empty tree");
                                    let t = 2 ** Math.floor(Math.log2(e));
                                    return t < e ? t : t / 2
                                }(t.length);
                                return function(e, t) {
                                    let r = new n.Sha256(Uint8Array.from([1]));
                                    return r.update(e), r.update(t), r.digest()
                                }(e(t.slice(0, r)), e(t.slice(r)))
                            }
                    }
                }([(0, o.encodeVersion)(e.version), (0, o.encodeString)(e.chainId), (0, o.encodeUvarint)(e.height), (0, o.encodeTime)(e.time), (0, o.encodeBlockId)(e.lastBlockId), (0, o.encodeBytes)(e.lastCommitHash), (0, o.encodeBytes)(e.dataHash), (0, o.encodeBytes)(e.validatorsHash), (0, o.encodeBytes)(e.nextValidatorsHash), (0, o.encodeBytes)(e.consensusHash), (0, o.encodeBytes)(e.appHash), (0, o.encodeBytes)(e.lastResultsHash), (0, o.encodeBytes)(e.evidenceHash), (0, o.encodeBytes)(e.proposerAddress)])
            }
        },
        56491: function(e, t, r) {
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: !0
            }), t.Tendermint37Client = t.VoteType = t.broadcastTxSyncSuccess = t.broadcastTxCommitSuccess = t.SubscriptionEventType = t.Method = void 0;
            var n = r(33174);
            Object.defineProperty(t, "Method", {
                enumerable: !0,
                get: function() {
                    return n.Method
                }
            }), Object.defineProperty(t, "SubscriptionEventType", {
                enumerable: !0,
                get: function() {
                    return n.SubscriptionEventType
                }
            });
            var o = r(64722);
            Object.defineProperty(t, "broadcastTxCommitSuccess", {
                enumerable: !0,
                get: function() {
                    return o.broadcastTxCommitSuccess
                }
            }), Object.defineProperty(t, "broadcastTxSyncSuccess", {
                enumerable: !0,
                get: function() {
                    return o.broadcastTxSyncSuccess
                }
            }), Object.defineProperty(t, "VoteType", {
                enumerable: !0,
                get: function() {
                    return o.VoteType
                }
            });
            var i = r(22646);
            Object.defineProperty(t, "Tendermint37Client", {
                enumerable: !0,
                get: function() {
                    return i.Tendermint37Client
                }
            })
        },
        33174: function(e, t) {
            "use strict";
            var r, n;
            Object.defineProperty(t, "__esModule", {
                value: !0
            }), t.buildQuery = t.SubscriptionEventType = t.Method = void 0, (r = t.Method || (t.Method = {})).AbciInfo = "abci_info", r.AbciQuery = "abci_query", r.Block = "block", r.Blockchain = "blockchain", r.BlockResults = "block_results", r.BlockSearch = "block_search", r.BroadcastTxAsync = "broadcast_tx_async", r.BroadcastTxSync = "broadcast_tx_sync", r.BroadcastTxCommit = "broadcast_tx_commit", r.Commit = "commit", r.Genesis = "genesis", r.Health = "health", r.NumUnconfirmedTxs = "num_unconfirmed_txs", r.Status = "status", r.Subscribe = "subscribe", r.Tx = "tx", r.TxSearch = "tx_search", r.Validators = "validators", r.Unsubscribe = "unsubscribe", (n = t.SubscriptionEventType || (t.SubscriptionEventType = {})).NewBlock = "NewBlock", n.NewBlockHeader = "NewBlockHeader", n.Tx = "Tx", t.buildQuery = function(e) {
                return [...(e.tags ? e.tags : []).map(e => `${e.key}='${e.value}'`), ...e.raw ? [e.raw] : []].join(" AND ")
            }
        },
        64722: function(e, t) {
            "use strict";
            var r;
            Object.defineProperty(t, "__esModule", {
                value: !0
            }), t.VoteType = t.broadcastTxCommitSuccess = t.broadcastTxSyncSuccess = void 0, t.broadcastTxSyncSuccess = function(e) {
                return 0 === e.code
            }, t.broadcastTxCommitSuccess = function(e) {
                return 0 === e.checkTx.code && !!e.deliverTx && 0 === e.deliverTx.code
            }, (r = t.VoteType || (t.VoteType = {}))[r.PreVote = 1] = "PreVote", r[r.PreCommit = 2] = "PreCommit"
        },
        22646: function(e, t, r) {
            "use strict";
            var n = this && this.__createBinding || (Object.create ? function(e, t, r, n) {
                    void 0 === n && (n = r);
                    var o = Object.getOwnPropertyDescriptor(t, r);
                    (!o || ("get" in o ? !t.__esModule : o.writable || o.configurable)) && (o = {
                        enumerable: !0,
                        get: function() {
                            return t[r]
                        }
                    }), Object.defineProperty(e, n, o)
                } : function(e, t, r, n) {
                    void 0 === n && (n = r), e[n] = t[r]
                }),
                o = this && this.__setModuleDefault || (Object.create ? function(e, t) {
                    Object.defineProperty(e, "default", {
                        enumerable: !0,
                        value: t
                    })
                } : function(e, t) {
                    e.default = t
                }),
                i = this && this.__importStar || function(e) {
                    if (e && e.__esModule) return e;
                    var t = {};
                    if (null != e)
                        for (var r in e) "default" !== r && Object.prototype.hasOwnProperty.call(e, r) && n(t, e, r);
                    return o(t, e), t
                };
            Object.defineProperty(t, "__esModule", {
                value: !0
            }), t.Tendermint37Client = void 0;
            let a = r(53609),
                s = r(81418),
                d = r(32936),
                c = i(r(33174));
            class l {
                static async connect(e) {
                    let t;
                    return t = "object" == typeof e ? new s.HttpClient(e) : e.startsWith("http://") || e.startsWith("https://") ? new s.HttpClient(e) : new s.WebsocketClient(e), await this.detectVersion(t), l.create(t)
                }
                static async create(e) {
                    return new l(e)
                }
                static async detectVersion(e) {
                    let t = (0, a.createJsonRpcRequest)(c.Method.Status),
                        r = (await e.execute(t)).result;
                    if (!r || !r.node_info) throw Error("Unrecognized format for status response");
                    let n = r.node_info.version;
                    if ("string" != typeof n) throw Error("Unrecognized version format: must be string");
                    return n
                }
                constructor(e) {
                    this.client = e
                }
                disconnect() {
                    this.client.disconnect()
                }
                async abciInfo() {
                    let e = {
                        method: c.Method.AbciInfo
                    };
                    return this.doCall(e, d.Params.encodeAbciInfo, d.Responses.decodeAbciInfo)
                }
                async abciQuery(e) {
                    let t = {
                        params: e,
                        method: c.Method.AbciQuery
                    };
                    return this.doCall(t, d.Params.encodeAbciQuery, d.Responses.decodeAbciQuery)
                }
                async block(e) {
                    let t = {
                        method: c.Method.Block,
                        params: {
                            height: e
                        }
                    };
                    return this.doCall(t, d.Params.encodeBlock, d.Responses.decodeBlock)
                }
                async blockResults(e) {
                    let t = {
                        method: c.Method.BlockResults,
                        params: {
                            height: e
                        }
                    };
                    return this.doCall(t, d.Params.encodeBlockResults, d.Responses.decodeBlockResults)
                }
                async blockSearch(e) {
                    let t = {
                            params: e,
                            method: c.Method.BlockSearch
                        },
                        r = await this.doCall(t, d.Params.encodeBlockSearch, d.Responses.decodeBlockSearch);
                    return { ...r,
                        blocks: [...r.blocks].sort((e, t) => e.block.header.height - t.block.header.height)
                    }
                }
                async blockSearchAll(e) {
                    let t = e.page || 1,
                        r = [],
                        n = !1;
                    for (; !n;) {
                        let o = await this.blockSearch({ ...e,
                            page: t
                        });
                        r.push(...o.blocks), r.length < o.totalCount ? t++ : n = !0
                    }
                    return r.sort((e, t) => e.block.header.height - t.block.header.height), {
                        totalCount: r.length,
                        blocks: r
                    }
                }
                async blockchain(e, t) {
                    let r = {
                        method: c.Method.Blockchain,
                        params: {
                            minHeight: e,
                            maxHeight: t
                        }
                    };
                    return this.doCall(r, d.Params.encodeBlockchain, d.Responses.decodeBlockchain)
                }
                async broadcastTxSync(e) {
                    let t = {
                        params: e,
                        method: c.Method.BroadcastTxSync
                    };
                    return this.doCall(t, d.Params.encodeBroadcastTx, d.Responses.decodeBroadcastTxSync)
                }
                async broadcastTxAsync(e) {
                    let t = {
                        params: e,
                        method: c.Method.BroadcastTxAsync
                    };
                    return this.doCall(t, d.Params.encodeBroadcastTx, d.Responses.decodeBroadcastTxAsync)
                }
                async broadcastTxCommit(e) {
                    let t = {
                        params: e,
                        method: c.Method.BroadcastTxCommit
                    };
                    return this.doCall(t, d.Params.encodeBroadcastTx, d.Responses.decodeBroadcastTxCommit)
                }
                async commit(e) {
                    let t = {
                        method: c.Method.Commit,
                        params: {
                            height: e
                        }
                    };
                    return this.doCall(t, d.Params.encodeCommit, d.Responses.decodeCommit)
                }
                async genesis() {
                    let e = {
                        method: c.Method.Genesis
                    };
                    return this.doCall(e, d.Params.encodeGenesis, d.Responses.decodeGenesis)
                }
                async health() {
                    let e = {
                        method: c.Method.Health
                    };
                    return this.doCall(e, d.Params.encodeHealth, d.Responses.decodeHealth)
                }
                async numUnconfirmedTxs() {
                    let e = {
                        method: c.Method.NumUnconfirmedTxs
                    };
                    return this.doCall(e, d.Params.encodeNumUnconfirmedTxs, d.Responses.decodeNumUnconfirmedTxs)
                }
                async status() {
                    let e = {
                        method: c.Method.Status
                    };
                    return this.doCall(e, d.Params.encodeStatus, d.Responses.decodeStatus)
                }
                subscribeNewBlock() {
                    let e = {
                        method: c.Method.Subscribe,
                        query: {
                            type: c.SubscriptionEventType.NewBlock
                        }
                    };
                    return this.subscribe(e, d.Responses.decodeNewBlockEvent)
                }
                subscribeNewBlockHeader() {
                    let e = {
                        method: c.Method.Subscribe,
                        query: {
                            type: c.SubscriptionEventType.NewBlockHeader
                        }
                    };
                    return this.subscribe(e, d.Responses.decodeNewBlockHeaderEvent)
                }
                subscribeTx(e) {
                    let t = {
                        method: c.Method.Subscribe,
                        query: {
                            type: c.SubscriptionEventType.Tx,
                            raw: e
                        }
                    };
                    return this.subscribe(t, d.Responses.decodeTxEvent)
                }
                async tx(e) {
                    let t = {
                        params: e,
                        method: c.Method.Tx
                    };
                    return this.doCall(t, d.Params.encodeTx, d.Responses.decodeTx)
                }
                async txSearch(e) {
                    let t = {
                        params: e,
                        method: c.Method.TxSearch
                    };
                    return this.doCall(t, d.Params.encodeTxSearch, d.Responses.decodeTxSearch)
                }
                async txSearchAll(e) {
                    let t = e.page || 1,
                        r = [],
                        n = !1;
                    for (; !n;) {
                        let o = await this.txSearch({ ...e,
                            page: t
                        });
                        r.push(...o.txs), r.length < o.totalCount ? t++ : n = !0
                    }
                    return {
                        totalCount: r.length,
                        txs: r
                    }
                }
                async validators(e) {
                    let t = {
                        method: c.Method.Validators,
                        params: e
                    };
                    return this.doCall(t, d.Params.encodeValidators, d.Responses.decodeValidators)
                }
                async validatorsAll(e) {
                    let t = [],
                        r = 1,
                        n = !1,
                        o = e;
                    for (; !n;) {
                        let e = await this.validators({
                            per_page: 50,
                            height: o,
                            page: r
                        });
                        t.push(...e.validators), o = o || e.blockHeight, t.length < e.total ? r++ : n = !0
                    }
                    return {
                        blockHeight: o ? ? 0,
                        count: t.length,
                        total: t.length,
                        validators: t
                    }
                }
                async doCall(e, t, r) {
                    let n = t(e);
                    return r(await this.client.execute(n))
                }
                subscribe(e, t) {
                    if (!(0, s.instanceOfRpcStreamingClient)(this.client)) throw Error("This RPC client type cannot subscribe to events");
                    let r = d.Params.encodeSubscribe(e);
                    return this.client.listen(r).map(e => t(e))
                }
            }
            t.Tendermint37Client = l
        },
        34140: function(e, t, r) {
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: !0
            }), t.connectComet = t.isComet38Client = t.isTendermint37Client = t.isTendermint34Client = void 0;
            let n = r(26069),
                o = r(22682),
                i = r(56491);
            async function a(e) {
                let t;
                let r = await i.Tendermint37Client.connect(e),
                    a = (await r.status()).nodeInfo.version;
                return a.startsWith("0.37.") ? t = r : a.startsWith("0.38.") ? (r.disconnect(), t = await n.Comet38Client.connect(e)) : (r.disconnect(), t = await o.Tendermint34Client.connect(e)), t
            }
            t.isTendermint34Client = function(e) {
                return e instanceof o.Tendermint34Client
            }, t.isTendermint37Client = function(e) {
                return e instanceof i.Tendermint37Client
            }, t.isComet38Client = function(e) {
                return e instanceof n.Comet38Client
            }, t.connectComet = a
        },
        32196: function(e, t) {
            "use strict";
            var r;
            Object.defineProperty(t, "__esModule", {
                value: !0
            }), t.BlockIdFlag = void 0, (r = t.BlockIdFlag || (t.BlockIdFlag = {}))[r.Unknown = 0] = "Unknown", r[r.Absent = 1] = "Absent", r[r.Commit = 2] = "Commit", r[r.Nil = 3] = "Nil", r[r.Unrecognized = -1] = "Unrecognized"
        },
        85638: function(e, t) {
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: !0
            }), t.arrayContentStartsWith = t.arrayContentEquals = void 0, t.arrayContentEquals = function(e, t) {
                if (e.length !== t.length) return !1;
                for (let r = 0; r < e.length; ++r)
                    if (e[r] !== t[r]) return !1;
                return !0
            }, t.arrayContentStartsWith = function(e, t) {
                if (e.length < t.length) return !1;
                for (let r = 0; r < t.length; ++r)
                    if (e[r] !== t[r]) return !1;
                return !0
            }
        },
        25216: function(e, t) {
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: !0
            }), t.assertDefinedAndNotNull = t.assertDefined = t.assert = void 0, t.assert = function(e, t) {
                if (!e) throw Error(t || "condition is not truthy")
            }, t.assertDefined = function(e, t) {
                if (void 0 === e) throw Error(t ? ? "value is undefined")
            }, t.assertDefinedAndNotNull = function(e, t) {
                if (null == e) throw Error(t ? ? "value is undefined or null")
            }
        },
        93337: function(e, t, r) {
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: !0
            }), t.isUint8Array = t.isNonNullObject = t.isDefined = t.sleep = t.assertDefinedAndNotNull = t.assertDefined = t.assert = t.arrayContentStartsWith = t.arrayContentEquals = void 0;
            var n = r(85638);
            Object.defineProperty(t, "arrayContentEquals", {
                enumerable: !0,
                get: function() {
                    return n.arrayContentEquals
                }
            }), Object.defineProperty(t, "arrayContentStartsWith", {
                enumerable: !0,
                get: function() {
                    return n.arrayContentStartsWith
                }
            });
            var o = r(25216);
            Object.defineProperty(t, "assert", {
                enumerable: !0,
                get: function() {
                    return o.assert
                }
            }), Object.defineProperty(t, "assertDefined", {
                enumerable: !0,
                get: function() {
                    return o.assertDefined
                }
            }), Object.defineProperty(t, "assertDefinedAndNotNull", {
                enumerable: !0,
                get: function() {
                    return o.assertDefinedAndNotNull
                }
            });
            var i = r(32721);
            Object.defineProperty(t, "sleep", {
                enumerable: !0,
                get: function() {
                    return i.sleep
                }
            });
            var a = r(11445);
            Object.defineProperty(t, "isDefined", {
                enumerable: !0,
                get: function() {
                    return a.isDefined
                }
            }), Object.defineProperty(t, "isNonNullObject", {
                enumerable: !0,
                get: function() {
                    return a.isNonNullObject
                }
            }), Object.defineProperty(t, "isUint8Array", {
                enumerable: !0,
                get: function() {
                    return a.isUint8Array
                }
            })
        },
        32721: function(e, t) {
            "use strict";
            async function r(e) {
                return new Promise(t => setTimeout(t, e))
            }
            Object.defineProperty(t, "__esModule", {
                value: !0
            }), t.sleep = void 0, t.sleep = r
        },
        11445: function(e, t, r) {
            "use strict";
            var n = r(48764).Buffer;

            function o(e) {
                return "object" == typeof e && null !== e
            }
            Object.defineProperty(t, "__esModule", {
                value: !0
            }), t.isDefined = t.isUint8Array = t.isNonNullObject = void 0, t.isNonNullObject = o, t.isUint8Array = function(e) {
                return !(!o(e) || "[object Uint8Array]" !== Object.prototype.toString.call(e) || void 0 !== n && void 0 !== n.isBuffer && n.isBuffer(e))
            }, t.isDefined = function(e) {
                return void 0 !== e
            }
        },
        90093: function(e) {
            "use strict";
            for (var t = "qpzry9x8gf2tvdw0s3jn54khce6mua7l", r = {}, n = 0; n < t.length; n++) {
                var o = t.charAt(n);
                if (void 0 !== r[o]) throw TypeError(o + " is ambiguous");
                r[o] = n
            }

            function i(e) {
                var t = e >> 25;
                return (33554431 & e) << 5 ^ 996825010 & -(t >> 0 & 1) ^ 642813549 & -(t >> 1 & 1) ^ 513874426 & -(t >> 2 & 1) ^ 1027748829 & -(t >> 3 & 1) ^ 705979059 & -(t >> 4 & 1)
            }

            function a(e) {
                for (var t = 1, r = 0; r < e.length; ++r) {
                    var n = e.charCodeAt(r);
                    if (n < 33 || n > 126) return "Invalid prefix (" + e + ")";
                    t = i(t) ^ n >> 5
                }
                for (r = 0, t = i(t); r < e.length; ++r) {
                    var o = e.charCodeAt(r);
                    t = i(t) ^ 31 & o
                }
                return t
            }

            function s(e, t) {
                if (t = t || 90, e.length < 8) return e + " too short";
                if (e.length > t) return "Exceeds length limit";
                var n = e.toLowerCase(),
                    o = e.toUpperCase();
                if (e !== n && e !== o) return "Mixed-case string " + e;
                var s = (e = n).lastIndexOf("1");
                if (-1 === s) return "No separator character for " + e;
                if (0 === s) return "Missing prefix for " + e;
                var d = e.slice(0, s),
                    c = e.slice(s + 1);
                if (c.length < 6) return "Data too short";
                var l = a(d);
                if ("string" == typeof l) return l;
                for (var u = [], p = 0; p < c.length; ++p) {
                    var m = c.charAt(p),
                        g = r[m];
                    if (void 0 === g) return "Unknown character " + m;
                    l = i(l) ^ g, p + 6 >= c.length || u.push(g)
                }
                return 1 !== l ? "Invalid checksum for " + e : {
                    prefix: d,
                    words: u
                }
            }

            function d(e, t, r, n) {
                for (var o = 0, i = 0, a = (1 << r) - 1, s = [], d = 0; d < e.length; ++d)
                    for (o = o << t | e[d], i += t; i >= r;) s.push(o >> (i -= r) & a);
                if (n) i > 0 && s.push(o << r - i & a);
                else {
                    if (i >= t) return "Excess padding";
                    if (o << r - i & a) return "Non-zero padding"
                }
                return s
            }
            e.exports = {
                decodeUnsafe: function() {
                    var e = s.apply(null, arguments);
                    if ("object" == typeof e) return e
                },
                decode: function(e) {
                    var t = s.apply(null, arguments);
                    if ("object" == typeof t) return t;
                    throw Error(t)
                },
                encode: function(e, r, n) {
                    if (n = n || 90, e.length + 7 + r.length > n) throw TypeError("Exceeds length limit");
                    var o = a(e = e.toLowerCase());
                    if ("string" == typeof o) throw Error(o);
                    for (var s = e + "1", d = 0; d < r.length; ++d) {
                        var c = r[d];
                        if (c >> 5 != 0) throw Error("Non 5-bit word");
                        o = i(o) ^ c, s += t.charAt(c)
                    }
                    for (d = 0; d < 6; ++d) o = i(o);
                    for (o ^= 1, d = 0; d < 6; ++d) {
                        var l = o >> (5 - d) * 5 & 31;
                        s += t.charAt(l)
                    }
                    return s
                },
                toWordsUnsafe: function(e) {
                    var t = d(e, 8, 5, !0);
                    if (Array.isArray(t)) return t
                },
                toWords: function(e) {
                    var t = d(e, 8, 5, !0);
                    if (Array.isArray(t)) return t;
                    throw Error(t)
                },
                fromWordsUnsafe: function(e) {
                    var t = d(e, 5, 8, !1);
                    if (Array.isArray(t)) return t
                },
                fromWords: function(e) {
                    var t = d(e, 5, 8, !1);
                    if (Array.isArray(t)) return t;
                    throw Error(t)
                }
            }
        },
        28486: function(e, t, r) {
            "use strict";
            var n, o;
            Object.defineProperty(t, "__esModule", {
                value: !0
            }), t.BinaryWriter = t.BinaryReader = t.WireType = void 0;
            let i = r(83578),
                a = r(88767);
            (o = n || (t.WireType = n = {}))[o.Varint = 0] = "Varint", o[o.Fixed64 = 1] = "Fixed64", o[o.Bytes = 2] = "Bytes", o[o.Fixed32 = 5] = "Fixed32";
            class s {
                assertBounds() {
                    if (this.pos > this.len) throw RangeError("premature EOF")
                }
                constructor(e) {
                    this.buf = new Uint8Array(e || 0), this.pos = 0, this.type = 0, this.len = this.buf.length
                }
                tag() {
                    let e = this.uint32(),
                        t = e >>> 3,
                        r = 7 & e;
                    if (t <= 0 || r < 0 || r > 5) throw Error("illegal tag: field no " + t + " wire type " + r);
                    return [t, r, e]
                }
                skip(e) {
                    if ("number" == typeof e) {
                        if (this.pos + e > this.len) throw p(this, e);
                        this.pos += e
                    } else
                        do
                            if (this.pos >= this.len) throw p(this); while (128 & this.buf[this.pos++]);
                    return this
                }
                skipType(e) {
                    switch (e) {
                        case n.Varint:
                            this.skip();
                            break;
                        case n.Fixed64:
                            this.skip(8);
                            break;
                        case n.Bytes:
                            this.skip(this.uint32());
                            break;
                        case 3:
                            for (; 4 != (e = 7 & this.uint32());) this.skipType(e);
                            break;
                        case n.Fixed32:
                            this.skip(4);
                            break;
                        default:
                            throw Error("invalid wire type " + e + " at offset " + this.pos)
                    }
                    return this
                }
                uint32() {
                    return a.varint32read.bind(this)()
                }
                int32() {
                    return 0 | this.uint32()
                }
                sint32() {
                    let e = this.uint32();
                    return e % 2 == 1 ? -((e + 1) / 2) : e / 2
                }
                fixed32() {
                    let e = (0, a.readUInt32)(this.buf, this.pos);
                    return this.pos += 4, e
                }
                sfixed32() {
                    let e = (0, a.readInt32)(this.buf, this.pos);
                    return this.pos += 4, e
                }
                int64() {
                    let [e, t] = a.varint64read.bind(this)();
                    return BigInt((0, a.int64ToString)(e, t))
                }
                uint64() {
                    let [e, t] = a.varint64read.bind(this)();
                    return BigInt((0, a.uInt64ToString)(e, t))
                }
                sint64() {
                    let [e, t] = a.varint64read.bind(this)();
                    return [e, t] = (0, a.zzDecode)(e, t), BigInt((0, a.int64ToString)(e, t))
                }
                fixed64() {
                    let e = this.sfixed32(),
                        t = this.sfixed32();
                    return BigInt((0, a.uInt64ToString)(e, t))
                }
                sfixed64() {
                    let e = this.sfixed32(),
                        t = this.sfixed32();
                    return BigInt((0, a.int64ToString)(e, t))
                }
                float() {
                    throw Error("float not supported")
                }
                double() {
                    throw Error("double not supported")
                }
                bool() {
                    let [e, t] = a.varint64read.bind(this)();
                    return 0 !== e || 0 !== t
                }
                bytes() {
                    let e = this.uint32(),
                        t = this.pos;
                    return this.pos += e, this.assertBounds(), this.buf.subarray(t, t + e)
                }
                string() {
                    let e = this.bytes();
                    return (0, i.utf8Read)(e, 0, e.length)
                }
            }
            t.BinaryReader = s;
            class d {
                constructor(e, t, r) {
                    this.fn = e, this.len = t, this.val = r
                }
                proceed(e, t) {
                    this.fn && this.fn(this.val, e, t)
                }
            }
            class c {
                constructor(e) {
                    this.head = e.head, this.tail = e.tail, this.len = e.len, this.next = e.states
                }
            }
            class l {
                constructor() {
                    this.len = 0, this.uint64 = l.prototype.int64, this.sfixed64 = l.prototype.fixed64, this.sfixed32 = l.prototype.fixed32, this.head = new d(null, 0, 0), this.tail = this.head, this.states = null
                }
                static create() {
                    return new l
                }
                static alloc(e) {
                    return "undefined" != typeof Uint8Array ? (function(e, t, r) {
                        let n = 4096,
                            o = null,
                            i = 8192;
                        return function(r) {
                            if (r < 1 || r > n) return e(r);
                            i + r > 8192 && (o = e(8192), i = 0);
                            let a = t.call(o, i, i += r);
                            return 7 & i && (i = (7 | i) + 1), a
                        }
                    })(e => new Uint8Array(e), Uint8Array.prototype.subarray)(e) : Array(e)
                }
                _push(e, t, r) {
                    return this.tail = this.tail.next = new d(e, t, r), this.len += t, this
                }
                finish() {
                    let e = this.head.next,
                        t = 0,
                        r = l.alloc(this.len);
                    for (; e;) e.proceed(r, t), t += e.len, e = e.next;
                    return r
                }
                fork() {
                    return this.states = new c(this), this.head = this.tail = new d(null, 0, 0), this.len = 0, this
                }
                reset() {
                    return this.states ? (this.head = this.states.head, this.tail = this.states.tail, this.len = this.states.len, this.states = this.states.next) : (this.head = this.tail = new d(null, 0, 0), this.len = 0), this
                }
                ldelim() {
                    let e = this.head,
                        t = this.tail,
                        r = this.len;
                    return this.reset().uint32(r), r && (this.tail.next = e.next, this.tail = t, this.len += r), this
                }
                tag(e, t) {
                    return this.uint32((e << 3 | t) >>> 0)
                }
                uint32(e) {
                    return this.len += (this.tail = this.tail.next = new d(a.writeVarint32, (e >>>= 0) < 128 ? 1 : e < 16384 ? 2 : e < 2097152 ? 3 : e < 268435456 ? 4 : 5, e)).len, this
                }
                int32(e) {
                    return e < 0 ? this._push(a.writeVarint64, 10, (0, a.int64FromString)(e.toString())) : this.uint32(e)
                }
                sint32(e) {
                    return this.uint32((e << 1 ^ e >> 31) >>> 0)
                }
                int64(e) {
                    let {
                        lo: t,
                        hi: r
                    } = (0, a.int64FromString)(e.toString());
                    return this._push(a.writeVarint64, (0, a.int64Length)(t, r), {
                        lo: t,
                        hi: r
                    })
                }
                sint64(e) {
                    let {
                        lo: t,
                        hi: r
                    } = (0, a.int64FromString)(e.toString());
                    return [t, r] = (0, a.zzEncode)(t, r), this._push(a.writeVarint64, (0, a.int64Length)(t, r), {
                        lo: t,
                        hi: r
                    })
                }
                fixed64(e) {
                    let {
                        lo: t,
                        hi: r
                    } = (0, a.int64FromString)(e.toString());
                    return this._push(a.writeFixed32, 4, t)._push(a.writeFixed32, 4, r)
                }
                bool(e) {
                    return this._push(a.writeByte, 1, e ? 1 : 0)
                }
                fixed32(e) {
                    return this._push(a.writeFixed32, 4, e >>> 0)
                }
                float(e) {
                    throw Error("float not supported" + e)
                }
                double(e) {
                    throw Error("double not supported" + e)
                }
                bytes(e) {
                    let t = e.length >>> 0;
                    return t ? this.uint32(t)._push(u, t, e) : this._push(a.writeByte, 1, 0)
                }
                string(e) {
                    let t = (0, i.utf8Length)(e);
                    return t ? this.uint32(t)._push(i.utf8Write, t, e) : this._push(a.writeByte, 1, 0)
                }
            }

            function u(e, t, r) {
                if ("undefined" != typeof Uint8Array) t.set(e, r);
                else
                    for (let n = 0; n < e.length; ++n) t[r + n] = e[n]
            }

            function p(e, t) {
                return RangeError("index out of range: " + e.pos + " + " + (t || 1) + " > " + e.len)
            }
            t.BinaryWriter = l
        },
        50166: function(e, t, r) {
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: !0
            }), t.Params = t.ModuleCredential = t.ModuleAccount = t.BaseAccount = t.protobufPackage = void 0;
            let n = r(65676),
                o = r(28486),
                i = r(6476);

            function a() {
                return {
                    address: "",
                    pubKey: void 0,
                    accountNumber: BigInt(0),
                    sequence: BigInt(0)
                }
            }

            function s() {
                return {
                    baseAccount: void 0,
                    name: "",
                    permissions: []
                }
            }

            function d() {
                return {
                    moduleName: "",
                    derivationKeys: []
                }
            }

            function c() {
                return {
                    maxMemoCharacters: BigInt(0),
                    txSigLimit: BigInt(0),
                    txSizeCostPerByte: BigInt(0),
                    sigVerifyCostEd25519: BigInt(0),
                    sigVerifyCostSecp256k1: BigInt(0)
                }
            }
            t.protobufPackage = "cosmos.auth.v1beta1", t.BaseAccount = {
                typeUrl: "/cosmos.auth.v1beta1.BaseAccount",
                encode: (e, t = o.BinaryWriter.create()) => ("" !== e.address && t.uint32(10).string(e.address), void 0 !== e.pubKey && n.Any.encode(e.pubKey, t.uint32(18).fork()).ldelim(), e.accountNumber !== BigInt(0) && t.uint32(24).uint64(e.accountNumber), e.sequence !== BigInt(0) && t.uint32(32).uint64(e.sequence), t),
                decode(e, t) {
                    let r = e instanceof o.BinaryReader ? e : new o.BinaryReader(e),
                        i = void 0 === t ? r.len : r.pos + t,
                        s = a();
                    for (; r.pos < i;) {
                        let e = r.uint32();
                        switch (e >>> 3) {
                            case 1:
                                s.address = r.string();
                                break;
                            case 2:
                                s.pubKey = n.Any.decode(r, r.uint32());
                                break;
                            case 3:
                                s.accountNumber = r.uint64();
                                break;
                            case 4:
                                s.sequence = r.uint64();
                                break;
                            default:
                                r.skipType(7 & e)
                        }
                    }
                    return s
                },
                fromJSON(e) {
                    let t = a();
                    return (0, i.isSet)(e.address) && (t.address = String(e.address)), (0, i.isSet)(e.pubKey) && (t.pubKey = n.Any.fromJSON(e.pubKey)), (0, i.isSet)(e.accountNumber) && (t.accountNumber = BigInt(e.accountNumber.toString())), (0, i.isSet)(e.sequence) && (t.sequence = BigInt(e.sequence.toString())), t
                },
                toJSON(e) {
                    let t = {};
                    return void 0 !== e.address && (t.address = e.address), void 0 !== e.pubKey && (t.pubKey = e.pubKey ? n.Any.toJSON(e.pubKey) : void 0), void 0 !== e.accountNumber && (t.accountNumber = (e.accountNumber || BigInt(0)).toString()), void 0 !== e.sequence && (t.sequence = (e.sequence || BigInt(0)).toString()), t
                },
                fromPartial(e) {
                    let t = a();
                    return t.address = e.address ? ? "", void 0 !== e.pubKey && null !== e.pubKey && (t.pubKey = n.Any.fromPartial(e.pubKey)), void 0 !== e.accountNumber && null !== e.accountNumber && (t.accountNumber = BigInt(e.accountNumber.toString())), void 0 !== e.sequence && null !== e.sequence && (t.sequence = BigInt(e.sequence.toString())), t
                }
            }, t.ModuleAccount = {
                typeUrl: "/cosmos.auth.v1beta1.ModuleAccount",
                encode(e, r = o.BinaryWriter.create()) {
                    for (let n of (void 0 !== e.baseAccount && t.BaseAccount.encode(e.baseAccount, r.uint32(10).fork()).ldelim(), "" !== e.name && r.uint32(18).string(e.name), e.permissions)) r.uint32(26).string(n);
                    return r
                },
                decode(e, r) {
                    let n = e instanceof o.BinaryReader ? e : new o.BinaryReader(e),
                        i = void 0 === r ? n.len : n.pos + r,
                        a = s();
                    for (; n.pos < i;) {
                        let e = n.uint32();
                        switch (e >>> 3) {
                            case 1:
                                a.baseAccount = t.BaseAccount.decode(n, n.uint32());
                                break;
                            case 2:
                                a.name = n.string();
                                break;
                            case 3:
                                a.permissions.push(n.string());
                                break;
                            default:
                                n.skipType(7 & e)
                        }
                    }
                    return a
                },
                fromJSON(e) {
                    let r = s();
                    return (0, i.isSet)(e.baseAccount) && (r.baseAccount = t.BaseAccount.fromJSON(e.baseAccount)), (0, i.isSet)(e.name) && (r.name = String(e.name)), Array.isArray(e ? .permissions) && (r.permissions = e.permissions.map(e => String(e))), r
                },
                toJSON(e) {
                    let r = {};
                    return void 0 !== e.baseAccount && (r.baseAccount = e.baseAccount ? t.BaseAccount.toJSON(e.baseAccount) : void 0), void 0 !== e.name && (r.name = e.name), e.permissions ? r.permissions = e.permissions.map(e => e) : r.permissions = [], r
                },
                fromPartial(e) {
                    let r = s();
                    return void 0 !== e.baseAccount && null !== e.baseAccount && (r.baseAccount = t.BaseAccount.fromPartial(e.baseAccount)), r.name = e.name ? ? "", r.permissions = e.permissions ? .map(e => e) || [], r
                }
            }, t.ModuleCredential = {
                typeUrl: "/cosmos.auth.v1beta1.ModuleCredential",
                encode(e, t = o.BinaryWriter.create()) {
                    for (let r of ("" !== e.moduleName && t.uint32(10).string(e.moduleName), e.derivationKeys)) t.uint32(18).bytes(r);
                    return t
                },
                decode(e, t) {
                    let r = e instanceof o.BinaryReader ? e : new o.BinaryReader(e),
                        n = void 0 === t ? r.len : r.pos + t,
                        i = d();
                    for (; r.pos < n;) {
                        let e = r.uint32();
                        switch (e >>> 3) {
                            case 1:
                                i.moduleName = r.string();
                                break;
                            case 2:
                                i.derivationKeys.push(r.bytes());
                                break;
                            default:
                                r.skipType(7 & e)
                        }
                    }
                    return i
                },
                fromJSON(e) {
                    let t = d();
                    return (0, i.isSet)(e.moduleName) && (t.moduleName = String(e.moduleName)), Array.isArray(e ? .derivationKeys) && (t.derivationKeys = e.derivationKeys.map(e => (0, i.bytesFromBase64)(e))), t
                },
                toJSON(e) {
                    let t = {};
                    return void 0 !== e.moduleName && (t.moduleName = e.moduleName), e.derivationKeys ? t.derivationKeys = e.derivationKeys.map(e => (0, i.base64FromBytes)(void 0 !== e ? e : new Uint8Array)) : t.derivationKeys = [], t
                },
                fromPartial(e) {
                    let t = d();
                    return t.moduleName = e.moduleName ? ? "", t.derivationKeys = e.derivationKeys ? .map(e => e) || [], t
                }
            }, t.Params = {
                typeUrl: "/cosmos.auth.v1beta1.Params",
                encode: (e, t = o.BinaryWriter.create()) => (e.maxMemoCharacters !== BigInt(0) && t.uint32(8).uint64(e.maxMemoCharacters), e.txSigLimit !== BigInt(0) && t.uint32(16).uint64(e.txSigLimit), e.txSizeCostPerByte !== BigInt(0) && t.uint32(24).uint64(e.txSizeCostPerByte), e.sigVerifyCostEd25519 !== BigInt(0) && t.uint32(32).uint64(e.sigVerifyCostEd25519), e.sigVerifyCostSecp256k1 !== BigInt(0) && t.uint32(40).uint64(e.sigVerifyCostSecp256k1), t),
                decode(e, t) {
                    let r = e instanceof o.BinaryReader ? e : new o.BinaryReader(e),
                        n = void 0 === t ? r.len : r.pos + t,
                        i = c();
                    for (; r.pos < n;) {
                        let e = r.uint32();
                        switch (e >>> 3) {
                            case 1:
                                i.maxMemoCharacters = r.uint64();
                                break;
                            case 2:
                                i.txSigLimit = r.uint64();
                                break;
                            case 3:
                                i.txSizeCostPerByte = r.uint64();
                                break;
                            case 4:
                                i.sigVerifyCostEd25519 = r.uint64();
                                break;
                            case 5:
                                i.sigVerifyCostSecp256k1 = r.uint64();
                                break;
                            default:
                                r.skipType(7 & e)
                        }
                    }
                    return i
                },
                fromJSON(e) {
                    let t = c();
                    return (0, i.isSet)(e.maxMemoCharacters) && (t.maxMemoCharacters = BigInt(e.maxMemoCharacters.toString())), (0, i.isSet)(e.txSigLimit) && (t.txSigLimit = BigInt(e.txSigLimit.toString())), (0, i.isSet)(e.txSizeCostPerByte) && (t.txSizeCostPerByte = BigInt(e.txSizeCostPerByte.toString())), (0, i.isSet)(e.sigVerifyCostEd25519) && (t.sigVerifyCostEd25519 = BigInt(e.sigVerifyCostEd25519.toString())), (0, i.isSet)(e.sigVerifyCostSecp256k1) && (t.sigVerifyCostSecp256k1 = BigInt(e.sigVerifyCostSecp256k1.toString())), t
                },
                toJSON(e) {
                    let t = {};
                    return void 0 !== e.maxMemoCharacters && (t.maxMemoCharacters = (e.maxMemoCharacters || BigInt(0)).toString()), void 0 !== e.txSigLimit && (t.txSigLimit = (e.txSigLimit || BigInt(0)).toString()), void 0 !== e.txSizeCostPerByte && (t.txSizeCostPerByte = (e.txSizeCostPerByte || BigInt(0)).toString()), void 0 !== e.sigVerifyCostEd25519 && (t.sigVerifyCostEd25519 = (e.sigVerifyCostEd25519 || BigInt(0)).toString()), void 0 !== e.sigVerifyCostSecp256k1 && (t.sigVerifyCostSecp256k1 = (e.sigVerifyCostSecp256k1 || BigInt(0)).toString()), t
                },
                fromPartial(e) {
                    let t = c();
                    return void 0 !== e.maxMemoCharacters && null !== e.maxMemoCharacters && (t.maxMemoCharacters = BigInt(e.maxMemoCharacters.toString())), void 0 !== e.txSigLimit && null !== e.txSigLimit && (t.txSigLimit = BigInt(e.txSigLimit.toString())), void 0 !== e.txSizeCostPerByte && null !== e.txSizeCostPerByte && (t.txSizeCostPerByte = BigInt(e.txSizeCostPerByte.toString())), void 0 !== e.sigVerifyCostEd25519 && null !== e.sigVerifyCostEd25519 && (t.sigVerifyCostEd25519 = BigInt(e.sigVerifyCostEd25519.toString())), void 0 !== e.sigVerifyCostSecp256k1 && null !== e.sigVerifyCostSecp256k1 && (t.sigVerifyCostSecp256k1 = BigInt(e.sigVerifyCostSecp256k1.toString())), t
                }
            }
        },
        25517: function(e, t, r) {
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: !0
            }), t.QueryClientImpl = t.QueryAccountInfoResponse = t.QueryAccountInfoRequest = t.QueryAccountAddressByIDResponse = t.QueryAccountAddressByIDRequest = t.AddressStringToBytesResponse = t.AddressStringToBytesRequest = t.AddressBytesToStringResponse = t.AddressBytesToStringRequest = t.Bech32PrefixResponse = t.Bech32PrefixRequest = t.QueryModuleAccountByNameResponse = t.QueryModuleAccountByNameRequest = t.QueryModuleAccountsResponse = t.QueryModuleAccountsRequest = t.QueryParamsResponse = t.QueryParamsRequest = t.QueryAccountResponse = t.QueryAccountRequest = t.QueryAccountsResponse = t.QueryAccountsRequest = t.protobufPackage = void 0;
            let n = r(38792),
                o = r(65676),
                i = r(50166),
                a = r(28486),
                s = r(6476);

            function d() {
                return {
                    pagination: void 0
                }
            }

            function c() {
                return {
                    accounts: [],
                    pagination: void 0
                }
            }

            function l() {
                return {
                    address: ""
                }
            }

            function u() {
                return {
                    account: void 0
                }
            }

            function p() {
                return {
                    params: i.Params.fromPartial({})
                }
            }

            function m() {
                return {
                    accounts: []
                }
            }

            function g() {
                return {
                    name: ""
                }
            }

            function f() {
                return {
                    account: void 0
                }
            }

            function y() {
                return {
                    bech32Prefix: ""
                }
            }

            function h() {
                return {
                    addressBytes: new Uint8Array
                }
            }

            function v() {
                return {
                    addressString: ""
                }
            }

            function b() {
                return {
                    addressString: ""
                }
            }

            function S() {
                return {
                    addressBytes: new Uint8Array
                }
            }

            function k() {
                return {
                    id: BigInt(0),
                    accountId: BigInt(0)
                }
            }

            function P() {
                return {
                    accountAddress: ""
                }
            }

            function _() {
                return {
                    address: ""
                }
            }

            function B() {
                return {
                    info: void 0
                }
            }
            t.protobufPackage = "cosmos.auth.v1beta1", t.QueryAccountsRequest = {
                typeUrl: "/cosmos.auth.v1beta1.QueryAccountsRequest",
                encode: (e, t = a.BinaryWriter.create()) => (void 0 !== e.pagination && n.PageRequest.encode(e.pagination, t.uint32(10).fork()).ldelim(), t),
                decode(e, t) {
                    let r = e instanceof a.BinaryReader ? e : new a.BinaryReader(e),
                        o = void 0 === t ? r.len : r.pos + t,
                        i = d();
                    for (; r.pos < o;) {
                        let e = r.uint32();
                        e >>> 3 == 1 ? i.pagination = n.PageRequest.decode(r, r.uint32()) : r.skipType(7 & e)
                    }
                    return i
                },
                fromJSON(e) {
                    let t = d();
                    return (0, s.isSet)(e.pagination) && (t.pagination = n.PageRequest.fromJSON(e.pagination)), t
                },
                toJSON(e) {
                    let t = {};
                    return void 0 !== e.pagination && (t.pagination = e.pagination ? n.PageRequest.toJSON(e.pagination) : void 0), t
                },
                fromPartial(e) {
                    let t = d();
                    return void 0 !== e.pagination && null !== e.pagination && (t.pagination = n.PageRequest.fromPartial(e.pagination)), t
                }
            }, t.QueryAccountsResponse = {
                typeUrl: "/cosmos.auth.v1beta1.QueryAccountsResponse",
                encode(e, t = a.BinaryWriter.create()) {
                    for (let r of e.accounts) o.Any.encode(r, t.uint32(10).fork()).ldelim();
                    return void 0 !== e.pagination && n.PageResponse.encode(e.pagination, t.uint32(18).fork()).ldelim(), t
                },
                decode(e, t) {
                    let r = e instanceof a.BinaryReader ? e : new a.BinaryReader(e),
                        i = void 0 === t ? r.len : r.pos + t,
                        s = c();
                    for (; r.pos < i;) {
                        let e = r.uint32();
                        switch (e >>> 3) {
                            case 1:
                                s.accounts.push(o.Any.decode(r, r.uint32()));
                                break;
                            case 2:
                                s.pagination = n.PageResponse.decode(r, r.uint32());
                                break;
                            default:
                                r.skipType(7 & e)
                        }
                    }
                    return s
                },
                fromJSON(e) {
                    let t = c();
                    return Array.isArray(e ? .accounts) && (t.accounts = e.accounts.map(e => o.Any.fromJSON(e))), (0, s.isSet)(e.pagination) && (t.pagination = n.PageResponse.fromJSON(e.pagination)), t
                },
                toJSON(e) {
                    let t = {};
                    return e.accounts ? t.accounts = e.accounts.map(e => e ? o.Any.toJSON(e) : void 0) : t.accounts = [], void 0 !== e.pagination && (t.pagination = e.pagination ? n.PageResponse.toJSON(e.pagination) : void 0), t
                },
                fromPartial(e) {
                    let t = c();
                    return t.accounts = e.accounts ? .map(e => o.Any.fromPartial(e)) || [], void 0 !== e.pagination && null !== e.pagination && (t.pagination = n.PageResponse.fromPartial(e.pagination)), t
                }
            }, t.QueryAccountRequest = {
                typeUrl: "/cosmos.auth.v1beta1.QueryAccountRequest",
                encode: (e, t = a.BinaryWriter.create()) => ("" !== e.address && t.uint32(10).string(e.address), t),
                decode(e, t) {
                    let r = e instanceof a.BinaryReader ? e : new a.BinaryReader(e),
                        n = void 0 === t ? r.len : r.pos + t,
                        o = l();
                    for (; r.pos < n;) {
                        let e = r.uint32();
                        e >>> 3 == 1 ? o.address = r.string() : r.skipType(7 & e)
                    }
                    return o
                },
                fromJSON(e) {
                    let t = l();
                    return (0, s.isSet)(e.address) && (t.address = String(e.address)), t
                },
                toJSON(e) {
                    let t = {};
                    return void 0 !== e.address && (t.address = e.address), t
                },
                fromPartial(e) {
                    let t = l();
                    return t.address = e.address ? ? "", t
                }
            }, t.QueryAccountResponse = {
                typeUrl: "/cosmos.auth.v1beta1.QueryAccountResponse",
                encode: (e, t = a.BinaryWriter.create()) => (void 0 !== e.account && o.Any.encode(e.account, t.uint32(10).fork()).ldelim(), t),
                decode(e, t) {
                    let r = e instanceof a.BinaryReader ? e : new a.BinaryReader(e),
                        n = void 0 === t ? r.len : r.pos + t,
                        i = u();
                    for (; r.pos < n;) {
                        let e = r.uint32();
                        e >>> 3 == 1 ? i.account = o.Any.decode(r, r.uint32()) : r.skipType(7 & e)
                    }
                    return i
                },
                fromJSON(e) {
                    let t = u();
                    return (0, s.isSet)(e.account) && (t.account = o.Any.fromJSON(e.account)), t
                },
                toJSON(e) {
                    let t = {};
                    return void 0 !== e.account && (t.account = e.account ? o.Any.toJSON(e.account) : void 0), t
                },
                fromPartial(e) {
                    let t = u();
                    return void 0 !== e.account && null !== e.account && (t.account = o.Any.fromPartial(e.account)), t
                }
            }, t.QueryParamsRequest = {
                typeUrl: "/cosmos.auth.v1beta1.QueryParamsRequest",
                encode: (e, t = a.BinaryWriter.create()) => t,
                decode(e, t) {
                    let r = e instanceof a.BinaryReader ? e : new a.BinaryReader(e),
                        n = void 0 === t ? r.len : r.pos + t;
                    for (; r.pos < n;) {
                        let e = r.uint32();
                        r.skipType(7 & e)
                    }
                    return {}
                },
                fromJSON: e => ({}),
                toJSON: e => ({}),
                fromPartial: e => ({})
            }, t.QueryParamsResponse = {
                typeUrl: "/cosmos.auth.v1beta1.QueryParamsResponse",
                encode: (e, t = a.BinaryWriter.create()) => (void 0 !== e.params && i.Params.encode(e.params, t.uint32(10).fork()).ldelim(), t),
                decode(e, t) {
                    let r = e instanceof a.BinaryReader ? e : new a.BinaryReader(e),
                        n = void 0 === t ? r.len : r.pos + t,
                        o = p();
                    for (; r.pos < n;) {
                        let e = r.uint32();
                        e >>> 3 == 1 ? o.params = i.Params.decode(r, r.uint32()) : r.skipType(7 & e)
                    }
                    return o
                },
                fromJSON(e) {
                    let t = p();
                    return (0, s.isSet)(e.params) && (t.params = i.Params.fromJSON(e.params)), t
                },
                toJSON(e) {
                    let t = {};
                    return void 0 !== e.params && (t.params = e.params ? i.Params.toJSON(e.params) : void 0), t
                },
                fromPartial(e) {
                    let t = p();
                    return void 0 !== e.params && null !== e.params && (t.params = i.Params.fromPartial(e.params)), t
                }
            }, t.QueryModuleAccountsRequest = {
                typeUrl: "/cosmos.auth.v1beta1.QueryModuleAccountsRequest",
                encode: (e, t = a.BinaryWriter.create()) => t,
                decode(e, t) {
                    let r = e instanceof a.BinaryReader ? e : new a.BinaryReader(e),
                        n = void 0 === t ? r.len : r.pos + t;
                    for (; r.pos < n;) {
                        let e = r.uint32();
                        r.skipType(7 & e)
                    }
                    return {}
                },
                fromJSON: e => ({}),
                toJSON: e => ({}),
                fromPartial: e => ({})
            }, t.QueryModuleAccountsResponse = {
                typeUrl: "/cosmos.auth.v1beta1.QueryModuleAccountsResponse",
                encode(e, t = a.BinaryWriter.create()) {
                    for (let r of e.accounts) o.Any.encode(r, t.uint32(10).fork()).ldelim();
                    return t
                },
                decode(e, t) {
                    let r = e instanceof a.BinaryReader ? e : new a.BinaryReader(e),
                        n = void 0 === t ? r.len : r.pos + t,
                        i = m();
                    for (; r.pos < n;) {
                        let e = r.uint32();
                        e >>> 3 == 1 ? i.accounts.push(o.Any.decode(r, r.uint32())) : r.skipType(7 & e)
                    }
                    return i
                },
                fromJSON(e) {
                    let t = m();
                    return Array.isArray(e ? .accounts) && (t.accounts = e.accounts.map(e => o.Any.fromJSON(e))), t
                },
                toJSON(e) {
                    let t = {};
                    return e.accounts ? t.accounts = e.accounts.map(e => e ? o.Any.toJSON(e) : void 0) : t.accounts = [], t
                },
                fromPartial(e) {
                    let t = m();
                    return t.accounts = e.accounts ? .map(e => o.Any.fromPartial(e)) || [], t
                }
            }, t.QueryModuleAccountByNameRequest = {
                typeUrl: "/cosmos.auth.v1beta1.QueryModuleAccountByNameRequest",
                encode: (e, t = a.BinaryWriter.create()) => ("" !== e.name && t.uint32(10).string(e.name), t),
                decode(e, t) {
                    let r = e instanceof a.BinaryReader ? e : new a.BinaryReader(e),
                        n = void 0 === t ? r.len : r.pos + t,
                        o = g();
                    for (; r.pos < n;) {
                        let e = r.uint32();
                        e >>> 3 == 1 ? o.name = r.string() : r.skipType(7 & e)
                    }
                    return o
                },
                fromJSON(e) {
                    let t = g();
                    return (0, s.isSet)(e.name) && (t.name = String(e.name)), t
                },
                toJSON(e) {
                    let t = {};
                    return void 0 !== e.name && (t.name = e.name), t
                },
                fromPartial(e) {
                    let t = g();
                    return t.name = e.name ? ? "", t
                }
            }, t.QueryModuleAccountByNameResponse = {
                typeUrl: "/cosmos.auth.v1beta1.QueryModuleAccountByNameResponse",
                encode: (e, t = a.BinaryWriter.create()) => (void 0 !== e.account && o.Any.encode(e.account, t.uint32(10).fork()).ldelim(), t),
                decode(e, t) {
                    let r = e instanceof a.BinaryReader ? e : new a.BinaryReader(e),
                        n = void 0 === t ? r.len : r.pos + t,
                        i = f();
                    for (; r.pos < n;) {
                        let e = r.uint32();
                        e >>> 3 == 1 ? i.account = o.Any.decode(r, r.uint32()) : r.skipType(7 & e)
                    }
                    return i
                },
                fromJSON(e) {
                    let t = f();
                    return (0, s.isSet)(e.account) && (t.account = o.Any.fromJSON(e.account)), t
                },
                toJSON(e) {
                    let t = {};
                    return void 0 !== e.account && (t.account = e.account ? o.Any.toJSON(e.account) : void 0), t
                },
                fromPartial(e) {
                    let t = f();
                    return void 0 !== e.account && null !== e.account && (t.account = o.Any.fromPartial(e.account)), t
                }
            }, t.Bech32PrefixRequest = {
                typeUrl: "/cosmos.auth.v1beta1.Bech32PrefixRequest",
                encode: (e, t = a.BinaryWriter.create()) => t,
                decode(e, t) {
                    let r = e instanceof a.BinaryReader ? e : new a.BinaryReader(e),
                        n = void 0 === t ? r.len : r.pos + t;
                    for (; r.pos < n;) {
                        let e = r.uint32();
                        r.skipType(7 & e)
                    }
                    return {}
                },
                fromJSON: e => ({}),
                toJSON: e => ({}),
                fromPartial: e => ({})
            }, t.Bech32PrefixResponse = {
                typeUrl: "/cosmos.auth.v1beta1.Bech32PrefixResponse",
                encode: (e, t = a.BinaryWriter.create()) => ("" !== e.bech32Prefix && t.uint32(10).string(e.bech32Prefix), t),
                decode(e, t) {
                    let r = e instanceof a.BinaryReader ? e : new a.BinaryReader(e),
                        n = void 0 === t ? r.len : r.pos + t,
                        o = y();
                    for (; r.pos < n;) {
                        let e = r.uint32();
                        e >>> 3 == 1 ? o.bech32Prefix = r.string() : r.skipType(7 & e)
                    }
                    return o
                },
                fromJSON(e) {
                    let t = y();
                    return (0, s.isSet)(e.bech32Prefix) && (t.bech32Prefix = String(e.bech32Prefix)), t
                },
                toJSON(e) {
                    let t = {};
                    return void 0 !== e.bech32Prefix && (t.bech32Prefix = e.bech32Prefix), t
                },
                fromPartial(e) {
                    let t = y();
                    return t.bech32Prefix = e.bech32Prefix ? ? "", t
                }
            }, t.AddressBytesToStringRequest = {
                typeUrl: "/cosmos.auth.v1beta1.AddressBytesToStringRequest",
                encode: (e, t = a.BinaryWriter.create()) => (0 !== e.addressBytes.length && t.uint32(10).bytes(e.addressBytes), t),
                decode(e, t) {
                    let r = e instanceof a.BinaryReader ? e : new a.BinaryReader(e),
                        n = void 0 === t ? r.len : r.pos + t,
                        o = h();
                    for (; r.pos < n;) {
                        let e = r.uint32();
                        e >>> 3 == 1 ? o.addressBytes = r.bytes() : r.skipType(7 & e)
                    }
                    return o
                },
                fromJSON(e) {
                    let t = h();
                    return (0, s.isSet)(e.addressBytes) && (t.addressBytes = (0, s.bytesFromBase64)(e.addressBytes)), t
                },
                toJSON(e) {
                    let t = {};
                    return void 0 !== e.addressBytes && (t.addressBytes = (0, s.base64FromBytes)(void 0 !== e.addressBytes ? e.addressBytes : new Uint8Array)), t
                },
                fromPartial(e) {
                    let t = h();
                    return t.addressBytes = e.addressBytes ? ? new Uint8Array, t
                }
            }, t.AddressBytesToStringResponse = {
                typeUrl: "/cosmos.auth.v1beta1.AddressBytesToStringResponse",
                encode: (e, t = a.BinaryWriter.create()) => ("" !== e.addressString && t.uint32(10).string(e.addressString), t),
                decode(e, t) {
                    let r = e instanceof a.BinaryReader ? e : new a.BinaryReader(e),
                        n = void 0 === t ? r.len : r.pos + t,
                        o = v();
                    for (; r.pos < n;) {
                        let e = r.uint32();
                        e >>> 3 == 1 ? o.addressString = r.string() : r.skipType(7 & e)
                    }
                    return o
                },
                fromJSON(e) {
                    let t = v();
                    return (0, s.isSet)(e.addressString) && (t.addressString = String(e.addressString)), t
                },
                toJSON(e) {
                    let t = {};
                    return void 0 !== e.addressString && (t.addressString = e.addressString), t
                },
                fromPartial(e) {
                    let t = v();
                    return t.addressString = e.addressString ? ? "", t
                }
            }, t.AddressStringToBytesRequest = {
                typeUrl: "/cosmos.auth.v1beta1.AddressStringToBytesRequest",
                encode: (e, t = a.BinaryWriter.create()) => ("" !== e.addressString && t.uint32(10).string(e.addressString), t),
                decode(e, t) {
                    let r = e instanceof a.BinaryReader ? e : new a.BinaryReader(e),
                        n = void 0 === t ? r.len : r.pos + t,
                        o = b();
                    for (; r.pos < n;) {
                        let e = r.uint32();
                        e >>> 3 == 1 ? o.addressString = r.string() : r.skipType(7 & e)
                    }
                    return o
                },
                fromJSON(e) {
                    let t = b();
                    return (0, s.isSet)(e.addressString) && (t.addressString = String(e.addressString)), t
                },
                toJSON(e) {
                    let t = {};
                    return void 0 !== e.addressString && (t.addressString = e.addressString), t
                },
                fromPartial(e) {
                    let t = b();
                    return t.addressString = e.addressString ? ? "", t
                }
            }, t.AddressStringToBytesResponse = {
                typeUrl: "/cosmos.auth.v1beta1.AddressStringToBytesResponse",
                encode: (e, t = a.BinaryWriter.create()) => (0 !== e.addressBytes.length && t.uint32(10).bytes(e.addressBytes), t),
                decode(e, t) {
                    let r = e instanceof a.BinaryReader ? e : new a.BinaryReader(e),
                        n = void 0 === t ? r.len : r.pos + t,
                        o = S();
                    for (; r.pos < n;) {
                        let e = r.uint32();
                        e >>> 3 == 1 ? o.addressBytes = r.bytes() : r.skipType(7 & e)
                    }
                    return o
                },
                fromJSON(e) {
                    let t = S();
                    return (0, s.isSet)(e.addressBytes) && (t.addressBytes = (0, s.bytesFromBase64)(e.addressBytes)), t
                },
                toJSON(e) {
                    let t = {};
                    return void 0 !== e.addressBytes && (t.addressBytes = (0, s.base64FromBytes)(void 0 !== e.addressBytes ? e.addressBytes : new Uint8Array)), t
                },
                fromPartial(e) {
                    let t = S();
                    return t.addressBytes = e.addressBytes ? ? new Uint8Array, t
                }
            }, t.QueryAccountAddressByIDRequest = {
                typeUrl: "/cosmos.auth.v1beta1.QueryAccountAddressByIDRequest",
                encode: (e, t = a.BinaryWriter.create()) => (e.id !== BigInt(0) && t.uint32(8).int64(e.id), e.accountId !== BigInt(0) && t.uint32(16).uint64(e.accountId), t),
                decode(e, t) {
                    let r = e instanceof a.BinaryReader ? e : new a.BinaryReader(e),
                        n = void 0 === t ? r.len : r.pos + t,
                        o = k();
                    for (; r.pos < n;) {
                        let e = r.uint32();
                        switch (e >>> 3) {
                            case 1:
                                o.id = r.int64();
                                break;
                            case 2:
                                o.accountId = r.uint64();
                                break;
                            default:
                                r.skipType(7 & e)
                        }
                    }
                    return o
                },
                fromJSON(e) {
                    let t = k();
                    return (0, s.isSet)(e.id) && (t.id = BigInt(e.id.toString())), (0, s.isSet)(e.accountId) && (t.accountId = BigInt(e.accountId.toString())), t
                },
                toJSON(e) {
                    let t = {};
                    return void 0 !== e.id && (t.id = (e.id || BigInt(0)).toString()), void 0 !== e.accountId && (t.accountId = (e.accountId || BigInt(0)).toString()), t
                },
                fromPartial(e) {
                    let t = k();
                    return void 0 !== e.id && null !== e.id && (t.id = BigInt(e.id.toString())), void 0 !== e.accountId && null !== e.accountId && (t.accountId = BigInt(e.accountId.toString())), t
                }
            }, t.QueryAccountAddressByIDResponse = {
                typeUrl: "/cosmos.auth.v1beta1.QueryAccountAddressByIDResponse",
                encode: (e, t = a.BinaryWriter.create()) => ("" !== e.accountAddress && t.uint32(10).string(e.accountAddress), t),
                decode(e, t) {
                    let r = e instanceof a.BinaryReader ? e : new a.BinaryReader(e),
                        n = void 0 === t ? r.len : r.pos + t,
                        o = P();
                    for (; r.pos < n;) {
                        let e = r.uint32();
                        e >>> 3 == 1 ? o.accountAddress = r.string() : r.skipType(7 & e)
                    }
                    return o
                },
                fromJSON(e) {
                    let t = P();
                    return (0, s.isSet)(e.accountAddress) && (t.accountAddress = String(e.accountAddress)), t
                },
                toJSON(e) {
                    let t = {};
                    return void 0 !== e.accountAddress && (t.accountAddress = e.accountAddress), t
                },
                fromPartial(e) {
                    let t = P();
                    return t.accountAddress = e.accountAddress ? ? "", t
                }
            }, t.QueryAccountInfoRequest = {
                typeUrl: "/cosmos.auth.v1beta1.QueryAccountInfoRequest",
                encode: (e, t = a.BinaryWriter.create()) => ("" !== e.address && t.uint32(10).string(e.address), t),
                decode(e, t) {
                    let r = e instanceof a.BinaryReader ? e : new a.BinaryReader(e),
                        n = void 0 === t ? r.len : r.pos + t,
                        o = _();
                    for (; r.pos < n;) {
                        let e = r.uint32();
                        e >>> 3 == 1 ? o.address = r.string() : r.skipType(7 & e)
                    }
                    return o
                },
                fromJSON(e) {
                    let t = _();
                    return (0, s.isSet)(e.address) && (t.address = String(e.address)), t
                },
                toJSON(e) {
                    let t = {};
                    return void 0 !== e.address && (t.address = e.address), t
                },
                fromPartial(e) {
                    let t = _();
                    return t.address = e.address ? ? "", t
                }
            }, t.QueryAccountInfoResponse = {
                typeUrl: "/cosmos.auth.v1beta1.QueryAccountInfoResponse",
                encode: (e, t = a.BinaryWriter.create()) => (void 0 !== e.info && i.BaseAccount.encode(e.info, t.uint32(10).fork()).ldelim(), t),
                decode(e, t) {
                    let r = e instanceof a.BinaryReader ? e : new a.BinaryReader(e),
                        n = void 0 === t ? r.len : r.pos + t,
                        o = B();
                    for (; r.pos < n;) {
                        let e = r.uint32();
                        e >>> 3 == 1 ? o.info = i.BaseAccount.decode(r, r.uint32()) : r.skipType(7 & e)
                    }
                    return o
                },
                fromJSON(e) {
                    let t = B();
                    return (0, s.isSet)(e.info) && (t.info = i.BaseAccount.fromJSON(e.info)), t
                },
                toJSON(e) {
                    let t = {};
                    return void 0 !== e.info && (t.info = e.info ? i.BaseAccount.toJSON(e.info) : void 0), t
                },
                fromPartial(e) {
                    let t = B();
                    return void 0 !== e.info && null !== e.info && (t.info = i.BaseAccount.fromPartial(e.info)), t
                }
            };
            class O {
                constructor(e) {
                    this.rpc = e, this.Accounts = this.Accounts.bind(this), this.Account = this.Account.bind(this), this.AccountAddressByID = this.AccountAddressByID.bind(this), this.Params = this.Params.bind(this), this.ModuleAccounts = this.ModuleAccounts.bind(this), this.ModuleAccountByName = this.ModuleAccountByName.bind(this), this.Bech32Prefix = this.Bech32Prefix.bind(this), this.AddressBytesToString = this.AddressBytesToString.bind(this), this.AddressStringToBytes = this.AddressStringToBytes.bind(this), this.AccountInfo = this.AccountInfo.bind(this)
                }
                Accounts(e = {
                    pagination: n.PageRequest.fromPartial({})
                }) {
                    let r = t.QueryAccountsRequest.encode(e).finish();
                    return this.rpc.request("cosmos.auth.v1beta1.Query", "Accounts", r).then(e => t.QueryAccountsResponse.decode(new a.BinaryReader(e)))
                }
                Account(e) {
                    let r = t.QueryAccountRequest.encode(e).finish();
                    return this.rpc.request("cosmos.auth.v1beta1.Query", "Account", r).then(e => t.QueryAccountResponse.decode(new a.BinaryReader(e)))
                }
                AccountAddressByID(e) {
                    let r = t.QueryAccountAddressByIDRequest.encode(e).finish();
                    return this.rpc.request("cosmos.auth.v1beta1.Query", "AccountAddressByID", r).then(e => t.QueryAccountAddressByIDResponse.decode(new a.BinaryReader(e)))
                }
                Params(e = {}) {
                    let r = t.QueryParamsRequest.encode(e).finish();
                    return this.rpc.request("cosmos.auth.v1beta1.Query", "Params", r).then(e => t.QueryParamsResponse.decode(new a.BinaryReader(e)))
                }
                ModuleAccounts(e = {}) {
                    let r = t.QueryModuleAccountsRequest.encode(e).finish();
                    return this.rpc.request("cosmos.auth.v1beta1.Query", "ModuleAccounts", r).then(e => t.QueryModuleAccountsResponse.decode(new a.BinaryReader(e)))
                }
                ModuleAccountByName(e) {
                    let r = t.QueryModuleAccountByNameRequest.encode(e).finish();
                    return this.rpc.request("cosmos.auth.v1beta1.Query", "ModuleAccountByName", r).then(e => t.QueryModuleAccountByNameResponse.decode(new a.BinaryReader(e)))
                }
                Bech32Prefix(e = {}) {
                    let r = t.Bech32PrefixRequest.encode(e).finish();
                    return this.rpc.request("cosmos.auth.v1beta1.Query", "Bech32Prefix", r).then(e => t.Bech32PrefixResponse.decode(new a.BinaryReader(e)))
                }
                AddressBytesToString(e) {
                    let r = t.AddressBytesToStringRequest.encode(e).finish();
                    return this.rpc.request("cosmos.auth.v1beta1.Query", "AddressBytesToString", r).then(e => t.AddressBytesToStringResponse.decode(new a.BinaryReader(e)))
                }
                AddressStringToBytes(e) {
                    let r = t.AddressStringToBytesRequest.encode(e).finish();
                    return this.rpc.request("cosmos.auth.v1beta1.Query", "AddressStringToBytes", r).then(e => t.AddressStringToBytesResponse.decode(new a.BinaryReader(e)))
                }
                AccountInfo(e) {
                    let r = t.QueryAccountInfoRequest.encode(e).finish();
                    return this.rpc.request("cosmos.auth.v1beta1.Query", "AccountInfo", r).then(e => t.QueryAccountInfoResponse.decode(new a.BinaryReader(e)))
                }
            }
            t.QueryClientImpl = O
        },
        88221: function(e, t, r) {
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: !0
            }), t.GrantQueueItem = t.GrantAuthorization = t.Grant = t.GenericAuthorization = t.protobufPackage = void 0;
            let n = r(65676),
                o = r(90614),
                i = r(28486),
                a = r(6476);

            function s() {
                return {
                    msg: ""
                }
            }

            function d() {
                return {
                    authorization: void 0,
                    expiration: void 0
                }
            }

            function c() {
                return {
                    granter: "",
                    grantee: "",
                    authorization: void 0,
                    expiration: void 0
                }
            }

            function l() {
                return {
                    msgTypeUrls: []
                }
            }
            t.protobufPackage = "cosmos.authz.v1beta1", t.GenericAuthorization = {
                typeUrl: "/cosmos.authz.v1beta1.GenericAuthorization",
                encode: (e, t = i.BinaryWriter.create()) => ("" !== e.msg && t.uint32(10).string(e.msg), t),
                decode(e, t) {
                    let r = e instanceof i.BinaryReader ? e : new i.BinaryReader(e),
                        n = void 0 === t ? r.len : r.pos + t,
                        o = s();
                    for (; r.pos < n;) {
                        let e = r.uint32();
                        e >>> 3 == 1 ? o.msg = r.string() : r.skipType(7 & e)
                    }
                    return o
                },
                fromJSON(e) {
                    let t = s();
                    return (0, a.isSet)(e.msg) && (t.msg = String(e.msg)), t
                },
                toJSON(e) {
                    let t = {};
                    return void 0 !== e.msg && (t.msg = e.msg), t
                },
                fromPartial(e) {
                    let t = s();
                    return t.msg = e.msg ? ? "", t
                }
            }, t.Grant = {
                typeUrl: "/cosmos.authz.v1beta1.Grant",
                encode: (e, t = i.BinaryWriter.create()) => (void 0 !== e.authorization && n.Any.encode(e.authorization, t.uint32(10).fork()).ldelim(), void 0 !== e.expiration && o.Timestamp.encode(e.expiration, t.uint32(18).fork()).ldelim(), t),
                decode(e, t) {
                    let r = e instanceof i.BinaryReader ? e : new i.BinaryReader(e),
                        a = void 0 === t ? r.len : r.pos + t,
                        s = d();
                    for (; r.pos < a;) {
                        let e = r.uint32();
                        switch (e >>> 3) {
                            case 1:
                                s.authorization = n.Any.decode(r, r.uint32());
                                break;
                            case 2:
                                s.expiration = o.Timestamp.decode(r, r.uint32());
                                break;
                            default:
                                r.skipType(7 & e)
                        }
                    }
                    return s
                },
                fromJSON(e) {
                    let t = d();
                    return (0, a.isSet)(e.authorization) && (t.authorization = n.Any.fromJSON(e.authorization)), (0, a.isSet)(e.expiration) && (t.expiration = (0, a.fromJsonTimestamp)(e.expiration)), t
                },
                toJSON(e) {
                    let t = {};
                    return void 0 !== e.authorization && (t.authorization = e.authorization ? n.Any.toJSON(e.authorization) : void 0), void 0 !== e.expiration && (t.expiration = (0, a.fromTimestamp)(e.expiration).toISOString()), t
                },
                fromPartial(e) {
                    let t = d();
                    return void 0 !== e.authorization && null !== e.authorization && (t.authorization = n.Any.fromPartial(e.authorization)), void 0 !== e.expiration && null !== e.expiration && (t.expiration = o.Timestamp.fromPartial(e.expiration)), t
                }
            }, t.GrantAuthorization = {
                typeUrl: "/cosmos.authz.v1beta1.GrantAuthorization",
                encode: (e, t = i.BinaryWriter.create()) => ("" !== e.granter && t.uint32(10).string(e.granter), "" !== e.grantee && t.uint32(18).string(e.grantee), void 0 !== e.authorization && n.Any.encode(e.authorization, t.uint32(26).fork()).ldelim(), void 0 !== e.expiration && o.Timestamp.encode(e.expiration, t.uint32(34).fork()).ldelim(), t),
                decode(e, t) {
                    let r = e instanceof i.BinaryReader ? e : new i.BinaryReader(e),
                        a = void 0 === t ? r.len : r.pos + t,
                        s = c();
                    for (; r.pos < a;) {
                        let e = r.uint32();
                        switch (e >>> 3) {
                            case 1:
                                s.granter = r.string();
                                break;
                            case 2:
                                s.grantee = r.string();
                                break;
                            case 3:
                                s.authorization = n.Any.decode(r, r.uint32());
                                break;
                            case 4:
                                s.expiration = o.Timestamp.decode(r, r.uint32());
                                break;
                            default:
                                r.skipType(7 & e)
                        }
                    }
                    return s
                },
                fromJSON(e) {
                    let t = c();
                    return (0, a.isSet)(e.granter) && (t.granter = String(e.granter)), (0, a.isSet)(e.grantee) && (t.grantee = String(e.grantee)), (0, a.isSet)(e.authorization) && (t.authorization = n.Any.fromJSON(e.authorization)), (0, a.isSet)(e.expiration) && (t.expiration = (0, a.fromJsonTimestamp)(e.expiration)), t
                },
                toJSON(e) {
                    let t = {};
                    return void 0 !== e.granter && (t.granter = e.granter), void 0 !== e.grantee && (t.grantee = e.grantee), void 0 !== e.authorization && (t.authorization = e.authorization ? n.Any.toJSON(e.authorization) : void 0), void 0 !== e.expiration && (t.expiration = (0, a.fromTimestamp)(e.expiration).toISOString()), t
                },
                fromPartial(e) {
                    let t = c();
                    return t.granter = e.granter ? ? "", t.grantee = e.grantee ? ? "", void 0 !== e.authorization && null !== e.authorization && (t.authorization = n.Any.fromPartial(e.authorization)), void 0 !== e.expiration && null !== e.expiration && (t.expiration = o.Timestamp.fromPartial(e.expiration)), t
                }
            }, t.GrantQueueItem = {
                typeUrl: "/cosmos.authz.v1beta1.GrantQueueItem",
                encode(e, t = i.BinaryWriter.create()) {
                    for (let r of e.msgTypeUrls) t.uint32(10).string(r);
                    return t
                },
                decode(e, t) {
                    let r = e instanceof i.BinaryReader ? e : new i.BinaryReader(e),
                        n = void 0 === t ? r.len : r.pos + t,
                        o = l();
                    for (; r.pos < n;) {
                        let e = r.uint32();
                        e >>> 3 == 1 ? o.msgTypeUrls.push(r.string()) : r.skipType(7 & e)
                    }
                    return o
                },
                fromJSON(e) {
                    let t = l();
                    return Array.isArray(e ? .msgTypeUrls) && (t.msgTypeUrls = e.msgTypeUrls.map(e => String(e))), t
                },
                toJSON(e) {
                    let t = {};
                    return e.msgTypeUrls ? t.msgTypeUrls = e.msgTypeUrls.map(e => e) : t.msgTypeUrls = [], t
                },
                fromPartial(e) {
                    let t = l();
                    return t.msgTypeUrls = e.msgTypeUrls ? .map(e => e) || [], t
                }
            }
        },
        6034: function(e, t, r) {
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: !0
            }), t.QueryClientImpl = t.QueryGranteeGrantsResponse = t.QueryGranteeGrantsRequest = t.QueryGranterGrantsResponse = t.QueryGranterGrantsRequest = t.QueryGrantsResponse = t.QueryGrantsRequest = t.protobufPackage = void 0;
            let n = r(38792),
                o = r(88221),
                i = r(28486),
                a = r(6476);

            function s() {
                return {
                    granter: "",
                    grantee: "",
                    msgTypeUrl: "",
                    pagination: void 0
                }
            }

            function d() {
                return {
                    grants: [],
                    pagination: void 0
                }
            }

            function c() {
                return {
                    granter: "",
                    pagination: void 0
                }
            }

            function l() {
                return {
                    grants: [],
                    pagination: void 0
                }
            }

            function u() {
                return {
                    grantee: "",
                    pagination: void 0
                }
            }

            function p() {
                return {
                    grants: [],
                    pagination: void 0
                }
            }
            t.protobufPackage = "cosmos.authz.v1beta1", t.QueryGrantsRequest = {
                typeUrl: "/cosmos.authz.v1beta1.QueryGrantsRequest",
                encode: (e, t = i.BinaryWriter.create()) => ("" !== e.granter && t.uint32(10).string(e.granter), "" !== e.grantee && t.uint32(18).string(e.grantee), "" !== e.msgTypeUrl && t.uint32(26).string(e.msgTypeUrl), void 0 !== e.pagination && n.PageRequest.encode(e.pagination, t.uint32(34).fork()).ldelim(), t),
                decode(e, t) {
                    let r = e instanceof i.BinaryReader ? e : new i.BinaryReader(e),
                        o = void 0 === t ? r.len : r.pos + t,
                        a = s();
                    for (; r.pos < o;) {
                        let e = r.uint32();
                        switch (e >>> 3) {
                            case 1:
                                a.granter = r.string();
                                break;
                            case 2:
                                a.grantee = r.string();
                                break;
                            case 3:
                                a.msgTypeUrl = r.string();
                                break;
                            case 4:
                                a.pagination = n.PageRequest.decode(r, r.uint32());
                                break;
                            default:
                                r.skipType(7 & e)
                        }
                    }
                    return a
                },
                fromJSON(e) {
                    let t = s();
                    return (0, a.isSet)(e.granter) && (t.granter = String(e.granter)), (0, a.isSet)(e.grantee) && (t.grantee = String(e.grantee)), (0, a.isSet)(e.msgTypeUrl) && (t.msgTypeUrl = String(e.msgTypeUrl)), (0, a.isSet)(e.pagination) && (t.pagination = n.PageRequest.fromJSON(e.pagination)), t
                },
                toJSON(e) {
                    let t = {};
                    return void 0 !== e.granter && (t.granter = e.granter), void 0 !== e.grantee && (t.grantee = e.grantee), void 0 !== e.msgTypeUrl && (t.msgTypeUrl = e.msgTypeUrl), void 0 !== e.pagination && (t.pagination = e.pagination ? n.PageRequest.toJSON(e.pagination) : void 0), t
                },
                fromPartial(e) {
                    let t = s();
                    return t.granter = e.granter ? ? "", t.grantee = e.grantee ? ? "", t.msgTypeUrl = e.msgTypeUrl ? ? "", void 0 !== e.pagination && null !== e.pagination && (t.pagination = n.PageRequest.fromPartial(e.pagination)), t
                }
            }, t.QueryGrantsResponse = {
                typeUrl: "/cosmos.authz.v1beta1.QueryGrantsResponse",
                encode(e, t = i.BinaryWriter.create()) {
                    for (let r of e.grants) o.Grant.encode(r, t.uint32(10).fork()).ldelim();
                    return void 0 !== e.pagination && n.PageResponse.encode(e.pagination, t.uint32(18).fork()).ldelim(), t
                },
                decode(e, t) {
                    let r = e instanceof i.BinaryReader ? e : new i.BinaryReader(e),
                        a = void 0 === t ? r.len : r.pos + t,
                        s = d();
                    for (; r.pos < a;) {
                        let e = r.uint32();
                        switch (e >>> 3) {
                            case 1:
                                s.grants.push(o.Grant.decode(r, r.uint32()));
                                break;
                            case 2:
                                s.pagination = n.PageResponse.decode(r, r.uint32());
                                break;
                            default:
                                r.skipType(7 & e)
                        }
                    }
                    return s
                },
                fromJSON(e) {
                    let t = d();
                    return Array.isArray(e ? .grants) && (t.grants = e.grants.map(e => o.Grant.fromJSON(e))), (0, a.isSet)(e.pagination) && (t.pagination = n.PageResponse.fromJSON(e.pagination)), t
                },
                toJSON(e) {
                    let t = {};
                    return e.grants ? t.grants = e.grants.map(e => e ? o.Grant.toJSON(e) : void 0) : t.grants = [], void 0 !== e.pagination && (t.pagination = e.pagination ? n.PageResponse.toJSON(e.pagination) : void 0), t
                },
                fromPartial(e) {
                    let t = d();
                    return t.grants = e.grants ? .map(e => o.Grant.fromPartial(e)) || [], void 0 !== e.pagination && null !== e.pagination && (t.pagination = n.PageResponse.fromPartial(e.pagination)), t
                }
            }, t.QueryGranterGrantsRequest = {
                typeUrl: "/cosmos.authz.v1beta1.QueryGranterGrantsRequest",
                encode: (e, t = i.BinaryWriter.create()) => ("" !== e.granter && t.uint32(10).string(e.granter), void 0 !== e.pagination && n.PageRequest.encode(e.pagination, t.uint32(18).fork()).ldelim(), t),
                decode(e, t) {
                    let r = e instanceof i.BinaryReader ? e : new i.BinaryReader(e),
                        o = void 0 === t ? r.len : r.pos + t,
                        a = c();
                    for (; r.pos < o;) {
                        let e = r.uint32();
                        switch (e >>> 3) {
                            case 1:
                                a.granter = r.string();
                                break;
                            case 2:
                                a.pagination = n.PageRequest.decode(r, r.uint32());
                                break;
                            default:
                                r.skipType(7 & e)
                        }
                    }
                    return a
                },
                fromJSON(e) {
                    let t = c();
                    return (0, a.isSet)(e.granter) && (t.granter = String(e.granter)), (0, a.isSet)(e.pagination) && (t.pagination = n.PageRequest.fromJSON(e.pagination)), t
                },
                toJSON(e) {
                    let t = {};
                    return void 0 !== e.granter && (t.granter = e.granter), void 0 !== e.pagination && (t.pagination = e.pagination ? n.PageRequest.toJSON(e.pagination) : void 0), t
                },
                fromPartial(e) {
                    let t = c();
                    return t.granter = e.granter ? ? "", void 0 !== e.pagination && null !== e.pagination && (t.pagination = n.PageRequest.fromPartial(e.pagination)), t
                }
            }, t.QueryGranterGrantsResponse = {
                typeUrl: "/cosmos.authz.v1beta1.QueryGranterGrantsResponse",
                encode(e, t = i.BinaryWriter.create()) {
                    for (let r of e.grants) o.GrantAuthorization.encode(r, t.uint32(10).fork()).ldelim();
                    return void 0 !== e.pagination && n.PageResponse.encode(e.pagination, t.uint32(18).fork()).ldelim(), t
                },
                decode(e, t) {
                    let r = e instanceof i.BinaryReader ? e : new i.BinaryReader(e),
                        a = void 0 === t ? r.len : r.pos + t,
                        s = l();
                    for (; r.pos < a;) {
                        let e = r.uint32();
                        switch (e >>> 3) {
                            case 1:
                                s.grants.push(o.GrantAuthorization.decode(r, r.uint32()));
                                break;
                            case 2:
                                s.pagination = n.PageResponse.decode(r, r.uint32());
                                break;
                            default:
                                r.skipType(7 & e)
                        }
                    }
                    return s
                },
                fromJSON(e) {
                    let t = l();
                    return Array.isArray(e ? .grants) && (t.grants = e.grants.map(e => o.GrantAuthorization.fromJSON(e))), (0, a.isSet)(e.pagination) && (t.pagination = n.PageResponse.fromJSON(e.pagination)), t
                },
                toJSON(e) {
                    let t = {};
                    return e.grants ? t.grants = e.grants.map(e => e ? o.GrantAuthorization.toJSON(e) : void 0) : t.grants = [], void 0 !== e.pagination && (t.pagination = e.pagination ? n.PageResponse.toJSON(e.pagination) : void 0), t
                },
                fromPartial(e) {
                    let t = l();
                    return t.grants = e.grants ? .map(e => o.GrantAuthorization.fromPartial(e)) || [], void 0 !== e.pagination && null !== e.pagination && (t.pagination = n.PageResponse.fromPartial(e.pagination)), t
                }
            }, t.QueryGranteeGrantsRequest = {
                typeUrl: "/cosmos.authz.v1beta1.QueryGranteeGrantsRequest",
                encode: (e, t = i.BinaryWriter.create()) => ("" !== e.grantee && t.uint32(10).string(e.grantee), void 0 !== e.pagination && n.PageRequest.encode(e.pagination, t.uint32(18).fork()).ldelim(), t),
                decode(e, t) {
                    let r = e instanceof i.BinaryReader ? e : new i.BinaryReader(e),
                        o = void 0 === t ? r.len : r.pos + t,
                        a = u();
                    for (; r.pos < o;) {
                        let e = r.uint32();
                        switch (e >>> 3) {
                            case 1:
                                a.grantee = r.string();
                                break;
                            case 2:
                                a.pagination = n.PageRequest.decode(r, r.uint32());
                                break;
                            default:
                                r.skipType(7 & e)
                        }
                    }
                    return a
                },
                fromJSON(e) {
                    let t = u();
                    return (0, a.isSet)(e.grantee) && (t.grantee = String(e.grantee)), (0, a.isSet)(e.pagination) && (t.pagination = n.PageRequest.fromJSON(e.pagination)), t
                },
                toJSON(e) {
                    let t = {};
                    return void 0 !== e.grantee && (t.grantee = e.grantee), void 0 !== e.pagination && (t.pagination = e.pagination ? n.PageRequest.toJSON(e.pagination) : void 0), t
                },
                fromPartial(e) {
                    let t = u();
                    return t.grantee = e.grantee ? ? "", void 0 !== e.pagination && null !== e.pagination && (t.pagination = n.PageRequest.fromPartial(e.pagination)), t
                }
            }, t.QueryGranteeGrantsResponse = {
                typeUrl: "/cosmos.authz.v1beta1.QueryGranteeGrantsResponse",
                encode(e, t = i.BinaryWriter.create()) {
                    for (let r of e.grants) o.GrantAuthorization.encode(r, t.uint32(10).fork()).ldelim();
                    return void 0 !== e.pagination && n.PageResponse.encode(e.pagination, t.uint32(18).fork()).ldelim(), t
                },
                decode(e, t) {
                    let r = e instanceof i.BinaryReader ? e : new i.BinaryReader(e),
                        a = void 0 === t ? r.len : r.pos + t,
                        s = p();
                    for (; r.pos < a;) {
                        let e = r.uint32();
                        switch (e >>> 3) {
                            case 1:
                                s.grants.push(o.GrantAuthorization.decode(r, r.uint32()));
                                break;
                            case 2:
                                s.pagination = n.PageResponse.decode(r, r.uint32());
                                break;
                            default:
                                r.skipType(7 & e)
                        }
                    }
                    return s
                },
                fromJSON(e) {
                    let t = p();
                    return Array.isArray(e ? .grants) && (t.grants = e.grants.map(e => o.GrantAuthorization.fromJSON(e))), (0, a.isSet)(e.pagination) && (t.pagination = n.PageResponse.fromJSON(e.pagination)), t
                },
                toJSON(e) {
                    let t = {};
                    return e.grants ? t.grants = e.grants.map(e => e ? o.GrantAuthorization.toJSON(e) : void 0) : t.grants = [], void 0 !== e.pagination && (t.pagination = e.pagination ? n.PageResponse.toJSON(e.pagination) : void 0), t
                },
                fromPartial(e) {
                    let t = p();
                    return t.grants = e.grants ? .map(e => o.GrantAuthorization.fromPartial(e)) || [], void 0 !== e.pagination && null !== e.pagination && (t.pagination = n.PageResponse.fromPartial(e.pagination)), t
                }
            };
            class m {
                constructor(e) {
                    this.rpc = e, this.Grants = this.Grants.bind(this), this.GranterGrants = this.GranterGrants.bind(this), this.GranteeGrants = this.GranteeGrants.bind(this)
                }
                Grants(e) {
                    let r = t.QueryGrantsRequest.encode(e).finish();
                    return this.rpc.request("cosmos.authz.v1beta1.Query", "Grants", r).then(e => t.QueryGrantsResponse.decode(new i.BinaryReader(e)))
                }
                GranterGrants(e) {
                    let r = t.QueryGranterGrantsRequest.encode(e).finish();
                    return this.rpc.request("cosmos.authz.v1beta1.Query", "GranterGrants", r).then(e => t.QueryGranterGrantsResponse.decode(new i.BinaryReader(e)))
                }
                GranteeGrants(e) {
                    let r = t.QueryGranteeGrantsRequest.encode(e).finish();
                    return this.rpc.request("cosmos.authz.v1beta1.Query", "GranteeGrants", r).then(e => t.QueryGranteeGrantsResponse.decode(new i.BinaryReader(e)))
                }
            }
            t.QueryClientImpl = m
        },
        72060: function(e, t, r) {
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: !0
            }), t.MsgClientImpl = t.MsgRevokeResponse = t.MsgRevoke = t.MsgGrantResponse = t.MsgExec = t.MsgExecResponse = t.MsgGrant = t.protobufPackage = void 0;
            let n = r(88221),
                o = r(65676),
                i = r(28486),
                a = r(6476);

            function s() {
                return {
                    granter: "",
                    grantee: "",
                    grant: n.Grant.fromPartial({})
                }
            }

            function d() {
                return {
                    results: []
                }
            }

            function c() {
                return {
                    grantee: "",
                    msgs: []
                }
            }

            function l() {
                return {
                    granter: "",
                    grantee: "",
                    msgTypeUrl: ""
                }
            }
            t.protobufPackage = "cosmos.authz.v1beta1", t.MsgGrant = {
                typeUrl: "/cosmos.authz.v1beta1.MsgGrant",
                encode: (e, t = i.BinaryWriter.create()) => ("" !== e.granter && t.uint32(10).string(e.granter), "" !== e.grantee && t.uint32(18).string(e.grantee), void 0 !== e.grant && n.Grant.encode(e.grant, t.uint32(26).fork()).ldelim(), t),
                decode(e, t) {
                    let r = e instanceof i.BinaryReader ? e : new i.BinaryReader(e),
                        o = void 0 === t ? r.len : r.pos + t,
                        a = s();
                    for (; r.pos < o;) {
                        let e = r.uint32();
                        switch (e >>> 3) {
                            case 1:
                                a.granter = r.string();
                                break;
                            case 2:
                                a.grantee = r.string();
                                break;
                            case 3:
                                a.grant = n.Grant.decode(r, r.uint32());
                                break;
                            default:
                                r.skipType(7 & e)
                        }
                    }
                    return a
                },
                fromJSON(e) {
                    let t = s();
                    return (0, a.isSet)(e.granter) && (t.granter = String(e.granter)), (0, a.isSet)(e.grantee) && (t.grantee = String(e.grantee)), (0, a.isSet)(e.grant) && (t.grant = n.Grant.fromJSON(e.grant)), t
                },
                toJSON(e) {
                    let t = {};
                    return void 0 !== e.granter && (t.granter = e.granter), void 0 !== e.grantee && (t.grantee = e.grantee), void 0 !== e.grant && (t.grant = e.grant ? n.Grant.toJSON(e.grant) : void 0), t
                },
                fromPartial(e) {
                    let t = s();
                    return t.granter = e.granter ? ? "", t.grantee = e.grantee ? ? "", void 0 !== e.grant && null !== e.grant && (t.grant = n.Grant.fromPartial(e.grant)), t
                }
            }, t.MsgExecResponse = {
                typeUrl: "/cosmos.authz.v1beta1.MsgExecResponse",
                encode(e, t = i.BinaryWriter.create()) {
                    for (let r of e.results) t.uint32(10).bytes(r);
                    return t
                },
                decode(e, t) {
                    let r = e instanceof i.BinaryReader ? e : new i.BinaryReader(e),
                        n = void 0 === t ? r.len : r.pos + t,
                        o = d();
                    for (; r.pos < n;) {
                        let e = r.uint32();
                        e >>> 3 == 1 ? o.results.push(r.bytes()) : r.skipType(7 & e)
                    }
                    return o
                },
                fromJSON(e) {
                    let t = d();
                    return Array.isArray(e ? .results) && (t.results = e.results.map(e => (0, a.bytesFromBase64)(e))), t
                },
                toJSON(e) {
                    let t = {};
                    return e.results ? t.results = e.results.map(e => (0, a.base64FromBytes)(void 0 !== e ? e : new Uint8Array)) : t.results = [], t
                },
                fromPartial(e) {
                    let t = d();
                    return t.results = e.results ? .map(e => e) || [], t
                }
            }, t.MsgExec = {
                typeUrl: "/cosmos.authz.v1beta1.MsgExec",
                encode(e, t = i.BinaryWriter.create()) {
                    for (let r of ("" !== e.grantee && t.uint32(10).string(e.grantee), e.msgs)) o.Any.encode(r, t.uint32(18).fork()).ldelim();
                    return t
                },
                decode(e, t) {
                    let r = e instanceof i.BinaryReader ? e : new i.BinaryReader(e),
                        n = void 0 === t ? r.len : r.pos + t,
                        a = c();
                    for (; r.pos < n;) {
                        let e = r.uint32();
                        switch (e >>> 3) {
                            case 1:
                                a.grantee = r.string();
                                break;
                            case 2:
                                a.msgs.push(o.Any.decode(r, r.uint32()));
                                break;
                            default:
                                r.skipType(7 & e)
                        }
                    }
                    return a
                },
                fromJSON(e) {
                    let t = c();
                    return (0, a.isSet)(e.grantee) && (t.grantee = String(e.grantee)), Array.isArray(e ? .msgs) && (t.msgs = e.msgs.map(e => o.Any.fromJSON(e))), t
                },
                toJSON(e) {
                    let t = {};
                    return void 0 !== e.grantee && (t.grantee = e.grantee), e.msgs ? t.msgs = e.msgs.map(e => e ? o.Any.toJSON(e) : void 0) : t.msgs = [], t
                },
                fromPartial(e) {
                    let t = c();
                    return t.grantee = e.grantee ? ? "", t.msgs = e.msgs ? .map(e => o.Any.fromPartial(e)) || [], t
                }
            }, t.MsgGrantResponse = {
                typeUrl: "/cosmos.authz.v1beta1.MsgGrantResponse",
                encode: (e, t = i.BinaryWriter.create()) => t,
                decode(e, t) {
                    let r = e instanceof i.BinaryReader ? e : new i.BinaryReader(e),
                        n = void 0 === t ? r.len : r.pos + t;
                    for (; r.pos < n;) {
                        let e = r.uint32();
                        r.skipType(7 & e)
                    }
                    return {}
                },
                fromJSON: e => ({}),
                toJSON: e => ({}),
                fromPartial: e => ({})
            }, t.MsgRevoke = {
                typeUrl: "/cosmos.authz.v1beta1.MsgRevoke",
                encode: (e, t = i.BinaryWriter.create()) => ("" !== e.granter && t.uint32(10).string(e.granter), "" !== e.grantee && t.uint32(18).string(e.grantee), "" !== e.msgTypeUrl && t.uint32(26).string(e.msgTypeUrl), t),
                decode(e, t) {
                    let r = e instanceof i.BinaryReader ? e : new i.BinaryReader(e),
                        n = void 0 === t ? r.len : r.pos + t,
                        o = l();
                    for (; r.pos < n;) {
                        let e = r.uint32();
                        switch (e >>> 3) {
                            case 1:
                                o.granter = r.string();
                                break;
                            case 2:
                                o.grantee = r.string();
                                break;
                            case 3:
                                o.msgTypeUrl = r.string();
                                break;
                            default:
                                r.skipType(7 & e)
                        }
                    }
                    return o
                },
                fromJSON(e) {
                    let t = l();
                    return (0, a.isSet)(e.granter) && (t.granter = String(e.granter)), (0, a.isSet)(e.grantee) && (t.grantee = String(e.grantee)), (0, a.isSet)(e.msgTypeUrl) && (t.msgTypeUrl = String(e.msgTypeUrl)), t
                },
                toJSON(e) {
                    let t = {};
                    return void 0 !== e.granter && (t.granter = e.granter), void 0 !== e.grantee && (t.grantee = e.grantee), void 0 !== e.msgTypeUrl && (t.msgTypeUrl = e.msgTypeUrl), t
                },
                fromPartial(e) {
                    let t = l();
                    return t.granter = e.granter ? ? "", t.grantee = e.grantee ? ? "", t.msgTypeUrl = e.msgTypeUrl ? ? "", t
                }
            }, t.MsgRevokeResponse = {
                typeUrl: "/cosmos.authz.v1beta1.MsgRevokeResponse",
                encode: (e, t = i.BinaryWriter.create()) => t,
                decode(e, t) {
                    let r = e instanceof i.BinaryReader ? e : new i.BinaryReader(e),
                        n = void 0 === t ? r.len : r.pos + t;
                    for (; r.pos < n;) {
                        let e = r.uint32();
                        r.skipType(7 & e)
                    }
                    return {}
                },
                fromJSON: e => ({}),
                toJSON: e => ({}),
                fromPartial: e => ({})
            };
            class u {
                constructor(e) {
                    this.rpc = e, this.Grant = this.Grant.bind(this), this.Exec = this.Exec.bind(this), this.Revoke = this.Revoke.bind(this)
                }
                Grant(e) {
                    let r = t.MsgGrant.encode(e).finish();
                    return this.rpc.request("cosmos.authz.v1beta1.Msg", "Grant", r).then(e => t.MsgGrantResponse.decode(new i.BinaryReader(e)))
                }
                Exec(e) {
                    let r = t.MsgExec.encode(e).finish();
                    return this.rpc.request("cosmos.authz.v1beta1.Msg", "Exec", r).then(e => t.MsgExecResponse.decode(new i.BinaryReader(e)))
                }
                Revoke(e) {
                    let r = t.MsgRevoke.encode(e).finish();
                    return this.rpc.request("cosmos.authz.v1beta1.Msg", "Revoke", r).then(e => t.MsgRevokeResponse.decode(new i.BinaryReader(e)))
                }
            }
            t.MsgClientImpl = u
        },
        7401: function(e, t, r) {
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: !0
            }), t.Metadata = t.DenomUnit = t.Supply = t.Output = t.Input = t.SendEnabled = t.Params = t.protobufPackage = void 0;
            let n = r(62809),
                o = r(28486),
                i = r(6476);

            function a() {
                return {
                    sendEnabled: [],
                    defaultSendEnabled: !1
                }
            }

            function s() {
                return {
                    denom: "",
                    enabled: !1
                }
            }

            function d() {
                return {
                    address: "",
                    coins: []
                }
            }

            function c() {
                return {
                    address: "",
                    coins: []
                }
            }

            function l() {
                return {
                    total: []
                }
            }

            function u() {
                return {
                    denom: "",
                    exponent: 0,
                    aliases: []
                }
            }

            function p() {
                return {
                    description: "",
                    denomUnits: [],
                    base: "",
                    display: "",
                    name: "",
                    symbol: "",
                    uri: "",
                    uriHash: ""
                }
            }
            t.protobufPackage = "cosmos.bank.v1beta1", t.Params = {
                typeUrl: "/cosmos.bank.v1beta1.Params",
                encode(e, r = o.BinaryWriter.create()) {
                    for (let n of e.sendEnabled) t.SendEnabled.encode(n, r.uint32(10).fork()).ldelim();
                    return !0 === e.defaultSendEnabled && r.uint32(16).bool(e.defaultSendEnabled), r
                },
                decode(e, r) {
                    let n = e instanceof o.BinaryReader ? e : new o.BinaryReader(e),
                        i = void 0 === r ? n.len : n.pos + r,
                        s = a();
                    for (; n.pos < i;) {
                        let e = n.uint32();
                        switch (e >>> 3) {
                            case 1:
                                s.sendEnabled.push(t.SendEnabled.decode(n, n.uint32()));
                                break;
                            case 2:
                                s.defaultSendEnabled = n.bool();
                                break;
                            default:
                                n.skipType(7 & e)
                        }
                    }
                    return s
                },
                fromJSON(e) {
                    let r = a();
                    return Array.isArray(e ? .sendEnabled) && (r.sendEnabled = e.sendEnabled.map(e => t.SendEnabled.fromJSON(e))), (0, i.isSet)(e.defaultSendEnabled) && (r.defaultSendEnabled = !!e.defaultSendEnabled), r
                },
                toJSON(e) {
                    let r = {};
                    return e.sendEnabled ? r.sendEnabled = e.sendEnabled.map(e => e ? t.SendEnabled.toJSON(e) : void 0) : r.sendEnabled = [], void 0 !== e.defaultSendEnabled && (r.defaultSendEnabled = e.defaultSendEnabled), r
                },
                fromPartial(e) {
                    let r = a();
                    return r.sendEnabled = e.sendEnabled ? .map(e => t.SendEnabled.fromPartial(e)) || [], r.defaultSendEnabled = e.defaultSendEnabled ? ? !1, r
                }
            }, t.SendEnabled = {
                typeUrl: "/cosmos.bank.v1beta1.SendEnabled",
                encode: (e, t = o.BinaryWriter.create()) => ("" !== e.denom && t.uint32(10).string(e.denom), !0 === e.enabled && t.uint32(16).bool(e.enabled), t),
                decode(e, t) {
                    let r = e instanceof o.BinaryReader ? e : new o.BinaryReader(e),
                        n = void 0 === t ? r.len : r.pos + t,
                        i = s();
                    for (; r.pos < n;) {
                        let e = r.uint32();
                        switch (e >>> 3) {
                            case 1:
                                i.denom = r.string();
                                break;
                            case 2:
                                i.enabled = r.bool();
                                break;
                            default:
                                r.skipType(7 & e)
                        }
                    }
                    return i
                },
                fromJSON(e) {
                    let t = s();
                    return (0, i.isSet)(e.denom) && (t.denom = String(e.denom)), (0, i.isSet)(e.enabled) && (t.enabled = !!e.enabled), t
                },
                toJSON(e) {
                    let t = {};
                    return void 0 !== e.denom && (t.denom = e.denom), void 0 !== e.enabled && (t.enabled = e.enabled), t
                },
                fromPartial(e) {
                    let t = s();
                    return t.denom = e.denom ? ? "", t.enabled = e.enabled ? ? !1, t
                }
            }, t.Input = {
                typeUrl: "/cosmos.bank.v1beta1.Input",
                encode(e, t = o.BinaryWriter.create()) {
                    for (let r of ("" !== e.address && t.uint32(10).string(e.address), e.coins)) n.Coin.encode(r, t.uint32(18).fork()).ldelim();
                    return t
                },
                decode(e, t) {
                    let r = e instanceof o.BinaryReader ? e : new o.BinaryReader(e),
                        i = void 0 === t ? r.len : r.pos + t,
                        a = d();
                    for (; r.pos < i;) {
                        let e = r.uint32();
                        switch (e >>> 3) {
                            case 1:
                                a.address = r.string();
                                break;
                            case 2:
                                a.coins.push(n.Coin.decode(r, r.uint32()));
                                break;
                            default:
                                r.skipType(7 & e)
                        }
                    }
                    return a
                },
                fromJSON(e) {
                    let t = d();
                    return (0, i.isSet)(e.address) && (t.address = String(e.address)), Array.isArray(e ? .coins) && (t.coins = e.coins.map(e => n.Coin.fromJSON(e))), t
                },
                toJSON(e) {
                    let t = {};
                    return void 0 !== e.address && (t.address = e.address), e.coins ? t.coins = e.coins.map(e => e ? n.Coin.toJSON(e) : void 0) : t.coins = [], t
                },
                fromPartial(e) {
                    let t = d();
                    return t.address = e.address ? ? "", t.coins = e.coins ? .map(e => n.Coin.fromPartial(e)) || [], t
                }
            }, t.Output = {
                typeUrl: "/cosmos.bank.v1beta1.Output",
                encode(e, t = o.BinaryWriter.create()) {
                    for (let r of ("" !== e.address && t.uint32(10).string(e.address), e.coins)) n.Coin.encode(r, t.uint32(18).fork()).ldelim();
                    return t
                },
                decode(e, t) {
                    let r = e instanceof o.BinaryReader ? e : new o.BinaryReader(e),
                        i = void 0 === t ? r.len : r.pos + t,
                        a = c();
                    for (; r.pos < i;) {
                        let e = r.uint32();
                        switch (e >>> 3) {
                            case 1:
                                a.address = r.string();
                                break;
                            case 2:
                                a.coins.push(n.Coin.decode(r, r.uint32()));
                                break;
                            default:
                                r.skipType(7 & e)
                        }
                    }
                    return a
                },
                fromJSON(e) {
                    let t = c();
                    return (0, i.isSet)(e.address) && (t.address = String(e.address)), Array.isArray(e ? .coins) && (t.coins = e.coins.map(e => n.Coin.fromJSON(e))), t
                },
                toJSON(e) {
                    let t = {};
                    return void 0 !== e.address && (t.address = e.address), e.coins ? t.coins = e.coins.map(e => e ? n.Coin.toJSON(e) : void 0) : t.coins = [], t
                },
                fromPartial(e) {
                    let t = c();
                    return t.address = e.address ? ? "", t.coins = e.coins ? .map(e => n.Coin.fromPartial(e)) || [], t
                }
            }, t.Supply = {
                typeUrl: "/cosmos.bank.v1beta1.Supply",
                encode(e, t = o.BinaryWriter.create()) {
                    for (let r of e.total) n.Coin.encode(r, t.uint32(10).fork()).ldelim();
                    return t
                },
                decode(e, t) {
                    let r = e instanceof o.BinaryReader ? e : new o.BinaryReader(e),
                        i = void 0 === t ? r.len : r.pos + t,
                        a = l();
                    for (; r.pos < i;) {
                        let e = r.uint32();
                        e >>> 3 == 1 ? a.total.push(n.Coin.decode(r, r.uint32())) : r.skipType(7 & e)
                    }
                    return a
                },
                fromJSON(e) {
                    let t = l();
                    return Array.isArray(e ? .total) && (t.total = e.total.map(e => n.Coin.fromJSON(e))), t
                },
                toJSON(e) {
                    let t = {};
                    return e.total ? t.total = e.total.map(e => e ? n.Coin.toJSON(e) : void 0) : t.total = [], t
                },
                fromPartial(e) {
                    let t = l();
                    return t.total = e.total ? .map(e => n.Coin.fromPartial(e)) || [], t
                }
            }, t.DenomUnit = {
                typeUrl: "/cosmos.bank.v1beta1.DenomUnit",
                encode(e, t = o.BinaryWriter.create()) {
                    for (let r of ("" !== e.denom && t.uint32(10).string(e.denom), 0 !== e.exponent && t.uint32(16).uint32(e.exponent), e.aliases)) t.uint32(26).string(r);
                    return t
                },
                decode(e, t) {
                    let r = e instanceof o.BinaryReader ? e : new o.BinaryReader(e),
                        n = void 0 === t ? r.len : r.pos + t,
                        i = u();
                    for (; r.pos < n;) {
                        let e = r.uint32();
                        switch (e >>> 3) {
                            case 1:
                                i.denom = r.string();
                                break;
                            case 2:
                                i.exponent = r.uint32();
                                break;
                            case 3:
                                i.aliases.push(r.string());
                                break;
                            default:
                                r.skipType(7 & e)
                        }
                    }
                    return i
                },
                fromJSON(e) {
                    let t = u();
                    return (0, i.isSet)(e.denom) && (t.denom = String(e.denom)), (0, i.isSet)(e.exponent) && (t.exponent = Number(e.exponent)), Array.isArray(e ? .aliases) && (t.aliases = e.aliases.map(e => String(e))), t
                },
                toJSON(e) {
                    let t = {};
                    return void 0 !== e.denom && (t.denom = e.denom), void 0 !== e.exponent && (t.exponent = Math.round(e.exponent)), e.aliases ? t.aliases = e.aliases.map(e => e) : t.aliases = [], t
                },
                fromPartial(e) {
                    let t = u();
                    return t.denom = e.denom ? ? "", t.exponent = e.exponent ? ? 0, t.aliases = e.aliases ? .map(e => e) || [], t
                }
            }, t.Metadata = {
                typeUrl: "/cosmos.bank.v1beta1.Metadata",
                encode(e, r = o.BinaryWriter.create()) {
                    for (let n of ("" !== e.description && r.uint32(10).string(e.description), e.denomUnits)) t.DenomUnit.encode(n, r.uint32(18).fork()).ldelim();
                    return "" !== e.base && r.uint32(26).string(e.base), "" !== e.display && r.uint32(34).string(e.display), "" !== e.name && r.uint32(42).string(e.name), "" !== e.symbol && r.uint32(50).string(e.symbol), "" !== e.uri && r.uint32(58).string(e.uri), "" !== e.uriHash && r.uint32(66).string(e.uriHash), r
                },
                decode(e, r) {
                    let n = e instanceof o.BinaryReader ? e : new o.BinaryReader(e),
                        i = void 0 === r ? n.len : n.pos + r,
                        a = p();
                    for (; n.pos < i;) {
                        let e = n.uint32();
                        switch (e >>> 3) {
                            case 1:
                                a.description = n.string();
                                break;
                            case 2:
                                a.denomUnits.push(t.DenomUnit.decode(n, n.uint32()));
                                break;
                            case 3:
                                a.base = n.string();
                                break;
                            case 4:
                                a.display = n.string();
                                break;
                            case 5:
                                a.name = n.string();
                                break;
                            case 6:
                                a.symbol = n.string();
                                break;
                            case 7:
                                a.uri = n.string();
                                break;
                            case 8:
                                a.uriHash = n.string();
                                break;
                            default:
                                n.skipType(7 & e)
                        }
                    }
                    return a
                },
                fromJSON(e) {
                    let r = p();
                    return (0, i.isSet)(e.description) && (r.description = String(e.description)), Array.isArray(e ? .denomUnits) && (r.denomUnits = e.denomUnits.map(e => t.DenomUnit.fromJSON(e))), (0, i.isSet)(e.base) && (r.base = String(e.base)), (0, i.isSet)(e.display) && (r.display = String(e.display)), (0, i.isSet)(e.name) && (r.name = String(e.name)), (0, i.isSet)(e.symbol) && (r.symbol = String(e.symbol)), (0, i.isSet)(e.uri) && (r.uri = String(e.uri)), (0, i.isSet)(e.uriHash) && (r.uriHash = String(e.uriHash)), r
                },
                toJSON(e) {
                    let r = {};
                    return void 0 !== e.description && (r.description = e.description), e.denomUnits ? r.denomUnits = e.denomUnits.map(e => e ? t.DenomUnit.toJSON(e) : void 0) : r.denomUnits = [], void 0 !== e.base && (r.base = e.base), void 0 !== e.display && (r.display = e.display), void 0 !== e.name && (r.name = e.name), void 0 !== e.symbol && (r.symbol = e.symbol), void 0 !== e.uri && (r.uri = e.uri), void 0 !== e.uriHash && (r.uriHash = e.uriHash), r
                },
                fromPartial(e) {
                    let r = p();
                    return r.description = e.description ? ? "", r.denomUnits = e.denomUnits ? .map(e => t.DenomUnit.fromPartial(e)) || [], r.base = e.base ? ? "", r.display = e.display ? ? "", r.name = e.name ? ? "", r.symbol = e.symbol ? ? "", r.uri = e.uri ? ? "", r.uriHash = e.uriHash ? ? "", r
                }
            }
        },
        53659: function(e, t, r) {
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: !0
            }), t.QueryClientImpl = t.QuerySendEnabledResponse = t.QuerySendEnabledRequest = t.QueryDenomOwnersResponse = t.DenomOwner = t.QueryDenomOwnersRequest = t.QueryDenomMetadataResponse = t.QueryDenomMetadataRequest = t.QueryDenomsMetadataResponse = t.QueryDenomsMetadataRequest = t.QueryParamsResponse = t.QueryParamsRequest = t.QuerySupplyOfResponse = t.QuerySupplyOfRequest = t.QueryTotalSupplyResponse = t.QueryTotalSupplyRequest = t.QuerySpendableBalanceByDenomResponse = t.QuerySpendableBalanceByDenomRequest = t.QuerySpendableBalancesResponse = t.QuerySpendableBalancesRequest = t.QueryAllBalancesResponse = t.QueryAllBalancesRequest = t.QueryBalanceResponse = t.QueryBalanceRequest = t.protobufPackage = void 0;
            let n = r(38792),
                o = r(62809),
                i = r(7401),
                a = r(28486),
                s = r(6476);

            function d() {
                return {
                    address: "",
                    denom: ""
                }
            }

            function c() {
                return {
                    balance: void 0
                }
            }

            function l() {
                return {
                    address: "",
                    pagination: void 0
                }
            }

            function u() {
                return {
                    balances: [],
                    pagination: void 0
                }
            }

            function p() {
                return {
                    address: "",
                    pagination: void 0
                }
            }

            function m() {
                return {
                    balances: [],
                    pagination: void 0
                }
            }

            function g() {
                return {
                    address: "",
                    denom: ""
                }
            }

            function f() {
                return {
                    balance: void 0
                }
            }

            function y() {
                return {
                    pagination: void 0
                }
            }

            function h() {
                return {
                    supply: [],
                    pagination: void 0
                }
            }

            function v() {
                return {
                    denom: ""
                }
            }

            function b() {
                return {
                    amount: o.Coin.fromPartial({})
                }
            }

            function S() {
                return {
                    params: i.Params.fromPartial({})
                }
            }

            function k() {
                return {
                    pagination: void 0
                }
            }

            function P() {
                return {
                    metadatas: [],
                    pagination: void 0
                }
            }

            function _() {
                return {
                    denom: ""
                }
            }

            function B() {
                return {
                    metadata: i.Metadata.fromPartial({})
                }
            }

            function O() {
                return {
                    denom: "",
                    pagination: void 0
                }
            }

            function R() {
                return {
                    address: "",
                    balance: o.Coin.fromPartial({})
                }
            }

            function A() {
                return {
                    denomOwners: [],
                    pagination: void 0
                }
            }

            function I() {
                return {
                    denoms: [],
                    pagination: void 0
                }
            }

            function w() {
                return {
                    sendEnabled: [],
                    pagination: void 0
                }
            }
            t.protobufPackage = "cosmos.bank.v1beta1", t.QueryBalanceRequest = {
                typeUrl: "/cosmos.bank.v1beta1.QueryBalanceRequest",
                encode: (e, t = a.BinaryWriter.create()) => ("" !== e.address && t.uint32(10).string(e.address), "" !== e.denom && t.uint32(18).string(e.denom), t),
                decode(e, t) {
                    let r = e instanceof a.BinaryReader ? e : new a.BinaryReader(e),
                        n = void 0 === t ? r.len : r.pos + t,
                        o = d();
                    for (; r.pos < n;) {
                        let e = r.uint32();
                        switch (e >>> 3) {
                            case 1:
                                o.address = r.string();
                                break;
                            case 2:
                                o.denom = r.string();
                                break;
                            default:
                                r.skipType(7 & e)
                        }
                    }
                    return o
                },
                fromJSON(e) {
                    let t = d();
                    return (0, s.isSet)(e.address) && (t.address = String(e.address)), (0, s.isSet)(e.denom) && (t.denom = String(e.denom)), t
                },
                toJSON(e) {
                    let t = {};
                    return void 0 !== e.address && (t.address = e.address), void 0 !== e.denom && (t.denom = e.denom), t
                },
                fromPartial(e) {
                    let t = d();
                    return t.address = e.address ? ? "", t.denom = e.denom ? ? "", t
                }
            }, t.QueryBalanceResponse = {
                typeUrl: "/cosmos.bank.v1beta1.QueryBalanceResponse",
                encode: (e, t = a.BinaryWriter.create()) => (void 0 !== e.balance && o.Coin.encode(e.balance, t.uint32(10).fork()).ldelim(), t),
                decode(e, t) {
                    let r = e instanceof a.BinaryReader ? e : new a.BinaryReader(e),
                        n = void 0 === t ? r.len : r.pos + t,
                        i = c();
                    for (; r.pos < n;) {
                        let e = r.uint32();
                        e >>> 3 == 1 ? i.balance = o.Coin.decode(r, r.uint32()) : r.skipType(7 & e)
                    }
                    return i
                },
                fromJSON(e) {
                    let t = c();
                    return (0, s.isSet)(e.balance) && (t.balance = o.Coin.fromJSON(e.balance)), t
                },
                toJSON(e) {
                    let t = {};
                    return void 0 !== e.balance && (t.balance = e.balance ? o.Coin.toJSON(e.balance) : void 0), t
                },
                fromPartial(e) {
                    let t = c();
                    return void 0 !== e.balance && null !== e.balance && (t.balance = o.Coin.fromPartial(e.balance)), t
                }
            }, t.QueryAllBalancesRequest = {
                typeUrl: "/cosmos.bank.v1beta1.QueryAllBalancesRequest",
                encode: (e, t = a.BinaryWriter.create()) => ("" !== e.address && t.uint32(10).string(e.address), void 0 !== e.pagination && n.PageRequest.encode(e.pagination, t.uint32(18).fork()).ldelim(), t),
                decode(e, t) {
                    let r = e instanceof a.BinaryReader ? e : new a.BinaryReader(e),
                        o = void 0 === t ? r.len : r.pos + t,
                        i = l();
                    for (; r.pos < o;) {
                        let e = r.uint32();
                        switch (e >>> 3) {
                            case 1:
                                i.address = r.string();
                                break;
                            case 2:
                                i.pagination = n.PageRequest.decode(r, r.uint32());
                                break;
                            default:
                                r.skipType(7 & e)
                        }
                    }
                    return i
                },
                fromJSON(e) {
                    let t = l();
                    return (0, s.isSet)(e.address) && (t.address = String(e.address)), (0, s.isSet)(e.pagination) && (t.pagination = n.PageRequest.fromJSON(e.pagination)), t
                },
                toJSON(e) {
                    let t = {};
                    return void 0 !== e.address && (t.address = e.address), void 0 !== e.pagination && (t.pagination = e.pagination ? n.PageRequest.toJSON(e.pagination) : void 0), t
                },
                fromPartial(e) {
                    let t = l();
                    return t.address = e.address ? ? "", void 0 !== e.pagination && null !== e.pagination && (t.pagination = n.PageRequest.fromPartial(e.pagination)), t
                }
            }, t.QueryAllBalancesResponse = {
                typeUrl: "/cosmos.bank.v1beta1.QueryAllBalancesResponse",
                encode(e, t = a.BinaryWriter.create()) {
                    for (let r of e.balances) o.Coin.encode(r, t.uint32(10).fork()).ldelim();
                    return void 0 !== e.pagination && n.PageResponse.encode(e.pagination, t.uint32(18).fork()).ldelim(), t
                },
                decode(e, t) {
                    let r = e instanceof a.BinaryReader ? e : new a.BinaryReader(e),
                        i = void 0 === t ? r.len : r.pos + t,
                        s = u();
                    for (; r.pos < i;) {
                        let e = r.uint32();
                        switch (e >>> 3) {
                            case 1:
                                s.balances.push(o.Coin.decode(r, r.uint32()));
                                break;
                            case 2:
                                s.pagination = n.PageResponse.decode(r, r.uint32());
                                break;
                            default:
                                r.skipType(7 & e)
                        }
                    }
                    return s
                },
                fromJSON(e) {
                    let t = u();
                    return Array.isArray(e ? .balances) && (t.balances = e.balances.map(e => o.Coin.fromJSON(e))), (0, s.isSet)(e.pagination) && (t.pagination = n.PageResponse.fromJSON(e.pagination)), t
                },
                toJSON(e) {
                    let t = {};
                    return e.balances ? t.balances = e.balances.map(e => e ? o.Coin.toJSON(e) : void 0) : t.balances = [], void 0 !== e.pagination && (t.pagination = e.pagination ? n.PageResponse.toJSON(e.pagination) : void 0), t
                },
                fromPartial(e) {
                    let t = u();
                    return t.balances = e.balances ? .map(e => o.Coin.fromPartial(e)) || [], void 0 !== e.pagination && null !== e.pagination && (t.pagination = n.PageResponse.fromPartial(e.pagination)), t
                }
            }, t.QuerySpendableBalancesRequest = {
                typeUrl: "/cosmos.bank.v1beta1.QuerySpendableBalancesRequest",
                encode: (e, t = a.BinaryWriter.create()) => ("" !== e.address && t.uint32(10).string(e.address), void 0 !== e.pagination && n.PageRequest.encode(e.pagination, t.uint32(18).fork()).ldelim(), t),
                decode(e, t) {
                    let r = e instanceof a.BinaryReader ? e : new a.BinaryReader(e),
                        o = void 0 === t ? r.len : r.pos + t,
                        i = p();
                    for (; r.pos < o;) {
                        let e = r.uint32();
                        switch (e >>> 3) {
                            case 1:
                                i.address = r.string();
                                break;
                            case 2:
                                i.pagination = n.PageRequest.decode(r, r.uint32());
                                break;
                            default:
                                r.skipType(7 & e)
                        }
                    }
                    return i
                },
                fromJSON(e) {
                    let t = p();
                    return (0, s.isSet)(e.address) && (t.address = String(e.address)), (0, s.isSet)(e.pagination) && (t.pagination = n.PageRequest.fromJSON(e.pagination)), t
                },
                toJSON(e) {
                    let t = {};
                    return void 0 !== e.address && (t.address = e.address), void 0 !== e.pagination && (t.pagination = e.pagination ? n.PageRequest.toJSON(e.pagination) : void 0), t
                },
                fromPartial(e) {
                    let t = p();
                    return t.address = e.address ? ? "", void 0 !== e.pagination && null !== e.pagination && (t.pagination = n.PageRequest.fromPartial(e.pagination)), t
                }
            }, t.QuerySpendableBalancesResponse = {
                typeUrl: "/cosmos.bank.v1beta1.QuerySpendableBalancesResponse",
                encode(e, t = a.BinaryWriter.create()) {
                    for (let r of e.balances) o.Coin.encode(r, t.uint32(10).fork()).ldelim();
                    return void 0 !== e.pagination && n.PageResponse.encode(e.pagination, t.uint32(18).fork()).ldelim(), t
                },
                decode(e, t) {
                    let r = e instanceof a.BinaryReader ? e : new a.BinaryReader(e),
                        i = void 0 === t ? r.len : r.pos + t,
                        s = m();
                    for (; r.pos < i;) {
                        let e = r.uint32();
                        switch (e >>> 3) {
                            case 1:
                                s.balances.push(o.Coin.decode(r, r.uint32()));
                                break;
                            case 2:
                                s.pagination = n.PageResponse.decode(r, r.uint32());
                                break;
                            default:
                                r.skipType(7 & e)
                        }
                    }
                    return s
                },
                fromJSON(e) {
                    let t = m();
                    return Array.isArray(e ? .balances) && (t.balances = e.balances.map(e => o.Coin.fromJSON(e))), (0, s.isSet)(e.pagination) && (t.pagination = n.PageResponse.fromJSON(e.pagination)), t
                },
                toJSON(e) {
                    let t = {};
                    return e.balances ? t.balances = e.balances.map(e => e ? o.Coin.toJSON(e) : void 0) : t.balances = [], void 0 !== e.pagination && (t.pagination = e.pagination ? n.PageResponse.toJSON(e.pagination) : void 0), t
                },
                fromPartial(e) {
                    let t = m();
                    return t.balances = e.balances ? .map(e => o.Coin.fromPartial(e)) || [], void 0 !== e.pagination && null !== e.pagination && (t.pagination = n.PageResponse.fromPartial(e.pagination)), t
                }
            }, t.QuerySpendableBalanceByDenomRequest = {
                typeUrl: "/cosmos.bank.v1beta1.QuerySpendableBalanceByDenomRequest",
                encode: (e, t = a.BinaryWriter.create()) => ("" !== e.address && t.uint32(10).string(e.address), "" !== e.denom && t.uint32(18).string(e.denom), t),
                decode(e, t) {
                    let r = e instanceof a.BinaryReader ? e : new a.BinaryReader(e),
                        n = void 0 === t ? r.len : r.pos + t,
                        o = g();
                    for (; r.pos < n;) {
                        let e = r.uint32();
                        switch (e >>> 3) {
                            case 1:
                                o.address = r.string();
                                break;
                            case 2:
                                o.denom = r.string();
                                break;
                            default:
                                r.skipType(7 & e)
                        }
                    }
                    return o
                },
                fromJSON(e) {
                    let t = g();
                    return (0, s.isSet)(e.address) && (t.address = String(e.address)), (0, s.isSet)(e.denom) && (t.denom = String(e.denom)), t
                },
                toJSON(e) {
                    let t = {};
                    return void 0 !== e.address && (t.address = e.address), void 0 !== e.denom && (t.denom = e.denom), t
                },
                fromPartial(e) {
                    let t = g();
                    return t.address = e.address ? ? "", t.denom = e.denom ? ? "", t
                }
            }, t.QuerySpendableBalanceByDenomResponse = {
                typeUrl: "/cosmos.bank.v1beta1.QuerySpendableBalanceByDenomResponse",
                encode: (e, t = a.BinaryWriter.create()) => (void 0 !== e.balance && o.Coin.encode(e.balance, t.uint32(10).fork()).ldelim(), t),
                decode(e, t) {
                    let r = e instanceof a.BinaryReader ? e : new a.BinaryReader(e),
                        n = void 0 === t ? r.len : r.pos + t,
                        i = f();
                    for (; r.pos < n;) {
                        let e = r.uint32();
                        e >>> 3 == 1 ? i.balance = o.Coin.decode(r, r.uint32()) : r.skipType(7 & e)
                    }
                    return i
                },
                fromJSON(e) {
                    let t = f();
                    return (0, s.isSet)(e.balance) && (t.balance = o.Coin.fromJSON(e.balance)), t
                },
                toJSON(e) {
                    let t = {};
                    return void 0 !== e.balance && (t.balance = e.balance ? o.Coin.toJSON(e.balance) : void 0), t
                },
                fromPartial(e) {
                    let t = f();
                    return void 0 !== e.balance && null !== e.balance && (t.balance = o.Coin.fromPartial(e.balance)), t
                }
            }, t.QueryTotalSupplyRequest = {
                typeUrl: "/cosmos.bank.v1beta1.QueryTotalSupplyRequest",
                encode: (e, t = a.BinaryWriter.create()) => (void 0 !== e.pagination && n.PageRequest.encode(e.pagination, t.uint32(10).fork()).ldelim(), t),
                decode(e, t) {
                    let r = e instanceof a.BinaryReader ? e : new a.BinaryReader(e),
                        o = void 0 === t ? r.len : r.pos + t,
                        i = y();
                    for (; r.pos < o;) {
                        let e = r.uint32();
                        e >>> 3 == 1 ? i.pagination = n.PageRequest.decode(r, r.uint32()) : r.skipType(7 & e)
                    }
                    return i
                },
                fromJSON(e) {
                    let t = y();
                    return (0, s.isSet)(e.pagination) && (t.pagination = n.PageRequest.fromJSON(e.pagination)), t
                },
                toJSON(e) {
                    let t = {};
                    return void 0 !== e.pagination && (t.pagination = e.pagination ? n.PageRequest.toJSON(e.pagination) : void 0), t
                },
                fromPartial(e) {
                    let t = y();
                    return void 0 !== e.pagination && null !== e.pagination && (t.pagination = n.PageRequest.fromPartial(e.pagination)), t
                }
            }, t.QueryTotalSupplyResponse = {
                typeUrl: "/cosmos.bank.v1beta1.QueryTotalSupplyResponse",
                encode(e, t = a.BinaryWriter.create()) {
                    for (let r of e.supply) o.Coin.encode(r, t.uint32(10).fork()).ldelim();
                    return void 0 !== e.pagination && n.PageResponse.encode(e.pagination, t.uint32(18).fork()).ldelim(), t
                },
                decode(e, t) {
                    let r = e instanceof a.BinaryReader ? e : new a.BinaryReader(e),
                        i = void 0 === t ? r.len : r.pos + t,
                        s = h();
                    for (; r.pos < i;) {
                        let e = r.uint32();
                        switch (e >>> 3) {
                            case 1:
                                s.supply.push(o.Coin.decode(r, r.uint32()));
                                break;
                            case 2:
                                s.pagination = n.PageResponse.decode(r, r.uint32());
                                break;
                            default:
                                r.skipType(7 & e)
                        }
                    }
                    return s
                },
                fromJSON(e) {
                    let t = h();
                    return Array.isArray(e ? .supply) && (t.supply = e.supply.map(e => o.Coin.fromJSON(e))), (0, s.isSet)(e.pagination) && (t.pagination = n.PageResponse.fromJSON(e.pagination)), t
                },
                toJSON(e) {
                    let t = {};
                    return e.supply ? t.supply = e.supply.map(e => e ? o.Coin.toJSON(e) : void 0) : t.supply = [], void 0 !== e.pagination && (t.pagination = e.pagination ? n.PageResponse.toJSON(e.pagination) : void 0), t
                },
                fromPartial(e) {
                    let t = h();
                    return t.supply = e.supply ? .map(e => o.Coin.fromPartial(e)) || [], void 0 !== e.pagination && null !== e.pagination && (t.pagination = n.PageResponse.fromPartial(e.pagination)), t
                }
            }, t.QuerySupplyOfRequest = {
                typeUrl: "/cosmos.bank.v1beta1.QuerySupplyOfRequest",
                encode: (e, t = a.BinaryWriter.create()) => ("" !== e.denom && t.uint32(10).string(e.denom), t),
                decode(e, t) {
                    let r = e instanceof a.BinaryReader ? e : new a.BinaryReader(e),
                        n = void 0 === t ? r.len : r.pos + t,
                        o = v();
                    for (; r.pos < n;) {
                        let e = r.uint32();
                        e >>> 3 == 1 ? o.denom = r.string() : r.skipType(7 & e)
                    }
                    return o
                },
                fromJSON(e) {
                    let t = v();
                    return (0, s.isSet)(e.denom) && (t.denom = String(e.denom)), t
                },
                toJSON(e) {
                    let t = {};
                    return void 0 !== e.denom && (t.denom = e.denom), t
                },
                fromPartial(e) {
                    let t = v();
                    return t.denom = e.denom ? ? "", t
                }
            }, t.QuerySupplyOfResponse = {
                typeUrl: "/cosmos.bank.v1beta1.QuerySupplyOfResponse",
                encode: (e, t = a.BinaryWriter.create()) => (void 0 !== e.amount && o.Coin.encode(e.amount, t.uint32(10).fork()).ldelim(), t),
                decode(e, t) {
                    let r = e instanceof a.BinaryReader ? e : new a.BinaryReader(e),
                        n = void 0 === t ? r.len : r.pos + t,
                        i = b();
                    for (; r.pos < n;) {
                        let e = r.uint32();
                        e >>> 3 == 1 ? i.amount = o.Coin.decode(r, r.uint32()) : r.skipType(7 & e)
                    }
                    return i
                },
                fromJSON(e) {
                    let t = b();
                    return (0, s.isSet)(e.amount) && (t.amount = o.Coin.fromJSON(e.amount)), t
                },
                toJSON(e) {
                    let t = {};
                    return void 0 !== e.amount && (t.amount = e.amount ? o.Coin.toJSON(e.amount) : void 0), t
                },
                fromPartial(e) {
                    let t = b();
                    return void 0 !== e.amount && null !== e.amount && (t.amount = o.Coin.fromPartial(e.amount)), t
                }
            }, t.QueryParamsRequest = {
                typeUrl: "/cosmos.bank.v1beta1.QueryParamsRequest",
                encode: (e, t = a.BinaryWriter.create()) => t,
                decode(e, t) {
                    let r = e instanceof a.BinaryReader ? e : new a.BinaryReader(e),
                        n = void 0 === t ? r.len : r.pos + t;
                    for (; r.pos < n;) {
                        let e = r.uint32();
                        r.skipType(7 & e)
                    }
                    return {}
                },
                fromJSON: e => ({}),
                toJSON: e => ({}),
                fromPartial: e => ({})
            }, t.QueryParamsResponse = {
                typeUrl: "/cosmos.bank.v1beta1.QueryParamsResponse",
                encode: (e, t = a.BinaryWriter.create()) => (void 0 !== e.params && i.Params.encode(e.params, t.uint32(10).fork()).ldelim(), t),
                decode(e, t) {
                    let r = e instanceof a.BinaryReader ? e : new a.BinaryReader(e),
                        n = void 0 === t ? r.len : r.pos + t,
                        o = S();
                    for (; r.pos < n;) {
                        let e = r.uint32();
                        e >>> 3 == 1 ? o.params = i.Params.decode(r, r.uint32()) : r.skipType(7 & e)
                    }
                    return o
                },
                fromJSON(e) {
                    let t = S();
                    return (0, s.isSet)(e.params) && (t.params = i.Params.fromJSON(e.params)), t
                },
                toJSON(e) {
                    let t = {};
                    return void 0 !== e.params && (t.params = e.params ? i.Params.toJSON(e.params) : void 0), t
                },
                fromPartial(e) {
                    let t = S();
                    return void 0 !== e.params && null !== e.params && (t.params = i.Params.fromPartial(e.params)), t
                }
            }, t.QueryDenomsMetadataRequest = {
                typeUrl: "/cosmos.bank.v1beta1.QueryDenomsMetadataRequest",
                encode: (e, t = a.BinaryWriter.create()) => (void 0 !== e.pagination && n.PageRequest.encode(e.pagination, t.uint32(10).fork()).ldelim(), t),
                decode(e, t) {
                    let r = e instanceof a.BinaryReader ? e : new a.BinaryReader(e),
                        o = void 0 === t ? r.len : r.pos + t,
                        i = k();
                    for (; r.pos < o;) {
                        let e = r.uint32();
                        e >>> 3 == 1 ? i.pagination = n.PageRequest.decode(r, r.uint32()) : r.skipType(7 & e)
                    }
                    return i
                },
                fromJSON(e) {
                    let t = k();
                    return (0, s.isSet)(e.pagination) && (t.pagination = n.PageRequest.fromJSON(e.pagination)), t
                },
                toJSON(e) {
                    let t = {};
                    return void 0 !== e.pagination && (t.pagination = e.pagination ? n.PageRequest.toJSON(e.pagination) : void 0), t
                },
                fromPartial(e) {
                    let t = k();
                    return void 0 !== e.pagination && null !== e.pagination && (t.pagination = n.PageRequest.fromPartial(e.pagination)), t
                }
            }, t.QueryDenomsMetadataResponse = {
                typeUrl: "/cosmos.bank.v1beta1.QueryDenomsMetadataResponse",
                encode(e, t = a.BinaryWriter.create()) {
                    for (let r of e.metadatas) i.Metadata.encode(r, t.uint32(10).fork()).ldelim();
                    return void 0 !== e.pagination && n.PageResponse.encode(e.pagination, t.uint32(18).fork()).ldelim(), t
                },
                decode(e, t) {
                    let r = e instanceof a.BinaryReader ? e : new a.BinaryReader(e),
                        o = void 0 === t ? r.len : r.pos + t,
                        s = P();
                    for (; r.pos < o;) {
                        let e = r.uint32();
                        switch (e >>> 3) {
                            case 1:
                                s.metadatas.push(i.Metadata.decode(r, r.uint32()));
                                break;
                            case 2:
                                s.pagination = n.PageResponse.decode(r, r.uint32());
                                break;
                            default:
                                r.skipType(7 & e)
                        }
                    }
                    return s
                },
                fromJSON(e) {
                    let t = P();
                    return Array.isArray(e ? .metadatas) && (t.metadatas = e.metadatas.map(e => i.Metadata.fromJSON(e))), (0, s.isSet)(e.pagination) && (t.pagination = n.PageResponse.fromJSON(e.pagination)), t
                },
                toJSON(e) {
                    let t = {};
                    return e.metadatas ? t.metadatas = e.metadatas.map(e => e ? i.Metadata.toJSON(e) : void 0) : t.metadatas = [], void 0 !== e.pagination && (t.pagination = e.pagination ? n.PageResponse.toJSON(e.pagination) : void 0), t
                },
                fromPartial(e) {
                    let t = P();
                    return t.metadatas = e.metadatas ? .map(e => i.Metadata.fromPartial(e)) || [], void 0 !== e.pagination && null !== e.pagination && (t.pagination = n.PageResponse.fromPartial(e.pagination)), t
                }
            }, t.QueryDenomMetadataRequest = {
                typeUrl: "/cosmos.bank.v1beta1.QueryDenomMetadataRequest",
                encode: (e, t = a.BinaryWriter.create()) => ("" !== e.denom && t.uint32(10).string(e.denom), t),
                decode(e, t) {
                    let r = e instanceof a.BinaryReader ? e : new a.BinaryReader(e),
                        n = void 0 === t ? r.len : r.pos + t,
                        o = _();
                    for (; r.pos < n;) {
                        let e = r.uint32();
                        e >>> 3 == 1 ? o.denom = r.string() : r.skipType(7 & e)
                    }
                    return o
                },
                fromJSON(e) {
                    let t = _();
                    return (0, s.isSet)(e.denom) && (t.denom = String(e.denom)), t
                },
                toJSON(e) {
                    let t = {};
                    return void 0 !== e.denom && (t.denom = e.denom), t
                },
                fromPartial(e) {
                    let t = _();
                    return t.denom = e.denom ? ? "", t
                }
            }, t.QueryDenomMetadataResponse = {
                typeUrl: "/cosmos.bank.v1beta1.QueryDenomMetadataResponse",
                encode: (e, t = a.BinaryWriter.create()) => (void 0 !== e.metadata && i.Metadata.encode(e.metadata, t.uint32(10).fork()).ldelim(), t),
                decode(e, t) {
                    let r = e instanceof a.BinaryReader ? e : new a.BinaryReader(e),
                        n = void 0 === t ? r.len : r.pos + t,
                        o = B();
                    for (; r.pos < n;) {
                        let e = r.uint32();
                        e >>> 3 == 1 ? o.metadata = i.Metadata.decode(r, r.uint32()) : r.skipType(7 & e)
                    }
                    return o
                },
                fromJSON(e) {
                    let t = B();
                    return (0, s.isSet)(e.metadata) && (t.metadata = i.Metadata.fromJSON(e.metadata)), t
                },
                toJSON(e) {
                    let t = {};
                    return void 0 !== e.metadata && (t.metadata = e.metadata ? i.Metadata.toJSON(e.metadata) : void 0), t
                },
                fromPartial(e) {
                    let t = B();
                    return void 0 !== e.metadata && null !== e.metadata && (t.metadata = i.Metadata.fromPartial(e.metadata)), t
                }
            }, t.QueryDenomOwnersRequest = {
                typeUrl: "/cosmos.bank.v1beta1.QueryDenomOwnersRequest",
                encode: (e, t = a.BinaryWriter.create()) => ("" !== e.denom && t.uint32(10).string(e.denom), void 0 !== e.pagination && n.PageRequest.encode(e.pagination, t.uint32(18).fork()).ldelim(), t),
                decode(e, t) {
                    let r = e instanceof a.BinaryReader ? e : new a.BinaryReader(e),
                        o = void 0 === t ? r.len : r.pos + t,
                        i = O();
                    for (; r.pos < o;) {
                        let e = r.uint32();
                        switch (e >>> 3) {
                            case 1:
                                i.denom = r.string();
                                break;
                            case 2:
                                i.pagination = n.PageRequest.decode(r, r.uint32());
                                break;
                            default:
                                r.skipType(7 & e)
                        }
                    }
                    return i
                },
                fromJSON(e) {
                    let t = O();
                    return (0, s.isSet)(e.denom) && (t.denom = String(e.denom)), (0, s.isSet)(e.pagination) && (t.pagination = n.PageRequest.fromJSON(e.pagination)), t
                },
                toJSON(e) {
                    let t = {};
                    return void 0 !== e.denom && (t.denom = e.denom), void 0 !== e.pagination && (t.pagination = e.pagination ? n.PageRequest.toJSON(e.pagination) : void 0), t
                },
                fromPartial(e) {
                    let t = O();
                    return t.denom = e.denom ? ? "", void 0 !== e.pagination && null !== e.pagination && (t.pagination = n.PageRequest.fromPartial(e.pagination)), t
                }
            }, t.DenomOwner = {
                typeUrl: "/cosmos.bank.v1beta1.DenomOwner",
                encode: (e, t = a.BinaryWriter.create()) => ("" !== e.address && t.uint32(10).string(e.address), void 0 !== e.balance && o.Coin.encode(e.balance, t.uint32(18).fork()).ldelim(), t),
                decode(e, t) {
                    let r = e instanceof a.BinaryReader ? e : new a.BinaryReader(e),
                        n = void 0 === t ? r.len : r.pos + t,
                        i = R();
                    for (; r.pos < n;) {
                        let e = r.uint32();
                        switch (e >>> 3) {
                            case 1:
                                i.address = r.string();
                                break;
                            case 2:
                                i.balance = o.Coin.decode(r, r.uint32());
                                break;
                            default:
                                r.skipType(7 & e)
                        }
                    }
                    return i
                },
                fromJSON(e) {
                    let t = R();
                    return (0, s.isSet)(e.address) && (t.address = String(e.address)), (0, s.isSet)(e.balance) && (t.balance = o.Coin.fromJSON(e.balance)), t
                },
                toJSON(e) {
                    let t = {};
                    return void 0 !== e.address && (t.address = e.address), void 0 !== e.balance && (t.balance = e.balance ? o.Coin.toJSON(e.balance) : void 0), t
                },
                fromPartial(e) {
                    let t = R();
                    return t.address = e.address ? ? "", void 0 !== e.balance && null !== e.balance && (t.balance = o.Coin.fromPartial(e.balance)), t
                }
            }, t.QueryDenomOwnersResponse = {
                typeUrl: "/cosmos.bank.v1beta1.QueryDenomOwnersResponse",
                encode(e, r = a.BinaryWriter.create()) {
                    for (let n of e.denomOwners) t.DenomOwner.encode(n, r.uint32(10).fork()).ldelim();
                    return void 0 !== e.pagination && n.PageResponse.encode(e.pagination, r.uint32(18).fork()).ldelim(), r
                },
                decode(e, r) {
                    let o = e instanceof a.BinaryReader ? e : new a.BinaryReader(e),
                        i = void 0 === r ? o.len : o.pos + r,
                        s = A();
                    for (; o.pos < i;) {
                        let e = o.uint32();
                        switch (e >>> 3) {
                            case 1:
                                s.denomOwners.push(t.DenomOwner.decode(o, o.uint32()));
                                break;
                            case 2:
                                s.pagination = n.PageResponse.decode(o, o.uint32());
                                break;
                            default:
                                o.skipType(7 & e)
                        }
                    }
                    return s
                },
                fromJSON(e) {
                    let r = A();
                    return Array.isArray(e ? .denomOwners) && (r.denomOwners = e.denomOwners.map(e => t.DenomOwner.fromJSON(e))), (0, s.isSet)(e.pagination) && (r.pagination = n.PageResponse.fromJSON(e.pagination)), r
                },
                toJSON(e) {
                    let r = {};
                    return e.denomOwners ? r.denomOwners = e.denomOwners.map(e => e ? t.DenomOwner.toJSON(e) : void 0) : r.denomOwners = [], void 0 !== e.pagination && (r.pagination = e.pagination ? n.PageResponse.toJSON(e.pagination) : void 0), r
                },
                fromPartial(e) {
                    let r = A();
                    return r.denomOwners = e.denomOwners ? .map(e => t.DenomOwner.fromPartial(e)) || [], void 0 !== e.pagination && null !== e.pagination && (r.pagination = n.PageResponse.fromPartial(e.pagination)), r
                }
            }, t.QuerySendEnabledRequest = {
                typeUrl: "/cosmos.bank.v1beta1.QuerySendEnabledRequest",
                encode(e, t = a.BinaryWriter.create()) {
                    for (let r of e.denoms) t.uint32(10).string(r);
                    return void 0 !== e.pagination && n.PageRequest.encode(e.pagination, t.uint32(794).fork()).ldelim(), t
                },
                decode(e, t) {
                    let r = e instanceof a.BinaryReader ? e : new a.BinaryReader(e),
                        o = void 0 === t ? r.len : r.pos + t,
                        i = I();
                    for (; r.pos < o;) {
                        let e = r.uint32();
                        switch (e >>> 3) {
                            case 1:
                                i.denoms.push(r.string());
                                break;
                            case 99:
                                i.pagination = n.PageRequest.decode(r, r.uint32());
                                break;
                            default:
                                r.skipType(7 & e)
                        }
                    }
                    return i
                },
                fromJSON(e) {
                    let t = I();
                    return Array.isArray(e ? .denoms) && (t.denoms = e.denoms.map(e => String(e))), (0, s.isSet)(e.pagination) && (t.pagination = n.PageRequest.fromJSON(e.pagination)), t
                },
                toJSON(e) {
                    let t = {};
                    return e.denoms ? t.denoms = e.denoms.map(e => e) : t.denoms = [], void 0 !== e.pagination && (t.pagination = e.pagination ? n.PageRequest.toJSON(e.pagination) : void 0), t
                },
                fromPartial(e) {
                    let t = I();
                    return t.denoms = e.denoms ? .map(e => e) || [], void 0 !== e.pagination && null !== e.pagination && (t.pagination = n.PageRequest.fromPartial(e.pagination)), t
                }
            }, t.QuerySendEnabledResponse = {
                typeUrl: "/cosmos.bank.v1beta1.QuerySendEnabledResponse",
                encode(e, t = a.BinaryWriter.create()) {
                    for (let r of e.sendEnabled) i.SendEnabled.encode(r, t.uint32(10).fork()).ldelim();
                    return void 0 !== e.pagination && n.PageResponse.encode(e.pagination, t.uint32(794).fork()).ldelim(), t
                },
                decode(e, t) {
                    let r = e instanceof a.BinaryReader ? e : new a.BinaryReader(e),
                        o = void 0 === t ? r.len : r.pos + t,
                        s = w();
                    for (; r.pos < o;) {
                        let e = r.uint32();
                        switch (e >>> 3) {
                            case 1:
                                s.sendEnabled.push(i.SendEnabled.decode(r, r.uint32()));
                                break;
                            case 99:
                                s.pagination = n.PageResponse.decode(r, r.uint32());
                                break;
                            default:
                                r.skipType(7 & e)
                        }
                    }
                    return s
                },
                fromJSON(e) {
                    let t = w();
                    return Array.isArray(e ? .sendEnabled) && (t.sendEnabled = e.sendEnabled.map(e => i.SendEnabled.fromJSON(e))), (0, s.isSet)(e.pagination) && (t.pagination = n.PageResponse.fromJSON(e.pagination)), t
                },
                toJSON(e) {
                    let t = {};
                    return e.sendEnabled ? t.sendEnabled = e.sendEnabled.map(e => e ? i.SendEnabled.toJSON(e) : void 0) : t.sendEnabled = [], void 0 !== e.pagination && (t.pagination = e.pagination ? n.PageResponse.toJSON(e.pagination) : void 0), t
                },
                fromPartial(e) {
                    let t = w();
                    return t.sendEnabled = e.sendEnabled ? .map(e => i.SendEnabled.fromPartial(e)) || [], void 0 !== e.pagination && null !== e.pagination && (t.pagination = n.PageResponse.fromPartial(e.pagination)), t
                }
            };
            class T {
                constructor(e) {
                    this.rpc = e, this.Balance = this.Balance.bind(this), this.AllBalances = this.AllBalances.bind(this), this.SpendableBalances = this.SpendableBalances.bind(this), this.SpendableBalanceByDenom = this.SpendableBalanceByDenom.bind(this), this.TotalSupply = this.TotalSupply.bind(this), this.SupplyOf = this.SupplyOf.bind(this), this.Params = this.Params.bind(this), this.DenomMetadata = this.DenomMetadata.bind(this), this.DenomsMetadata = this.DenomsMetadata.bind(this), this.DenomOwners = this.DenomOwners.bind(this), this.SendEnabled = this.SendEnabled.bind(this)
                }
                Balance(e) {
                    let r = t.QueryBalanceRequest.encode(e).finish();
                    return this.rpc.request("cosmos.bank.v1beta1.Query", "Balance", r).then(e => t.QueryBalanceResponse.decode(new a.BinaryReader(e)))
                }
                AllBalances(e) {
                    let r = t.QueryAllBalancesRequest.encode(e).finish();
                    return this.rpc.request("cosmos.bank.v1beta1.Query", "AllBalances", r).then(e => t.QueryAllBalancesResponse.decode(new a.BinaryReader(e)))
                }
                SpendableBalances(e) {
                    let r = t.QuerySpendableBalancesRequest.encode(e).finish();
                    return this.rpc.request("cosmos.bank.v1beta1.Query", "SpendableBalances", r).then(e => t.QuerySpendableBalancesResponse.decode(new a.BinaryReader(e)))
                }
                SpendableBalanceByDenom(e) {
                    let r = t.QuerySpendableBalanceByDenomRequest.encode(e).finish();
                    return this.rpc.request("cosmos.bank.v1beta1.Query", "SpendableBalanceByDenom", r).then(e => t.QuerySpendableBalanceByDenomResponse.decode(new a.BinaryReader(e)))
                }
                TotalSupply(e = {
                    pagination: n.PageRequest.fromPartial({})
                }) {
                    let r = t.QueryTotalSupplyRequest.encode(e).finish();
                    return this.rpc.request("cosmos.bank.v1beta1.Query", "TotalSupply", r).then(e => t.QueryTotalSupplyResponse.decode(new a.BinaryReader(e)))
                }
                SupplyOf(e) {
                    let r = t.QuerySupplyOfRequest.encode(e).finish();
                    return this.rpc.request("cosmos.bank.v1beta1.Query", "SupplyOf", r).then(e => t.QuerySupplyOfResponse.decode(new a.BinaryReader(e)))
                }
                Params(e = {}) {
                    let r = t.QueryParamsRequest.encode(e).finish();
                    return this.rpc.request("cosmos.bank.v1beta1.Query", "Params", r).then(e => t.QueryParamsResponse.decode(new a.BinaryReader(e)))
                }
                DenomMetadata(e) {
                    let r = t.QueryDenomMetadataRequest.encode(e).finish();
                    return this.rpc.request("cosmos.bank.v1beta1.Query", "DenomMetadata", r).then(e => t.QueryDenomMetadataResponse.decode(new a.BinaryReader(e)))
                }
                DenomsMetadata(e = {
                    pagination: n.PageRequest.fromPartial({})
                }) {
                    let r = t.QueryDenomsMetadataRequest.encode(e).finish();
                    return this.rpc.request("cosmos.bank.v1beta1.Query", "DenomsMetadata", r).then(e => t.QueryDenomsMetadataResponse.decode(new a.BinaryReader(e)))
                }
                DenomOwners(e) {
                    let r = t.QueryDenomOwnersRequest.encode(e).finish();
                    return this.rpc.request("cosmos.bank.v1beta1.Query", "DenomOwners", r).then(e => t.QueryDenomOwnersResponse.decode(new a.BinaryReader(e)))
                }
                SendEnabled(e) {
                    let r = t.QuerySendEnabledRequest.encode(e).finish();
                    return this.rpc.request("cosmos.bank.v1beta1.Query", "SendEnabled", r).then(e => t.QuerySendEnabledResponse.decode(new a.BinaryReader(e)))
                }
            }
            t.QueryClientImpl = T
        },
        64395: function(e, t, r) {
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: !0
            }), t.MsgClientImpl = t.MsgSetSendEnabledResponse = t.MsgSetSendEnabled = t.MsgUpdateParamsResponse = t.MsgUpdateParams = t.MsgMultiSendResponse = t.MsgMultiSend = t.MsgSendResponse = t.MsgSend = t.protobufPackage = void 0;
            let n = r(62809),
                o = r(7401),
                i = r(28486),
                a = r(6476);

            function s() {
                return {
                    fromAddress: "",
                    toAddress: "",
                    amount: []
                }
            }

            function d() {
                return {
                    inputs: [],
                    outputs: []
                }
            }

            function c() {
                return {
                    authority: "",
                    params: o.Params.fromPartial({})
                }
            }

            function l() {
                return {
                    authority: "",
                    sendEnabled: [],
                    useDefaultFor: []
                }
            }
            t.protobufPackage = "cosmos.bank.v1beta1", t.MsgSend = {
                typeUrl: "/cosmos.bank.v1beta1.MsgSend",
                encode(e, t = i.BinaryWriter.create()) {
                    for (let r of ("" !== e.fromAddress && t.uint32(10).string(e.fromAddress), "" !== e.toAddress && t.uint32(18).string(e.toAddress), e.amount)) n.Coin.encode(r, t.uint32(26).fork()).ldelim();
                    return t
                },
                decode(e, t) {
                    let r = e instanceof i.BinaryReader ? e : new i.BinaryReader(e),
                        o = void 0 === t ? r.len : r.pos + t,
                        a = s();
                    for (; r.pos < o;) {
                        let e = r.uint32();
                        switch (e >>> 3) {
                            case 1:
                                a.fromAddress = r.string();
                                break;
                            case 2:
                                a.toAddress = r.string();
                                break;
                            case 3:
                                a.amount.push(n.Coin.decode(r, r.uint32()));
                                break;
                            default:
                                r.skipType(7 & e)
                        }
                    }
                    return a
                },
                fromJSON(e) {
                    let t = s();
                    return (0, a.isSet)(e.fromAddress) && (t.fromAddress = String(e.fromAddress)), (0, a.isSet)(e.toAddress) && (t.toAddress = String(e.toAddress)), Array.isArray(e ? .amount) && (t.amount = e.amount.map(e => n.Coin.fromJSON(e))), t
                },
                toJSON(e) {
                    let t = {};
                    return void 0 !== e.fromAddress && (t.fromAddress = e.fromAddress), void 0 !== e.toAddress && (t.toAddress = e.toAddress), e.amount ? t.amount = e.amount.map(e => e ? n.Coin.toJSON(e) : void 0) : t.amount = [], t
                },
                fromPartial(e) {
                    let t = s();
                    return t.fromAddress = e.fromAddress ? ? "", t.toAddress = e.toAddress ? ? "", t.amount = e.amount ? .map(e => n.Coin.fromPartial(e)) || [], t
                }
            }, t.MsgSendResponse = {
                typeUrl: "/cosmos.bank.v1beta1.MsgSendResponse",
                encode: (e, t = i.BinaryWriter.create()) => t,
                decode(e, t) {
                    let r = e instanceof i.BinaryReader ? e : new i.BinaryReader(e),
                        n = void 0 === t ? r.len : r.pos + t;
                    for (; r.pos < n;) {
                        let e = r.uint32();
                        r.skipType(7 & e)
                    }
                    return {}
                },
                fromJSON: e => ({}),
                toJSON: e => ({}),
                fromPartial: e => ({})
            }, t.MsgMultiSend = {
                typeUrl: "/cosmos.bank.v1beta1.MsgMultiSend",
                encode(e, t = i.BinaryWriter.create()) {
                    for (let r of e.inputs) o.Input.encode(r, t.uint32(10).fork()).ldelim();
                    for (let r of e.outputs) o.Output.encode(r, t.uint32(18).fork()).ldelim();
                    return t
                },
                decode(e, t) {
                    let r = e instanceof i.BinaryReader ? e : new i.BinaryReader(e),
                        n = void 0 === t ? r.len : r.pos + t,
                        a = d();
                    for (; r.pos < n;) {
                        let e = r.uint32();
                        switch (e >>> 3) {
                            case 1:
                                a.inputs.push(o.Input.decode(r, r.uint32()));
                                break;
                            case 2:
                                a.outputs.push(o.Output.decode(r, r.uint32()));
                                break;
                            default:
                                r.skipType(7 & e)
                        }
                    }
                    return a
                },
                fromJSON(e) {
                    let t = d();
                    return Array.isArray(e ? .inputs) && (t.inputs = e.inputs.map(e => o.Input.fromJSON(e))), Array.isArray(e ? .outputs) && (t.outputs = e.outputs.map(e => o.Output.fromJSON(e))), t
                },
                toJSON(e) {
                    let t = {};
                    return e.inputs ? t.inputs = e.inputs.map(e => e ? o.Input.toJSON(e) : void 0) : t.inputs = [], e.outputs ? t.outputs = e.outputs.map(e => e ? o.Output.toJSON(e) : void 0) : t.outputs = [], t
                },
                fromPartial(e) {
                    let t = d();
                    return t.inputs = e.inputs ? .map(e => o.Input.fromPartial(e)) || [], t.outputs = e.outputs ? .map(e => o.Output.fromPartial(e)) || [], t
                }
            }, t.MsgMultiSendResponse = {
                typeUrl: "/cosmos.bank.v1beta1.MsgMultiSendResponse",
                encode: (e, t = i.BinaryWriter.create()) => t,
                decode(e, t) {
                    let r = e instanceof i.BinaryReader ? e : new i.BinaryReader(e),
                        n = void 0 === t ? r.len : r.pos + t;
                    for (; r.pos < n;) {
                        let e = r.uint32();
                        r.skipType(7 & e)
                    }
                    return {}
                },
                fromJSON: e => ({}),
                toJSON: e => ({}),
                fromPartial: e => ({})
            }, t.MsgUpdateParams = {
                typeUrl: "/cosmos.bank.v1beta1.MsgUpdateParams",
                encode: (e, t = i.BinaryWriter.create()) => ("" !== e.authority && t.uint32(10).string(e.authority), void 0 !== e.params && o.Params.encode(e.params, t.uint32(18).fork()).ldelim(), t),
                decode(e, t) {
                    let r = e instanceof i.BinaryReader ? e : new i.BinaryReader(e),
                        n = void 0 === t ? r.len : r.pos + t,
                        a = c();
                    for (; r.pos < n;) {
                        let e = r.uint32();
                        switch (e >>> 3) {
                            case 1:
                                a.authority = r.string();
                                break;
                            case 2:
                                a.params = o.Params.decode(r, r.uint32());
                                break;
                            default:
                                r.skipType(7 & e)
                        }
                    }
                    return a
                },
                fromJSON(e) {
                    let t = c();
                    return (0, a.isSet)(e.authority) && (t.authority = String(e.authority)), (0, a.isSet)(e.params) && (t.params = o.Params.fromJSON(e.params)), t
                },
                toJSON(e) {
                    let t = {};
                    return void 0 !== e.authority && (t.authority = e.authority), void 0 !== e.params && (t.params = e.params ? o.Params.toJSON(e.params) : void 0), t
                },
                fromPartial(e) {
                    let t = c();
                    return t.authority = e.authority ? ? "", void 0 !== e.params && null !== e.params && (t.params = o.Params.fromPartial(e.params)), t
                }
            }, t.MsgUpdateParamsResponse = {
                typeUrl: "/cosmos.bank.v1beta1.MsgUpdateParamsResponse",
                encode: (e, t = i.BinaryWriter.create()) => t,
                decode(e, t) {
                    let r = e instanceof i.BinaryReader ? e : new i.BinaryReader(e),
                        n = void 0 === t ? r.len : r.pos + t;
                    for (; r.pos < n;) {
                        let e = r.uint32();
                        r.skipType(7 & e)
                    }
                    return {}
                },
                fromJSON: e => ({}),
                toJSON: e => ({}),
                fromPartial: e => ({})
            }, t.MsgSetSendEnabled = {
                typeUrl: "/cosmos.bank.v1beta1.MsgSetSendEnabled",
                encode(e, t = i.BinaryWriter.create()) {
                    for (let r of ("" !== e.authority && t.uint32(10).string(e.authority), e.sendEnabled)) o.SendEnabled.encode(r, t.uint32(18).fork()).ldelim();
                    for (let r of e.useDefaultFor) t.uint32(26).string(r);
                    return t
                },
                decode(e, t) {
                    let r = e instanceof i.BinaryReader ? e : new i.BinaryReader(e),
                        n = void 0 === t ? r.len : r.pos + t,
                        a = l();
                    for (; r.pos < n;) {
                        let e = r.uint32();
                        switch (e >>> 3) {
                            case 1:
                                a.authority = r.string();
                                break;
                            case 2:
                                a.sendEnabled.push(o.SendEnabled.decode(r, r.uint32()));
                                break;
                            case 3:
                                a.useDefaultFor.push(r.string());
                                break;
                            default:
                                r.skipType(7 & e)
                        }
                    }
                    return a
                },
                fromJSON(e) {
                    let t = l();
                    return (0, a.isSet)(e.authority) && (t.authority = String(e.authority)), Array.isArray(e ? .sendEnabled) && (t.sendEnabled = e.sendEnabled.map(e => o.SendEnabled.fromJSON(e))), Array.isArray(e ? .useDefaultFor) && (t.useDefaultFor = e.useDefaultFor.map(e => String(e))), t
                },
                toJSON(e) {
                    let t = {};
                    return void 0 !== e.authority && (t.authority = e.authority), e.sendEnabled ? t.sendEnabled = e.sendEnabled.map(e => e ? o.SendEnabled.toJSON(e) : void 0) : t.sendEnabled = [], e.useDefaultFor ? t.useDefaultFor = e.useDefaultFor.map(e => e) : t.useDefaultFor = [], t
                },
                fromPartial(e) {
                    let t = l();
                    return t.authority = e.authority ? ? "", t.sendEnabled = e.sendEnabled ? .map(e => o.SendEnabled.fromPartial(e)) || [], t.useDefaultFor = e.useDefaultFor ? .map(e => e) || [], t
                }
            }, t.MsgSetSendEnabledResponse = {
                typeUrl: "/cosmos.bank.v1beta1.MsgSetSendEnabledResponse",
                encode: (e, t = i.BinaryWriter.create()) => t,
                decode(e, t) {
                    let r = e instanceof i.BinaryReader ? e : new i.BinaryReader(e),
                        n = void 0 === t ? r.len : r.pos + t;
                    for (; r.pos < n;) {
                        let e = r.uint32();
                        r.skipType(7 & e)
                    }
                    return {}
                },
                fromJSON: e => ({}),
                toJSON: e => ({}),
                fromPartial: e => ({})
            };
            class u {
                constructor(e) {
                    this.rpc = e, this.Send = this.Send.bind(this), this.MultiSend = this.MultiSend.bind(this), this.UpdateParams = this.UpdateParams.bind(this), this.SetSendEnabled = this.SetSendEnabled.bind(this)
                }
                Send(e) {
                    let r = t.MsgSend.encode(e).finish();
                    return this.rpc.request("cosmos.bank.v1beta1.Msg", "Send", r).then(e => t.MsgSendResponse.decode(new i.BinaryReader(e)))
                }
                MultiSend(e) {
                    let r = t.MsgMultiSend.encode(e).finish();
                    return this.rpc.request("cosmos.bank.v1beta1.Msg", "MultiSend", r).then(e => t.MsgMultiSendResponse.decode(new i.BinaryReader(e)))
                }
                UpdateParams(e) {
                    let r = t.MsgUpdateParams.encode(e).finish();
                    return this.rpc.request("cosmos.bank.v1beta1.Msg", "UpdateParams", r).then(e => t.MsgUpdateParamsResponse.decode(new i.BinaryReader(e)))
                }
                SetSendEnabled(e) {
                    let r = t.MsgSetSendEnabled.encode(e).finish();
                    return this.rpc.request("cosmos.bank.v1beta1.Msg", "SetSendEnabled", r).then(e => t.MsgSetSendEnabledResponse.decode(new i.BinaryReader(e)))
                }
            }
            t.MsgClientImpl = u
        },
        6916: function(e, t, r) {
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: !0
            }), t.SearchTxsResult = t.TxMsgData = t.MsgData = t.SimulationResponse = t.Result = t.GasInfo = t.Attribute = t.StringEvent = t.ABCIMessageLog = t.TxResponse = t.protobufPackage = void 0;
            let n = r(65676),
                o = r(50783),
                i = r(28486),
                a = r(6476);

            function s() {
                return {
                    height: BigInt(0),
                    txhash: "",
                    codespace: "",
                    code: 0,
                    data: "",
                    rawLog: "",
                    logs: [],
                    info: "",
                    gasWanted: BigInt(0),
                    gasUsed: BigInt(0),
                    tx: void 0,
                    timestamp: "",
                    events: []
                }
            }

            function d() {
                return {
                    msgIndex: 0,
                    log: "",
                    events: []
                }
            }

            function c() {
                return {
                    type: "",
                    attributes: []
                }
            }

            function l() {
                return {
                    key: "",
                    value: ""
                }
            }

            function u() {
                return {
                    gasWanted: BigInt(0),
                    gasUsed: BigInt(0)
                }
            }

            function p() {
                return {
                    data: new Uint8Array,
                    log: "",
                    events: [],
                    msgResponses: []
                }
            }

            function m() {
                return {
                    gasInfo: t.GasInfo.fromPartial({}),
                    result: void 0
                }
            }

            function g() {
                return {
                    msgType: "",
                    data: new Uint8Array
                }
            }

            function f() {
                return {
                    data: [],
                    msgResponses: []
                }
            }

            function y() {
                return {
                    totalCount: BigInt(0),
                    count: BigInt(0),
                    pageNumber: BigInt(0),
                    pageTotal: BigInt(0),
                    limit: BigInt(0),
                    txs: []
                }
            }
            t.protobufPackage = "cosmos.base.abci.v1beta1", t.TxResponse = {
                typeUrl: "/cosmos.base.abci.v1beta1.TxResponse",
                encode(e, r = i.BinaryWriter.create()) {
                    for (let n of (e.height !== BigInt(0) && r.uint32(8).int64(e.height), "" !== e.txhash && r.uint32(18).string(e.txhash), "" !== e.codespace && r.uint32(26).string(e.codespace), 0 !== e.code && r.uint32(32).uint32(e.code), "" !== e.data && r.uint32(42).string(e.data), "" !== e.rawLog && r.uint32(50).string(e.rawLog), e.logs)) t.ABCIMessageLog.encode(n, r.uint32(58).fork()).ldelim();
                    for (let t of ("" !== e.info && r.uint32(66).string(e.info), e.gasWanted !== BigInt(0) && r.uint32(72).int64(e.gasWanted), e.gasUsed !== BigInt(0) && r.uint32(80).int64(e.gasUsed), void 0 !== e.tx && n.Any.encode(e.tx, r.uint32(90).fork()).ldelim(), "" !== e.timestamp && r.uint32(98).string(e.timestamp), e.events)) o.Event.encode(t, r.uint32(106).fork()).ldelim();
                    return r
                },
                decode(e, r) {
                    let a = e instanceof i.BinaryReader ? e : new i.BinaryReader(e),
                        d = void 0 === r ? a.len : a.pos + r,
                        c = s();
                    for (; a.pos < d;) {
                        let e = a.uint32();
                        switch (e >>> 3) {
                            case 1:
                                c.height = a.int64();
                                break;
                            case 2:
                                c.txhash = a.string();
                                break;
                            case 3:
                                c.codespace = a.string();
                                break;
                            case 4:
                                c.code = a.uint32();
                                break;
                            case 5:
                                c.data = a.string();
                                break;
                            case 6:
                                c.rawLog = a.string();
                                break;
                            case 7:
                                c.logs.push(t.ABCIMessageLog.decode(a, a.uint32()));
                                break;
                            case 8:
                                c.info = a.string();
                                break;
                            case 9:
                                c.gasWanted = a.int64();
                                break;
                            case 10:
                                c.gasUsed = a.int64();
                                break;
                            case 11:
                                c.tx = n.Any.decode(a, a.uint32());
                                break;
                            case 12:
                                c.timestamp = a.string();
                                break;
                            case 13:
                                c.events.push(o.Event.decode(a, a.uint32()));
                                break;
                            default:
                                a.skipType(7 & e)
                        }
                    }
                    return c
                },
                fromJSON(e) {
                    let r = s();
                    return (0, a.isSet)(e.height) && (r.height = BigInt(e.height.toString())), (0, a.isSet)(e.txhash) && (r.txhash = String(e.txhash)), (0, a.isSet)(e.codespace) && (r.codespace = String(e.codespace)), (0, a.isSet)(e.code) && (r.code = Number(e.code)), (0, a.isSet)(e.data) && (r.data = String(e.data)), (0, a.isSet)(e.rawLog) && (r.rawLog = String(e.rawLog)), Array.isArray(e ? .logs) && (r.logs = e.logs.map(e => t.ABCIMessageLog.fromJSON(e))), (0, a.isSet)(e.info) && (r.info = String(e.info)), (0, a.isSet)(e.gasWanted) && (r.gasWanted = BigInt(e.gasWanted.toString())), (0, a.isSet)(e.gasUsed) && (r.gasUsed = BigInt(e.gasUsed.toString())), (0, a.isSet)(e.tx) && (r.tx = n.Any.fromJSON(e.tx)), (0, a.isSet)(e.timestamp) && (r.timestamp = String(e.timestamp)), Array.isArray(e ? .events) && (r.events = e.events.map(e => o.Event.fromJSON(e))), r
                },
                toJSON(e) {
                    let r = {};
                    return void 0 !== e.height && (r.height = (e.height || BigInt(0)).toString()), void 0 !== e.txhash && (r.txhash = e.txhash), void 0 !== e.codespace && (r.codespace = e.codespace), void 0 !== e.code && (r.code = Math.round(e.code)), void 0 !== e.data && (r.data = e.data), void 0 !== e.rawLog && (r.rawLog = e.rawLog), e.logs ? r.logs = e.logs.map(e => e ? t.ABCIMessageLog.toJSON(e) : void 0) : r.logs = [], void 0 !== e.info && (r.info = e.info), void 0 !== e.gasWanted && (r.gasWanted = (e.gasWanted || BigInt(0)).toString()), void 0 !== e.gasUsed && (r.gasUsed = (e.gasUsed || BigInt(0)).toString()), void 0 !== e.tx && (r.tx = e.tx ? n.Any.toJSON(e.tx) : void 0), void 0 !== e.timestamp && (r.timestamp = e.timestamp), e.events ? r.events = e.events.map(e => e ? o.Event.toJSON(e) : void 0) : r.events = [], r
                },
                fromPartial(e) {
                    let r = s();
                    return void 0 !== e.height && null !== e.height && (r.height = BigInt(e.height.toString())), r.txhash = e.txhash ? ? "", r.codespace = e.codespace ? ? "", r.code = e.code ? ? 0, r.data = e.data ? ? "", r.rawLog = e.rawLog ? ? "", r.logs = e.logs ? .map(e => t.ABCIMessageLog.fromPartial(e)) || [], r.info = e.info ? ? "", void 0 !== e.gasWanted && null !== e.gasWanted && (r.gasWanted = BigInt(e.gasWanted.toString())), void 0 !== e.gasUsed && null !== e.gasUsed && (r.gasUsed = BigInt(e.gasUsed.toString())), void 0 !== e.tx && null !== e.tx && (r.tx = n.Any.fromPartial(e.tx)), r.timestamp = e.timestamp ? ? "", r.events = e.events ? .map(e => o.Event.fromPartial(e)) || [], r
                }
            }, t.ABCIMessageLog = {
                typeUrl: "/cosmos.base.abci.v1beta1.ABCIMessageLog",
                encode(e, r = i.BinaryWriter.create()) {
                    for (let n of (0 !== e.msgIndex && r.uint32(8).uint32(e.msgIndex), "" !== e.log && r.uint32(18).string(e.log), e.events)) t.StringEvent.encode(n, r.uint32(26).fork()).ldelim();
                    return r
                },
                decode(e, r) {
                    let n = e instanceof i.BinaryReader ? e : new i.BinaryReader(e),
                        o = void 0 === r ? n.len : n.pos + r,
                        a = d();
                    for (; n.pos < o;) {
                        let e = n.uint32();
                        switch (e >>> 3) {
                            case 1:
                                a.msgIndex = n.uint32();
                                break;
                            case 2:
                                a.log = n.string();
                                break;
                            case 3:
                                a.events.push(t.StringEvent.decode(n, n.uint32()));
                                break;
                            default:
                                n.skipType(7 & e)
                        }
                    }
                    return a
                },
                fromJSON(e) {
                    let r = d();
                    return (0, a.isSet)(e.msgIndex) && (r.msgIndex = Number(e.msgIndex)), (0, a.isSet)(e.log) && (r.log = String(e.log)), Array.isArray(e ? .events) && (r.events = e.events.map(e => t.StringEvent.fromJSON(e))), r
                },
                toJSON(e) {
                    let r = {};
                    return void 0 !== e.msgIndex && (r.msgIndex = Math.round(e.msgIndex)), void 0 !== e.log && (r.log = e.log), e.events ? r.events = e.events.map(e => e ? t.StringEvent.toJSON(e) : void 0) : r.events = [], r
                },
                fromPartial(e) {
                    let r = d();
                    return r.msgIndex = e.msgIndex ? ? 0, r.log = e.log ? ? "", r.events = e.events ? .map(e => t.StringEvent.fromPartial(e)) || [], r
                }
            }, t.StringEvent = {
                typeUrl: "/cosmos.base.abci.v1beta1.StringEvent",
                encode(e, r = i.BinaryWriter.create()) {
                    for (let n of ("" !== e.type && r.uint32(10).string(e.type), e.attributes)) t.Attribute.encode(n, r.uint32(18).fork()).ldelim();
                    return r
                },
                decode(e, r) {
                    let n = e instanceof i.BinaryReader ? e : new i.BinaryReader(e),
                        o = void 0 === r ? n.len : n.pos + r,
                        a = c();
                    for (; n.pos < o;) {
                        let e = n.uint32();
                        switch (e >>> 3) {
                            case 1:
                                a.type = n.string();
                                break;
                            case 2:
                                a.attributes.push(t.Attribute.decode(n, n.uint32()));
                                break;
                            default:
                                n.skipType(7 & e)
                        }
                    }
                    return a
                },
                fromJSON(e) {
                    let r = c();
                    return (0, a.isSet)(e.type) && (r.type = String(e.type)), Array.isArray(e ? .attributes) && (r.attributes = e.attributes.map(e => t.Attribute.fromJSON(e))), r
                },
                toJSON(e) {
                    let r = {};
                    return void 0 !== e.type && (r.type = e.type), e.attributes ? r.attributes = e.attributes.map(e => e ? t.Attribute.toJSON(e) : void 0) : r.attributes = [], r
                },
                fromPartial(e) {
                    let r = c();
                    return r.type = e.type ? ? "", r.attributes = e.attributes ? .map(e => t.Attribute.fromPartial(e)) || [], r
                }
            }, t.Attribute = {
                typeUrl: "/cosmos.base.abci.v1beta1.Attribute",
                encode: (e, t = i.BinaryWriter.create()) => ("" !== e.key && t.uint32(10).string(e.key), "" !== e.value && t.uint32(18).string(e.value), t),
                decode(e, t) {
                    let r = e instanceof i.BinaryReader ? e : new i.BinaryReader(e),
                        n = void 0 === t ? r.len : r.pos + t,
                        o = l();
                    for (; r.pos < n;) {
                        let e = r.uint32();
                        switch (e >>> 3) {
                            case 1:
                                o.key = r.string();
                                break;
                            case 2:
                                o.value = r.string();
                                break;
                            default:
                                r.skipType(7 & e)
                        }
                    }
                    return o
                },
                fromJSON(e) {
                    let t = l();
                    return (0, a.isSet)(e.key) && (t.key = String(e.key)), (0, a.isSet)(e.value) && (t.value = String(e.value)), t
                },
                toJSON(e) {
                    let t = {};
                    return void 0 !== e.key && (t.key = e.key), void 0 !== e.value && (t.value = e.value), t
                },
                fromPartial(e) {
                    let t = l();
                    return t.key = e.key ? ? "", t.value = e.value ? ? "", t
                }
            }, t.GasInfo = {
                typeUrl: "/cosmos.base.abci.v1beta1.GasInfo",
                encode: (e, t = i.BinaryWriter.create()) => (e.gasWanted !== BigInt(0) && t.uint32(8).uint64(e.gasWanted), e.gasUsed !== BigInt(0) && t.uint32(16).uint64(e.gasUsed), t),
                decode(e, t) {
                    let r = e instanceof i.BinaryReader ? e : new i.BinaryReader(e),
                        n = void 0 === t ? r.len : r.pos + t,
                        o = u();
                    for (; r.pos < n;) {
                        let e = r.uint32();
                        switch (e >>> 3) {
                            case 1:
                                o.gasWanted = r.uint64();
                                break;
                            case 2:
                                o.gasUsed = r.uint64();
                                break;
                            default:
                                r.skipType(7 & e)
                        }
                    }
                    return o
                },
                fromJSON(e) {
                    let t = u();
                    return (0, a.isSet)(e.gasWanted) && (t.gasWanted = BigInt(e.gasWanted.toString())), (0, a.isSet)(e.gasUsed) && (t.gasUsed = BigInt(e.gasUsed.toString())), t
                },
                toJSON(e) {
                    let t = {};
                    return void 0 !== e.gasWanted && (t.gasWanted = (e.gasWanted || BigInt(0)).toString()), void 0 !== e.gasUsed && (t.gasUsed = (e.gasUsed || BigInt(0)).toString()), t
                },
                fromPartial(e) {
                    let t = u();
                    return void 0 !== e.gasWanted && null !== e.gasWanted && (t.gasWanted = BigInt(e.gasWanted.toString())), void 0 !== e.gasUsed && null !== e.gasUsed && (t.gasUsed = BigInt(e.gasUsed.toString())), t
                }
            }, t.Result = {
                typeUrl: "/cosmos.base.abci.v1beta1.Result",
                encode(e, t = i.BinaryWriter.create()) {
                    for (let r of (0 !== e.data.length && t.uint32(10).bytes(e.data), "" !== e.log && t.uint32(18).string(e.log), e.events)) o.Event.encode(r, t.uint32(26).fork()).ldelim();
                    for (let r of e.msgResponses) n.Any.encode(r, t.uint32(34).fork()).ldelim();
                    return t
                },
                decode(e, t) {
                    let r = e instanceof i.BinaryReader ? e : new i.BinaryReader(e),
                        a = void 0 === t ? r.len : r.pos + t,
                        s = p();
                    for (; r.pos < a;) {
                        let e = r.uint32();
                        switch (e >>> 3) {
                            case 1:
                                s.data = r.bytes();
                                break;
                            case 2:
                                s.log = r.string();
                                break;
                            case 3:
                                s.events.push(o.Event.decode(r, r.uint32()));
                                break;
                            case 4:
                                s.msgResponses.push(n.Any.decode(r, r.uint32()));
                                break;
                            default:
                                r.skipType(7 & e)
                        }
                    }
                    return s
                },
                fromJSON(e) {
                    let t = p();
                    return (0, a.isSet)(e.data) && (t.data = (0, a.bytesFromBase64)(e.data)), (0, a.isSet)(e.log) && (t.log = String(e.log)), Array.isArray(e ? .events) && (t.events = e.events.map(e => o.Event.fromJSON(e))), Array.isArray(e ? .msgResponses) && (t.msgResponses = e.msgResponses.map(e => n.Any.fromJSON(e))), t
                },
                toJSON(e) {
                    let t = {};
                    return void 0 !== e.data && (t.data = (0, a.base64FromBytes)(void 0 !== e.data ? e.data : new Uint8Array)), void 0 !== e.log && (t.log = e.log), e.events ? t.events = e.events.map(e => e ? o.Event.toJSON(e) : void 0) : t.events = [], e.msgResponses ? t.msgResponses = e.msgResponses.map(e => e ? n.Any.toJSON(e) : void 0) : t.msgResponses = [], t
                },
                fromPartial(e) {
                    let t = p();
                    return t.data = e.data ? ? new Uint8Array, t.log = e.log ? ? "", t.events = e.events ? .map(e => o.Event.fromPartial(e)) || [], t.msgResponses = e.msgResponses ? .map(e => n.Any.fromPartial(e)) || [], t
                }
            }, t.SimulationResponse = {
                typeUrl: "/cosmos.base.abci.v1beta1.SimulationResponse",
                encode: (e, r = i.BinaryWriter.create()) => (void 0 !== e.gasInfo && t.GasInfo.encode(e.gasInfo, r.uint32(10).fork()).ldelim(), void 0 !== e.result && t.Result.encode(e.result, r.uint32(18).fork()).ldelim(), r),
                decode(e, r) {
                    let n = e instanceof i.BinaryReader ? e : new i.BinaryReader(e),
                        o = void 0 === r ? n.len : n.pos + r,
                        a = m();
                    for (; n.pos < o;) {
                        let e = n.uint32();
                        switch (e >>> 3) {
                            case 1:
                                a.gasInfo = t.GasInfo.decode(n, n.uint32());
                                break;
                            case 2:
                                a.result = t.Result.decode(n, n.uint32());
                                break;
                            default:
                                n.skipType(7 & e)
                        }
                    }
                    return a
                },
                fromJSON(e) {
                    let r = m();
                    return (0, a.isSet)(e.gasInfo) && (r.gasInfo = t.GasInfo.fromJSON(e.gasInfo)), (0, a.isSet)(e.result) && (r.result = t.Result.fromJSON(e.result)), r
                },
                toJSON(e) {
                    let r = {};
                    return void 0 !== e.gasInfo && (r.gasInfo = e.gasInfo ? t.GasInfo.toJSON(e.gasInfo) : void 0), void 0 !== e.result && (r.result = e.result ? t.Result.toJSON(e.result) : void 0), r
                },
                fromPartial(e) {
                    let r = m();
                    return void 0 !== e.gasInfo && null !== e.gasInfo && (r.gasInfo = t.GasInfo.fromPartial(e.gasInfo)), void 0 !== e.result && null !== e.result && (r.result = t.Result.fromPartial(e.result)), r
                }
            }, t.MsgData = {
                typeUrl: "/cosmos.base.abci.v1beta1.MsgData",
                encode: (e, t = i.BinaryWriter.create()) => ("" !== e.msgType && t.uint32(10).string(e.msgType), 0 !== e.data.length && t.uint32(18).bytes(e.data), t),
                decode(e, t) {
                    let r = e instanceof i.BinaryReader ? e : new i.BinaryReader(e),
                        n = void 0 === t ? r.len : r.pos + t,
                        o = g();
                    for (; r.pos < n;) {
                        let e = r.uint32();
                        switch (e >>> 3) {
                            case 1:
                                o.msgType = r.string();
                                break;
                            case 2:
                                o.data = r.bytes();
                                break;
                            default:
                                r.skipType(7 & e)
                        }
                    }
                    return o
                },
                fromJSON(e) {
                    let t = g();
                    return (0, a.isSet)(e.msgType) && (t.msgType = String(e.msgType)), (0, a.isSet)(e.data) && (t.data = (0, a.bytesFromBase64)(e.data)), t
                },
                toJSON(e) {
                    let t = {};
                    return void 0 !== e.msgType && (t.msgType = e.msgType), void 0 !== e.data && (t.data = (0, a.base64FromBytes)(void 0 !== e.data ? e.data : new Uint8Array)), t
                },
                fromPartial(e) {
                    let t = g();
                    return t.msgType = e.msgType ? ? "", t.data = e.data ? ? new Uint8Array, t
                }
            }, t.TxMsgData = {
                typeUrl: "/cosmos.base.abci.v1beta1.TxMsgData",
                encode(e, r = i.BinaryWriter.create()) {
                    for (let n of e.data) t.MsgData.encode(n, r.uint32(10).fork()).ldelim();
                    for (let t of e.msgResponses) n.Any.encode(t, r.uint32(18).fork()).ldelim();
                    return r
                },
                decode(e, r) {
                    let o = e instanceof i.BinaryReader ? e : new i.BinaryReader(e),
                        a = void 0 === r ? o.len : o.pos + r,
                        s = f();
                    for (; o.pos < a;) {
                        let e = o.uint32();
                        switch (e >>> 3) {
                            case 1:
                                s.data.push(t.MsgData.decode(o, o.uint32()));
                                break;
                            case 2:
                                s.msgResponses.push(n.Any.decode(o, o.uint32()));
                                break;
                            default:
                                o.skipType(7 & e)
                        }
                    }
                    return s
                },
                fromJSON(e) {
                    let r = f();
                    return Array.isArray(e ? .data) && (r.data = e.data.map(e => t.MsgData.fromJSON(e))), Array.isArray(e ? .msgResponses) && (r.msgResponses = e.msgResponses.map(e => n.Any.fromJSON(e))), r
                },
                toJSON(e) {
                    let r = {};
                    return e.data ? r.data = e.data.map(e => e ? t.MsgData.toJSON(e) : void 0) : r.data = [], e.msgResponses ? r.msgResponses = e.msgResponses.map(e => e ? n.Any.toJSON(e) : void 0) : r.msgResponses = [], r
                },
                fromPartial(e) {
                    let r = f();
                    return r.data = e.data ? .map(e => t.MsgData.fromPartial(e)) || [], r.msgResponses = e.msgResponses ? .map(e => n.Any.fromPartial(e)) || [], r
                }
            }, t.SearchTxsResult = {
                typeUrl: "/cosmos.base.abci.v1beta1.SearchTxsResult",
                encode(e, r = i.BinaryWriter.create()) {
                    for (let n of (e.totalCount !== BigInt(0) && r.uint32(8).uint64(e.totalCount), e.count !== BigInt(0) && r.uint32(16).uint64(e.count), e.pageNumber !== BigInt(0) && r.uint32(24).uint64(e.pageNumber), e.pageTotal !== BigInt(0) && r.uint32(32).uint64(e.pageTotal), e.limit !== BigInt(0) && r.uint32(40).uint64(e.limit), e.txs)) t.TxResponse.encode(n, r.uint32(50).fork()).ldelim();
                    return r
                },
                decode(e, r) {
                    let n = e instanceof i.BinaryReader ? e : new i.BinaryReader(e),
                        o = void 0 === r ? n.len : n.pos + r,
                        a = y();
                    for (; n.pos < o;) {
                        let e = n.uint32();
                        switch (e >>> 3) {
                            case 1:
                                a.totalCount = n.uint64();
                                break;
                            case 2:
                                a.count = n.uint64();
                                break;
                            case 3:
                                a.pageNumber = n.uint64();
                                break;
                            case 4:
                                a.pageTotal = n.uint64();
                                break;
                            case 5:
                                a.limit = n.uint64();
                                break;
                            case 6:
                                a.txs.push(t.TxResponse.decode(n, n.uint32()));
                                break;
                            default:
                                n.skipType(7 & e)
                        }
                    }
                    return a
                },
                fromJSON(e) {
                    let r = y();
                    return (0, a.isSet)(e.totalCount) && (r.totalCount = BigInt(e.totalCount.toString())), (0, a.isSet)(e.count) && (r.count = BigInt(e.count.toString())), (0, a.isSet)(e.pageNumber) && (r.pageNumber = BigInt(e.pageNumber.toString())), (0, a.isSet)(e.pageTotal) && (r.pageTotal = BigInt(e.pageTotal.toString())), (0, a.isSet)(e.limit) && (r.limit = BigInt(e.limit.toString())), Array.isArray(e ? .txs) && (r.txs = e.txs.map(e => t.TxResponse.fromJSON(e))), r
                },
                toJSON(e) {
                    let r = {};
                    return void 0 !== e.totalCount && (r.totalCount = (e.totalCount || BigInt(0)).toString()), void 0 !== e.count && (r.count = (e.count || BigInt(0)).toString()), void 0 !== e.pageNumber && (r.pageNumber = (e.pageNumber || BigInt(0)).toString()), void 0 !== e.pageTotal && (r.pageTotal = (e.pageTotal || BigInt(0)).toString()), void 0 !== e.limit && (r.limit = (e.limit || BigInt(0)).toString()), e.txs ? r.txs = e.txs.map(e => e ? t.TxResponse.toJSON(e) : void 0) : r.txs = [], r
                },
                fromPartial(e) {
                    let r = y();
                    return void 0 !== e.totalCount && null !== e.totalCount && (r.totalCount = BigInt(e.totalCount.toString())), void 0 !== e.count && null !== e.count && (r.count = BigInt(e.count.toString())), void 0 !== e.pageNumber && null !== e.pageNumber && (r.pageNumber = BigInt(e.pageNumber.toString())), void 0 !== e.pageTotal && null !== e.pageTotal && (r.pageTotal = BigInt(e.pageTotal.toString())), void 0 !== e.limit && null !== e.limit && (r.limit = BigInt(e.limit.toString())), r.txs = e.txs ? .map(e => t.TxResponse.fromPartial(e)) || [], r
                }
            }
        },
        38792: function(e, t, r) {
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: !0
            }), t.PageResponse = t.PageRequest = t.protobufPackage = void 0;
            let n = r(28486),
                o = r(6476);

            function i() {
                return {
                    key: new Uint8Array,
                    offset: BigInt(0),
                    limit: BigInt(0),
                    countTotal: !1,
                    reverse: !1
                }
            }

            function a() {
                return {
                    nextKey: new Uint8Array,
                    total: BigInt(0)
                }
            }
            t.protobufPackage = "cosmos.base.query.v1beta1", t.PageRequest = {
                typeUrl: "/cosmos.base.query.v1beta1.PageRequest",
                encode: (e, t = n.BinaryWriter.create()) => (0 !== e.key.length && t.uint32(10).bytes(e.key), e.offset !== BigInt(0) && t.uint32(16).uint64(e.offset), e.limit !== BigInt(0) && t.uint32(24).uint64(e.limit), !0 === e.countTotal && t.uint32(32).bool(e.countTotal), !0 === e.reverse && t.uint32(40).bool(e.reverse), t),
                decode(e, t) {
                    let r = e instanceof n.BinaryReader ? e : new n.BinaryReader(e),
                        o = void 0 === t ? r.len : r.pos + t,
                        a = i();
                    for (; r.pos < o;) {
                        let e = r.uint32();
                        switch (e >>> 3) {
                            case 1:
                                a.key = r.bytes();
                                break;
                            case 2:
                                a.offset = r.uint64();
                                break;
                            case 3:
                                a.limit = r.uint64();
                                break;
                            case 4:
                                a.countTotal = r.bool();
                                break;
                            case 5:
                                a.reverse = r.bool();
                                break;
                            default:
                                r.skipType(7 & e)
                        }
                    }
                    return a
                },
                fromJSON(e) {
                    let t = i();
                    return (0, o.isSet)(e.key) && (t.key = (0, o.bytesFromBase64)(e.key)), (0, o.isSet)(e.offset) && (t.offset = BigInt(e.offset.toString())), (0, o.isSet)(e.limit) && (t.limit = BigInt(e.limit.toString())), (0, o.isSet)(e.countTotal) && (t.countTotal = !!e.countTotal), (0, o.isSet)(e.reverse) && (t.reverse = !!e.reverse), t
                },
                toJSON(e) {
                    let t = {};
                    return void 0 !== e.key && (t.key = (0, o.base64FromBytes)(void 0 !== e.key ? e.key : new Uint8Array)), void 0 !== e.offset && (t.offset = (e.offset || BigInt(0)).toString()), void 0 !== e.limit && (t.limit = (e.limit || BigInt(0)).toString()), void 0 !== e.countTotal && (t.countTotal = e.countTotal), void 0 !== e.reverse && (t.reverse = e.reverse), t
                },
                fromPartial(e) {
                    let t = i();
                    return t.key = e.key ? ? new Uint8Array, void 0 !== e.offset && null !== e.offset && (t.offset = BigInt(e.offset.toString())), void 0 !== e.limit && null !== e.limit && (t.limit = BigInt(e.limit.toString())), t.countTotal = e.countTotal ? ? !1, t.reverse = e.reverse ? ? !1, t
                }
            }, t.PageResponse = {
                typeUrl: "/cosmos.base.query.v1beta1.PageResponse",
                encode: (e, t = n.BinaryWriter.create()) => (0 !== e.nextKey.length && t.uint32(10).bytes(e.nextKey), e.total !== BigInt(0) && t.uint32(16).uint64(e.total), t),
                decode(e, t) {
                    let r = e instanceof n.BinaryReader ? e : new n.BinaryReader(e),
                        o = void 0 === t ? r.len : r.pos + t,
                        i = a();
                    for (; r.pos < o;) {
                        let e = r.uint32();
                        switch (e >>> 3) {
                            case 1:
                                i.nextKey = r.bytes();
                                break;
                            case 2:
                                i.total = r.uint64();
                                break;
                            default:
                                r.skipType(7 & e)
                        }
                    }
                    return i
                },
                fromJSON(e) {
                    let t = a();
                    return (0, o.isSet)(e.nextKey) && (t.nextKey = (0, o.bytesFromBase64)(e.nextKey)), (0, o.isSet)(e.total) && (t.total = BigInt(e.total.toString())), t
                },
                toJSON(e) {
                    let t = {};
                    return void 0 !== e.nextKey && (t.nextKey = (0, o.base64FromBytes)(void 0 !== e.nextKey ? e.nextKey : new Uint8Array)), void 0 !== e.total && (t.total = (e.total || BigInt(0)).toString()), t
                },
                fromPartial(e) {
                    let t = a();
                    return t.nextKey = e.nextKey ? ? new Uint8Array, void 0 !== e.total && null !== e.total && (t.total = BigInt(e.total.toString())), t
                }
            }
        },
        62809: function(e, t, r) {
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: !0
            }), t.DecProto = t.IntProto = t.DecCoin = t.Coin = t.protobufPackage = void 0;
            let n = r(28486),
                o = r(6476);

            function i() {
                return {
                    denom: "",
                    amount: ""
                }
            }

            function a() {
                return {
                    denom: "",
                    amount: ""
                }
            }

            function s() {
                return {
                    int: ""
                }
            }

            function d() {
                return {
                    dec: ""
                }
            }
            t.protobufPackage = "cosmos.base.v1beta1", t.Coin = {
                typeUrl: "/cosmos.base.v1beta1.Coin",
                encode: (e, t = n.BinaryWriter.create()) => ("" !== e.denom && t.uint32(10).string(e.denom), "" !== e.amount && t.uint32(18).string(e.amount), t),
                decode(e, t) {
                    let r = e instanceof n.BinaryReader ? e : new n.BinaryReader(e),
                        o = void 0 === t ? r.len : r.pos + t,
                        a = i();
                    for (; r.pos < o;) {
                        let e = r.uint32();
                        switch (e >>> 3) {
                            case 1:
                                a.denom = r.string();
                                break;
                            case 2:
                                a.amount = r.string();
                                break;
                            default:
                                r.skipType(7 & e)
                        }
                    }
                    return a
                },
                fromJSON(e) {
                    let t = i();
                    return (0, o.isSet)(e.denom) && (t.denom = String(e.denom)), (0, o.isSet)(e.amount) && (t.amount = String(e.amount)), t
                },
                toJSON(e) {
                    let t = {};
                    return void 0 !== e.denom && (t.denom = e.denom), void 0 !== e.amount && (t.amount = e.amount), t
                },
                fromPartial(e) {
                    let t = i();
                    return t.denom = e.denom ? ? "", t.amount = e.amount ? ? "", t
                }
            }, t.DecCoin = {
                typeUrl: "/cosmos.base.v1beta1.DecCoin",
                encode: (e, t = n.BinaryWriter.create()) => ("" !== e.denom && t.uint32(10).string(e.denom), "" !== e.amount && t.uint32(18).string(e.amount), t),
                decode(e, t) {
                    let r = e instanceof n.BinaryReader ? e : new n.BinaryReader(e),
                        o = void 0 === t ? r.len : r.pos + t,
                        i = a();
                    for (; r.pos < o;) {
                        let e = r.uint32();
                        switch (e >>> 3) {
                            case 1:
                                i.denom = r.string();
                                break;
                            case 2:
                                i.amount = r.string();
                                break;
                            default:
                                r.skipType(7 & e)
                        }
                    }
                    return i
                },
                fromJSON(e) {
                    let t = a();
                    return (0, o.isSet)(e.denom) && (t.denom = String(e.denom)), (0, o.isSet)(e.amount) && (t.amount = String(e.amount)), t
                },
                toJSON(e) {
                    let t = {};
                    return void 0 !== e.denom && (t.denom = e.denom), void 0 !== e.amount && (t.amount = e.amount), t
                },
                fromPartial(e) {
                    let t = a();
                    return t.denom = e.denom ? ? "", t.amount = e.amount ? ? "", t
                }
            }, t.IntProto = {
                typeUrl: "/cosmos.base.v1beta1.IntProto",
                encode: (e, t = n.BinaryWriter.create()) => ("" !== e.int && t.uint32(10).string(e.int), t),
                decode(e, t) {
                    let r = e instanceof n.BinaryReader ? e : new n.BinaryReader(e),
                        o = void 0 === t ? r.len : r.pos + t,
                        i = s();
                    for (; r.pos < o;) {
                        let e = r.uint32();
                        e >>> 3 == 1 ? i.int = r.string() : r.skipType(7 & e)
                    }
                    return i
                },
                fromJSON(e) {
                    let t = s();
                    return (0, o.isSet)(e.int) && (t.int = String(e.int)), t
                },
                toJSON(e) {
                    let t = {};
                    return void 0 !== e.int && (t.int = e.int), t
                },
                fromPartial(e) {
                    let t = s();
                    return t.int = e.int ? ? "", t
                }
            }, t.DecProto = {
                typeUrl: "/cosmos.base.v1beta1.DecProto",
                encode: (e, t = n.BinaryWriter.create()) => ("" !== e.dec && t.uint32(10).string(e.dec), t),
                decode(e, t) {
                    let r = e instanceof n.BinaryReader ? e : new n.BinaryReader(e),
                        o = void 0 === t ? r.len : r.pos + t,
                        i = d();
                    for (; r.pos < o;) {
                        let e = r.uint32();
                        e >>> 3 == 1 ? i.dec = r.string() : r.skipType(7 & e)
                    }
                    return i
                },
                fromJSON(e) {
                    let t = d();
                    return (0, o.isSet)(e.dec) && (t.dec = String(e.dec)), t
                },
                toJSON(e) {
                    let t = {};
                    return void 0 !== e.dec && (t.dec = e.dec), t
                },
                fromPartial(e) {
                    let t = d();
                    return t.dec = e.dec ? ? "", t
                }
            }
        },
        8196: function(e, t, r) {
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: !0
            }), t.PrivKey = t.PubKey = t.protobufPackage = void 0;
            let n = r(28486),
                o = r(6476);

            function i() {
                return {
                    key: new Uint8Array
                }
            }

            function a() {
                return {
                    key: new Uint8Array
                }
            }
            t.protobufPackage = "cosmos.crypto.ed25519", t.PubKey = {
                typeUrl: "/cosmos.crypto.ed25519.PubKey",
                encode: (e, t = n.BinaryWriter.create()) => (0 !== e.key.length && t.uint32(10).bytes(e.key), t),
                decode(e, t) {
                    let r = e instanceof n.BinaryReader ? e : new n.BinaryReader(e),
                        o = void 0 === t ? r.len : r.pos + t,
                        a = i();
                    for (; r.pos < o;) {
                        let e = r.uint32();
                        e >>> 3 == 1 ? a.key = r.bytes() : r.skipType(7 & e)
                    }
                    return a
                },
                fromJSON(e) {
                    let t = i();
                    return (0, o.isSet)(e.key) && (t.key = (0, o.bytesFromBase64)(e.key)), t
                },
                toJSON(e) {
                    let t = {};
                    return void 0 !== e.key && (t.key = (0, o.base64FromBytes)(void 0 !== e.key ? e.key : new Uint8Array)), t
                },
                fromPartial(e) {
                    let t = i();
                    return t.key = e.key ? ? new Uint8Array, t
                }
            }, t.PrivKey = {
                typeUrl: "/cosmos.crypto.ed25519.PrivKey",
                encode: (e, t = n.BinaryWriter.create()) => (0 !== e.key.length && t.uint32(10).bytes(e.key), t),
                decode(e, t) {
                    let r = e instanceof n.BinaryReader ? e : new n.BinaryReader(e),
                        o = void 0 === t ? r.len : r.pos + t,
                        i = a();
                    for (; r.pos < o;) {
                        let e = r.uint32();
                        e >>> 3 == 1 ? i.key = r.bytes() : r.skipType(7 & e)
                    }
                    return i
                },
                fromJSON(e) {
                    let t = a();
                    return (0, o.isSet)(e.key) && (t.key = (0, o.bytesFromBase64)(e.key)), t
                },
                toJSON(e) {
                    let t = {};
                    return void 0 !== e.key && (t.key = (0, o.base64FromBytes)(void 0 !== e.key ? e.key : new Uint8Array)), t
                },
                fromPartial(e) {
                    let t = a();
                    return t.key = e.key ? ? new Uint8Array, t
                }
            }
        },
        99679: function(e, t, r) {
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: !0
            }), t.LegacyAminoPubKey = t.protobufPackage = void 0;
            let n = r(65676),
                o = r(28486),
                i = r(6476);

            function a() {
                return {
                    threshold: 0,
                    publicKeys: []
                }
            }
            t.protobufPackage = "cosmos.crypto.multisig", t.LegacyAminoPubKey = {
                typeUrl: "/cosmos.crypto.multisig.LegacyAminoPubKey",
                encode(e, t = o.BinaryWriter.create()) {
                    for (let r of (0 !== e.threshold && t.uint32(8).uint32(e.threshold), e.publicKeys)) n.Any.encode(r, t.uint32(18).fork()).ldelim();
                    return t
                },
                decode(e, t) {
                    let r = e instanceof o.BinaryReader ? e : new o.BinaryReader(e),
                        i = void 0 === t ? r.len : r.pos + t,
                        s = a();
                    for (; r.pos < i;) {
                        let e = r.uint32();
                        switch (e >>> 3) {
                            case 1:
                                s.threshold = r.uint32();
                                break;
                            case 2:
                                s.publicKeys.push(n.Any.decode(r, r.uint32()));
                                break;
                            default:
                                r.skipType(7 & e)
                        }
                    }
                    return s
                },
                fromJSON(e) {
                    let t = a();
                    return (0, i.isSet)(e.threshold) && (t.threshold = Number(e.threshold)), Array.isArray(e ? .publicKeys) && (t.publicKeys = e.publicKeys.map(e => n.Any.fromJSON(e))), t
                },
                toJSON(e) {
                    let t = {};
                    return void 0 !== e.threshold && (t.threshold = Math.round(e.threshold)), e.publicKeys ? t.publicKeys = e.publicKeys.map(e => e ? n.Any.toJSON(e) : void 0) : t.publicKeys = [], t
                },
                fromPartial(e) {
                    let t = a();
                    return t.threshold = e.threshold ? ? 0, t.publicKeys = e.publicKeys ? .map(e => n.Any.fromPartial(e)) || [], t
                }
            }
        },
        96947: function(e, t, r) {
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: !0
            }), t.CompactBitArray = t.MultiSignature = t.protobufPackage = void 0;
            let n = r(28486),
                o = r(6476);

            function i() {
                return {
                    signatures: []
                }
            }

            function a() {
                return {
                    extraBitsStored: 0,
                    elems: new Uint8Array
                }
            }
            t.protobufPackage = "cosmos.crypto.multisig.v1beta1", t.MultiSignature = {
                typeUrl: "/cosmos.crypto.multisig.v1beta1.MultiSignature",
                encode(e, t = n.BinaryWriter.create()) {
                    for (let r of e.signatures) t.uint32(10).bytes(r);
                    return t
                },
                decode(e, t) {
                    let r = e instanceof n.BinaryReader ? e : new n.BinaryReader(e),
                        o = void 0 === t ? r.len : r.pos + t,
                        a = i();
                    for (; r.pos < o;) {
                        let e = r.uint32();
                        e >>> 3 == 1 ? a.signatures.push(r.bytes()) : r.skipType(7 & e)
                    }
                    return a
                },
                fromJSON(e) {
                    let t = i();
                    return Array.isArray(e ? .signatures) && (t.signatures = e.signatures.map(e => (0, o.bytesFromBase64)(e))), t
                },
                toJSON(e) {
                    let t = {};
                    return e.signatures ? t.signatures = e.signatures.map(e => (0, o.base64FromBytes)(void 0 !== e ? e : new Uint8Array)) : t.signatures = [], t
                },
                fromPartial(e) {
                    let t = i();
                    return t.signatures = e.signatures ? .map(e => e) || [], t
                }
            }, t.CompactBitArray = {
                typeUrl: "/cosmos.crypto.multisig.v1beta1.CompactBitArray",
                encode: (e, t = n.BinaryWriter.create()) => (0 !== e.extraBitsStored && t.uint32(8).uint32(e.extraBitsStored), 0 !== e.elems.length && t.uint32(18).bytes(e.elems), t),
                decode(e, t) {
                    let r = e instanceof n.BinaryReader ? e : new n.BinaryReader(e),
                        o = void 0 === t ? r.len : r.pos + t,
                        i = a();
                    for (; r.pos < o;) {
                        let e = r.uint32();
                        switch (e >>> 3) {
                            case 1:
                                i.extraBitsStored = r.uint32();
                                break;
                            case 2:
                                i.elems = r.bytes();
                                break;
                            default:
                                r.skipType(7 & e)
                        }
                    }
                    return i
                },
                fromJSON(e) {
                    let t = a();
                    return (0, o.isSet)(e.extraBitsStored) && (t.extraBitsStored = Number(e.extraBitsStored)), (0, o.isSet)(e.elems) && (t.elems = (0, o.bytesFromBase64)(e.elems)), t
                },
                toJSON(e) {
                    let t = {};
                    return void 0 !== e.extraBitsStored && (t.extraBitsStored = Math.round(e.extraBitsStored)), void 0 !== e.elems && (t.elems = (0, o.base64FromBytes)(void 0 !== e.elems ? e.elems : new Uint8Array)), t
                },
                fromPartial(e) {
                    let t = a();
                    return t.extraBitsStored = e.extraBitsStored ? ? 0, t.elems = e.elems ? ? new Uint8Array, t
                }
            }
        },
        27918: function(e, t, r) {
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: !0
            }), t.PrivKey = t.PubKey = t.protobufPackage = void 0;
            let n = r(28486),
                o = r(6476);

            function i() {
                return {
                    key: new Uint8Array
                }
            }

            function a() {
                return {
                    key: new Uint8Array
                }
            }
            t.protobufPackage = "cosmos.crypto.secp256k1", t.PubKey = {
                typeUrl: "/cosmos.crypto.secp256k1.PubKey",
                encode: (e, t = n.BinaryWriter.create()) => (0 !== e.key.length && t.uint32(10).bytes(e.key), t),
                decode(e, t) {
                    let r = e instanceof n.BinaryReader ? e : new n.BinaryReader(e),
                        o = void 0 === t ? r.len : r.pos + t,
                        a = i();
                    for (; r.pos < o;) {
                        let e = r.uint32();
                        e >>> 3 == 1 ? a.key = r.bytes() : r.skipType(7 & e)
                    }
                    return a
                },
                fromJSON(e) {
                    let t = i();
                    return (0, o.isSet)(e.key) && (t.key = (0, o.bytesFromBase64)(e.key)), t
                },
                toJSON(e) {
                    let t = {};
                    return void 0 !== e.key && (t.key = (0, o.base64FromBytes)(void 0 !== e.key ? e.key : new Uint8Array)), t
                },
                fromPartial(e) {
                    let t = i();
                    return t.key = e.key ? ? new Uint8Array, t
                }
            }, t.PrivKey = {
                typeUrl: "/cosmos.crypto.secp256k1.PrivKey",
                encode: (e, t = n.BinaryWriter.create()) => (0 !== e.key.length && t.uint32(10).bytes(e.key), t),
                decode(e, t) {
                    let r = e instanceof n.BinaryReader ? e : new n.BinaryReader(e),
                        o = void 0 === t ? r.len : r.pos + t,
                        i = a();
                    for (; r.pos < o;) {
                        let e = r.uint32();
                        e >>> 3 == 1 ? i.key = r.bytes() : r.skipType(7 & e)
                    }
                    return i
                },
                fromJSON(e) {
                    let t = a();
                    return (0, o.isSet)(e.key) && (t.key = (0, o.bytesFromBase64)(e.key)), t
                },
                toJSON(e) {
                    let t = {};
                    return void 0 !== e.key && (t.key = (0, o.base64FromBytes)(void 0 !== e.key ? e.key : new Uint8Array)), t
                },
                fromPartial(e) {
                    let t = a();
                    return t.key = e.key ? ? new Uint8Array, t
                }
            }
        },
        66551: function(e, t, r) {
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: !0
            }), t.CommunityPoolSpendProposalWithDeposit = t.DelegationDelegatorReward = t.DelegatorStartingInfo = t.CommunityPoolSpendProposal = t.FeePool = t.ValidatorSlashEvents = t.ValidatorSlashEvent = t.ValidatorOutstandingRewards = t.ValidatorAccumulatedCommission = t.ValidatorCurrentRewards = t.ValidatorHistoricalRewards = t.Params = t.protobufPackage = void 0;
            let n = r(62809),
                o = r(28486),
                i = r(6476);

            function a() {
                return {
                    communityTax: "",
                    baseProposerReward: "",
                    bonusProposerReward: "",
                    withdrawAddrEnabled: !1
                }
            }

            function s() {
                return {
                    cumulativeRewardRatio: [],
                    referenceCount: 0
                }
            }

            function d() {
                return {
                    rewards: [],
                    period: BigInt(0)
                }
            }

            function c() {
                return {
                    commission: []
                }
            }

            function l() {
                return {
                    rewards: []
                }
            }

            function u() {
                return {
                    validatorPeriod: BigInt(0),
                    fraction: ""
                }
            }

            function p() {
                return {
                    validatorSlashEvents: []
                }
            }

            function m() {
                return {
                    communityPool: []
                }
            }

            function g() {
                return {
                    title: "",
                    description: "",
                    recipient: "",
                    amount: []
                }
            }

            function f() {
                return {
                    previousPeriod: BigInt(0),
                    stake: "",
                    height: BigInt(0)
                }
            }

            function y() {
                return {
                    validatorAddress: "",
                    reward: []
                }
            }

            function h() {
                return {
                    title: "",
                    description: "",
                    recipient: "",
                    amount: "",
                    deposit: ""
                }
            }
            t.protobufPackage = "cosmos.distribution.v1beta1", t.Params = {
                typeUrl: "/cosmos.distribution.v1beta1.Params",
                encode: (e, t = o.BinaryWriter.create()) => ("" !== e.communityTax && t.uint32(10).string(e.communityTax), "" !== e.baseProposerReward && t.uint32(18).string(e.baseProposerReward), "" !== e.bonusProposerReward && t.uint32(26).string(e.bonusProposerReward), !0 === e.withdrawAddrEnabled && t.uint32(32).bool(e.withdrawAddrEnabled), t),
                decode(e, t) {
                    let r = e instanceof o.BinaryReader ? e : new o.BinaryReader(e),
                        n = void 0 === t ? r.len : r.pos + t,
                        i = a();
                    for (; r.pos < n;) {
                        let e = r.uint32();
                        switch (e >>> 3) {
                            case 1:
                                i.communityTax = r.string();
                                break;
                            case 2:
                                i.baseProposerReward = r.string();
                                break;
                            case 3:
                                i.bonusProposerReward = r.string();
                                break;
                            case 4:
                                i.withdrawAddrEnabled = r.bool();
                                break;
                            default:
                                r.skipType(7 & e)
                        }
                    }
                    return i
                },
                fromJSON(e) {
                    let t = a();
                    return (0, i.isSet)(e.communityTax) && (t.communityTax = String(e.communityTax)), (0, i.isSet)(e.baseProposerReward) && (t.baseProposerReward = String(e.baseProposerReward)), (0, i.isSet)(e.bonusProposerReward) && (t.bonusProposerReward = String(e.bonusProposerReward)), (0, i.isSet)(e.withdrawAddrEnabled) && (t.withdrawAddrEnabled = !!e.withdrawAddrEnabled), t
                },
                toJSON(e) {
                    let t = {};
                    return void 0 !== e.communityTax && (t.communityTax = e.communityTax), void 0 !== e.baseProposerReward && (t.baseProposerReward = e.baseProposerReward), void 0 !== e.bonusProposerReward && (t.bonusProposerReward = e.bonusProposerReward), void 0 !== e.withdrawAddrEnabled && (t.withdrawAddrEnabled = e.withdrawAddrEnabled), t
                },
                fromPartial(e) {
                    let t = a();
                    return t.communityTax = e.communityTax ? ? "", t.baseProposerReward = e.baseProposerReward ? ? "", t.bonusProposerReward = e.bonusProposerReward ? ? "", t.withdrawAddrEnabled = e.withdrawAddrEnabled ? ? !1, t
                }
            }, t.ValidatorHistoricalRewards = {
                typeUrl: "/cosmos.distribution.v1beta1.ValidatorHistoricalRewards",
                encode(e, t = o.BinaryWriter.create()) {
                    for (let r of e.cumulativeRewardRatio) n.DecCoin.encode(r, t.uint32(10).fork()).ldelim();
                    return 0 !== e.referenceCount && t.uint32(16).uint32(e.referenceCount), t
                },
                decode(e, t) {
                    let r = e instanceof o.BinaryReader ? e : new o.BinaryReader(e),
                        i = void 0 === t ? r.len : r.pos + t,
                        a = s();
                    for (; r.pos < i;) {
                        let e = r.uint32();
                        switch (e >>> 3) {
                            case 1:
                                a.cumulativeRewardRatio.push(n.DecCoin.decode(r, r.uint32()));
                                break;
                            case 2:
                                a.referenceCount = r.uint32();
                                break;
                            default:
                                r.skipType(7 & e)
                        }
                    }
                    return a
                },
                fromJSON(e) {
                    let t = s();
                    return Array.isArray(e ? .cumulativeRewardRatio) && (t.cumulativeRewardRatio = e.cumulativeRewardRatio.map(e => n.DecCoin.fromJSON(e))), (0, i.isSet)(e.referenceCount) && (t.referenceCount = Number(e.referenceCount)), t
                },
                toJSON(e) {
                    let t = {};
                    return e.cumulativeRewardRatio ? t.cumulativeRewardRatio = e.cumulativeRewardRatio.map(e => e ? n.DecCoin.toJSON(e) : void 0) : t.cumulativeRewardRatio = [], void 0 !== e.referenceCount && (t.referenceCount = Math.round(e.referenceCount)), t
                },
                fromPartial(e) {
                    let t = s();
                    return t.cumulativeRewardRatio = e.cumulativeRewardRatio ? .map(e => n.DecCoin.fromPartial(e)) || [], t.referenceCount = e.referenceCount ? ? 0, t
                }
            }, t.ValidatorCurrentRewards = {
                typeUrl: "/cosmos.distribution.v1beta1.ValidatorCurrentRewards",
                encode(e, t = o.BinaryWriter.create()) {
                    for (let r of e.rewards) n.DecCoin.encode(r, t.uint32(10).fork()).ldelim();
                    return e.period !== BigInt(0) && t.uint32(16).uint64(e.period), t
                },
                decode(e, t) {
                    let r = e instanceof o.BinaryReader ? e : new o.BinaryReader(e),
                        i = void 0 === t ? r.len : r.pos + t,
                        a = d();
                    for (; r.pos < i;) {
                        let e = r.uint32();
                        switch (e >>> 3) {
                            case 1:
                                a.rewards.push(n.DecCoin.decode(r, r.uint32()));
                                break;
                            case 2:
                                a.period = r.uint64();
                                break;
                            default:
                                r.skipType(7 & e)
                        }
                    }
                    return a
                },
                fromJSON(e) {
                    let t = d();
                    return Array.isArray(e ? .rewards) && (t.rewards = e.rewards.map(e => n.DecCoin.fromJSON(e))), (0, i.isSet)(e.period) && (t.period = BigInt(e.period.toString())), t
                },
                toJSON(e) {
                    let t = {};
                    return e.rewards ? t.rewards = e.rewards.map(e => e ? n.DecCoin.toJSON(e) : void 0) : t.rewards = [], void 0 !== e.period && (t.period = (e.period || BigInt(0)).toString()), t
                },
                fromPartial(e) {
                    let t = d();
                    return t.rewards = e.rewards ? .map(e => n.DecCoin.fromPartial(e)) || [], void 0 !== e.period && null !== e.period && (t.period = BigInt(e.period.toString())), t
                }
            }, t.ValidatorAccumulatedCommission = {
                typeUrl: "/cosmos.distribution.v1beta1.ValidatorAccumulatedCommission",
                encode(e, t = o.BinaryWriter.create()) {
                    for (let r of e.commission) n.DecCoin.encode(r, t.uint32(10).fork()).ldelim();
                    return t
                },
                decode(e, t) {
                    let r = e instanceof o.BinaryReader ? e : new o.BinaryReader(e),
                        i = void 0 === t ? r.len : r.pos + t,
                        a = c();
                    for (; r.pos < i;) {
                        let e = r.uint32();
                        e >>> 3 == 1 ? a.commission.push(n.DecCoin.decode(r, r.uint32())) : r.skipType(7 & e)
                    }
                    return a
                },
                fromJSON(e) {
                    let t = c();
                    return Array.isArray(e ? .commission) && (t.commission = e.commission.map(e => n.DecCoin.fromJSON(e))), t
                },
                toJSON(e) {
                    let t = {};
                    return e.commission ? t.commission = e.commission.map(e => e ? n.DecCoin.toJSON(e) : void 0) : t.commission = [], t
                },
                fromPartial(e) {
                    let t = c();
                    return t.commission = e.commission ? .map(e => n.DecCoin.fromPartial(e)) || [], t
                }
            }, t.ValidatorOutstandingRewards = {
                typeUrl: "/cosmos.distribution.v1beta1.ValidatorOutstandingRewards",
                encode(e, t = o.BinaryWriter.create()) {
                    for (let r of e.rewards) n.DecCoin.encode(r, t.uint32(10).fork()).ldelim();
                    return t
                },
                decode(e, t) {
                    let r = e instanceof o.BinaryReader ? e : new o.BinaryReader(e),
                        i = void 0 === t ? r.len : r.pos + t,
                        a = l();
                    for (; r.pos < i;) {
                        let e = r.uint32();
                        e >>> 3 == 1 ? a.rewards.push(n.DecCoin.decode(r, r.uint32())) : r.skipType(7 & e)
                    }
                    return a
                },
                fromJSON(e) {
                    let t = l();
                    return Array.isArray(e ? .rewards) && (t.rewards = e.rewards.map(e => n.DecCoin.fromJSON(e))), t
                },
                toJSON(e) {
                    let t = {};
                    return e.rewards ? t.rewards = e.rewards.map(e => e ? n.DecCoin.toJSON(e) : void 0) : t.rewards = [], t
                },
                fromPartial(e) {
                    let t = l();
                    return t.rewards = e.rewards ? .map(e => n.DecCoin.fromPartial(e)) || [], t
                }
            }, t.ValidatorSlashEvent = {
                typeUrl: "/cosmos.distribution.v1beta1.ValidatorSlashEvent",
                encode: (e, t = o.BinaryWriter.create()) => (e.validatorPeriod !== BigInt(0) && t.uint32(8).uint64(e.validatorPeriod), "" !== e.fraction && t.uint32(18).string(e.fraction), t),
                decode(e, t) {
                    let r = e instanceof o.BinaryReader ? e : new o.BinaryReader(e),
                        n = void 0 === t ? r.len : r.pos + t,
                        i = u();
                    for (; r.pos < n;) {
                        let e = r.uint32();
                        switch (e >>> 3) {
                            case 1:
                                i.validatorPeriod = r.uint64();
                                break;
                            case 2:
                                i.fraction = r.string();
                                break;
                            default:
                                r.skipType(7 & e)
                        }
                    }
                    return i
                },
                fromJSON(e) {
                    let t = u();
                    return (0, i.isSet)(e.validatorPeriod) && (t.validatorPeriod = BigInt(e.validatorPeriod.toString())), (0, i.isSet)(e.fraction) && (t.fraction = String(e.fraction)), t
                },
                toJSON(e) {
                    let t = {};
                    return void 0 !== e.validatorPeriod && (t.validatorPeriod = (e.validatorPeriod || BigInt(0)).toString()), void 0 !== e.fraction && (t.fraction = e.fraction), t
                },
                fromPartial(e) {
                    let t = u();
                    return void 0 !== e.validatorPeriod && null !== e.validatorPeriod && (t.validatorPeriod = BigInt(e.validatorPeriod.toString())), t.fraction = e.fraction ? ? "", t
                }
            }, t.ValidatorSlashEvents = {
                typeUrl: "/cosmos.distribution.v1beta1.ValidatorSlashEvents",
                encode(e, r = o.BinaryWriter.create()) {
                    for (let n of e.validatorSlashEvents) t.ValidatorSlashEvent.encode(n, r.uint32(10).fork()).ldelim();
                    return r
                },
                decode(e, r) {
                    let n = e instanceof o.BinaryReader ? e : new o.BinaryReader(e),
                        i = void 0 === r ? n.len : n.pos + r,
                        a = p();
                    for (; n.pos < i;) {
                        let e = n.uint32();
                        e >>> 3 == 1 ? a.validatorSlashEvents.push(t.ValidatorSlashEvent.decode(n, n.uint32())) : n.skipType(7 & e)
                    }
                    return a
                },
                fromJSON(e) {
                    let r = p();
                    return Array.isArray(e ? .validatorSlashEvents) && (r.validatorSlashEvents = e.validatorSlashEvents.map(e => t.ValidatorSlashEvent.fromJSON(e))), r
                },
                toJSON(e) {
                    let r = {};
                    return e.validatorSlashEvents ? r.validatorSlashEvents = e.validatorSlashEvents.map(e => e ? t.ValidatorSlashEvent.toJSON(e) : void 0) : r.validatorSlashEvents = [], r
                },
                fromPartial(e) {
                    let r = p();
                    return r.validatorSlashEvents = e.validatorSlashEvents ? .map(e => t.ValidatorSlashEvent.fromPartial(e)) || [], r
                }
            }, t.FeePool = {
                typeUrl: "/cosmos.distribution.v1beta1.FeePool",
                encode(e, t = o.BinaryWriter.create()) {
                    for (let r of e.communityPool) n.DecCoin.encode(r, t.uint32(10).fork()).ldelim();
                    return t
                },
                decode(e, t) {
                    let r = e instanceof o.BinaryReader ? e : new o.BinaryReader(e),
                        i = void 0 === t ? r.len : r.pos + t,
                        a = m();
                    for (; r.pos < i;) {
                        let e = r.uint32();
                        e >>> 3 == 1 ? a.communityPool.push(n.DecCoin.decode(r, r.uint32())) : r.skipType(7 & e)
                    }
                    return a
                },
                fromJSON(e) {
                    let t = m();
                    return Array.isArray(e ? .communityPool) && (t.communityPool = e.communityPool.map(e => n.DecCoin.fromJSON(e))), t
                },
                toJSON(e) {
                    let t = {};
                    return e.communityPool ? t.communityPool = e.communityPool.map(e => e ? n.DecCoin.toJSON(e) : void 0) : t.communityPool = [], t
                },
                fromPartial(e) {
                    let t = m();
                    return t.communityPool = e.communityPool ? .map(e => n.DecCoin.fromPartial(e)) || [], t
                }
            }, t.CommunityPoolSpendProposal = {
                typeUrl: "/cosmos.distribution.v1beta1.CommunityPoolSpendProposal",
                encode(e, t = o.BinaryWriter.create()) {
                    for (let r of ("" !== e.title && t.uint32(10).string(e.title), "" !== e.description && t.uint32(18).string(e.description), "" !== e.recipient && t.uint32(26).string(e.recipient), e.amount)) n.Coin.encode(r, t.uint32(34).fork()).ldelim();
                    return t
                },
                decode(e, t) {
                    let r = e instanceof o.BinaryReader ? e : new o.BinaryReader(e),
                        i = void 0 === t ? r.len : r.pos + t,
                        a = g();
                    for (; r.pos < i;) {
                        let e = r.uint32();
                        switch (e >>> 3) {
                            case 1:
                                a.title = r.string();
                                break;
                            case 2:
                                a.description = r.string();
                                break;
                            case 3:
                                a.recipient = r.string();
                                break;
                            case 4:
                                a.amount.push(n.Coin.decode(r, r.uint32()));
                                break;
                            default:
                                r.skipType(7 & e)
                        }
                    }
                    return a
                },
                fromJSON(e) {
                    let t = g();
                    return (0, i.isSet)(e.title) && (t.title = String(e.title)), (0, i.isSet)(e.description) && (t.description = String(e.description)), (0, i.isSet)(e.recipient) && (t.recipient = String(e.recipient)), Array.isArray(e ? .amount) && (t.amount = e.amount.map(e => n.Coin.fromJSON(e))), t
                },
                toJSON(e) {
                    let t = {};
                    return void 0 !== e.title && (t.title = e.title), void 0 !== e.description && (t.description = e.description), void 0 !== e.recipient && (t.recipient = e.recipient), e.amount ? t.amount = e.amount.map(e => e ? n.Coin.toJSON(e) : void 0) : t.amount = [], t
                },
                fromPartial(e) {
                    let t = g();
                    return t.title = e.title ? ? "", t.description = e.description ? ? "", t.recipient = e.recipient ? ? "", t.amount = e.amount ? .map(e => n.Coin.fromPartial(e)) || [], t
                }
            }, t.DelegatorStartingInfo = {
                typeUrl: "/cosmos.distribution.v1beta1.DelegatorStartingInfo",
                encode: (e, t = o.BinaryWriter.create()) => (e.previousPeriod !== BigInt(0) && t.uint32(8).uint64(e.previousPeriod), "" !== e.stake && t.uint32(18).string(e.stake), e.height !== BigInt(0) && t.uint32(24).uint64(e.height), t),
                decode(e, t) {
                    let r = e instanceof o.BinaryReader ? e : new o.BinaryReader(e),
                        n = void 0 === t ? r.len : r.pos + t,
                        i = f();
                    for (; r.pos < n;) {
                        let e = r.uint32();
                        switch (e >>> 3) {
                            case 1:
                                i.previousPeriod = r.uint64();
                                break;
                            case 2:
                                i.stake = r.string();
                                break;
                            case 3:
                                i.height = r.uint64();
                                break;
                            default:
                                r.skipType(7 & e)
                        }
                    }
                    return i
                },
                fromJSON(e) {
                    let t = f();
                    return (0, i.isSet)(e.previousPeriod) && (t.previousPeriod = BigInt(e.previousPeriod.toString())), (0, i.isSet)(e.stake) && (t.stake = String(e.stake)), (0, i.isSet)(e.height) && (t.height = BigInt(e.height.toString())), t
                },
                toJSON(e) {
                    let t = {};
                    return void 0 !== e.previousPeriod && (t.previousPeriod = (e.previousPeriod || BigInt(0)).toString()), void 0 !== e.stake && (t.stake = e.stake), void 0 !== e.height && (t.height = (e.height || BigInt(0)).toString()), t
                },
                fromPartial(e) {
                    let t = f();
                    return void 0 !== e.previousPeriod && null !== e.previousPeriod && (t.previousPeriod = BigInt(e.previousPeriod.toString())), t.stake = e.stake ? ? "", void 0 !== e.height && null !== e.height && (t.height = BigInt(e.height.toString())), t
                }
            }, t.DelegationDelegatorReward = {
                typeUrl: "/cosmos.distribution.v1beta1.DelegationDelegatorReward",
                encode(e, t = o.BinaryWriter.create()) {
                    for (let r of ("" !== e.validatorAddress && t.uint32(10).string(e.validatorAddress), e.reward)) n.DecCoin.encode(r, t.uint32(18).fork()).ldelim();
                    return t
                },
                decode(e, t) {
                    let r = e instanceof o.BinaryReader ? e : new o.BinaryReader(e),
                        i = void 0 === t ? r.len : r.pos + t,
                        a = y();
                    for (; r.pos < i;) {
                        let e = r.uint32();
                        switch (e >>> 3) {
                            case 1:
                                a.validatorAddress = r.string();
                                break;
                            case 2:
                                a.reward.push(n.DecCoin.decode(r, r.uint32()));
                                break;
                            default:
                                r.skipType(7 & e)
                        }
                    }
                    return a
                },
                fromJSON(e) {
                    let t = y();
                    return (0, i.isSet)(e.validatorAddress) && (t.validatorAddress = String(e.validatorAddress)), Array.isArray(e ? .reward) && (t.reward = e.reward.map(e => n.DecCoin.fromJSON(e))), t
                },
                toJSON(e) {
                    let t = {};
                    return void 0 !== e.validatorAddress && (t.validatorAddress = e.validatorAddress), e.reward ? t.reward = e.reward.map(e => e ? n.DecCoin.toJSON(e) : void 0) : t.reward = [], t
                },
                fromPartial(e) {
                    let t = y();
                    return t.validatorAddress = e.validatorAddress ? ? "", t.reward = e.reward ? .map(e => n.DecCoin.fromPartial(e)) || [], t
                }
            }, t.CommunityPoolSpendProposalWithDeposit = {
                typeUrl: "/cosmos.distribution.v1beta1.CommunityPoolSpendProposalWithDeposit",
                encode: (e, t = o.BinaryWriter.create()) => ("" !== e.title && t.uint32(10).string(e.title), "" !== e.description && t.uint32(18).string(e.description), "" !== e.recipient && t.uint32(26).string(e.recipient), "" !== e.amount && t.uint32(34).string(e.amount), "" !== e.deposit && t.uint32(42).string(e.deposit), t),
                decode(e, t) {
                    let r = e instanceof o.BinaryReader ? e : new o.BinaryReader(e),
                        n = void 0 === t ? r.len : r.pos + t,
                        i = h();
                    for (; r.pos < n;) {
                        let e = r.uint32();
                        switch (e >>> 3) {
                            case 1:
                                i.title = r.string();
                                break;
                            case 2:
                                i.description = r.string();
                                break;
                            case 3:
                                i.recipient = r.string();
                                break;
                            case 4:
                                i.amount = r.string();
                                break;
                            case 5:
                                i.deposit = r.string();
                                break;
                            default:
                                r.skipType(7 & e)
                        }
                    }
                    return i
                },
                fromJSON(e) {
                    let t = h();
                    return (0, i.isSet)(e.title) && (t.title = String(e.title)), (0, i.isSet)(e.description) && (t.description = String(e.description)), (0, i.isSet)(e.recipient) && (t.recipient = String(e.recipient)), (0, i.isSet)(e.amount) && (t.amount = String(e.amount)), (0, i.isSet)(e.deposit) && (t.deposit = String(e.deposit)), t
                },
                toJSON(e) {
                    let t = {};
                    return void 0 !== e.title && (t.title = e.title), void 0 !== e.description && (t.description = e.description), void 0 !== e.recipient && (t.recipient = e.recipient), void 0 !== e.amount && (t.amount = e.amount), void 0 !== e.deposit && (t.deposit = e.deposit), t
                },
                fromPartial(e) {
                    let t = h();
                    return t.title = e.title ? ? "", t.description = e.description ? ? "", t.recipient = e.recipient ? ? "", t.amount = e.amount ? ? "", t.deposit = e.deposit ? ? "", t
                }
            }
        },
        43085: function(e, t, r) {
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: !0
            }), t.QueryClientImpl = t.QueryCommunityPoolResponse = t.QueryCommunityPoolRequest = t.QueryDelegatorWithdrawAddressResponse = t.QueryDelegatorWithdrawAddressRequest = t.QueryDelegatorValidatorsResponse = t.QueryDelegatorValidatorsRequest = t.QueryDelegationTotalRewardsResponse = t.QueryDelegationTotalRewardsRequest = t.QueryDelegationRewardsResponse = t.QueryDelegationRewardsRequest = t.QueryValidatorSlashesResponse = t.QueryValidatorSlashesRequest = t.QueryValidatorCommissionResponse = t.QueryValidatorCommissionRequest = t.QueryValidatorOutstandingRewardsResponse = t.QueryValidatorOutstandingRewardsRequest = t.QueryValidatorDistributionInfoResponse = t.QueryValidatorDistributionInfoRequest = t.QueryParamsResponse = t.QueryParamsRequest = t.protobufPackage = void 0;
            let n = r(38792),
                o = r(66551),
                i = r(62809),
                a = r(28486),
                s = r(6476);

            function d() {
                return {
                    params: o.Params.fromPartial({})
                }
            }

            function c() {
                return {
                    validatorAddress: ""
                }
            }

            function l() {
                return {
                    operatorAddress: "",
                    selfBondRewards: [],
                    commission: []
                }
            }

            function u() {
                return {
                    validatorAddress: ""
                }
            }

            function p() {
                return {
                    rewards: o.ValidatorOutstandingRewards.fromPartial({})
                }
            }

            function m() {
                return {
                    validatorAddress: ""
                }
            }

            function g() {
                return {
                    commission: o.ValidatorAccumulatedCommission.fromPartial({})
                }
            }

            function f() {
                return {
                    validatorAddress: "",
                    startingHeight: BigInt(0),
                    endingHeight: BigInt(0),
                    pagination: void 0
                }
            }

            function y() {
                return {
                    slashes: [],
                    pagination: void 0
                }
            }

            function h() {
                return {
                    delegatorAddress: "",
                    validatorAddress: ""
                }
            }

            function v() {
                return {
                    rewards: []
                }
            }

            function b() {
                return {
                    delegatorAddress: ""
                }
            }

            function S() {
                return {
                    rewards: [],
                    total: []
                }
            }

            function k() {
                return {
                    delegatorAddress: ""
                }
            }

            function P() {
                return {
                    validators: []
                }
            }

            function _() {
                return {
                    delegatorAddress: ""
                }
            }

            function B() {
                return {
                    withdrawAddress: ""
                }
            }

            function O() {
                return {
                    pool: []
                }
            }
            t.protobufPackage = "cosmos.distribution.v1beta1", t.QueryParamsRequest = {
                typeUrl: "/cosmos.distribution.v1beta1.QueryParamsRequest",
                encode: (e, t = a.BinaryWriter.create()) => t,
                decode(e, t) {
                    let r = e instanceof a.BinaryReader ? e : new a.BinaryReader(e),
                        n = void 0 === t ? r.len : r.pos + t;
                    for (; r.pos < n;) {
                        let e = r.uint32();
                        r.skipType(7 & e)
                    }
                    return {}
                },
                fromJSON: e => ({}),
                toJSON: e => ({}),
                fromPartial: e => ({})
            }, t.QueryParamsResponse = {
                typeUrl: "/cosmos.distribution.v1beta1.QueryParamsResponse",
                encode: (e, t = a.BinaryWriter.create()) => (void 0 !== e.params && o.Params.encode(e.params, t.uint32(10).fork()).ldelim(), t),
                decode(e, t) {
                    let r = e instanceof a.BinaryReader ? e : new a.BinaryReader(e),
                        n = void 0 === t ? r.len : r.pos + t,
                        i = d();
                    for (; r.pos < n;) {
                        let e = r.uint32();
                        e >>> 3 == 1 ? i.params = o.Params.decode(r, r.uint32()) : r.skipType(7 & e)
                    }
                    return i
                },
                fromJSON(e) {
                    let t = d();
                    return (0, s.isSet)(e.params) && (t.params = o.Params.fromJSON(e.params)), t
                },
                toJSON(e) {
                    let t = {};
                    return void 0 !== e.params && (t.params = e.params ? o.Params.toJSON(e.params) : void 0), t
                },
                fromPartial(e) {
                    let t = d();
                    return void 0 !== e.params && null !== e.params && (t.params = o.Params.fromPartial(e.params)), t
                }
            }, t.QueryValidatorDistributionInfoRequest = {
                typeUrl: "/cosmos.distribution.v1beta1.QueryValidatorDistributionInfoRequest",
                encode: (e, t = a.BinaryWriter.create()) => ("" !== e.validatorAddress && t.uint32(10).string(e.validatorAddress), t),
                decode(e, t) {
                    let r = e instanceof a.BinaryReader ? e : new a.BinaryReader(e),
                        n = void 0 === t ? r.len : r.pos + t,
                        o = c();
                    for (; r.pos < n;) {
                        let e = r.uint32();
                        e >>> 3 == 1 ? o.validatorAddress = r.string() : r.skipType(7 & e)
                    }
                    return o
                },
                fromJSON(e) {
                    let t = c();
                    return (0, s.isSet)(e.validatorAddress) && (t.validatorAddress = String(e.validatorAddress)), t
                },
                toJSON(e) {
                    let t = {};
                    return void 0 !== e.validatorAddress && (t.validatorAddress = e.validatorAddress), t
                },
                fromPartial(e) {
                    let t = c();
                    return t.validatorAddress = e.validatorAddress ? ? "", t
                }
            }, t.QueryValidatorDistributionInfoResponse = {
                typeUrl: "/cosmos.distribution.v1beta1.QueryValidatorDistributionInfoResponse",
                encode(e, t = a.BinaryWriter.create()) {
                    for (let r of ("" !== e.operatorAddress && t.uint32(10).string(e.operatorAddress), e.selfBondRewards)) i.DecCoin.encode(r, t.uint32(18).fork()).ldelim();
                    for (let r of e.commission) i.DecCoin.encode(r, t.uint32(26).fork()).ldelim();
                    return t
                },
                decode(e, t) {
                    let r = e instanceof a.BinaryReader ? e : new a.BinaryReader(e),
                        n = void 0 === t ? r.len : r.pos + t,
                        o = l();
                    for (; r.pos < n;) {
                        let e = r.uint32();
                        switch (e >>> 3) {
                            case 1:
                                o.operatorAddress = r.string();
                                break;
                            case 2:
                                o.selfBondRewards.push(i.DecCoin.decode(r, r.uint32()));
                                break;
                            case 3:
                                o.commission.push(i.DecCoin.decode(r, r.uint32()));
                                break;
                            default:
                                r.skipType(7 & e)
                        }
                    }
                    return o
                },
                fromJSON(e) {
                    let t = l();
                    return (0, s.isSet)(e.operatorAddress) && (t.operatorAddress = String(e.operatorAddress)), Array.isArray(e ? .selfBondRewards) && (t.selfBondRewards = e.selfBondRewards.map(e => i.DecCoin.fromJSON(e))), Array.isArray(e ? .commission) && (t.commission = e.commission.map(e => i.DecCoin.fromJSON(e))), t
                },
                toJSON(e) {
                    let t = {};
                    return void 0 !== e.operatorAddress && (t.operatorAddress = e.operatorAddress), e.selfBondRewards ? t.selfBondRewards = e.selfBondRewards.map(e => e ? i.DecCoin.toJSON(e) : void 0) : t.selfBondRewards = [], e.commission ? t.commission = e.commission.map(e => e ? i.DecCoin.toJSON(e) : void 0) : t.commission = [], t
                },
                fromPartial(e) {
                    let t = l();
                    return t.operatorAddress = e.operatorAddress ? ? "", t.selfBondRewards = e.selfBondRewards ? .map(e => i.DecCoin.fromPartial(e)) || [], t.commission = e.commission ? .map(e => i.DecCoin.fromPartial(e)) || [], t
                }
            }, t.QueryValidatorOutstandingRewardsRequest = {
                typeUrl: "/cosmos.distribution.v1beta1.QueryValidatorOutstandingRewardsRequest",
                encode: (e, t = a.BinaryWriter.create()) => ("" !== e.validatorAddress && t.uint32(10).string(e.validatorAddress), t),
                decode(e, t) {
                    let r = e instanceof a.BinaryReader ? e : new a.BinaryReader(e),
                        n = void 0 === t ? r.len : r.pos + t,
                        o = u();
                    for (; r.pos < n;) {
                        let e = r.uint32();
                        e >>> 3 == 1 ? o.validatorAddress = r.string() : r.skipType(7 & e)
                    }
                    return o
                },
                fromJSON(e) {
                    let t = u();
                    return (0, s.isSet)(e.validatorAddress) && (t.validatorAddress = String(e.validatorAddress)), t
                },
                toJSON(e) {
                    let t = {};
                    return void 0 !== e.validatorAddress && (t.validatorAddress = e.validatorAddress), t
                },
                fromPartial(e) {
                    let t = u();
                    return t.validatorAddress = e.validatorAddress ? ? "", t
                }
            }, t.QueryValidatorOutstandingRewardsResponse = {
                typeUrl: "/cosmos.distribution.v1beta1.QueryValidatorOutstandingRewardsResponse",
                encode: (e, t = a.BinaryWriter.create()) => (void 0 !== e.rewards && o.ValidatorOutstandingRewards.encode(e.rewards, t.uint32(10).fork()).ldelim(), t),
                decode(e, t) {
                    let r = e instanceof a.BinaryReader ? e : new a.BinaryReader(e),
                        n = void 0 === t ? r.len : r.pos + t,
                        i = p();
                    for (; r.pos < n;) {
                        let e = r.uint32();
                        e >>> 3 == 1 ? i.rewards = o.ValidatorOutstandingRewards.decode(r, r.uint32()) : r.skipType(7 & e)
                    }
                    return i
                },
                fromJSON(e) {
                    let t = p();
                    return (0, s.isSet)(e.rewards) && (t.rewards = o.ValidatorOutstandingRewards.fromJSON(e.rewards)), t
                },
                toJSON(e) {
                    let t = {};
                    return void 0 !== e.rewards && (t.rewards = e.rewards ? o.ValidatorOutstandingRewards.toJSON(e.rewards) : void 0), t
                },
                fromPartial(e) {
                    let t = p();
                    return void 0 !== e.rewards && null !== e.rewards && (t.rewards = o.ValidatorOutstandingRewards.fromPartial(e.rewards)), t
                }
            }, t.QueryValidatorCommissionRequest = {
                typeUrl: "/cosmos.distribution.v1beta1.QueryValidatorCommissionRequest",
                encode: (e, t = a.BinaryWriter.create()) => ("" !== e.validatorAddress && t.uint32(10).string(e.validatorAddress), t),
                decode(e, t) {
                    let r = e instanceof a.BinaryReader ? e : new a.BinaryReader(e),
                        n = void 0 === t ? r.len : r.pos + t,
                        o = m();
                    for (; r.pos < n;) {
                        let e = r.uint32();
                        e >>> 3 == 1 ? o.validatorAddress = r.string() : r.skipType(7 & e)
                    }
                    return o
                },
                fromJSON(e) {
                    let t = m();
                    return (0, s.isSet)(e.validatorAddress) && (t.validatorAddress = String(e.validatorAddress)), t
                },
                toJSON(e) {
                    let t = {};
                    return void 0 !== e.validatorAddress && (t.validatorAddress = e.validatorAddress), t
                },
                fromPartial(e) {
                    let t = m();
                    return t.validatorAddress = e.validatorAddress ? ? "", t
                }
            }, t.QueryValidatorCommissionResponse = {
                typeUrl: "/cosmos.distribution.v1beta1.QueryValidatorCommissionResponse",
                encode: (e, t = a.BinaryWriter.create()) => (void 0 !== e.commission && o.ValidatorAccumulatedCommission.encode(e.commission, t.uint32(10).fork()).ldelim(), t),
                decode(e, t) {
                    let r = e instanceof a.BinaryReader ? e : new a.BinaryReader(e),
                        n = void 0 === t ? r.len : r.pos + t,
                        i = g();
                    for (; r.pos < n;) {
                        let e = r.uint32();
                        e >>> 3 == 1 ? i.commission = o.ValidatorAccumulatedCommission.decode(r, r.uint32()) : r.skipType(7 & e)
                    }
                    return i
                },
                fromJSON(e) {
                    let t = g();
                    return (0, s.isSet)(e.commission) && (t.commission = o.ValidatorAccumulatedCommission.fromJSON(e.commission)), t
                },
                toJSON(e) {
                    let t = {};
                    return void 0 !== e.commission && (t.commission = e.commission ? o.ValidatorAccumulatedCommission.toJSON(e.commission) : void 0), t
                },
                fromPartial(e) {
                    let t = g();
                    return void 0 !== e.commission && null !== e.commission && (t.commission = o.ValidatorAccumulatedCommission.fromPartial(e.commission)), t
                }
            }, t.QueryValidatorSlashesRequest = {
                typeUrl: "/cosmos.distribution.v1beta1.QueryValidatorSlashesRequest",
                encode: (e, t = a.BinaryWriter.create()) => ("" !== e.validatorAddress && t.uint32(10).string(e.validatorAddress), e.startingHeight !== BigInt(0) && t.uint32(16).uint64(e.startingHeight), e.endingHeight !== BigInt(0) && t.uint32(24).uint64(e.endingHeight), void 0 !== e.pagination && n.PageRequest.encode(e.pagination, t.uint32(34).fork()).ldelim(), t),
                decode(e, t) {
                    let r = e instanceof a.BinaryReader ? e : new a.BinaryReader(e),
                        o = void 0 === t ? r.len : r.pos + t,
                        i = f();
                    for (; r.pos < o;) {
                        let e = r.uint32();
                        switch (e >>> 3) {
                            case 1:
                                i.validatorAddress = r.string();
                                break;
                            case 2:
                                i.startingHeight = r.uint64();
                                break;
                            case 3:
                                i.endingHeight = r.uint64();
                                break;
                            case 4:
                                i.pagination = n.PageRequest.decode(r, r.uint32());
                                break;
                            default:
                                r.skipType(7 & e)
                        }
                    }
                    return i
                },
                fromJSON(e) {
                    let t = f();
                    return (0, s.isSet)(e.validatorAddress) && (t.validatorAddress = String(e.validatorAddress)), (0, s.isSet)(e.startingHeight) && (t.startingHeight = BigInt(e.startingHeight.toString())), (0, s.isSet)(e.endingHeight) && (t.endingHeight = BigInt(e.endingHeight.toString())), (0, s.isSet)(e.pagination) && (t.pagination = n.PageRequest.fromJSON(e.pagination)), t
                },
                toJSON(e) {
                    let t = {};
                    return void 0 !== e.validatorAddress && (t.validatorAddress = e.validatorAddress), void 0 !== e.startingHeight && (t.startingHeight = (e.startingHeight || BigInt(0)).toString()), void 0 !== e.endingHeight && (t.endingHeight = (e.endingHeight || BigInt(0)).toString()), void 0 !== e.pagination && (t.pagination = e.pagination ? n.PageRequest.toJSON(e.pagination) : void 0), t
                },
                fromPartial(e) {
                    let t = f();
                    return t.validatorAddress = e.validatorAddress ? ? "", void 0 !== e.startingHeight && null !== e.startingHeight && (t.startingHeight = BigInt(e.startingHeight.toString())), void 0 !== e.endingHeight && null !== e.endingHeight && (t.endingHeight = BigInt(e.endingHeight.toString())), void 0 !== e.pagination && null !== e.pagination && (t.pagination = n.PageRequest.fromPartial(e.pagination)), t
                }
            }, t.QueryValidatorSlashesResponse = {
                typeUrl: "/cosmos.distribution.v1beta1.QueryValidatorSlashesResponse",
                encode(e, t = a.BinaryWriter.create()) {
                    for (let r of e.slashes) o.ValidatorSlashEvent.encode(r, t.uint32(10).fork()).ldelim();
                    return void 0 !== e.pagination && n.PageResponse.encode(e.pagination, t.uint32(18).fork()).ldelim(), t
                },
                decode(e, t) {
                    let r = e instanceof a.BinaryReader ? e : new a.BinaryReader(e),
                        i = void 0 === t ? r.len : r.pos + t,
                        s = y();
                    for (; r.pos < i;) {
                        let e = r.uint32();
                        switch (e >>> 3) {
                            case 1:
                                s.slashes.push(o.ValidatorSlashEvent.decode(r, r.uint32()));
                                break;
                            case 2:
                                s.pagination = n.PageResponse.decode(r, r.uint32());
                                break;
                            default:
                                r.skipType(7 & e)
                        }
                    }
                    return s
                },
                fromJSON(e) {
                    let t = y();
                    return Array.isArray(e ? .slashes) && (t.slashes = e.slashes.map(e => o.ValidatorSlashEvent.fromJSON(e))), (0, s.isSet)(e.pagination) && (t.pagination = n.PageResponse.fromJSON(e.pagination)), t
                },
                toJSON(e) {
                    let t = {};
                    return e.slashes ? t.slashes = e.slashes.map(e => e ? o.ValidatorSlashEvent.toJSON(e) : void 0) : t.slashes = [], void 0 !== e.pagination && (t.pagination = e.pagination ? n.PageResponse.toJSON(e.pagination) : void 0), t
                },
                fromPartial(e) {
                    let t = y();
                    return t.slashes = e.slashes ? .map(e => o.ValidatorSlashEvent.fromPartial(e)) || [], void 0 !== e.pagination && null !== e.pagination && (t.pagination = n.PageResponse.fromPartial(e.pagination)), t
                }
            }, t.QueryDelegationRewardsRequest = {
                typeUrl: "/cosmos.distribution.v1beta1.QueryDelegationRewardsRequest",
                encode: (e, t = a.BinaryWriter.create()) => ("" !== e.delegatorAddress && t.uint32(10).string(e.delegatorAddress), "" !== e.validatorAddress && t.uint32(18).string(e.validatorAddress), t),
                decode(e, t) {
                    let r = e instanceof a.BinaryReader ? e : new a.BinaryReader(e),
                        n = void 0 === t ? r.len : r.pos + t,
                        o = h();
                    for (; r.pos < n;) {
                        let e = r.uint32();
                        switch (e >>> 3) {
                            case 1:
                                o.delegatorAddress = r.string();
                                break;
                            case 2:
                                o.validatorAddress = r.string();
                                break;
                            default:
                                r.skipType(7 & e)
                        }
                    }
                    return o
                },
                fromJSON(e) {
                    let t = h();
                    return (0, s.isSet)(e.delegatorAddress) && (t.delegatorAddress = String(e.delegatorAddress)), (0, s.isSet)(e.validatorAddress) && (t.validatorAddress = String(e.validatorAddress)), t
                },
                toJSON(e) {
                    let t = {};
                    return void 0 !== e.delegatorAddress && (t.delegatorAddress = e.delegatorAddress), void 0 !== e.validatorAddress && (t.validatorAddress = e.validatorAddress), t
                },
                fromPartial(e) {
                    let t = h();
                    return t.delegatorAddress = e.delegatorAddress ? ? "", t.validatorAddress = e.validatorAddress ? ? "", t
                }
            }, t.QueryDelegationRewardsResponse = {
                typeUrl: "/cosmos.distribution.v1beta1.QueryDelegationRewardsResponse",
                encode(e, t = a.BinaryWriter.create()) {
                    for (let r of e.rewards) i.DecCoin.encode(r, t.uint32(10).fork()).ldelim();
                    return t
                },
                decode(e, t) {
                    let r = e instanceof a.BinaryReader ? e : new a.BinaryReader(e),
                        n = void 0 === t ? r.len : r.pos + t,
                        o = v();
                    for (; r.pos < n;) {
                        let e = r.uint32();
                        e >>> 3 == 1 ? o.rewards.push(i.DecCoin.decode(r, r.uint32())) : r.skipType(7 & e)
                    }
                    return o
                },
                fromJSON(e) {
                    let t = v();
                    return Array.isArray(e ? .rewards) && (t.rewards = e.rewards.map(e => i.DecCoin.fromJSON(e))), t
                },
                toJSON(e) {
                    let t = {};
                    return e.rewards ? t.rewards = e.rewards.map(e => e ? i.DecCoin.toJSON(e) : void 0) : t.rewards = [], t
                },
                fromPartial(e) {
                    let t = v();
                    return t.rewards = e.rewards ? .map(e => i.DecCoin.fromPartial(e)) || [], t
                }
            }, t.QueryDelegationTotalRewardsRequest = {
                typeUrl: "/cosmos.distribution.v1beta1.QueryDelegationTotalRewardsRequest",
                encode: (e, t = a.BinaryWriter.create()) => ("" !== e.delegatorAddress && t.uint32(10).string(e.delegatorAddress), t),
                decode(e, t) {
                    let r = e instanceof a.BinaryReader ? e : new a.BinaryReader(e),
                        n = void 0 === t ? r.len : r.pos + t,
                        o = b();
                    for (; r.pos < n;) {
                        let e = r.uint32();
                        e >>> 3 == 1 ? o.delegatorAddress = r.string() : r.skipType(7 & e)
                    }
                    return o
                },
                fromJSON(e) {
                    let t = b();
                    return (0, s.isSet)(e.delegatorAddress) && (t.delegatorAddress = String(e.delegatorAddress)), t
                },
                toJSON(e) {
                    let t = {};
                    return void 0 !== e.delegatorAddress && (t.delegatorAddress = e.delegatorAddress), t
                },
                fromPartial(e) {
                    let t = b();
                    return t.delegatorAddress = e.delegatorAddress ? ? "", t
                }
            }, t.QueryDelegationTotalRewardsResponse = {
                typeUrl: "/cosmos.distribution.v1beta1.QueryDelegationTotalRewardsResponse",
                encode(e, t = a.BinaryWriter.create()) {
                    for (let r of e.rewards) o.DelegationDelegatorReward.encode(r, t.uint32(10).fork()).ldelim();
                    for (let r of e.total) i.DecCoin.encode(r, t.uint32(18).fork()).ldelim();
                    return t
                },
                decode(e, t) {
                    let r = e instanceof a.BinaryReader ? e : new a.BinaryReader(e),
                        n = void 0 === t ? r.len : r.pos + t,
                        s = S();
                    for (; r.pos < n;) {
                        let e = r.uint32();
                        switch (e >>> 3) {
                            case 1:
                                s.rewards.push(o.DelegationDelegatorReward.decode(r, r.uint32()));
                                break;
                            case 2:
                                s.total.push(i.DecCoin.decode(r, r.uint32()));
                                break;
                            default:
                                r.skipType(7 & e)
                        }
                    }
                    return s
                },
                fromJSON(e) {
                    let t = S();
                    return Array.isArray(e ? .rewards) && (t.rewards = e.rewards.map(e => o.DelegationDelegatorReward.fromJSON(e))), Array.isArray(e ? .total) && (t.total = e.total.map(e => i.DecCoin.fromJSON(e))), t
                },
                toJSON(e) {
                    let t = {};
                    return e.rewards ? t.rewards = e.rewards.map(e => e ? o.DelegationDelegatorReward.toJSON(e) : void 0) : t.rewards = [], e.total ? t.total = e.total.map(e => e ? i.DecCoin.toJSON(e) : void 0) : t.total = [], t
                },
                fromPartial(e) {
                    let t = S();
                    return t.rewards = e.rewards ? .map(e => o.DelegationDelegatorReward.fromPartial(e)) || [], t.total = e.total ? .map(e => i.DecCoin.fromPartial(e)) || [], t
                }
            }, t.QueryDelegatorValidatorsRequest = {
                typeUrl: "/cosmos.distribution.v1beta1.QueryDelegatorValidatorsRequest",
                encode: (e, t = a.BinaryWriter.create()) => ("" !== e.delegatorAddress && t.uint32(10).string(e.delegatorAddress), t),
                decode(e, t) {
                    let r = e instanceof a.BinaryReader ? e : new a.BinaryReader(e),
                        n = void 0 === t ? r.len : r.pos + t,
                        o = k();
                    for (; r.pos < n;) {
                        let e = r.uint32();
                        e >>> 3 == 1 ? o.delegatorAddress = r.string() : r.skipType(7 & e)
                    }
                    return o
                },
                fromJSON(e) {
                    let t = k();
                    return (0, s.isSet)(e.delegatorAddress) && (t.delegatorAddress = String(e.delegatorAddress)), t
                },
                toJSON(e) {
                    let t = {};
                    return void 0 !== e.delegatorAddress && (t.delegatorAddress = e.delegatorAddress), t
                },
                fromPartial(e) {
                    let t = k();
                    return t.delegatorAddress = e.delegatorAddress ? ? "", t
                }
            }, t.QueryDelegatorValidatorsResponse = {
                typeUrl: "/cosmos.distribution.v1beta1.QueryDelegatorValidatorsResponse",
                encode(e, t = a.BinaryWriter.create()) {
                    for (let r of e.validators) t.uint32(10).string(r);
                    return t
                },
                decode(e, t) {
                    let r = e instanceof a.BinaryReader ? e : new a.BinaryReader(e),
                        n = void 0 === t ? r.len : r.pos + t,
                        o = P();
                    for (; r.pos < n;) {
                        let e = r.uint32();
                        e >>> 3 == 1 ? o.validators.push(r.string()) : r.skipType(7 & e)
                    }
                    return o
                },
                fromJSON(e) {
                    let t = P();
                    return Array.isArray(e ? .validators) && (t.validators = e.validators.map(e => String(e))), t
                },
                toJSON(e) {
                    let t = {};
                    return e.validators ? t.validators = e.validators.map(e => e) : t.validators = [], t
                },
                fromPartial(e) {
                    let t = P();
                    return t.validators = e.validators ? .map(e => e) || [], t
                }
            }, t.QueryDelegatorWithdrawAddressRequest = {
                typeUrl: "/cosmos.distribution.v1beta1.QueryDelegatorWithdrawAddressRequest",
                encode: (e, t = a.BinaryWriter.create()) => ("" !== e.delegatorAddress && t.uint32(10).string(e.delegatorAddress), t),
                decode(e, t) {
                    let r = e instanceof a.BinaryReader ? e : new a.BinaryReader(e),
                        n = void 0 === t ? r.len : r.pos + t,
                        o = _();
                    for (; r.pos < n;) {
                        let e = r.uint32();
                        e >>> 3 == 1 ? o.delegatorAddress = r.string() : r.skipType(7 & e)
                    }
                    return o
                },
                fromJSON(e) {
                    let t = _();
                    return (0, s.isSet)(e.delegatorAddress) && (t.delegatorAddress = String(e.delegatorAddress)), t
                },
                toJSON(e) {
                    let t = {};
                    return void 0 !== e.delegatorAddress && (t.delegatorAddress = e.delegatorAddress), t
                },
                fromPartial(e) {
                    let t = _();
                    return t.delegatorAddress = e.delegatorAddress ? ? "", t
                }
            }, t.QueryDelegatorWithdrawAddressResponse = {
                typeUrl: "/cosmos.distribution.v1beta1.QueryDelegatorWithdrawAddressResponse",
                encode: (e, t = a.BinaryWriter.create()) => ("" !== e.withdrawAddress && t.uint32(10).string(e.withdrawAddress), t),
                decode(e, t) {
                    let r = e instanceof a.BinaryReader ? e : new a.BinaryReader(e),
                        n = void 0 === t ? r.len : r.pos + t,
                        o = B();
                    for (; r.pos < n;) {
                        let e = r.uint32();
                        e >>> 3 == 1 ? o.withdrawAddress = r.string() : r.skipType(7 & e)
                    }
                    return o
                },
                fromJSON(e) {
                    let t = B();
                    return (0, s.isSet)(e.withdrawAddress) && (t.withdrawAddress = String(e.withdrawAddress)), t
                },
                toJSON(e) {
                    let t = {};
                    return void 0 !== e.withdrawAddress && (t.withdrawAddress = e.withdrawAddress), t
                },
                fromPartial(e) {
                    let t = B();
                    return t.withdrawAddress = e.withdrawAddress ? ? "", t
                }
            }, t.QueryCommunityPoolRequest = {
                typeUrl: "/cosmos.distribution.v1beta1.QueryCommunityPoolRequest",
                encode: (e, t = a.BinaryWriter.create()) => t,
                decode(e, t) {
                    let r = e instanceof a.BinaryReader ? e : new a.BinaryReader(e),
                        n = void 0 === t ? r.len : r.pos + t;
                    for (; r.pos < n;) {
                        let e = r.uint32();
                        r.skipType(7 & e)
                    }
                    return {}
                },
                fromJSON: e => ({}),
                toJSON: e => ({}),
                fromPartial: e => ({})
            }, t.QueryCommunityPoolResponse = {
                typeUrl: "/cosmos.distribution.v1beta1.QueryCommunityPoolResponse",
                encode(e, t = a.BinaryWriter.create()) {
                    for (let r of e.pool) i.DecCoin.encode(r, t.uint32(10).fork()).ldelim();
                    return t
                },
                decode(e, t) {
                    let r = e instanceof a.BinaryReader ? e : new a.BinaryReader(e),
                        n = void 0 === t ? r.len : r.pos + t,
                        o = O();
                    for (; r.pos < n;) {
                        let e = r.uint32();
                        e >>> 3 == 1 ? o.pool.push(i.DecCoin.decode(r, r.uint32())) : r.skipType(7 & e)
                    }
                    return o
                },
                fromJSON(e) {
                    let t = O();
                    return Array.isArray(e ? .pool) && (t.pool = e.pool.map(e => i.DecCoin.fromJSON(e))), t
                },
                toJSON(e) {
                    let t = {};
                    return e.pool ? t.pool = e.pool.map(e => e ? i.DecCoin.toJSON(e) : void 0) : t.pool = [], t
                },
                fromPartial(e) {
                    let t = O();
                    return t.pool = e.pool ? .map(e => i.DecCoin.fromPartial(e)) || [], t
                }
            };
            class R {
                constructor(e) {
                    this.rpc = e, this.Params = this.Params.bind(this), this.ValidatorDistributionInfo = this.ValidatorDistributionInfo.bind(this), this.ValidatorOutstandingRewards = this.ValidatorOutstandingRewards.bind(this), this.ValidatorCommission = this.ValidatorCommission.bind(this), this.ValidatorSlashes = this.ValidatorSlashes.bind(this), this.DelegationRewards = this.DelegationRewards.bind(this), this.DelegationTotalRewards = this.DelegationTotalRewards.bind(this), this.DelegatorValidators = this.DelegatorValidators.bind(this), this.DelegatorWithdrawAddress = this.DelegatorWithdrawAddress.bind(this), this.CommunityPool = this.CommunityPool.bind(this)
                }
                Params(e = {}) {
                    let r = t.QueryParamsRequest.encode(e).finish();
                    return this.rpc.request("cosmos.distribution.v1beta1.Query", "Params", r).then(e => t.QueryParamsResponse.decode(new a.BinaryReader(e)))
                }
                ValidatorDistributionInfo(e) {
                    let r = t.QueryValidatorDistributionInfoRequest.encode(e).finish();
                    return this.rpc.request("cosmos.distribution.v1beta1.Query", "ValidatorDistributionInfo", r).then(e => t.QueryValidatorDistributionInfoResponse.decode(new a.BinaryReader(e)))
                }
                ValidatorOutstandingRewards(e) {
                    let r = t.QueryValidatorOutstandingRewardsRequest.encode(e).finish();
                    return this.rpc.request("cosmos.distribution.v1beta1.Query", "ValidatorOutstandingRewards", r).then(e => t.QueryValidatorOutstandingRewardsResponse.decode(new a.BinaryReader(e)))
                }
                ValidatorCommission(e) {
                    let r = t.QueryValidatorCommissionRequest.encode(e).finish();
                    return this.rpc.request("cosmos.distribution.v1beta1.Query", "ValidatorCommission", r).then(e => t.QueryValidatorCommissionResponse.decode(new a.BinaryReader(e)))
                }
                ValidatorSlashes(e) {
                    let r = t.QueryValidatorSlashesRequest.encode(e).finish();
                    return this.rpc.request("cosmos.distribution.v1beta1.Query", "ValidatorSlashes", r).then(e => t.QueryValidatorSlashesResponse.decode(new a.BinaryReader(e)))
                }
                DelegationRewards(e) {
                    let r = t.QueryDelegationRewardsRequest.encode(e).finish();
                    return this.rpc.request("cosmos.distribution.v1beta1.Query", "DelegationRewards", r).then(e => t.QueryDelegationRewardsResponse.decode(new a.BinaryReader(e)))
                }
                DelegationTotalRewards(e) {
                    let r = t.QueryDelegationTotalRewardsRequest.encode(e).finish();
                    return this.rpc.request("cosmos.distribution.v1beta1.Query", "DelegationTotalRewards", r).then(e => t.QueryDelegationTotalRewardsResponse.decode(new a.BinaryReader(e)))
                }
                DelegatorValidators(e) {
                    let r = t.QueryDelegatorValidatorsRequest.encode(e).finish();
                    return this.rpc.request("cosmos.distribution.v1beta1.Query", "DelegatorValidators", r).then(e => t.QueryDelegatorValidatorsResponse.decode(new a.BinaryReader(e)))
                }
                DelegatorWithdrawAddress(e) {
                    let r = t.QueryDelegatorWithdrawAddressRequest.encode(e).finish();
                    return this.rpc.request("cosmos.distribution.v1beta1.Query", "DelegatorWithdrawAddress", r).then(e => t.QueryDelegatorWithdrawAddressResponse.decode(new a.BinaryReader(e)))
                }
                CommunityPool(e = {}) {
                    let r = t.QueryCommunityPoolRequest.encode(e).finish();
                    return this.rpc.request("cosmos.distribution.v1beta1.Query", "CommunityPool", r).then(e => t.QueryCommunityPoolResponse.decode(new a.BinaryReader(e)))
                }
            }
            t.QueryClientImpl = R
        },
        3877: function(e, t, r) {
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: !0
            }), t.MsgClientImpl = t.MsgCommunityPoolSpendResponse = t.MsgCommunityPoolSpend = t.MsgUpdateParamsResponse = t.MsgUpdateParams = t.MsgFundCommunityPoolResponse = t.MsgFundCommunityPool = t.MsgWithdrawValidatorCommissionResponse = t.MsgWithdrawValidatorCommission = t.MsgWithdrawDelegatorRewardResponse = t.MsgWithdrawDelegatorReward = t.MsgSetWithdrawAddressResponse = t.MsgSetWithdrawAddress = t.protobufPackage = void 0;
            let n = r(62809),
                o = r(66551),
                i = r(28486),
                a = r(6476);

            function s() {
                return {
                    delegatorAddress: "",
                    withdrawAddress: ""
                }
            }

            function d() {
                return {
                    delegatorAddress: "",
                    validatorAddress: ""
                }
            }

            function c() {
                return {
                    amount: []
                }
            }

            function l() {
                return {
                    validatorAddress: ""
                }
            }

            function u() {
                return {
                    amount: []
                }
            }

            function p() {
                return {
                    amount: [],
                    depositor: ""
                }
            }

            function m() {
                return {
                    authority: "",
                    params: o.Params.fromPartial({})
                }
            }

            function g() {
                return {
                    authority: "",
                    recipient: "",
                    amount: []
                }
            }
            t.protobufPackage = "cosmos.distribution.v1beta1", t.MsgSetWithdrawAddress = {
                typeUrl: "/cosmos.distribution.v1beta1.MsgSetWithdrawAddress",
                encode: (e, t = i.BinaryWriter.create()) => ("" !== e.delegatorAddress && t.uint32(10).string(e.delegatorAddress), "" !== e.withdrawAddress && t.uint32(18).string(e.withdrawAddress), t),
                decode(e, t) {
                    let r = e instanceof i.BinaryReader ? e : new i.BinaryReader(e),
                        n = void 0 === t ? r.len : r.pos + t,
                        o = s();
                    for (; r.pos < n;) {
                        let e = r.uint32();
                        switch (e >>> 3) {
                            case 1:
                                o.delegatorAddress = r.string();
                                break;
                            case 2:
                                o.withdrawAddress = r.string();
                                break;
                            default:
                                r.skipType(7 & e)
                        }
                    }
                    return o
                },
                fromJSON(e) {
                    let t = s();
                    return (0, a.isSet)(e.delegatorAddress) && (t.delegatorAddress = String(e.delegatorAddress)), (0, a.isSet)(e.withdrawAddress) && (t.withdrawAddress = String(e.withdrawAddress)), t
                },
                toJSON(e) {
                    let t = {};
                    return void 0 !== e.delegatorAddress && (t.delegatorAddress = e.delegatorAddress), void 0 !== e.withdrawAddress && (t.withdrawAddress = e.withdrawAddress), t
                },
                fromPartial(e) {
                    let t = s();
                    return t.delegatorAddress = e.delegatorAddress ? ? "", t.withdrawAddress = e.withdrawAddress ? ? "", t
                }
            }, t.MsgSetWithdrawAddressResponse = {
                typeUrl: "/cosmos.distribution.v1beta1.MsgSetWithdrawAddressResponse",
                encode: (e, t = i.BinaryWriter.create()) => t,
                decode(e, t) {
                    let r = e instanceof i.BinaryReader ? e : new i.BinaryReader(e),
                        n = void 0 === t ? r.len : r.pos + t;
                    for (; r.pos < n;) {
                        let e = r.uint32();
                        r.skipType(7 & e)
                    }
                    return {}
                },
                fromJSON: e => ({}),
                toJSON: e => ({}),
                fromPartial: e => ({})
            }, t.MsgWithdrawDelegatorReward = {
                typeUrl: "/cosmos.distribution.v1beta1.MsgWithdrawDelegatorReward",
                encode: (e, t = i.BinaryWriter.create()) => ("" !== e.delegatorAddress && t.uint32(10).string(e.delegatorAddress), "" !== e.validatorAddress && t.uint32(18).string(e.validatorAddress), t),
                decode(e, t) {
                    let r = e instanceof i.BinaryReader ? e : new i.BinaryReader(e),
                        n = void 0 === t ? r.len : r.pos + t,
                        o = d();
                    for (; r.pos < n;) {
                        let e = r.uint32();
                        switch (e >>> 3) {
                            case 1:
                                o.delegatorAddress = r.string();
                                break;
                            case 2:
                                o.validatorAddress = r.string();
                                break;
                            default:
                                r.skipType(7 & e)
                        }
                    }
                    return o
                },
                fromJSON(e) {
                    let t = d();
                    return (0, a.isSet)(e.delegatorAddress) && (t.delegatorAddress = String(e.delegatorAddress)), (0, a.isSet)(e.validatorAddress) && (t.validatorAddress = String(e.validatorAddress)), t
                },
                toJSON(e) {
                    let t = {};
                    return void 0 !== e.delegatorAddress && (t.delegatorAddress = e.delegatorAddress), void 0 !== e.validatorAddress && (t.validatorAddress = e.validatorAddress), t
                },
                fromPartial(e) {
                    let t = d();
                    return t.delegatorAddress = e.delegatorAddress ? ? "", t.validatorAddress = e.validatorAddress ? ? "", t
                }
            }, t.MsgWithdrawDelegatorRewardResponse = {
                typeUrl: "/cosmos.distribution.v1beta1.MsgWithdrawDelegatorRewardResponse",
                encode(e, t = i.BinaryWriter.create()) {
                    for (let r of e.amount) n.Coin.encode(r, t.uint32(10).fork()).ldelim();
                    return t
                },
                decode(e, t) {
                    let r = e instanceof i.BinaryReader ? e : new i.BinaryReader(e),
                        o = void 0 === t ? r.len : r.pos + t,
                        a = c();
                    for (; r.pos < o;) {
                        let e = r.uint32();
                        e >>> 3 == 1 ? a.amount.push(n.Coin.decode(r, r.uint32())) : r.skipType(7 & e)
                    }
                    return a
                },
                fromJSON(e) {
                    let t = c();
                    return Array.isArray(e ? .amount) && (t.amount = e.amount.map(e => n.Coin.fromJSON(e))), t
                },
                toJSON(e) {
                    let t = {};
                    return e.amount ? t.amount = e.amount.map(e => e ? n.Coin.toJSON(e) : void 0) : t.amount = [], t
                },
                fromPartial(e) {
                    let t = c();
                    return t.amount = e.amount ? .map(e => n.Coin.fromPartial(e)) || [], t
                }
            }, t.MsgWithdrawValidatorCommission = {
                typeUrl: "/cosmos.distribution.v1beta1.MsgWithdrawValidatorCommission",
                encode: (e, t = i.BinaryWriter.create()) => ("" !== e.validatorAddress && t.uint32(10).string(e.validatorAddress), t),
                decode(e, t) {
                    let r = e instanceof i.BinaryReader ? e : new i.BinaryReader(e),
                        n = void 0 === t ? r.len : r.pos + t,
                        o = l();
                    for (; r.pos < n;) {
                        let e = r.uint32();
                        e >>> 3 == 1 ? o.validatorAddress = r.string() : r.skipType(7 & e)
                    }
                    return o
                },
                fromJSON(e) {
                    let t = l();
                    return (0, a.isSet)(e.validatorAddress) && (t.validatorAddress = String(e.validatorAddress)), t
                },
                toJSON(e) {
                    let t = {};
                    return void 0 !== e.validatorAddress && (t.validatorAddress = e.validatorAddress), t
                },
                fromPartial(e) {
                    let t = l();
                    return t.validatorAddress = e.validatorAddress ? ? "", t
                }
            }, t.MsgWithdrawValidatorCommissionResponse = {
                typeUrl: "/cosmos.distribution.v1beta1.MsgWithdrawValidatorCommissionResponse",
                encode(e, t = i.BinaryWriter.create()) {
                    for (let r of e.amount) n.Coin.encode(r, t.uint32(10).fork()).ldelim();
                    return t
                },
                decode(e, t) {
                    let r = e instanceof i.BinaryReader ? e : new i.BinaryReader(e),
                        o = void 0 === t ? r.len : r.pos + t,
                        a = u();
                    for (; r.pos < o;) {
                        let e = r.uint32();
                        e >>> 3 == 1 ? a.amount.push(n.Coin.decode(r, r.uint32())) : r.skipType(7 & e)
                    }
                    return a
                },
                fromJSON(e) {
                    let t = u();
                    return Array.isArray(e ? .amount) && (t.amount = e.amount.map(e => n.Coin.fromJSON(e))), t
                },
                toJSON(e) {
                    let t = {};
                    return e.amount ? t.amount = e.amount.map(e => e ? n.Coin.toJSON(e) : void 0) : t.amount = [], t
                },
                fromPartial(e) {
                    let t = u();
                    return t.amount = e.amount ? .map(e => n.Coin.fromPartial(e)) || [], t
                }
            }, t.MsgFundCommunityPool = {
                typeUrl: "/cosmos.distribution.v1beta1.MsgFundCommunityPool",
                encode(e, t = i.BinaryWriter.create()) {
                    for (let r of e.amount) n.Coin.encode(r, t.uint32(10).fork()).ldelim();
                    return "" !== e.depositor && t.uint32(18).string(e.depositor), t
                },
                decode(e, t) {
                    let r = e instanceof i.BinaryReader ? e : new i.BinaryReader(e),
                        o = void 0 === t ? r.len : r.pos + t,
                        a = p();
                    for (; r.pos < o;) {
                        let e = r.uint32();
                        switch (e >>> 3) {
                            case 1:
                                a.amount.push(n.Coin.decode(r, r.uint32()));
                                break;
                            case 2:
                                a.depositor = r.string();
                                break;
                            default:
                                r.skipType(7 & e)
                        }
                    }
                    return a
                },
                fromJSON(e) {
                    let t = p();
                    return Array.isArray(e ? .amount) && (t.amount = e.amount.map(e => n.Coin.fromJSON(e))), (0, a.isSet)(e.depositor) && (t.depositor = String(e.depositor)), t
                },
                toJSON(e) {
                    let t = {};
                    return e.amount ? t.amount = e.amount.map(e => e ? n.Coin.toJSON(e) : void 0) : t.amount = [], void 0 !== e.depositor && (t.depositor = e.depositor), t
                },
                fromPartial(e) {
                    let t = p();
                    return t.amount = e.amount ? .map(e => n.Coin.fromPartial(e)) || [], t.depositor = e.depositor ? ? "", t
                }
            }, t.MsgFundCommunityPoolResponse = {
                typeUrl: "/cosmos.distribution.v1beta1.MsgFundCommunityPoolResponse",
                encode: (e, t = i.BinaryWriter.create()) => t,
                decode(e, t) {
                    let r = e instanceof i.BinaryReader ? e : new i.BinaryReader(e),
                        n = void 0 === t ? r.len : r.pos + t;
                    for (; r.pos < n;) {
                        let e = r.uint32();
                        r.skipType(7 & e)
                    }
                    return {}
                },
                fromJSON: e => ({}),
                toJSON: e => ({}),
                fromPartial: e => ({})
            }, t.MsgUpdateParams = {
                typeUrl: "/cosmos.distribution.v1beta1.MsgUpdateParams",
                encode: (e, t = i.BinaryWriter.create()) => ("" !== e.authority && t.uint32(10).string(e.authority), void 0 !== e.params && o.Params.encode(e.params, t.uint32(18).fork()).ldelim(), t),
                decode(e, t) {
                    let r = e instanceof i.BinaryReader ? e : new i.BinaryReader(e),
                        n = void 0 === t ? r.len : r.pos + t,
                        a = m();
                    for (; r.pos < n;) {
                        let e = r.uint32();
                        switch (e >>> 3) {
                            case 1:
                                a.authority = r.string();
                                break;
                            case 2:
                                a.params = o.Params.decode(r, r.uint32());
                                break;
                            default:
                                r.skipType(7 & e)
                        }
                    }
                    return a
                },
                fromJSON(e) {
                    let t = m();
                    return (0, a.isSet)(e.authority) && (t.authority = String(e.authority)), (0, a.isSet)(e.params) && (t.params = o.Params.fromJSON(e.params)), t
                },
                toJSON(e) {
                    let t = {};
                    return void 0 !== e.authority && (t.authority = e.authority), void 0 !== e.params && (t.params = e.params ? o.Params.toJSON(e.params) : void 0), t
                },
                fromPartial(e) {
                    let t = m();
                    return t.authority = e.authority ? ? "", void 0 !== e.params && null !== e.params && (t.params = o.Params.fromPartial(e.params)), t
                }
            }, t.MsgUpdateParamsResponse = {
                typeUrl: "/cosmos.distribution.v1beta1.MsgUpdateParamsResponse",
                encode: (e, t = i.BinaryWriter.create()) => t,
                decode(e, t) {
                    let r = e instanceof i.BinaryReader ? e : new i.BinaryReader(e),
                        n = void 0 === t ? r.len : r.pos + t;
                    for (; r.pos < n;) {
                        let e = r.uint32();
                        r.skipType(7 & e)
                    }
                    return {}
                },
                fromJSON: e => ({}),
                toJSON: e => ({}),
                fromPartial: e => ({})
            }, t.MsgCommunityPoolSpend = {
                typeUrl: "/cosmos.distribution.v1beta1.MsgCommunityPoolSpend",
                encode(e, t = i.BinaryWriter.create()) {
                    for (let r of ("" !== e.authority && t.uint32(10).string(e.authority), "" !== e.recipient && t.uint32(18).string(e.recipient), e.amount)) n.Coin.encode(r, t.uint32(26).fork()).ldelim();
                    return t
                },
                decode(e, t) {
                    let r = e instanceof i.BinaryReader ? e : new i.BinaryReader(e),
                        o = void 0 === t ? r.len : r.pos + t,
                        a = g();
                    for (; r.pos < o;) {
                        let e = r.uint32();
                        switch (e >>> 3) {
                            case 1:
                                a.authority = r.string();
                                break;
                            case 2:
                                a.recipient = r.string();
                                break;
                            case 3:
                                a.amount.push(n.Coin.decode(r, r.uint32()));
                                break;
                            default:
                                r.skipType(7 & e)
                        }
                    }
                    return a
                },
                fromJSON(e) {
                    let t = g();
                    return (0, a.isSet)(e.authority) && (t.authority = String(e.authority)), (0, a.isSet)(e.recipient) && (t.recipient = String(e.recipient)), Array.isArray(e ? .amount) && (t.amount = e.amount.map(e => n.Coin.fromJSON(e))), t
                },
                toJSON(e) {
                    let t = {};
                    return void 0 !== e.authority && (t.authority = e.authority), void 0 !== e.recipient && (t.recipient = e.recipient), e.amount ? t.amount = e.amount.map(e => e ? n.Coin.toJSON(e) : void 0) : t.amount = [], t
                },
                fromPartial(e) {
                    let t = g();
                    return t.authority = e.authority ? ? "", t.recipient = e.recipient ? ? "", t.amount = e.amount ? .map(e => n.Coin.fromPartial(e)) || [], t
                }
            }, t.MsgCommunityPoolSpendResponse = {
                typeUrl: "/cosmos.distribution.v1beta1.MsgCommunityPoolSpendResponse",
                encode: (e, t = i.BinaryWriter.create()) => t,
                decode(e, t) {
                    let r = e instanceof i.BinaryReader ? e : new i.BinaryReader(e),
                        n = void 0 === t ? r.len : r.pos + t;
                    for (; r.pos < n;) {
                        let e = r.uint32();
                        r.skipType(7 & e)
                    }
                    return {}
                },
                fromJSON: e => ({}),
                toJSON: e => ({}),
                fromPartial: e => ({})
            };
            class f {
                constructor(e) {
                    this.rpc = e, this.SetWithdrawAddress = this.SetWithdrawAddress.bind(this), this.WithdrawDelegatorReward = this.WithdrawDelegatorReward.bind(this), this.WithdrawValidatorCommission = this.WithdrawValidatorCommission.bind(this), this.FundCommunityPool = this.FundCommunityPool.bind(this), this.UpdateParams = this.UpdateParams.bind(this), this.CommunityPoolSpend = this.CommunityPoolSpend.bind(this)
                }
                SetWithdrawAddress(e) {
                    let r = t.MsgSetWithdrawAddress.encode(e).finish();
                    return this.rpc.request("cosmos.distribution.v1beta1.Msg", "SetWithdrawAddress", r).then(e => t.MsgSetWithdrawAddressResponse.decode(new i.BinaryReader(e)))
                }
                WithdrawDelegatorReward(e) {
                    let r = t.MsgWithdrawDelegatorReward.encode(e).finish();
                    return this.rpc.request("cosmos.distribution.v1beta1.Msg", "WithdrawDelegatorReward", r).then(e => t.MsgWithdrawDelegatorRewardResponse.decode(new i.BinaryReader(e)))
                }
                WithdrawValidatorCommission(e) {
                    let r = t.MsgWithdrawValidatorCommission.encode(e).finish();
                    return this.rpc.request("cosmos.distribution.v1beta1.Msg", "WithdrawValidatorCommission", r).then(e => t.MsgWithdrawValidatorCommissionResponse.decode(new i.BinaryReader(e)))
                }
                FundCommunityPool(e) {
                    let r = t.MsgFundCommunityPool.encode(e).finish();
                    return this.rpc.request("cosmos.distribution.v1beta1.Msg", "FundCommunityPool", r).then(e => t.MsgFundCommunityPoolResponse.decode(new i.BinaryReader(e)))
                }
                UpdateParams(e) {
                    let r = t.MsgUpdateParams.encode(e).finish();
                    return this.rpc.request("cosmos.distribution.v1beta1.Msg", "UpdateParams", r).then(e => t.MsgUpdateParamsResponse.decode(new i.BinaryReader(e)))
                }
                CommunityPoolSpend(e) {
                    let r = t.MsgCommunityPoolSpend.encode(e).finish();
                    return this.rpc.request("cosmos.distribution.v1beta1.Msg", "CommunityPoolSpend", r).then(e => t.MsgCommunityPoolSpendResponse.decode(new i.BinaryReader(e)))
                }
            }
            t.MsgClientImpl = f
        },
        47094: function(e, t, r) {
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: !0
            }), t.Grant = t.AllowedMsgAllowance = t.PeriodicAllowance = t.BasicAllowance = t.protobufPackage = void 0;
            let n = r(62809),
                o = r(90614),
                i = r(69441),
                a = r(65676),
                s = r(28486),
                d = r(6476);

            function c() {
                return {
                    spendLimit: [],
                    expiration: void 0
                }
            }

            function l() {
                return {
                    basic: t.BasicAllowance.fromPartial({}),
                    period: i.Duration.fromPartial({}),
                    periodSpendLimit: [],
                    periodCanSpend: [],
                    periodReset: o.Timestamp.fromPartial({})
                }
            }

            function u() {
                return {
                    allowance: void 0,
                    allowedMessages: []
                }
            }

            function p() {
                return {
                    granter: "",
                    grantee: "",
                    allowance: void 0
                }
            }
            t.protobufPackage = "cosmos.feegrant.v1beta1", t.BasicAllowance = {
                typeUrl: "/cosmos.feegrant.v1beta1.BasicAllowance",
                encode(e, t = s.BinaryWriter.create()) {
                    for (let r of e.spendLimit) n.Coin.encode(r, t.uint32(10).fork()).ldelim();
                    return void 0 !== e.expiration && o.Timestamp.encode(e.expiration, t.uint32(18).fork()).ldelim(), t
                },
                decode(e, t) {
                    let r = e instanceof s.BinaryReader ? e : new s.BinaryReader(e),
                        i = void 0 === t ? r.len : r.pos + t,
                        a = c();
                    for (; r.pos < i;) {
                        let e = r.uint32();
                        switch (e >>> 3) {
                            case 1:
                                a.spendLimit.push(n.Coin.decode(r, r.uint32()));
                                break;
                            case 2:
                                a.expiration = o.Timestamp.decode(r, r.uint32());
                                break;
                            default:
                                r.skipType(7 & e)
                        }
                    }
                    return a
                },
                fromJSON(e) {
                    let t = c();
                    return Array.isArray(e ? .spendLimit) && (t.spendLimit = e.spendLimit.map(e => n.Coin.fromJSON(e))), (0, d.isSet)(e.expiration) && (t.expiration = (0, d.fromJsonTimestamp)(e.expiration)), t
                },
                toJSON(e) {
                    let t = {};
                    return e.spendLimit ? t.spendLimit = e.spendLimit.map(e => e ? n.Coin.toJSON(e) : void 0) : t.spendLimit = [], void 0 !== e.expiration && (t.expiration = (0, d.fromTimestamp)(e.expiration).toISOString()), t
                },
                fromPartial(e) {
                    let t = c();
                    return t.spendLimit = e.spendLimit ? .map(e => n.Coin.fromPartial(e)) || [], void 0 !== e.expiration && null !== e.expiration && (t.expiration = o.Timestamp.fromPartial(e.expiration)), t
                }
            }, t.PeriodicAllowance = {
                typeUrl: "/cosmos.feegrant.v1beta1.PeriodicAllowance",
                encode(e, r = s.BinaryWriter.create()) {
                    for (let o of (void 0 !== e.basic && t.BasicAllowance.encode(e.basic, r.uint32(10).fork()).ldelim(), void 0 !== e.period && i.Duration.encode(e.period, r.uint32(18).fork()).ldelim(), e.periodSpendLimit)) n.Coin.encode(o, r.uint32(26).fork()).ldelim();
                    for (let t of e.periodCanSpend) n.Coin.encode(t, r.uint32(34).fork()).ldelim();
                    return void 0 !== e.periodReset && o.Timestamp.encode(e.periodReset, r.uint32(42).fork()).ldelim(), r
                },
                decode(e, r) {
                    let a = e instanceof s.BinaryReader ? e : new s.BinaryReader(e),
                        d = void 0 === r ? a.len : a.pos + r,
                        c = l();
                    for (; a.pos < d;) {
                        let e = a.uint32();
                        switch (e >>> 3) {
                            case 1:
                                c.basic = t.BasicAllowance.decode(a, a.uint32());
                                break;
                            case 2:
                                c.period = i.Duration.decode(a, a.uint32());
                                break;
                            case 3:
                                c.periodSpendLimit.push(n.Coin.decode(a, a.uint32()));
                                break;
                            case 4:
                                c.periodCanSpend.push(n.Coin.decode(a, a.uint32()));
                                break;
                            case 5:
                                c.periodReset = o.Timestamp.decode(a, a.uint32());
                                break;
                            default:
                                a.skipType(7 & e)
                        }
                    }
                    return c
                },
                fromJSON(e) {
                    let r = l();
                    return (0, d.isSet)(e.basic) && (r.basic = t.BasicAllowance.fromJSON(e.basic)), (0, d.isSet)(e.period) && (r.period = i.Duration.fromJSON(e.period)), Array.isArray(e ? .periodSpendLimit) && (r.periodSpendLimit = e.periodSpendLimit.map(e => n.Coin.fromJSON(e))), Array.isArray(e ? .periodCanSpend) && (r.periodCanSpend = e.periodCanSpend.map(e => n.Coin.fromJSON(e))), (0, d.isSet)(e.periodReset) && (r.periodReset = (0, d.fromJsonTimestamp)(e.periodReset)), r
                },
                toJSON(e) {
                    let r = {};
                    return void 0 !== e.basic && (r.basic = e.basic ? t.BasicAllowance.toJSON(e.basic) : void 0), void 0 !== e.period && (r.period = e.period ? i.Duration.toJSON(e.period) : void 0), e.periodSpendLimit ? r.periodSpendLimit = e.periodSpendLimit.map(e => e ? n.Coin.toJSON(e) : void 0) : r.periodSpendLimit = [], e.periodCanSpend ? r.periodCanSpend = e.periodCanSpend.map(e => e ? n.Coin.toJSON(e) : void 0) : r.periodCanSpend = [], void 0 !== e.periodReset && (r.periodReset = (0, d.fromTimestamp)(e.periodReset).toISOString()), r
                },
                fromPartial(e) {
                    let r = l();
                    return void 0 !== e.basic && null !== e.basic && (r.basic = t.BasicAllowance.fromPartial(e.basic)), void 0 !== e.period && null !== e.period && (r.period = i.Duration.fromPartial(e.period)), r.periodSpendLimit = e.periodSpendLimit ? .map(e => n.Coin.fromPartial(e)) || [], r.periodCanSpend = e.periodCanSpend ? .map(e => n.Coin.fromPartial(e)) || [], void 0 !== e.periodReset && null !== e.periodReset && (r.periodReset = o.Timestamp.fromPartial(e.periodReset)), r
                }
            }, t.AllowedMsgAllowance = {
                typeUrl: "/cosmos.feegrant.v1beta1.AllowedMsgAllowance",
                encode(e, t = s.BinaryWriter.create()) {
                    for (let r of (void 0 !== e.allowance && a.Any.encode(e.allowance, t.uint32(10).fork()).ldelim(), e.allowedMessages)) t.uint32(18).string(r);
                    return t
                },
                decode(e, t) {
                    let r = e instanceof s.BinaryReader ? e : new s.BinaryReader(e),
                        n = void 0 === t ? r.len : r.pos + t,
                        o = u();
                    for (; r.pos < n;) {
                        let e = r.uint32();
                        switch (e >>> 3) {
                            case 1:
                                o.allowance = a.Any.decode(r, r.uint32());
                                break;
                            case 2:
                                o.allowedMessages.push(r.string());
                                break;
                            default:
                                r.skipType(7 & e)
                        }
                    }
                    return o
                },
                fromJSON(e) {
                    let t = u();
                    return (0, d.isSet)(e.allowance) && (t.allowance = a.Any.fromJSON(e.allowance)), Array.isArray(e ? .allowedMessages) && (t.allowedMessages = e.allowedMessages.map(e => String(e))), t
                },
                toJSON(e) {
                    let t = {};
                    return void 0 !== e.allowance && (t.allowance = e.allowance ? a.Any.toJSON(e.allowance) : void 0), e.allowedMessages ? t.allowedMessages = e.allowedMessages.map(e => e) : t.allowedMessages = [], t
                },
                fromPartial(e) {
                    let t = u();
                    return void 0 !== e.allowance && null !== e.allowance && (t.allowance = a.Any.fromPartial(e.allowance)), t.allowedMessages = e.allowedMessages ? .map(e => e) || [], t
                }
            }, t.Grant = {
                typeUrl: "/cosmos.feegrant.v1beta1.Grant",
                encode: (e, t = s.BinaryWriter.create()) => ("" !== e.granter && t.uint32(10).string(e.granter), "" !== e.grantee && t.uint32(18).string(e.grantee), void 0 !== e.allowance && a.Any.encode(e.allowance, t.uint32(26).fork()).ldelim(), t),
                decode(e, t) {
                    let r = e instanceof s.BinaryReader ? e : new s.BinaryReader(e),
                        n = void 0 === t ? r.len : r.pos + t,
                        o = p();
                    for (; r.pos < n;) {
                        let e = r.uint32();
                        switch (e >>> 3) {
                            case 1:
                                o.granter = r.string();
                                break;
                            case 2:
                                o.grantee = r.string();
                                break;
                            case 3:
                                o.allowance = a.Any.decode(r, r.uint32());
                                break;
                            default:
                                r.skipType(7 & e)
                        }
                    }
                    return o
                },
                fromJSON(e) {
                    let t = p();
                    return (0, d.isSet)(e.granter) && (t.granter = String(e.granter)), (0, d.isSet)(e.grantee) && (t.grantee = String(e.grantee)), (0, d.isSet)(e.allowance) && (t.allowance = a.Any.fromJSON(e.allowance)), t
                },
                toJSON(e) {
                    let t = {};
                    return void 0 !== e.granter && (t.granter = e.granter), void 0 !== e.grantee && (t.grantee = e.grantee), void 0 !== e.allowance && (t.allowance = e.allowance ? a.Any.toJSON(e.allowance) : void 0), t
                },
                fromPartial(e) {
                    let t = p();
                    return t.granter = e.granter ? ? "", t.grantee = e.grantee ? ? "", void 0 !== e.allowance && null !== e.allowance && (t.allowance = a.Any.fromPartial(e.allowance)), t
                }
            }
        },
        79749: function(e, t, r) {
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: !0
            }), t.QueryClientImpl = t.QueryAllowancesByGranterResponse = t.QueryAllowancesByGranterRequest = t.QueryAllowancesResponse = t.QueryAllowancesRequest = t.QueryAllowanceResponse = t.QueryAllowanceRequest = t.protobufPackage = void 0;
            let n = r(38792),
                o = r(47094),
                i = r(28486),
                a = r(6476);

            function s() {
                return {
                    granter: "",
                    grantee: ""
                }
            }

            function d() {
                return {
                    allowance: void 0
                }
            }

            function c() {
                return {
                    grantee: "",
                    pagination: void 0
                }
            }

            function l() {
                return {
                    allowances: [],
                    pagination: void 0
                }
            }

            function u() {
                return {
                    granter: "",
                    pagination: void 0
                }
            }

            function p() {
                return {
                    allowances: [],
                    pagination: void 0
                }
            }
            t.protobufPackage = "cosmos.feegrant.v1beta1", t.QueryAllowanceRequest = {
                typeUrl: "/cosmos.feegrant.v1beta1.QueryAllowanceRequest",
                encode: (e, t = i.BinaryWriter.create()) => ("" !== e.granter && t.uint32(10).string(e.granter), "" !== e.grantee && t.uint32(18).string(e.grantee), t),
                decode(e, t) {
                    let r = e instanceof i.BinaryReader ? e : new i.BinaryReader(e),
                        n = void 0 === t ? r.len : r.pos + t,
                        o = s();
                    for (; r.pos < n;) {
                        let e = r.uint32();
                        switch (e >>> 3) {
                            case 1:
                                o.granter = r.string();
                                break;
                            case 2:
                                o.grantee = r.string();
                                break;
                            default:
                                r.skipType(7 & e)
                        }
                    }
                    return o
                },
                fromJSON(e) {
                    let t = s();
                    return (0, a.isSet)(e.granter) && (t.granter = String(e.granter)), (0, a.isSet)(e.grantee) && (t.grantee = String(e.grantee)), t
                },
                toJSON(e) {
                    let t = {};
                    return void 0 !== e.granter && (t.granter = e.granter), void 0 !== e.grantee && (t.grantee = e.grantee), t
                },
                fromPartial(e) {
                    let t = s();
                    return t.granter = e.granter ? ? "", t.grantee = e.grantee ? ? "", t
                }
            }, t.QueryAllowanceResponse = {
                typeUrl: "/cosmos.feegrant.v1beta1.QueryAllowanceResponse",
                encode: (e, t = i.BinaryWriter.create()) => (void 0 !== e.allowance && o.Grant.encode(e.allowance, t.uint32(10).fork()).ldelim(), t),
                decode(e, t) {
                    let r = e instanceof i.BinaryReader ? e : new i.BinaryReader(e),
                        n = void 0 === t ? r.len : r.pos + t,
                        a = d();
                    for (; r.pos < n;) {
                        let e = r.uint32();
                        e >>> 3 == 1 ? a.allowance = o.Grant.decode(r, r.uint32()) : r.skipType(7 & e)
                    }
                    return a
                },
                fromJSON(e) {
                    let t = d();
                    return (0, a.isSet)(e.allowance) && (t.allowance = o.Grant.fromJSON(e.allowance)), t
                },
                toJSON(e) {
                    let t = {};
                    return void 0 !== e.allowance && (t.allowance = e.allowance ? o.Grant.toJSON(e.allowance) : void 0), t
                },
                fromPartial(e) {
                    let t = d();
                    return void 0 !== e.allowance && null !== e.allowance && (t.allowance = o.Grant.fromPartial(e.allowance)), t
                }
            }, t.QueryAllowancesRequest = {
                typeUrl: "/cosmos.feegrant.v1beta1.QueryAllowancesRequest",
                encode: (e, t = i.BinaryWriter.create()) => ("" !== e.grantee && t.uint32(10).string(e.grantee), void 0 !== e.pagination && n.PageRequest.encode(e.pagination, t.uint32(18).fork()).ldelim(), t),
                decode(e, t) {
                    let r = e instanceof i.BinaryReader ? e : new i.BinaryReader(e),
                        o = void 0 === t ? r.len : r.pos + t,
                        a = c();
                    for (; r.pos < o;) {
                        let e = r.uint32();
                        switch (e >>> 3) {
                            case 1:
                                a.grantee = r.string();
                                break;
                            case 2:
                                a.pagination = n.PageRequest.decode(r, r.uint32());
                                break;
                            default:
                                r.skipType(7 & e)
                        }
                    }
                    return a
                },
                fromJSON(e) {
                    let t = c();
                    return (0, a.isSet)(e.grantee) && (t.grantee = String(e.grantee)), (0, a.isSet)(e.pagination) && (t.pagination = n.PageRequest.fromJSON(e.pagination)), t
                },
                toJSON(e) {
                    let t = {};
                    return void 0 !== e.grantee && (t.grantee = e.grantee), void 0 !== e.pagination && (t.pagination = e.pagination ? n.PageRequest.toJSON(e.pagination) : void 0), t
                },
                fromPartial(e) {
                    let t = c();
                    return t.grantee = e.grantee ? ? "", void 0 !== e.pagination && null !== e.pagination && (t.pagination = n.PageRequest.fromPartial(e.pagination)), t
                }
            }, t.QueryAllowancesResponse = {
                typeUrl: "/cosmos.feegrant.v1beta1.QueryAllowancesResponse",
                encode(e, t = i.BinaryWriter.create()) {
                    for (let r of e.allowances) o.Grant.encode(r, t.uint32(10).fork()).ldelim();
                    return void 0 !== e.pagination && n.PageResponse.encode(e.pagination, t.uint32(18).fork()).ldelim(), t
                },
                decode(e, t) {
                    let r = e instanceof i.BinaryReader ? e : new i.BinaryReader(e),
                        a = void 0 === t ? r.len : r.pos + t,
                        s = l();
                    for (; r.pos < a;) {
                        let e = r.uint32();
                        switch (e >>> 3) {
                            case 1:
                                s.allowances.push(o.Grant.decode(r, r.uint32()));
                                break;
                            case 2:
                                s.pagination = n.PageResponse.decode(r, r.uint32());
                                break;
                            default:
                                r.skipType(7 & e)
                        }
                    }
                    return s
                },
                fromJSON(e) {
                    let t = l();
                    return Array.isArray(e ? .allowances) && (t.allowances = e.allowances.map(e => o.Grant.fromJSON(e))), (0, a.isSet)(e.pagination) && (t.pagination = n.PageResponse.fromJSON(e.pagination)), t
                },
                toJSON(e) {
                    let t = {};
                    return e.allowances ? t.allowances = e.allowances.map(e => e ? o.Grant.toJSON(e) : void 0) : t.allowances = [], void 0 !== e.pagination && (t.pagination = e.pagination ? n.PageResponse.toJSON(e.pagination) : void 0), t
                },
                fromPartial(e) {
                    let t = l();
                    return t.allowances = e.allowances ? .map(e => o.Grant.fromPartial(e)) || [], void 0 !== e.pagination && null !== e.pagination && (t.pagination = n.PageResponse.fromPartial(e.pagination)), t
                }
            }, t.QueryAllowancesByGranterRequest = {
                typeUrl: "/cosmos.feegrant.v1beta1.QueryAllowancesByGranterRequest",
                encode: (e, t = i.BinaryWriter.create()) => ("" !== e.granter && t.uint32(10).string(e.granter), void 0 !== e.pagination && n.PageRequest.encode(e.pagination, t.uint32(18).fork()).ldelim(), t),
                decode(e, t) {
                    let r = e instanceof i.BinaryReader ? e : new i.BinaryReader(e),
                        o = void 0 === t ? r.len : r.pos + t,
                        a = u();
                    for (; r.pos < o;) {
                        let e = r.uint32();
                        switch (e >>> 3) {
                            case 1:
                                a.granter = r.string();
                                break;
                            case 2:
                                a.pagination = n.PageRequest.decode(r, r.uint32());
                                break;
                            default:
                                r.skipType(7 & e)
                        }
                    }
                    return a
                },
                fromJSON(e) {
                    let t = u();
                    return (0, a.isSet)(e.granter) && (t.granter = String(e.granter)), (0, a.isSet)(e.pagination) && (t.pagination = n.PageRequest.fromJSON(e.pagination)), t
                },
                toJSON(e) {
                    let t = {};
                    return void 0 !== e.granter && (t.granter = e.granter), void 0 !== e.pagination && (t.pagination = e.pagination ? n.PageRequest.toJSON(e.pagination) : void 0), t
                },
                fromPartial(e) {
                    let t = u();
                    return t.granter = e.granter ? ? "", void 0 !== e.pagination && null !== e.pagination && (t.pagination = n.PageRequest.fromPartial(e.pagination)), t
                }
            }, t.QueryAllowancesByGranterResponse = {
                typeUrl: "/cosmos.feegrant.v1beta1.QueryAllowancesByGranterResponse",
                encode(e, t = i.BinaryWriter.create()) {
                    for (let r of e.allowances) o.Grant.encode(r, t.uint32(10).fork()).ldelim();
                    return void 0 !== e.pagination && n.PageResponse.encode(e.pagination, t.uint32(18).fork()).ldelim(), t
                },
                decode(e, t) {
                    let r = e instanceof i.BinaryReader ? e : new i.BinaryReader(e),
                        a = void 0 === t ? r.len : r.pos + t,
                        s = p();
                    for (; r.pos < a;) {
                        let e = r.uint32();
                        switch (e >>> 3) {
                            case 1:
                                s.allowances.push(o.Grant.decode(r, r.uint32()));
                                break;
                            case 2:
                                s.pagination = n.PageResponse.decode(r, r.uint32());
                                break;
                            default:
                                r.skipType(7 & e)
                        }
                    }
                    return s
                },
                fromJSON(e) {
                    let t = p();
                    return Array.isArray(e ? .allowances) && (t.allowances = e.allowances.map(e => o.Grant.fromJSON(e))), (0, a.isSet)(e.pagination) && (t.pagination = n.PageResponse.fromJSON(e.pagination)), t
                },
                toJSON(e) {
                    let t = {};
                    return e.allowances ? t.allowances = e.allowances.map(e => e ? o.Grant.toJSON(e) : void 0) : t.allowances = [], void 0 !== e.pagination && (t.pagination = e.pagination ? n.PageResponse.toJSON(e.pagination) : void 0), t
                },
                fromPartial(e) {
                    let t = p();
                    return t.allowances = e.allowances ? .map(e => o.Grant.fromPartial(e)) || [], void 0 !== e.pagination && null !== e.pagination && (t.pagination = n.PageResponse.fromPartial(e.pagination)), t
                }
            };
            class m {
                constructor(e) {
                    this.rpc = e, this.Allowance = this.Allowance.bind(this), this.Allowances = this.Allowances.bind(this), this.AllowancesByGranter = this.AllowancesByGranter.bind(this)
                }
                Allowance(e) {
                    let r = t.QueryAllowanceRequest.encode(e).finish();
                    return this.rpc.request("cosmos.feegrant.v1beta1.Query", "Allowance", r).then(e => t.QueryAllowanceResponse.decode(new i.BinaryReader(e)))
                }
                Allowances(e) {
                    let r = t.QueryAllowancesRequest.encode(e).finish();
                    return this.rpc.request("cosmos.feegrant.v1beta1.Query", "Allowances", r).then(e => t.QueryAllowancesResponse.decode(new i.BinaryReader(e)))
                }
                AllowancesByGranter(e) {
                    let r = t.QueryAllowancesByGranterRequest.encode(e).finish();
                    return this.rpc.request("cosmos.feegrant.v1beta1.Query", "AllowancesByGranter", r).then(e => t.QueryAllowancesByGranterResponse.decode(new i.BinaryReader(e)))
                }
            }
            t.QueryClientImpl = m
        },
        71882: function(e, t, r) {
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: !0
            }), t.MsgClientImpl = t.MsgRevokeAllowanceResponse = t.MsgRevokeAllowance = t.MsgGrantAllowanceResponse = t.MsgGrantAllowance = t.protobufPackage = void 0;
            let n = r(65676),
                o = r(28486),
                i = r(6476);

            function a() {
                return {
                    granter: "",
                    grantee: "",
                    allowance: void 0
                }
            }

            function s() {
                return {
                    granter: "",
                    grantee: ""
                }
            }
            t.protobufPackage = "cosmos.feegrant.v1beta1", t.MsgGrantAllowance = {
                typeUrl: "/cosmos.feegrant.v1beta1.MsgGrantAllowance",
                encode: (e, t = o.BinaryWriter.create()) => ("" !== e.granter && t.uint32(10).string(e.granter), "" !== e.grantee && t.uint32(18).string(e.grantee), void 0 !== e.allowance && n.Any.encode(e.allowance, t.uint32(26).fork()).ldelim(), t),
                decode(e, t) {
                    let r = e instanceof o.BinaryReader ? e : new o.BinaryReader(e),
                        i = void 0 === t ? r.len : r.pos + t,
                        s = a();
                    for (; r.pos < i;) {
                        let e = r.uint32();
                        switch (e >>> 3) {
                            case 1:
                                s.granter = r.string();
                                break;
                            case 2:
                                s.grantee = r.string();
                                break;
                            case 3:
                                s.allowance = n.Any.decode(r, r.uint32());
                                break;
                            default:
                                r.skipType(7 & e)
                        }
                    }
                    return s
                },
                fromJSON(e) {
                    let t = a();
                    return (0, i.isSet)(e.granter) && (t.granter = String(e.granter)), (0, i.isSet)(e.grantee) && (t.grantee = String(e.grantee)), (0, i.isSet)(e.allowance) && (t.allowance = n.Any.fromJSON(e.allowance)), t
                },
                toJSON(e) {
                    let t = {};
                    return void 0 !== e.granter && (t.granter = e.granter), void 0 !== e.grantee && (t.grantee = e.grantee), void 0 !== e.allowance && (t.allowance = e.allowance ? n.Any.toJSON(e.allowance) : void 0), t
                },
                fromPartial(e) {
                    let t = a();
                    return t.granter = e.granter ? ? "", t.grantee = e.grantee ? ? "", void 0 !== e.allowance && null !== e.allowance && (t.allowance = n.Any.fromPartial(e.allowance)), t
                }
            }, t.MsgGrantAllowanceResponse = {
                typeUrl: "/cosmos.feegrant.v1beta1.MsgGrantAllowanceResponse",
                encode: (e, t = o.BinaryWriter.create()) => t,
                decode(e, t) {
                    let r = e instanceof o.BinaryReader ? e : new o.BinaryReader(e),
                        n = void 0 === t ? r.len : r.pos + t;
                    for (; r.pos < n;) {
                        let e = r.uint32();
                        r.skipType(7 & e)
                    }
                    return {}
                },
                fromJSON: e => ({}),
                toJSON: e => ({}),
                fromPartial: e => ({})
            }, t.MsgRevokeAllowance = {
                typeUrl: "/cosmos.feegrant.v1beta1.MsgRevokeAllowance",
                encode: (e, t = o.BinaryWriter.create()) => ("" !== e.granter && t.uint32(10).string(e.granter), "" !== e.grantee && t.uint32(18).string(e.grantee), t),
                decode(e, t) {
                    let r = e instanceof o.BinaryReader ? e : new o.BinaryReader(e),
                        n = void 0 === t ? r.len : r.pos + t,
                        i = s();
                    for (; r.pos < n;) {
                        let e = r.uint32();
                        switch (e >>> 3) {
                            case 1:
                                i.granter = r.string();
                                break;
                            case 2:
                                i.grantee = r.string();
                                break;
                            default:
                                r.skipType(7 & e)
                        }
                    }
                    return i
                },
                fromJSON(e) {
                    let t = s();
                    return (0, i.isSet)(e.granter) && (t.granter = String(e.granter)), (0, i.isSet)(e.grantee) && (t.grantee = String(e.grantee)), t
                },
                toJSON(e) {
                    let t = {};
                    return void 0 !== e.granter && (t.granter = e.granter), void 0 !== e.grantee && (t.grantee = e.grantee), t
                },
                fromPartial(e) {
                    let t = s();
                    return t.granter = e.granter ? ? "", t.grantee = e.grantee ? ? "", t
                }
            }, t.MsgRevokeAllowanceResponse = {
                typeUrl: "/cosmos.feegrant.v1beta1.MsgRevokeAllowanceResponse",
                encode: (e, t = o.BinaryWriter.create()) => t,
                decode(e, t) {
                    let r = e instanceof o.BinaryReader ? e : new o.BinaryReader(e),
                        n = void 0 === t ? r.len : r.pos + t;
                    for (; r.pos < n;) {
                        let e = r.uint32();
                        r.skipType(7 & e)
                    }
                    return {}
                },
                fromJSON: e => ({}),
                toJSON: e => ({}),
                fromPartial: e => ({})
            };
            class d {
                constructor(e) {
                    this.rpc = e, this.GrantAllowance = this.GrantAllowance.bind(this), this.RevokeAllowance = this.RevokeAllowance.bind(this)
                }
                GrantAllowance(e) {
                    let r = t.MsgGrantAllowance.encode(e).finish();
                    return this.rpc.request("cosmos.feegrant.v1beta1.Msg", "GrantAllowance", r).then(e => t.MsgGrantAllowanceResponse.decode(new o.BinaryReader(e)))
                }
                RevokeAllowance(e) {
                    let r = t.MsgRevokeAllowance.encode(e).finish();
                    return this.rpc.request("cosmos.feegrant.v1beta1.Msg", "RevokeAllowance", r).then(e => t.MsgRevokeAllowanceResponse.decode(new o.BinaryReader(e)))
                }
            }
            t.MsgClientImpl = d
        },
        42021: function(e, t, r) {
            "use strict";
            var n, o, i, a;
            Object.defineProperty(t, "__esModule", {
                value: !0
            }), t.Params = t.TallyParams = t.VotingParams = t.DepositParams = t.Vote = t.TallyResult = t.Proposal = t.Deposit = t.WeightedVoteOption = t.proposalStatusToJSON = t.proposalStatusFromJSON = t.ProposalStatus = t.voteOptionToJSON = t.voteOptionFromJSON = t.VoteOption = t.protobufPackage = void 0;
            let s = r(62809),
                d = r(65676),
                c = r(90614),
                l = r(69441),
                u = r(28486),
                p = r(6476);

            function m(e) {
                switch (e) {
                    case 0:
                    case "VOTE_OPTION_UNSPECIFIED":
                        return n.VOTE_OPTION_UNSPECIFIED;
                    case 1:
                    case "VOTE_OPTION_YES":
                        return n.VOTE_OPTION_YES;
                    case 2:
                    case "VOTE_OPTION_ABSTAIN":
                        return n.VOTE_OPTION_ABSTAIN;
                    case 3:
                    case "VOTE_OPTION_NO":
                        return n.VOTE_OPTION_NO;
                    case 4:
                    case "VOTE_OPTION_NO_WITH_VETO":
                        return n.VOTE_OPTION_NO_WITH_VETO;
                    default:
                        return n.UNRECOGNIZED
                }
            }

            function g(e) {
                switch (e) {
                    case n.VOTE_OPTION_UNSPECIFIED:
                        return "VOTE_OPTION_UNSPECIFIED";
                    case n.VOTE_OPTION_YES:
                        return "VOTE_OPTION_YES";
                    case n.VOTE_OPTION_ABSTAIN:
                        return "VOTE_OPTION_ABSTAIN";
                    case n.VOTE_OPTION_NO:
                        return "VOTE_OPTION_NO";
                    case n.VOTE_OPTION_NO_WITH_VETO:
                        return "VOTE_OPTION_NO_WITH_VETO";
                    case n.UNRECOGNIZED:
                    default:
                        return "UNRECOGNIZED"
                }
            }

            function f(e) {
                switch (e) {
                    case 0:
                    case "PROPOSAL_STATUS_UNSPECIFIED":
                        return o.PROPOSAL_STATUS_UNSPECIFIED;
                    case 1:
                    case "PROPOSAL_STATUS_DEPOSIT_PERIOD":
                        return o.PROPOSAL_STATUS_DEPOSIT_PERIOD;
                    case 2:
                    case "PROPOSAL_STATUS_VOTING_PERIOD":
                        return o.PROPOSAL_STATUS_VOTING_PERIOD;
                    case 3:
                    case "PROPOSAL_STATUS_PASSED":
                        return o.PROPOSAL_STATUS_PASSED;
                    case 4:
                    case "PROPOSAL_STATUS_REJECTED":
                        return o.PROPOSAL_STATUS_REJECTED;
                    case 5:
                    case "PROPOSAL_STATUS_FAILED":
                        return o.PROPOSAL_STATUS_FAILED;
                    default:
                        return o.UNRECOGNIZED
                }
            }

            function y(e) {
                switch (e) {
                    case o.PROPOSAL_STATUS_UNSPECIFIED:
                        return "PROPOSAL_STATUS_UNSPECIFIED";
                    case o.PROPOSAL_STATUS_DEPOSIT_PERIOD:
                        return "PROPOSAL_STATUS_DEPOSIT_PERIOD";
                    case o.PROPOSAL_STATUS_VOTING_PERIOD:
                        return "PROPOSAL_STATUS_VOTING_PERIOD";
                    case o.PROPOSAL_STATUS_PASSED:
                        return "PROPOSAL_STATUS_PASSED";
                    case o.PROPOSAL_STATUS_REJECTED:
                        return "PROPOSAL_STATUS_REJECTED";
                    case o.PROPOSAL_STATUS_FAILED:
                        return "PROPOSAL_STATUS_FAILED";
                    case o.UNRECOGNIZED:
                    default:
                        return "UNRECOGNIZED"
                }
            }

            function h() {
                return {
                    option: 0,
                    weight: ""
                }
            }

            function v() {
                return {
                    proposalId: BigInt(0),
                    depositor: "",
                    amount: []
                }
            }

            function b() {
                return {
                    id: BigInt(0),
                    messages: [],
                    status: 0,
                    finalTallyResult: void 0,
                    submitTime: void 0,
                    depositEndTime: void 0,
                    totalDeposit: [],
                    votingStartTime: void 0,
                    votingEndTime: void 0,
                    metadata: "",
                    title: "",
                    summary: "",
                    proposer: ""
                }
            }

            function S() {
                return {
                    yesCount: "",
                    abstainCount: "",
                    noCount: "",
                    noWithVetoCount: ""
                }
            }

            function k() {
                return {
                    proposalId: BigInt(0),
                    voter: "",
                    options: [],
                    metadata: ""
                }
            }

            function P() {
                return {
                    minDeposit: [],
                    maxDepositPeriod: void 0
                }
            }

            function _() {
                return {
                    votingPeriod: void 0
                }
            }

            function B() {
                return {
                    quorum: "",
                    threshold: "",
                    vetoThreshold: ""
                }
            }

            function O() {
                return {
                    minDeposit: [],
                    maxDepositPeriod: void 0,
                    votingPeriod: void 0,
                    quorum: "",
                    threshold: "",
                    vetoThreshold: "",
                    minInitialDepositRatio: "",
                    burnVoteQuorum: !1,
                    burnProposalDepositPrevote: !1,
                    burnVoteVeto: !1
                }
            }
            t.protobufPackage = "cosmos.gov.v1", (i = n || (t.VoteOption = n = {}))[i.VOTE_OPTION_UNSPECIFIED = 0] = "VOTE_OPTION_UNSPECIFIED", i[i.VOTE_OPTION_YES = 1] = "VOTE_OPTION_YES", i[i.VOTE_OPTION_ABSTAIN = 2] = "VOTE_OPTION_ABSTAIN", i[i.VOTE_OPTION_NO = 3] = "VOTE_OPTION_NO", i[i.VOTE_OPTION_NO_WITH_VETO = 4] = "VOTE_OPTION_NO_WITH_VETO", i[i.UNRECOGNIZED = -1] = "UNRECOGNIZED", t.voteOptionFromJSON = m, t.voteOptionToJSON = g, (a = o || (t.ProposalStatus = o = {}))[a.PROPOSAL_STATUS_UNSPECIFIED = 0] = "PROPOSAL_STATUS_UNSPECIFIED", a[a.PROPOSAL_STATUS_DEPOSIT_PERIOD = 1] = "PROPOSAL_STATUS_DEPOSIT_PERIOD", a[a.PROPOSAL_STATUS_VOTING_PERIOD = 2] = "PROPOSAL_STATUS_VOTING_PERIOD", a[a.PROPOSAL_STATUS_PASSED = 3] = "PROPOSAL_STATUS_PASSED", a[a.PROPOSAL_STATUS_REJECTED = 4] = "PROPOSAL_STATUS_REJECTED", a[a.PROPOSAL_STATUS_FAILED = 5] = "PROPOSAL_STATUS_FAILED", a[a.UNRECOGNIZED = -1] = "UNRECOGNIZED", t.proposalStatusFromJSON = f, t.proposalStatusToJSON = y, t.WeightedVoteOption = {
                typeUrl: "/cosmos.gov.v1.WeightedVoteOption",
                encode: (e, t = u.BinaryWriter.create()) => (0 !== e.option && t.uint32(8).int32(e.option), "" !== e.weight && t.uint32(18).string(e.weight), t),
                decode(e, t) {
                    let r = e instanceof u.BinaryReader ? e : new u.BinaryReader(e),
                        n = void 0 === t ? r.len : r.pos + t,
                        o = h();
                    for (; r.pos < n;) {
                        let e = r.uint32();
                        switch (e >>> 3) {
                            case 1:
                                o.option = r.int32();
                                break;
                            case 2:
                                o.weight = r.string();
                                break;
                            default:
                                r.skipType(7 & e)
                        }
                    }
                    return o
                },
                fromJSON(e) {
                    let t = h();
                    return (0, p.isSet)(e.option) && (t.option = m(e.option)), (0, p.isSet)(e.weight) && (t.weight = String(e.weight)), t
                },
                toJSON(e) {
                    let t = {};
                    return void 0 !== e.option && (t.option = g(e.option)), void 0 !== e.weight && (t.weight = e.weight), t
                },
                fromPartial(e) {
                    let t = h();
                    return t.option = e.option ? ? 0, t.weight = e.weight ? ? "", t
                }
            }, t.Deposit = {
                typeUrl: "/cosmos.gov.v1.Deposit",
                encode(e, t = u.BinaryWriter.create()) {
                    for (let r of (e.proposalId !== BigInt(0) && t.uint32(8).uint64(e.proposalId), "" !== e.depositor && t.uint32(18).string(e.depositor), e.amount)) s.Coin.encode(r, t.uint32(26).fork()).ldelim();
                    return t
                },
                decode(e, t) {
                    let r = e instanceof u.BinaryReader ? e : new u.BinaryReader(e),
                        n = void 0 === t ? r.len : r.pos + t,
                        o = v();
                    for (; r.pos < n;) {
                        let e = r.uint32();
                        switch (e >>> 3) {
                            case 1:
                                o.proposalId = r.uint64();
                                break;
                            case 2:
                                o.depositor = r.string();
                                break;
                            case 3:
                                o.amount.push(s.Coin.decode(r, r.uint32()));
                                break;
                            default:
                                r.skipType(7 & e)
                        }
                    }
                    return o
                },
                fromJSON(e) {
                    let t = v();
                    return (0, p.isSet)(e.proposalId) && (t.proposalId = BigInt(e.proposalId.toString())), (0, p.isSet)(e.depositor) && (t.depositor = String(e.depositor)), Array.isArray(e ? .amount) && (t.amount = e.amount.map(e => s.Coin.fromJSON(e))), t
                },
                toJSON(e) {
                    let t = {};
                    return void 0 !== e.proposalId && (t.proposalId = (e.proposalId || BigInt(0)).toString()), void 0 !== e.depositor && (t.depositor = e.depositor), e.amount ? t.amount = e.amount.map(e => e ? s.Coin.toJSON(e) : void 0) : t.amount = [], t
                },
                fromPartial(e) {
                    let t = v();
                    return void 0 !== e.proposalId && null !== e.proposalId && (t.proposalId = BigInt(e.proposalId.toString())), t.depositor = e.depositor ? ? "", t.amount = e.amount ? .map(e => s.Coin.fromPartial(e)) || [], t
                }
            }, t.Proposal = {
                typeUrl: "/cosmos.gov.v1.Proposal",
                encode(e, r = u.BinaryWriter.create()) {
                    for (let t of (e.id !== BigInt(0) && r.uint32(8).uint64(e.id), e.messages)) d.Any.encode(t, r.uint32(18).fork()).ldelim();
                    for (let n of (0 !== e.status && r.uint32(24).int32(e.status), void 0 !== e.finalTallyResult && t.TallyResult.encode(e.finalTallyResult, r.uint32(34).fork()).ldelim(), void 0 !== e.submitTime && c.Timestamp.encode(e.submitTime, r.uint32(42).fork()).ldelim(), void 0 !== e.depositEndTime && c.Timestamp.encode(e.depositEndTime, r.uint32(50).fork()).ldelim(), e.totalDeposit)) s.Coin.encode(n, r.uint32(58).fork()).ldelim();
                    return void 0 !== e.votingStartTime && c.Timestamp.encode(e.votingStartTime, r.uint32(66).fork()).ldelim(), void 0 !== e.votingEndTime && c.Timestamp.encode(e.votingEndTime, r.uint32(74).fork()).ldelim(), "" !== e.metadata && r.uint32(82).string(e.metadata), "" !== e.title && r.uint32(90).string(e.title), "" !== e.summary && r.uint32(98).string(e.summary), "" !== e.proposer && r.uint32(106).string(e.proposer), r
                },
                decode(e, r) {
                    let n = e instanceof u.BinaryReader ? e : new u.BinaryReader(e),
                        o = void 0 === r ? n.len : n.pos + r,
                        i = b();
                    for (; n.pos < o;) {
                        let e = n.uint32();
                        switch (e >>> 3) {
                            case 1:
                                i.id = n.uint64();
                                break;
                            case 2:
                                i.messages.push(d.Any.decode(n, n.uint32()));
                                break;
                            case 3:
                                i.status = n.int32();
                                break;
                            case 4:
                                i.finalTallyResult = t.TallyResult.decode(n, n.uint32());
                                break;
                            case 5:
                                i.submitTime = c.Timestamp.decode(n, n.uint32());
                                break;
                            case 6:
                                i.depositEndTime = c.Timestamp.decode(n, n.uint32());
                                break;
                            case 7:
                                i.totalDeposit.push(s.Coin.decode(n, n.uint32()));
                                break;
                            case 8:
                                i.votingStartTime = c.Timestamp.decode(n, n.uint32());
                                break;
                            case 9:
                                i.votingEndTime = c.Timestamp.decode(n, n.uint32());
                                break;
                            case 10:
                                i.metadata = n.string();
                                break;
                            case 11:
                                i.title = n.string();
                                break;
                            case 12:
                                i.summary = n.string();
                                break;
                            case 13:
                                i.proposer = n.string();
                                break;
                            default:
                                n.skipType(7 & e)
                        }
                    }
                    return i
                },
                fromJSON(e) {
                    let r = b();
                    return (0, p.isSet)(e.id) && (r.id = BigInt(e.id.toString())), Array.isArray(e ? .messages) && (r.messages = e.messages.map(e => d.Any.fromJSON(e))), (0, p.isSet)(e.status) && (r.status = f(e.status)), (0, p.isSet)(e.finalTallyResult) && (r.finalTallyResult = t.TallyResult.fromJSON(e.finalTallyResult)), (0, p.isSet)(e.submitTime) && (r.submitTime = (0, p.fromJsonTimestamp)(e.submitTime)), (0, p.isSet)(e.depositEndTime) && (r.depositEndTime = (0, p.fromJsonTimestamp)(e.depositEndTime)), Array.isArray(e ? .totalDeposit) && (r.totalDeposit = e.totalDeposit.map(e => s.Coin.fromJSON(e))), (0, p.isSet)(e.votingStartTime) && (r.votingStartTime = (0, p.fromJsonTimestamp)(e.votingStartTime)), (0, p.isSet)(e.votingEndTime) && (r.votingEndTime = (0, p.fromJsonTimestamp)(e.votingEndTime)), (0, p.isSet)(e.metadata) && (r.metadata = String(e.metadata)), (0, p.isSet)(e.title) && (r.title = String(e.title)), (0, p.isSet)(e.summary) && (r.summary = String(e.summary)), (0, p.isSet)(e.proposer) && (r.proposer = String(e.proposer)), r
                },
                toJSON(e) {
                    let r = {};
                    return void 0 !== e.id && (r.id = (e.id || BigInt(0)).toString()), e.messages ? r.messages = e.messages.map(e => e ? d.Any.toJSON(e) : void 0) : r.messages = [], void 0 !== e.status && (r.status = y(e.status)), void 0 !== e.finalTallyResult && (r.finalTallyResult = e.finalTallyResult ? t.TallyResult.toJSON(e.finalTallyResult) : void 0), void 0 !== e.submitTime && (r.submitTime = (0, p.fromTimestamp)(e.submitTime).toISOString()), void 0 !== e.depositEndTime && (r.depositEndTime = (0, p.fromTimestamp)(e.depositEndTime).toISOString()), e.totalDeposit ? r.totalDeposit = e.totalDeposit.map(e => e ? s.Coin.toJSON(e) : void 0) : r.totalDeposit = [], void 0 !== e.votingStartTime && (r.votingStartTime = (0, p.fromTimestamp)(e.votingStartTime).toISOString()), void 0 !== e.votingEndTime && (r.votingEndTime = (0, p.fromTimestamp)(e.votingEndTime).toISOString()), void 0 !== e.metadata && (r.metadata = e.metadata), void 0 !== e.title && (r.title = e.title), void 0 !== e.summary && (r.summary = e.summary), void 0 !== e.proposer && (r.proposer = e.proposer), r
                },
                fromPartial(e) {
                    let r = b();
                    return void 0 !== e.id && null !== e.id && (r.id = BigInt(e.id.toString())), r.messages = e.messages ? .map(e => d.Any.fromPartial(e)) || [], r.status = e.status ? ? 0, void 0 !== e.finalTallyResult && null !== e.finalTallyResult && (r.finalTallyResult = t.TallyResult.fromPartial(e.finalTallyResult)), void 0 !== e.submitTime && null !== e.submitTime && (r.submitTime = c.Timestamp.fromPartial(e.submitTime)), void 0 !== e.depositEndTime && null !== e.depositEndTime && (r.depositEndTime = c.Timestamp.fromPartial(e.depositEndTime)), r.totalDeposit = e.totalDeposit ? .map(e => s.Coin.fromPartial(e)) || [], void 0 !== e.votingStartTime && null !== e.votingStartTime && (r.votingStartTime = c.Timestamp.fromPartial(e.votingStartTime)), void 0 !== e.votingEndTime && null !== e.votingEndTime && (r.votingEndTime = c.Timestamp.fromPartial(e.votingEndTime)), r.metadata = e.metadata ? ? "", r.title = e.title ? ? "", r.summary = e.summary ? ? "", r.proposer = e.proposer ? ? "", r
                }
            }, t.TallyResult = {
                typeUrl: "/cosmos.gov.v1.TallyResult",
                encode: (e, t = u.BinaryWriter.create()) => ("" !== e.yesCount && t.uint32(10).string(e.yesCount), "" !== e.abstainCount && t.uint32(18).string(e.abstainCount), "" !== e.noCount && t.uint32(26).string(e.noCount), "" !== e.noWithVetoCount && t.uint32(34).string(e.noWithVetoCount), t),
                decode(e, t) {
                    let r = e instanceof u.BinaryReader ? e : new u.BinaryReader(e),
                        n = void 0 === t ? r.len : r.pos + t,
                        o = S();
                    for (; r.pos < n;) {
                        let e = r.uint32();
                        switch (e >>> 3) {
                            case 1:
                                o.yesCount = r.string();
                                break;
                            case 2:
                                o.abstainCount = r.string();
                                break;
                            case 3:
                                o.noCount = r.string();
                                break;
                            case 4:
                                o.noWithVetoCount = r.string();
                                break;
                            default:
                                r.skipType(7 & e)
                        }
                    }
                    return o
                },
                fromJSON(e) {
                    let t = S();
                    return (0, p.isSet)(e.yesCount) && (t.yesCount = String(e.yesCount)), (0, p.isSet)(e.abstainCount) && (t.abstainCount = String(e.abstainCount)), (0, p.isSet)(e.noCount) && (t.noCount = String(e.noCount)), (0, p.isSet)(e.noWithVetoCount) && (t.noWithVetoCount = String(e.noWithVetoCount)), t
                },
                toJSON(e) {
                    let t = {};
                    return void 0 !== e.yesCount && (t.yesCount = e.yesCount), void 0 !== e.abstainCount && (t.abstainCount = e.abstainCount), void 0 !== e.noCount && (t.noCount = e.noCount), void 0 !== e.noWithVetoCount && (t.noWithVetoCount = e.noWithVetoCount), t
                },
                fromPartial(e) {
                    let t = S();
                    return t.yesCount = e.yesCount ? ? "", t.abstainCount = e.abstainCount ? ? "", t.noCount = e.noCount ? ? "", t.noWithVetoCount = e.noWithVetoCount ? ? "", t
                }
            }, t.Vote = {
                typeUrl: "/cosmos.gov.v1.Vote",
                encode(e, r = u.BinaryWriter.create()) {
                    for (let n of (e.proposalId !== BigInt(0) && r.uint32(8).uint64(e.proposalId), "" !== e.voter && r.uint32(18).string(e.voter), e.options)) t.WeightedVoteOption.encode(n, r.uint32(34).fork()).ldelim();
                    return "" !== e.metadata && r.uint32(42).string(e.metadata), r
                },
                decode(e, r) {
                    let n = e instanceof u.BinaryReader ? e : new u.BinaryReader(e),
                        o = void 0 === r ? n.len : n.pos + r,
                        i = k();
                    for (; n.pos < o;) {
                        let e = n.uint32();
                        switch (e >>> 3) {
                            case 1:
                                i.proposalId = n.uint64();
                                break;
                            case 2:
                                i.voter = n.string();
                                break;
                            case 4:
                                i.options.push(t.WeightedVoteOption.decode(n, n.uint32()));
                                break;
                            case 5:
                                i.metadata = n.string();
                                break;
                            default:
                                n.skipType(7 & e)
                        }
                    }
                    return i
                },
                fromJSON(e) {
                    let r = k();
                    return (0, p.isSet)(e.proposalId) && (r.proposalId = BigInt(e.proposalId.toString())), (0, p.isSet)(e.voter) && (r.voter = String(e.voter)), Array.isArray(e ? .options) && (r.options = e.options.map(e => t.WeightedVoteOption.fromJSON(e))), (0, p.isSet)(e.metadata) && (r.metadata = String(e.metadata)), r
                },
                toJSON(e) {
                    let r = {};
                    return void 0 !== e.proposalId && (r.proposalId = (e.proposalId || BigInt(0)).toString()), void 0 !== e.voter && (r.voter = e.voter), e.options ? r.options = e.options.map(e => e ? t.WeightedVoteOption.toJSON(e) : void 0) : r.options = [], void 0 !== e.metadata && (r.metadata = e.metadata), r
                },
                fromPartial(e) {
                    let r = k();
                    return void 0 !== e.proposalId && null !== e.proposalId && (r.proposalId = BigInt(e.proposalId.toString())), r.voter = e.voter ? ? "", r.options = e.options ? .map(e => t.WeightedVoteOption.fromPartial(e)) || [], r.metadata = e.metadata ? ? "", r
                }
            }, t.DepositParams = {
                typeUrl: "/cosmos.gov.v1.DepositParams",
                encode(e, t = u.BinaryWriter.create()) {
                    for (let r of e.minDeposit) s.Coin.encode(r, t.uint32(10).fork()).ldelim();
                    return void 0 !== e.maxDepositPeriod && l.Duration.encode(e.maxDepositPeriod, t.uint32(18).fork()).ldelim(), t
                },
                decode(e, t) {
                    let r = e instanceof u.BinaryReader ? e : new u.BinaryReader(e),
                        n = void 0 === t ? r.len : r.pos + t,
                        o = P();
                    for (; r.pos < n;) {
                        let e = r.uint32();
                        switch (e >>> 3) {
                            case 1:
                                o.minDeposit.push(s.Coin.decode(r, r.uint32()));
                                break;
                            case 2:
                                o.maxDepositPeriod = l.Duration.decode(r, r.uint32());
                                break;
                            default:
                                r.skipType(7 & e)
                        }
                    }
                    return o
                },
                fromJSON(e) {
                    let t = P();
                    return Array.isArray(e ? .minDeposit) && (t.minDeposit = e.minDeposit.map(e => s.Coin.fromJSON(e))), (0, p.isSet)(e.maxDepositPeriod) && (t.maxDepositPeriod = l.Duration.fromJSON(e.maxDepositPeriod)), t
                },
                toJSON(e) {
                    let t = {};
                    return e.minDeposit ? t.minDeposit = e.minDeposit.map(e => e ? s.Coin.toJSON(e) : void 0) : t.minDeposit = [], void 0 !== e.maxDepositPeriod && (t.maxDepositPeriod = e.maxDepositPeriod ? l.Duration.toJSON(e.maxDepositPeriod) : void 0), t
                },
                fromPartial(e) {
                    let t = P();
                    return t.minDeposit = e.minDeposit ? .map(e => s.Coin.fromPartial(e)) || [], void 0 !== e.maxDepositPeriod && null !== e.maxDepositPeriod && (t.maxDepositPeriod = l.Duration.fromPartial(e.maxDepositPeriod)), t
                }
            }, t.VotingParams = {
                typeUrl: "/cosmos.gov.v1.VotingParams",
                encode: (e, t = u.BinaryWriter.create()) => (void 0 !== e.votingPeriod && l.Duration.encode(e.votingPeriod, t.uint32(10).fork()).ldelim(), t),
                decode(e, t) {
                    let r = e instanceof u.BinaryReader ? e : new u.BinaryReader(e),
                        n = void 0 === t ? r.len : r.pos + t,
                        o = _();
                    for (; r.pos < n;) {
                        let e = r.uint32();
                        e >>> 3 == 1 ? o.votingPeriod = l.Duration.decode(r, r.uint32()) : r.skipType(7 & e)
                    }
                    return o
                },
                fromJSON(e) {
                    let t = _();
                    return (0, p.isSet)(e.votingPeriod) && (t.votingPeriod = l.Duration.fromJSON(e.votingPeriod)), t
                },
                toJSON(e) {
                    let t = {};
                    return void 0 !== e.votingPeriod && (t.votingPeriod = e.votingPeriod ? l.Duration.toJSON(e.votingPeriod) : void 0), t
                },
                fromPartial(e) {
                    let t = _();
                    return void 0 !== e.votingPeriod && null !== e.votingPeriod && (t.votingPeriod = l.Duration.fromPartial(e.votingPeriod)), t
                }
            }, t.TallyParams = {
                typeUrl: "/cosmos.gov.v1.TallyParams",
                encode: (e, t = u.BinaryWriter.create()) => ("" !== e.quorum && t.uint32(10).string(e.quorum), "" !== e.threshold && t.uint32(18).string(e.threshold), "" !== e.vetoThreshold && t.uint32(26).string(e.vetoThreshold), t),
                decode(e, t) {
                    let r = e instanceof u.BinaryReader ? e : new u.BinaryReader(e),
                        n = void 0 === t ? r.len : r.pos + t,
                        o = B();
                    for (; r.pos < n;) {
                        let e = r.uint32();
                        switch (e >>> 3) {
                            case 1:
                                o.quorum = r.string();
                                break;
                            case 2:
                                o.threshold = r.string();
                                break;
                            case 3:
                                o.vetoThreshold = r.string();
                                break;
                            default:
                                r.skipType(7 & e)
                        }
                    }
                    return o
                },
                fromJSON(e) {
                    let t = B();
                    return (0, p.isSet)(e.quorum) && (t.quorum = String(e.quorum)), (0, p.isSet)(e.threshold) && (t.threshold = String(e.threshold)), (0, p.isSet)(e.vetoThreshold) && (t.vetoThreshold = String(e.vetoThreshold)), t
                },
                toJSON(e) {
                    let t = {};
                    return void 0 !== e.quorum && (t.quorum = e.quorum), void 0 !== e.threshold && (t.threshold = e.threshold), void 0 !== e.vetoThreshold && (t.vetoThreshold = e.vetoThreshold), t
                },
                fromPartial(e) {
                    let t = B();
                    return t.quorum = e.quorum ? ? "", t.threshold = e.threshold ? ? "", t.vetoThreshold = e.vetoThreshold ? ? "", t
                }
            }, t.Params = {
                typeUrl: "/cosmos.gov.v1.Params",
                encode(e, t = u.BinaryWriter.create()) {
                    for (let r of e.minDeposit) s.Coin.encode(r, t.uint32(10).fork()).ldelim();
                    return void 0 !== e.maxDepositPeriod && l.Duration.encode(e.maxDepositPeriod, t.uint32(18).fork()).ldelim(), void 0 !== e.votingPeriod && l.Duration.encode(e.votingPeriod, t.uint32(26).fork()).ldelim(), "" !== e.quorum && t.uint32(34).string(e.quorum), "" !== e.threshold && t.uint32(42).string(e.threshold), "" !== e.vetoThreshold && t.uint32(50).string(e.vetoThreshold), "" !== e.minInitialDepositRatio && t.uint32(58).string(e.minInitialDepositRatio), !0 === e.burnVoteQuorum && t.uint32(104).bool(e.burnVoteQuorum), !0 === e.burnProposalDepositPrevote && t.uint32(112).bool(e.burnProposalDepositPrevote), !0 === e.burnVoteVeto && t.uint32(120).bool(e.burnVoteVeto), t
                },
                decode(e, t) {
                    let r = e instanceof u.BinaryReader ? e : new u.BinaryReader(e),
                        n = void 0 === t ? r.len : r.pos + t,
                        o = O();
                    for (; r.pos < n;) {
                        let e = r.uint32();
                        switch (e >>> 3) {
                            case 1:
                                o.minDeposit.push(s.Coin.decode(r, r.uint32()));
                                break;
                            case 2:
                                o.maxDepositPeriod = l.Duration.decode(r, r.uint32());
                                break;
                            case 3:
                                o.votingPeriod = l.Duration.decode(r, r.uint32());
                                break;
                            case 4:
                                o.quorum = r.string();
                                break;
                            case 5:
                                o.threshold = r.string();
                                break;
                            case 6:
                                o.vetoThreshold = r.string();
                                break;
                            case 7:
                                o.minInitialDepositRatio = r.string();
                                break;
                            case 13:
                                o.burnVoteQuorum = r.bool();
                                break;
                            case 14:
                                o.burnProposalDepositPrevote = r.bool();
                                break;
                            case 15:
                                o.burnVoteVeto = r.bool();
                                break;
                            default:
                                r.skipType(7 & e)
                        }
                    }
                    return o
                },
                fromJSON(e) {
                    let t = O();
                    return Array.isArray(e ? .minDeposit) && (t.minDeposit = e.minDeposit.map(e => s.Coin.fromJSON(e))), (0, p.isSet)(e.maxDepositPeriod) && (t.maxDepositPeriod = l.Duration.fromJSON(e.maxDepositPeriod)), (0, p.isSet)(e.votingPeriod) && (t.votingPeriod = l.Duration.fromJSON(e.votingPeriod)), (0, p.isSet)(e.quorum) && (t.quorum = String(e.quorum)), (0, p.isSet)(e.threshold) && (t.threshold = String(e.threshold)), (0, p.isSet)(e.vetoThreshold) && (t.vetoThreshold = String(e.vetoThreshold)), (0, p.isSet)(e.minInitialDepositRatio) && (t.minInitialDepositRatio = String(e.minInitialDepositRatio)), (0, p.isSet)(e.burnVoteQuorum) && (t.burnVoteQuorum = !!e.burnVoteQuorum), (0, p.isSet)(e.burnProposalDepositPrevote) && (t.burnProposalDepositPrevote = !!e.burnProposalDepositPrevote), (0, p.isSet)(e.burnVoteVeto) && (t.burnVoteVeto = !!e.burnVoteVeto), t
                },
                toJSON(e) {
                    let t = {};
                    return e.minDeposit ? t.minDeposit = e.minDeposit.map(e => e ? s.Coin.toJSON(e) : void 0) : t.minDeposit = [], void 0 !== e.maxDepositPeriod && (t.maxDepositPeriod = e.maxDepositPeriod ? l.Duration.toJSON(e.maxDepositPeriod) : void 0), void 0 !== e.votingPeriod && (t.votingPeriod = e.votingPeriod ? l.Duration.toJSON(e.votingPeriod) : void 0), void 0 !== e.quorum && (t.quorum = e.quorum), void 0 !== e.threshold && (t.threshold = e.threshold), void 0 !== e.vetoThreshold && (t.vetoThreshold = e.vetoThreshold), void 0 !== e.minInitialDepositRatio && (t.minInitialDepositRatio = e.minInitialDepositRatio), void 0 !== e.burnVoteQuorum && (t.burnVoteQuorum = e.burnVoteQuorum), void 0 !== e.burnProposalDepositPrevote && (t.burnProposalDepositPrevote = e.burnProposalDepositPrevote), void 0 !== e.burnVoteVeto && (t.burnVoteVeto = e.burnVoteVeto), t
                },
                fromPartial(e) {
                    let t = O();
                    return t.minDeposit = e.minDeposit ? .map(e => s.Coin.fromPartial(e)) || [], void 0 !== e.maxDepositPeriod && null !== e.maxDepositPeriod && (t.maxDepositPeriod = l.Duration.fromPartial(e.maxDepositPeriod)), void 0 !== e.votingPeriod && null !== e.votingPeriod && (t.votingPeriod = l.Duration.fromPartial(e.votingPeriod)), t.quorum = e.quorum ? ? "", t.threshold = e.threshold ? ? "", t.vetoThreshold = e.vetoThreshold ? ? "", t.minInitialDepositRatio = e.minInitialDepositRatio ? ? "", t.burnVoteQuorum = e.burnVoteQuorum ? ? !1, t.burnProposalDepositPrevote = e.burnProposalDepositPrevote ? ? !1, t.burnVoteVeto = e.burnVoteVeto ? ? !1, t
                }
            }
        },
        63406: function(e, t, r) {
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: !0
            }), t.MsgClientImpl = t.MsgUpdateParamsResponse = t.MsgUpdateParams = t.MsgDepositResponse = t.MsgDeposit = t.MsgVoteWeightedResponse = t.MsgVoteWeighted = t.MsgVoteResponse = t.MsgVote = t.MsgExecLegacyContentResponse = t.MsgExecLegacyContent = t.MsgSubmitProposalResponse = t.MsgSubmitProposal = t.protobufPackage = void 0;
            let n = r(65676),
                o = r(62809),
                i = r(42021),
                a = r(28486),
                s = r(6476);

            function d() {
                return {
                    messages: [],
                    initialDeposit: [],
                    proposer: "",
                    metadata: "",
                    title: "",
                    summary: ""
                }
            }

            function c() {
                return {
                    proposalId: BigInt(0)
                }
            }

            function l() {
                return {
                    content: void 0,
                    authority: ""
                }
            }

            function u() {
                return {
                    proposalId: BigInt(0),
                    voter: "",
                    option: 0,
                    metadata: ""
                }
            }

            function p() {
                return {
                    proposalId: BigInt(0),
                    voter: "",
                    options: [],
                    metadata: ""
                }
            }

            function m() {
                return {
                    proposalId: BigInt(0),
                    depositor: "",
                    amount: []
                }
            }

            function g() {
                return {
                    authority: "",
                    params: i.Params.fromPartial({})
                }
            }
            t.protobufPackage = "cosmos.gov.v1", t.MsgSubmitProposal = {
                typeUrl: "/cosmos.gov.v1.MsgSubmitProposal",
                encode(e, t = a.BinaryWriter.create()) {
                    for (let r of e.messages) n.Any.encode(r, t.uint32(10).fork()).ldelim();
                    for (let r of e.initialDeposit) o.Coin.encode(r, t.uint32(18).fork()).ldelim();
                    return "" !== e.proposer && t.uint32(26).string(e.proposer), "" !== e.metadata && t.uint32(34).string(e.metadata), "" !== e.title && t.uint32(42).string(e.title), "" !== e.summary && t.uint32(50).string(e.summary), t
                },
                decode(e, t) {
                    let r = e instanceof a.BinaryReader ? e : new a.BinaryReader(e),
                        i = void 0 === t ? r.len : r.pos + t,
                        s = d();
                    for (; r.pos < i;) {
                        let e = r.uint32();
                        switch (e >>> 3) {
                            case 1:
                                s.messages.push(n.Any.decode(r, r.uint32()));
                                break;
                            case 2:
                                s.initialDeposit.push(o.Coin.decode(r, r.uint32()));
                                break;
                            case 3:
                                s.proposer = r.string();
                                break;
                            case 4:
                                s.metadata = r.string();
                                break;
                            case 5:
                                s.title = r.string();
                                break;
                            case 6:
                                s.summary = r.string();
                                break;
                            default:
                                r.skipType(7 & e)
                        }
                    }
                    return s
                },
                fromJSON(e) {
                    let t = d();
                    return Array.isArray(e ? .messages) && (t.messages = e.messages.map(e => n.Any.fromJSON(e))), Array.isArray(e ? .initialDeposit) && (t.initialDeposit = e.initialDeposit.map(e => o.Coin.fromJSON(e))), (0, s.isSet)(e.proposer) && (t.proposer = String(e.proposer)), (0, s.isSet)(e.metadata) && (t.metadata = String(e.metadata)), (0, s.isSet)(e.title) && (t.title = String(e.title)), (0, s.isSet)(e.summary) && (t.summary = String(e.summary)), t
                },
                toJSON(e) {
                    let t = {};
                    return e.messages ? t.messages = e.messages.map(e => e ? n.Any.toJSON(e) : void 0) : t.messages = [], e.initialDeposit ? t.initialDeposit = e.initialDeposit.map(e => e ? o.Coin.toJSON(e) : void 0) : t.initialDeposit = [], void 0 !== e.proposer && (t.proposer = e.proposer), void 0 !== e.metadata && (t.metadata = e.metadata), void 0 !== e.title && (t.title = e.title), void 0 !== e.summary && (t.summary = e.summary), t
                },
                fromPartial(e) {
                    let t = d();
                    return t.messages = e.messages ? .map(e => n.Any.fromPartial(e)) || [], t.initialDeposit = e.initialDeposit ? .map(e => o.Coin.fromPartial(e)) || [], t.proposer = e.proposer ? ? "", t.metadata = e.metadata ? ? "", t.title = e.title ? ? "", t.summary = e.summary ? ? "", t
                }
            }, t.MsgSubmitProposalResponse = {
                typeUrl: "/cosmos.gov.v1.MsgSubmitProposalResponse",
                encode: (e, t = a.BinaryWriter.create()) => (e.proposalId !== BigInt(0) && t.uint32(8).uint64(e.proposalId), t),
                decode(e, t) {
                    let r = e instanceof a.BinaryReader ? e : new a.BinaryReader(e),
                        n = void 0 === t ? r.len : r.pos + t,
                        o = c();
                    for (; r.pos < n;) {
                        let e = r.uint32();
                        e >>> 3 == 1 ? o.proposalId = r.uint64() : r.skipType(7 & e)
                    }
                    return o
                },
                fromJSON(e) {
                    let t = c();
                    return (0, s.isSet)(e.proposalId) && (t.proposalId = BigInt(e.proposalId.toString())), t
                },
                toJSON(e) {
                    let t = {};
                    return void 0 !== e.proposalId && (t.proposalId = (e.proposalId || BigInt(0)).toString()), t
                },
                fromPartial(e) {
                    let t = c();
                    return void 0 !== e.proposalId && null !== e.proposalId && (t.proposalId = BigInt(e.proposalId.toString())), t
                }
            }, t.MsgExecLegacyContent = {
                typeUrl: "/cosmos.gov.v1.MsgExecLegacyContent",
                encode: (e, t = a.BinaryWriter.create()) => (void 0 !== e.content && n.Any.encode(e.content, t.uint32(10).fork()).ldelim(), "" !== e.authority && t.uint32(18).string(e.authority), t),
                decode(e, t) {
                    let r = e instanceof a.BinaryReader ? e : new a.BinaryReader(e),
                        o = void 0 === t ? r.len : r.pos + t,
                        i = l();
                    for (; r.pos < o;) {
                        let e = r.uint32();
                        switch (e >>> 3) {
                            case 1:
                                i.content = n.Any.decode(r, r.uint32());
                                break;
                            case 2:
                                i.authority = r.string();
                                break;
                            default:
                                r.skipType(7 & e)
                        }
                    }
                    return i
                },
                fromJSON(e) {
                    let t = l();
                    return (0, s.isSet)(e.content) && (t.content = n.Any.fromJSON(e.content)), (0, s.isSet)(e.authority) && (t.authority = String(e.authority)), t
                },
                toJSON(e) {
                    let t = {};
                    return void 0 !== e.content && (t.content = e.content ? n.Any.toJSON(e.content) : void 0), void 0 !== e.authority && (t.authority = e.authority), t
                },
                fromPartial(e) {
                    let t = l();
                    return void 0 !== e.content && null !== e.content && (t.content = n.Any.fromPartial(e.content)), t.authority = e.authority ? ? "", t
                }
            }, t.MsgExecLegacyContentResponse = {
                typeUrl: "/cosmos.gov.v1.MsgExecLegacyContentResponse",
                encode: (e, t = a.BinaryWriter.create()) => t,
                decode(e, t) {
                    let r = e instanceof a.BinaryReader ? e : new a.BinaryReader(e),
                        n = void 0 === t ? r.len : r.pos + t;
                    for (; r.pos < n;) {
                        let e = r.uint32();
                        r.skipType(7 & e)
                    }
                    return {}
                },
                fromJSON: e => ({}),
                toJSON: e => ({}),
                fromPartial: e => ({})
            }, t.MsgVote = {
                typeUrl: "/cosmos.gov.v1.MsgVote",
                encode: (e, t = a.BinaryWriter.create()) => (e.proposalId !== BigInt(0) && t.uint32(8).uint64(e.proposalId), "" !== e.voter && t.uint32(18).string(e.voter), 0 !== e.option && t.uint32(24).int32(e.option), "" !== e.metadata && t.uint32(34).string(e.metadata), t),
                decode(e, t) {
                    let r = e instanceof a.BinaryReader ? e : new a.BinaryReader(e),
                        n = void 0 === t ? r.len : r.pos + t,
                        o = u();
                    for (; r.pos < n;) {
                        let e = r.uint32();
                        switch (e >>> 3) {
                            case 1:
                                o.proposalId = r.uint64();
                                break;
                            case 2:
                                o.voter = r.string();
                                break;
                            case 3:
                                o.option = r.int32();
                                break;
                            case 4:
                                o.metadata = r.string();
                                break;
                            default:
                                r.skipType(7 & e)
                        }
                    }
                    return o
                },
                fromJSON(e) {
                    let t = u();
                    return (0, s.isSet)(e.proposalId) && (t.proposalId = BigInt(e.proposalId.toString())), (0, s.isSet)(e.voter) && (t.voter = String(e.voter)), (0, s.isSet)(e.option) && (t.option = (0, i.voteOptionFromJSON)(e.option)), (0, s.isSet)(e.metadata) && (t.metadata = String(e.metadata)), t
                },
                toJSON(e) {
                    let t = {};
                    return void 0 !== e.proposalId && (t.proposalId = (e.proposalId || BigInt(0)).toString()), void 0 !== e.voter && (t.voter = e.voter), void 0 !== e.option && (t.option = (0, i.voteOptionToJSON)(e.option)), void 0 !== e.metadata && (t.metadata = e.metadata), t
                },
                fromPartial(e) {
                    let t = u();
                    return void 0 !== e.proposalId && null !== e.proposalId && (t.proposalId = BigInt(e.proposalId.toString())), t.voter = e.voter ? ? "", t.option = e.option ? ? 0, t.metadata = e.metadata ? ? "", t
                }
            }, t.MsgVoteResponse = {
                typeUrl: "/cosmos.gov.v1.MsgVoteResponse",
                encode: (e, t = a.BinaryWriter.create()) => t,
                decode(e, t) {
                    let r = e instanceof a.BinaryReader ? e : new a.BinaryReader(e),
                        n = void 0 === t ? r.len : r.pos + t;
                    for (; r.pos < n;) {
                        let e = r.uint32();
                        r.skipType(7 & e)
                    }
                    return {}
                },
                fromJSON: e => ({}),
                toJSON: e => ({}),
                fromPartial: e => ({})
            }, t.MsgVoteWeighted = {
                typeUrl: "/cosmos.gov.v1.MsgVoteWeighted",
                encode(e, t = a.BinaryWriter.create()) {
                    for (let r of (e.proposalId !== BigInt(0) && t.uint32(8).uint64(e.proposalId), "" !== e.voter && t.uint32(18).string(e.voter), e.options)) i.WeightedVoteOption.encode(r, t.uint32(26).fork()).ldelim();
                    return "" !== e.metadata && t.uint32(34).string(e.metadata), t
                },
                decode(e, t) {
                    let r = e instanceof a.BinaryReader ? e : new a.BinaryReader(e),
                        n = void 0 === t ? r.len : r.pos + t,
                        o = p();
                    for (; r.pos < n;) {
                        let e = r.uint32();
                        switch (e >>> 3) {
                            case 1:
                                o.proposalId = r.uint64();
                                break;
                            case 2:
                                o.voter = r.string();
                                break;
                            case 3:
                                o.options.push(i.WeightedVoteOption.decode(r, r.uint32()));
                                break;
                            case 4:
                                o.metadata = r.string();
                                break;
                            default:
                                r.skipType(7 & e)
                        }
                    }
                    return o
                },
                fromJSON(e) {
                    let t = p();
                    return (0, s.isSet)(e.proposalId) && (t.proposalId = BigInt(e.proposalId.toString())), (0, s.isSet)(e.voter) && (t.voter = String(e.voter)), Array.isArray(e ? .options) && (t.options = e.options.map(e => i.WeightedVoteOption.fromJSON(e))), (0, s.isSet)(e.metadata) && (t.metadata = String(e.metadata)), t
                },
                toJSON(e) {
                    let t = {};
                    return void 0 !== e.proposalId && (t.proposalId = (e.proposalId || BigInt(0)).toString()), void 0 !== e.voter && (t.voter = e.voter), e.options ? t.options = e.options.map(e => e ? i.WeightedVoteOption.toJSON(e) : void 0) : t.options = [], void 0 !== e.metadata && (t.metadata = e.metadata), t
                },
                fromPartial(e) {
                    let t = p();
                    return void 0 !== e.proposalId && null !== e.proposalId && (t.proposalId = BigInt(e.proposalId.toString())), t.voter = e.voter ? ? "", t.options = e.options ? .map(e => i.WeightedVoteOption.fromPartial(e)) || [], t.metadata = e.metadata ? ? "", t
                }
            }, t.MsgVoteWeightedResponse = {
                typeUrl: "/cosmos.gov.v1.MsgVoteWeightedResponse",
                encode: (e, t = a.BinaryWriter.create()) => t,
                decode(e, t) {
                    let r = e instanceof a.BinaryReader ? e : new a.BinaryReader(e),
                        n = void 0 === t ? r.len : r.pos + t;
                    for (; r.pos < n;) {
                        let e = r.uint32();
                        r.skipType(7 & e)
                    }
                    return {}
                },
                fromJSON: e => ({}),
                toJSON: e => ({}),
                fromPartial: e => ({})
            }, t.MsgDeposit = {
                typeUrl: "/cosmos.gov.v1.MsgDeposit",
                encode(e, t = a.BinaryWriter.create()) {
                    for (let r of (e.proposalId !== BigInt(0) && t.uint32(8).uint64(e.proposalId), "" !== e.depositor && t.uint32(18).string(e.depositor), e.amount)) o.Coin.encode(r, t.uint32(26).fork()).ldelim();
                    return t
                },
                decode(e, t) {
                    let r = e instanceof a.BinaryReader ? e : new a.BinaryReader(e),
                        n = void 0 === t ? r.len : r.pos + t,
                        i = m();
                    for (; r.pos < n;) {
                        let e = r.uint32();
                        switch (e >>> 3) {
                            case 1:
                                i.proposalId = r.uint64();
                                break;
                            case 2:
                                i.depositor = r.string();
                                break;
                            case 3:
                                i.amount.push(o.Coin.decode(r, r.uint32()));
                                break;
                            default:
                                r.skipType(7 & e)
                        }
                    }
                    return i
                },
                fromJSON(e) {
                    let t = m();
                    return (0, s.isSet)(e.proposalId) && (t.proposalId = BigInt(e.proposalId.toString())), (0, s.isSet)(e.depositor) && (t.depositor = String(e.depositor)), Array.isArray(e ? .amount) && (t.amount = e.amount.map(e => o.Coin.fromJSON(e))), t
                },
                toJSON(e) {
                    let t = {};
                    return void 0 !== e.proposalId && (t.proposalId = (e.proposalId || BigInt(0)).toString()), void 0 !== e.depositor && (t.depositor = e.depositor), e.amount ? t.amount = e.amount.map(e => e ? o.Coin.toJSON(e) : void 0) : t.amount = [], t
                },
                fromPartial(e) {
                    let t = m();
                    return void 0 !== e.proposalId && null !== e.proposalId && (t.proposalId = BigInt(e.proposalId.toString())), t.depositor = e.depositor ? ? "", t.amount = e.amount ? .map(e => o.Coin.fromPartial(e)) || [], t
                }
            }, t.MsgDepositResponse = {
                typeUrl: "/cosmos.gov.v1.MsgDepositResponse",
                encode: (e, t = a.BinaryWriter.create()) => t,
                decode(e, t) {
                    let r = e instanceof a.BinaryReader ? e : new a.BinaryReader(e),
                        n = void 0 === t ? r.len : r.pos + t;
                    for (; r.pos < n;) {
                        let e = r.uint32();
                        r.skipType(7 & e)
                    }
                    return {}
                },
                fromJSON: e => ({}),
                toJSON: e => ({}),
                fromPartial: e => ({})
            }, t.MsgUpdateParams = {
                typeUrl: "/cosmos.gov.v1.MsgUpdateParams",
                encode: (e, t = a.BinaryWriter.create()) => ("" !== e.authority && t.uint32(10).string(e.authority), void 0 !== e.params && i.Params.encode(e.params, t.uint32(18).fork()).ldelim(), t),
                decode(e, t) {
                    let r = e instanceof a.BinaryReader ? e : new a.BinaryReader(e),
                        n = void 0 === t ? r.len : r.pos + t,
                        o = g();
                    for (; r.pos < n;) {
                        let e = r.uint32();
                        switch (e >>> 3) {
                            case 1:
                                o.authority = r.string();
                                break;
                            case 2:
                                o.params = i.Params.decode(r, r.uint32());
                                break;
                            default:
                                r.skipType(7 & e)
                        }
                    }
                    return o
                },
                fromJSON(e) {
                    let t = g();
                    return (0, s.isSet)(e.authority) && (t.authority = String(e.authority)), (0, s.isSet)(e.params) && (t.params = i.Params.fromJSON(e.params)), t
                },
                toJSON(e) {
                    let t = {};
                    return void 0 !== e.authority && (t.authority = e.authority), void 0 !== e.params && (t.params = e.params ? i.Params.toJSON(e.params) : void 0), t
                },
                fromPartial(e) {
                    let t = g();
                    return t.authority = e.authority ? ? "", void 0 !== e.params && null !== e.params && (t.params = i.Params.fromPartial(e.params)), t
                }
            }, t.MsgUpdateParamsResponse = {
                typeUrl: "/cosmos.gov.v1.MsgUpdateParamsResponse",
                encode: (e, t = a.BinaryWriter.create()) => t,
                decode(e, t) {
                    let r = e instanceof a.BinaryReader ? e : new a.BinaryReader(e),
                        n = void 0 === t ? r.len : r.pos + t;
                    for (; r.pos < n;) {
                        let e = r.uint32();
                        r.skipType(7 & e)
                    }
                    return {}
                },
                fromJSON: e => ({}),
                toJSON: e => ({}),
                fromPartial: e => ({})
            };
            class f {
                constructor(e) {
                    this.rpc = e, this.SubmitProposal = this.SubmitProposal.bind(this), this.ExecLegacyContent = this.ExecLegacyContent.bind(this), this.Vote = this.Vote.bind(this), this.VoteWeighted = this.VoteWeighted.bind(this), this.Deposit = this.Deposit.bind(this), this.UpdateParams = this.UpdateParams.bind(this)
                }
                SubmitProposal(e) {
                    let r = t.MsgSubmitProposal.encode(e).finish();
                    return this.rpc.request("cosmos.gov.v1.Msg", "SubmitProposal", r).then(e => t.MsgSubmitProposalResponse.decode(new a.BinaryReader(e)))
                }
                ExecLegacyContent(e) {
                    let r = t.MsgExecLegacyContent.encode(e).finish();
                    return this.rpc.request("cosmos.gov.v1.Msg", "ExecLegacyContent", r).then(e => t.MsgExecLegacyContentResponse.decode(new a.BinaryReader(e)))
                }
                Vote(e) {
                    let r = t.MsgVote.encode(e).finish();
                    return this.rpc.request("cosmos.gov.v1.Msg", "Vote", r).then(e => t.MsgVoteResponse.decode(new a.BinaryReader(e)))
                }
                VoteWeighted(e) {
                    let r = t.MsgVoteWeighted.encode(e).finish();
                    return this.rpc.request("cosmos.gov.v1.Msg", "VoteWeighted", r).then(e => t.MsgVoteWeightedResponse.decode(new a.BinaryReader(e)))
                }
                Deposit(e) {
                    let r = t.MsgDeposit.encode(e).finish();
                    return this.rpc.request("cosmos.gov.v1.Msg", "Deposit", r).then(e => t.MsgDepositResponse.decode(new a.BinaryReader(e)))
                }
                UpdateParams(e) {
                    let r = t.MsgUpdateParams.encode(e).finish();
                    return this.rpc.request("cosmos.gov.v1.Msg", "UpdateParams", r).then(e => t.MsgUpdateParamsResponse.decode(new a.BinaryReader(e)))
                }
            }
            t.MsgClientImpl = f
        },
        62455: function(e, t, r) {
            "use strict";
            var n, o, i, a;
            Object.defineProperty(t, "__esModule", {
                value: !0
            }), t.TallyParams = t.VotingParams = t.DepositParams = t.Vote = t.TallyResult = t.Proposal = t.Deposit = t.TextProposal = t.WeightedVoteOption = t.proposalStatusToJSON = t.proposalStatusFromJSON = t.ProposalStatus = t.voteOptionToJSON = t.voteOptionFromJSON = t.VoteOption = t.protobufPackage = void 0;
            let s = r(62809),
                d = r(65676),
                c = r(90614),
                l = r(69441),
                u = r(28486),
                p = r(6476);

            function m(e) {
                switch (e) {
                    case 0:
                    case "VOTE_OPTION_UNSPECIFIED":
                        return n.VOTE_OPTION_UNSPECIFIED;
                    case 1:
                    case "VOTE_OPTION_YES":
                        return n.VOTE_OPTION_YES;
                    case 2:
                    case "VOTE_OPTION_ABSTAIN":
                        return n.VOTE_OPTION_ABSTAIN;
                    case 3:
                    case "VOTE_OPTION_NO":
                        return n.VOTE_OPTION_NO;
                    case 4:
                    case "VOTE_OPTION_NO_WITH_VETO":
                        return n.VOTE_OPTION_NO_WITH_VETO;
                    default:
                        return n.UNRECOGNIZED
                }
            }

            function g(e) {
                switch (e) {
                    case n.VOTE_OPTION_UNSPECIFIED:
                        return "VOTE_OPTION_UNSPECIFIED";
                    case n.VOTE_OPTION_YES:
                        return "VOTE_OPTION_YES";
                    case n.VOTE_OPTION_ABSTAIN:
                        return "VOTE_OPTION_ABSTAIN";
                    case n.VOTE_OPTION_NO:
                        return "VOTE_OPTION_NO";
                    case n.VOTE_OPTION_NO_WITH_VETO:
                        return "VOTE_OPTION_NO_WITH_VETO";
                    case n.UNRECOGNIZED:
                    default:
                        return "UNRECOGNIZED"
                }
            }

            function f(e) {
                switch (e) {
                    case 0:
                    case "PROPOSAL_STATUS_UNSPECIFIED":
                        return o.PROPOSAL_STATUS_UNSPECIFIED;
                    case 1:
                    case "PROPOSAL_STATUS_DEPOSIT_PERIOD":
                        return o.PROPOSAL_STATUS_DEPOSIT_PERIOD;
                    case 2:
                    case "PROPOSAL_STATUS_VOTING_PERIOD":
                        return o.PROPOSAL_STATUS_VOTING_PERIOD;
                    case 3:
                    case "PROPOSAL_STATUS_PASSED":
                        return o.PROPOSAL_STATUS_PASSED;
                    case 4:
                    case "PROPOSAL_STATUS_REJECTED":
                        return o.PROPOSAL_STATUS_REJECTED;
                    case 5:
                    case "PROPOSAL_STATUS_FAILED":
                        return o.PROPOSAL_STATUS_FAILED;
                    default:
                        return o.UNRECOGNIZED
                }
            }

            function y(e) {
                switch (e) {
                    case o.PROPOSAL_STATUS_UNSPECIFIED:
                        return "PROPOSAL_STATUS_UNSPECIFIED";
                    case o.PROPOSAL_STATUS_DEPOSIT_PERIOD:
                        return "PROPOSAL_STATUS_DEPOSIT_PERIOD";
                    case o.PROPOSAL_STATUS_VOTING_PERIOD:
                        return "PROPOSAL_STATUS_VOTING_PERIOD";
                    case o.PROPOSAL_STATUS_PASSED:
                        return "PROPOSAL_STATUS_PASSED";
                    case o.PROPOSAL_STATUS_REJECTED:
                        return "PROPOSAL_STATUS_REJECTED";
                    case o.PROPOSAL_STATUS_FAILED:
                        return "PROPOSAL_STATUS_FAILED";
                    case o.UNRECOGNIZED:
                    default:
                        return "UNRECOGNIZED"
                }
            }

            function h() {
                return {
                    option: 0,
                    weight: ""
                }
            }

            function v() {
                return {
                    title: "",
                    description: ""
                }
            }

            function b() {
                return {
                    proposalId: BigInt(0),
                    depositor: "",
                    amount: []
                }
            }

            function S() {
                return {
                    proposalId: BigInt(0),
                    content: void 0,
                    status: 0,
                    finalTallyResult: t.TallyResult.fromPartial({}),
                    submitTime: c.Timestamp.fromPartial({}),
                    depositEndTime: c.Timestamp.fromPartial({}),
                    totalDeposit: [],
                    votingStartTime: c.Timestamp.fromPartial({}),
                    votingEndTime: c.Timestamp.fromPartial({})
                }
            }

            function k() {
                return {
                    yes: "",
                    abstain: "",
                    no: "",
                    noWithVeto: ""
                }
            }

            function P() {
                return {
                    proposalId: BigInt(0),
                    voter: "",
                    option: 0,
                    options: []
                }
            }

            function _() {
                return {
                    minDeposit: [],
                    maxDepositPeriod: l.Duration.fromPartial({})
                }
            }

            function B() {
                return {
                    votingPeriod: l.Duration.fromPartial({})
                }
            }

            function O() {
                return {
                    quorum: new Uint8Array,
                    threshold: new Uint8Array,
                    vetoThreshold: new Uint8Array
                }
            }
            t.protobufPackage = "cosmos.gov.v1beta1", (i = n || (t.VoteOption = n = {}))[i.VOTE_OPTION_UNSPECIFIED = 0] = "VOTE_OPTION_UNSPECIFIED", i[i.VOTE_OPTION_YES = 1] = "VOTE_OPTION_YES", i[i.VOTE_OPTION_ABSTAIN = 2] = "VOTE_OPTION_ABSTAIN", i[i.VOTE_OPTION_NO = 3] = "VOTE_OPTION_NO", i[i.VOTE_OPTION_NO_WITH_VETO = 4] = "VOTE_OPTION_NO_WITH_VETO", i[i.UNRECOGNIZED = -1] = "UNRECOGNIZED", t.voteOptionFromJSON = m, t.voteOptionToJSON = g, (a = o || (t.ProposalStatus = o = {}))[a.PROPOSAL_STATUS_UNSPECIFIED = 0] = "PROPOSAL_STATUS_UNSPECIFIED", a[a.PROPOSAL_STATUS_DEPOSIT_PERIOD = 1] = "PROPOSAL_STATUS_DEPOSIT_PERIOD", a[a.PROPOSAL_STATUS_VOTING_PERIOD = 2] = "PROPOSAL_STATUS_VOTING_PERIOD", a[a.PROPOSAL_STATUS_PASSED = 3] = "PROPOSAL_STATUS_PASSED", a[a.PROPOSAL_STATUS_REJECTED = 4] = "PROPOSAL_STATUS_REJECTED", a[a.PROPOSAL_STATUS_FAILED = 5] = "PROPOSAL_STATUS_FAILED", a[a.UNRECOGNIZED = -1] = "UNRECOGNIZED", t.proposalStatusFromJSON = f, t.proposalStatusToJSON = y, t.WeightedVoteOption = {
                typeUrl: "/cosmos.gov.v1beta1.WeightedVoteOption",
                encode: (e, t = u.BinaryWriter.create()) => (0 !== e.option && t.uint32(8).int32(e.option), "" !== e.weight && t.uint32(18).string(e.weight), t),
                decode(e, t) {
                    let r = e instanceof u.BinaryReader ? e : new u.BinaryReader(e),
                        n = void 0 === t ? r.len : r.pos + t,
                        o = h();
                    for (; r.pos < n;) {
                        let e = r.uint32();
                        switch (e >>> 3) {
                            case 1:
                                o.option = r.int32();
                                break;
                            case 2:
                                o.weight = r.string();
                                break;
                            default:
                                r.skipType(7 & e)
                        }
                    }
                    return o
                },
                fromJSON(e) {
                    let t = h();
                    return (0, p.isSet)(e.option) && (t.option = m(e.option)), (0, p.isSet)(e.weight) && (t.weight = String(e.weight)), t
                },
                toJSON(e) {
                    let t = {};
                    return void 0 !== e.option && (t.option = g(e.option)), void 0 !== e.weight && (t.weight = e.weight), t
                },
                fromPartial(e) {
                    let t = h();
                    return t.option = e.option ? ? 0, t.weight = e.weight ? ? "", t
                }
            }, t.TextProposal = {
                typeUrl: "/cosmos.gov.v1beta1.TextProposal",
                encode: (e, t = u.BinaryWriter.create()) => ("" !== e.title && t.uint32(10).string(e.title), "" !== e.description && t.uint32(18).string(e.description), t),
                decode(e, t) {
                    let r = e instanceof u.BinaryReader ? e : new u.BinaryReader(e),
                        n = void 0 === t ? r.len : r.pos + t,
                        o = v();
                    for (; r.pos < n;) {
                        let e = r.uint32();
                        switch (e >>> 3) {
                            case 1:
                                o.title = r.string();
                                break;
                            case 2:
                                o.description = r.string();
                                break;
                            default:
                                r.skipType(7 & e)
                        }
                    }
                    return o
                },
                fromJSON(e) {
                    let t = v();
                    return (0, p.isSet)(e.title) && (t.title = String(e.title)), (0, p.isSet)(e.description) && (t.description = String(e.description)), t
                },
                toJSON(e) {
                    let t = {};
                    return void 0 !== e.title && (t.title = e.title), void 0 !== e.description && (t.description = e.description), t
                },
                fromPartial(e) {
                    let t = v();
                    return t.title = e.title ? ? "", t.description = e.description ? ? "", t
                }
            }, t.Deposit = {
                typeUrl: "/cosmos.gov.v1beta1.Deposit",
                encode(e, t = u.BinaryWriter.create()) {
                    for (let r of (e.proposalId !== BigInt(0) && t.uint32(8).uint64(e.proposalId), "" !== e.depositor && t.uint32(18).string(e.depositor), e.amount)) s.Coin.encode(r, t.uint32(26).fork()).ldelim();
                    return t
                },
                decode(e, t) {
                    let r = e instanceof u.BinaryReader ? e : new u.BinaryReader(e),
                        n = void 0 === t ? r.len : r.pos + t,
                        o = b();
                    for (; r.pos < n;) {
                        let e = r.uint32();
                        switch (e >>> 3) {
                            case 1:
                                o.proposalId = r.uint64();
                                break;
                            case 2:
                                o.depositor = r.string();
                                break;
                            case 3:
                                o.amount.push(s.Coin.decode(r, r.uint32()));
                                break;
                            default:
                                r.skipType(7 & e)
                        }
                    }
                    return o
                },
                fromJSON(e) {
                    let t = b();
                    return (0, p.isSet)(e.proposalId) && (t.proposalId = BigInt(e.proposalId.toString())), (0, p.isSet)(e.depositor) && (t.depositor = String(e.depositor)), Array.isArray(e ? .amount) && (t.amount = e.amount.map(e => s.Coin.fromJSON(e))), t
                },
                toJSON(e) {
                    let t = {};
                    return void 0 !== e.proposalId && (t.proposalId = (e.proposalId || BigInt(0)).toString()), void 0 !== e.depositor && (t.depositor = e.depositor), e.amount ? t.amount = e.amount.map(e => e ? s.Coin.toJSON(e) : void 0) : t.amount = [], t
                },
                fromPartial(e) {
                    let t = b();
                    return void 0 !== e.proposalId && null !== e.proposalId && (t.proposalId = BigInt(e.proposalId.toString())), t.depositor = e.depositor ? ? "", t.amount = e.amount ? .map(e => s.Coin.fromPartial(e)) || [], t
                }
            }, t.Proposal = {
                typeUrl: "/cosmos.gov.v1beta1.Proposal",
                encode(e, r = u.BinaryWriter.create()) {
                    for (let n of (e.proposalId !== BigInt(0) && r.uint32(8).uint64(e.proposalId), void 0 !== e.content && d.Any.encode(e.content, r.uint32(18).fork()).ldelim(), 0 !== e.status && r.uint32(24).int32(e.status), void 0 !== e.finalTallyResult && t.TallyResult.encode(e.finalTallyResult, r.uint32(34).fork()).ldelim(), void 0 !== e.submitTime && c.Timestamp.encode(e.submitTime, r.uint32(42).fork()).ldelim(), void 0 !== e.depositEndTime && c.Timestamp.encode(e.depositEndTime, r.uint32(50).fork()).ldelim(), e.totalDeposit)) s.Coin.encode(n, r.uint32(58).fork()).ldelim();
                    return void 0 !== e.votingStartTime && c.Timestamp.encode(e.votingStartTime, r.uint32(66).fork()).ldelim(), void 0 !== e.votingEndTime && c.Timestamp.encode(e.votingEndTime, r.uint32(74).fork()).ldelim(), r
                },
                decode(e, r) {
                    let n = e instanceof u.BinaryReader ? e : new u.BinaryReader(e),
                        o = void 0 === r ? n.len : n.pos + r,
                        i = S();
                    for (; n.pos < o;) {
                        let e = n.uint32();
                        switch (e >>> 3) {
                            case 1:
                                i.proposalId = n.uint64();
                                break;
                            case 2:
                                i.content = d.Any.decode(n, n.uint32());
                                break;
                            case 3:
                                i.status = n.int32();
                                break;
                            case 4:
                                i.finalTallyResult = t.TallyResult.decode(n, n.uint32());
                                break;
                            case 5:
                                i.submitTime = c.Timestamp.decode(n, n.uint32());
                                break;
                            case 6:
                                i.depositEndTime = c.Timestamp.decode(n, n.uint32());
                                break;
                            case 7:
                                i.totalDeposit.push(s.Coin.decode(n, n.uint32()));
                                break;
                            case 8:
                                i.votingStartTime = c.Timestamp.decode(n, n.uint32());
                                break;
                            case 9:
                                i.votingEndTime = c.Timestamp.decode(n, n.uint32());
                                break;
                            default:
                                n.skipType(7 & e)
                        }
                    }
                    return i
                },
                fromJSON(e) {
                    let r = S();
                    return (0, p.isSet)(e.proposalId) && (r.proposalId = BigInt(e.proposalId.toString())), (0, p.isSet)(e.content) && (r.content = d.Any.fromJSON(e.content)), (0, p.isSet)(e.status) && (r.status = f(e.status)), (0, p.isSet)(e.finalTallyResult) && (r.finalTallyResult = t.TallyResult.fromJSON(e.finalTallyResult)), (0, p.isSet)(e.submitTime) && (r.submitTime = (0, p.fromJsonTimestamp)(e.submitTime)), (0, p.isSet)(e.depositEndTime) && (r.depositEndTime = (0, p.fromJsonTimestamp)(e.depositEndTime)), Array.isArray(e ? .totalDeposit) && (r.totalDeposit = e.totalDeposit.map(e => s.Coin.fromJSON(e))), (0, p.isSet)(e.votingStartTime) && (r.votingStartTime = (0, p.fromJsonTimestamp)(e.votingStartTime)), (0, p.isSet)(e.votingEndTime) && (r.votingEndTime = (0, p.fromJsonTimestamp)(e.votingEndTime)), r
                },
                toJSON(e) {
                    let r = {};
                    return void 0 !== e.proposalId && (r.proposalId = (e.proposalId || BigInt(0)).toString()), void 0 !== e.content && (r.content = e.content ? d.Any.toJSON(e.content) : void 0), void 0 !== e.status && (r.status = y(e.status)), void 0 !== e.finalTallyResult && (r.finalTallyResult = e.finalTallyResult ? t.TallyResult.toJSON(e.finalTallyResult) : void 0), void 0 !== e.submitTime && (r.submitTime = (0, p.fromTimestamp)(e.submitTime).toISOString()), void 0 !== e.depositEndTime && (r.depositEndTime = (0, p.fromTimestamp)(e.depositEndTime).toISOString()), e.totalDeposit ? r.totalDeposit = e.totalDeposit.map(e => e ? s.Coin.toJSON(e) : void 0) : r.totalDeposit = [], void 0 !== e.votingStartTime && (r.votingStartTime = (0, p.fromTimestamp)(e.votingStartTime).toISOString()), void 0 !== e.votingEndTime && (r.votingEndTime = (0, p.fromTimestamp)(e.votingEndTime).toISOString()), r
                },
                fromPartial(e) {
                    let r = S();
                    return void 0 !== e.proposalId && null !== e.proposalId && (r.proposalId = BigInt(e.proposalId.toString())), void 0 !== e.content && null !== e.content && (r.content = d.Any.fromPartial(e.content)), r.status = e.status ? ? 0, void 0 !== e.finalTallyResult && null !== e.finalTallyResult && (r.finalTallyResult = t.TallyResult.fromPartial(e.finalTallyResult)), void 0 !== e.submitTime && null !== e.submitTime && (r.submitTime = c.Timestamp.fromPartial(e.submitTime)), void 0 !== e.depositEndTime && null !== e.depositEndTime && (r.depositEndTime = c.Timestamp.fromPartial(e.depositEndTime)), r.totalDeposit = e.totalDeposit ? .map(e => s.Coin.fromPartial(e)) || [], void 0 !== e.votingStartTime && null !== e.votingStartTime && (r.votingStartTime = c.Timestamp.fromPartial(e.votingStartTime)), void 0 !== e.votingEndTime && null !== e.votingEndTime && (r.votingEndTime = c.Timestamp.fromPartial(e.votingEndTime)), r
                }
            }, t.TallyResult = {
                typeUrl: "/cosmos.gov.v1beta1.TallyResult",
                encode: (e, t = u.BinaryWriter.create()) => ("" !== e.yes && t.uint32(10).string(e.yes), "" !== e.abstain && t.uint32(18).string(e.abstain), "" !== e.no && t.uint32(26).string(e.no), "" !== e.noWithVeto && t.uint32(34).string(e.noWithVeto), t),
                decode(e, t) {
                    let r = e instanceof u.BinaryReader ? e : new u.BinaryReader(e),
                        n = void 0 === t ? r.len : r.pos + t,
                        o = k();
                    for (; r.pos < n;) {
                        let e = r.uint32();
                        switch (e >>> 3) {
                            case 1:
                                o.yes = r.string();
                                break;
                            case 2:
                                o.abstain = r.string();
                                break;
                            case 3:
                                o.no = r.string();
                                break;
                            case 4:
                                o.noWithVeto = r.string();
                                break;
                            default:
                                r.skipType(7 & e)
                        }
                    }
                    return o
                },
                fromJSON(e) {
                    let t = k();
                    return (0, p.isSet)(e.yes) && (t.yes = String(e.yes)), (0, p.isSet)(e.abstain) && (t.abstain = String(e.abstain)), (0, p.isSet)(e.no) && (t.no = String(e.no)), (0, p.isSet)(e.noWithVeto) && (t.noWithVeto = String(e.noWithVeto)), t
                },
                toJSON(e) {
                    let t = {};
                    return void 0 !== e.yes && (t.yes = e.yes), void 0 !== e.abstain && (t.abstain = e.abstain), void 0 !== e.no && (t.no = e.no), void 0 !== e.noWithVeto && (t.noWithVeto = e.noWithVeto), t
                },
                fromPartial(e) {
                    let t = k();
                    return t.yes = e.yes ? ? "", t.abstain = e.abstain ? ? "", t.no = e.no ? ? "", t.noWithVeto = e.noWithVeto ? ? "", t
                }
            }, t.Vote = {
                typeUrl: "/cosmos.gov.v1beta1.Vote",
                encode(e, r = u.BinaryWriter.create()) {
                    for (let n of (e.proposalId !== BigInt(0) && r.uint32(8).uint64(e.proposalId), "" !== e.voter && r.uint32(18).string(e.voter), 0 !== e.option && r.uint32(24).int32(e.option), e.options)) t.WeightedVoteOption.encode(n, r.uint32(34).fork()).ldelim();
                    return r
                },
                decode(e, r) {
                    let n = e instanceof u.BinaryReader ? e : new u.BinaryReader(e),
                        o = void 0 === r ? n.len : n.pos + r,
                        i = P();
                    for (; n.pos < o;) {
                        let e = n.uint32();
                        switch (e >>> 3) {
                            case 1:
                                i.proposalId = n.uint64();
                                break;
                            case 2:
                                i.voter = n.string();
                                break;
                            case 3:
                                i.option = n.int32();
                                break;
                            case 4:
                                i.options.push(t.WeightedVoteOption.decode(n, n.uint32()));
                                break;
                            default:
                                n.skipType(7 & e)
                        }
                    }
                    return i
                },
                fromJSON(e) {
                    let r = P();
                    return (0, p.isSet)(e.proposalId) && (r.proposalId = BigInt(e.proposalId.toString())), (0, p.isSet)(e.voter) && (r.voter = String(e.voter)), (0, p.isSet)(e.option) && (r.option = m(e.option)), Array.isArray(e ? .options) && (r.options = e.options.map(e => t.WeightedVoteOption.fromJSON(e))), r
                },
                toJSON(e) {
                    let r = {};
                    return void 0 !== e.proposalId && (r.proposalId = (e.proposalId || BigInt(0)).toString()), void 0 !== e.voter && (r.voter = e.voter), void 0 !== e.option && (r.option = g(e.option)), e.options ? r.options = e.options.map(e => e ? t.WeightedVoteOption.toJSON(e) : void 0) : r.options = [], r
                },
                fromPartial(e) {
                    let r = P();
                    return void 0 !== e.proposalId && null !== e.proposalId && (r.proposalId = BigInt(e.proposalId.toString())), r.voter = e.voter ? ? "", r.option = e.option ? ? 0, r.options = e.options ? .map(e => t.WeightedVoteOption.fromPartial(e)) || [], r
                }
            }, t.DepositParams = {
                typeUrl: "/cosmos.gov.v1beta1.DepositParams",
                encode(e, t = u.BinaryWriter.create()) {
                    for (let r of e.minDeposit) s.Coin.encode(r, t.uint32(10).fork()).ldelim();
                    return void 0 !== e.maxDepositPeriod && l.Duration.encode(e.maxDepositPeriod, t.uint32(18).fork()).ldelim(), t
                },
                decode(e, t) {
                    let r = e instanceof u.BinaryReader ? e : new u.BinaryReader(e),
                        n = void 0 === t ? r.len : r.pos + t,
                        o = _();
                    for (; r.pos < n;) {
                        let e = r.uint32();
                        switch (e >>> 3) {
                            case 1:
                                o.minDeposit.push(s.Coin.decode(r, r.uint32()));
                                break;
                            case 2:
                                o.maxDepositPeriod = l.Duration.decode(r, r.uint32());
                                break;
                            default:
                                r.skipType(7 & e)
                        }
                    }
                    return o
                },
                fromJSON(e) {
                    let t = _();
                    return Array.isArray(e ? .minDeposit) && (t.minDeposit = e.minDeposit.map(e => s.Coin.fromJSON(e))), (0, p.isSet)(e.maxDepositPeriod) && (t.maxDepositPeriod = l.Duration.fromJSON(e.maxDepositPeriod)), t
                },
                toJSON(e) {
                    let t = {};
                    return e.minDeposit ? t.minDeposit = e.minDeposit.map(e => e ? s.Coin.toJSON(e) : void 0) : t.minDeposit = [], void 0 !== e.maxDepositPeriod && (t.maxDepositPeriod = e.maxDepositPeriod ? l.Duration.toJSON(e.maxDepositPeriod) : void 0), t
                },
                fromPartial(e) {
                    let t = _();
                    return t.minDeposit = e.minDeposit ? .map(e => s.Coin.fromPartial(e)) || [], void 0 !== e.maxDepositPeriod && null !== e.maxDepositPeriod && (t.maxDepositPeriod = l.Duration.fromPartial(e.maxDepositPeriod)), t
                }
            }, t.VotingParams = {
                typeUrl: "/cosmos.gov.v1beta1.VotingParams",
                encode: (e, t = u.BinaryWriter.create()) => (void 0 !== e.votingPeriod && l.Duration.encode(e.votingPeriod, t.uint32(10).fork()).ldelim(), t),
                decode(e, t) {
                    let r = e instanceof u.BinaryReader ? e : new u.BinaryReader(e),
                        n = void 0 === t ? r.len : r.pos + t,
                        o = B();
                    for (; r.pos < n;) {
                        let e = r.uint32();
                        e >>> 3 == 1 ? o.votingPeriod = l.Duration.decode(r, r.uint32()) : r.skipType(7 & e)
                    }
                    return o
                },
                fromJSON(e) {
                    let t = B();
                    return (0, p.isSet)(e.votingPeriod) && (t.votingPeriod = l.Duration.fromJSON(e.votingPeriod)), t
                },
                toJSON(e) {
                    let t = {};
                    return void 0 !== e.votingPeriod && (t.votingPeriod = e.votingPeriod ? l.Duration.toJSON(e.votingPeriod) : void 0), t
                },
                fromPartial(e) {
                    let t = B();
                    return void 0 !== e.votingPeriod && null !== e.votingPeriod && (t.votingPeriod = l.Duration.fromPartial(e.votingPeriod)), t
                }
            }, t.TallyParams = {
                typeUrl: "/cosmos.gov.v1beta1.TallyParams",
                encode: (e, t = u.BinaryWriter.create()) => (0 !== e.quorum.length && t.uint32(10).bytes(e.quorum), 0 !== e.threshold.length && t.uint32(18).bytes(e.threshold), 0 !== e.vetoThreshold.length && t.uint32(26).bytes(e.vetoThreshold), t),
                decode(e, t) {
                    let r = e instanceof u.BinaryReader ? e : new u.BinaryReader(e),
                        n = void 0 === t ? r.len : r.pos + t,
                        o = O();
                    for (; r.pos < n;) {
                        let e = r.uint32();
                        switch (e >>> 3) {
                            case 1:
                                o.quorum = r.bytes();
                                break;
                            case 2:
                                o.threshold = r.bytes();
                                break;
                            case 3:
                                o.vetoThreshold = r.bytes();
                                break;
                            default:
                                r.skipType(7 & e)
                        }
                    }
                    return o
                },
                fromJSON(e) {
                    let t = O();
                    return (0, p.isSet)(e.quorum) && (t.quorum = (0, p.bytesFromBase64)(e.quorum)), (0, p.isSet)(e.threshold) && (t.threshold = (0, p.bytesFromBase64)(e.threshold)), (0, p.isSet)(e.vetoThreshold) && (t.vetoThreshold = (0, p.bytesFromBase64)(e.vetoThreshold)), t
                },
                toJSON(e) {
                    let t = {};
                    return void 0 !== e.quorum && (t.quorum = (0, p.base64FromBytes)(void 0 !== e.quorum ? e.quorum : new Uint8Array)), void 0 !== e.threshold && (t.threshold = (0, p.base64FromBytes)(void 0 !== e.threshold ? e.threshold : new Uint8Array)), void 0 !== e.vetoThreshold && (t.vetoThreshold = (0, p.base64FromBytes)(void 0 !== e.vetoThreshold ? e.vetoThreshold : new Uint8Array)), t
                },
                fromPartial(e) {
                    let t = O();
                    return t.quorum = e.quorum ? ? new Uint8Array, t.threshold = e.threshold ? ? new Uint8Array, t.vetoThreshold = e.vetoThreshold ? ? new Uint8Array, t
                }
            }
        },
        58043: function(e, t, r) {
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: !0
            }), t.QueryClientImpl = t.QueryTallyResultResponse = t.QueryTallyResultRequest = t.QueryDepositsResponse = t.QueryDepositsRequest = t.QueryDepositResponse = t.QueryDepositRequest = t.QueryParamsResponse = t.QueryParamsRequest = t.QueryVotesResponse = t.QueryVotesRequest = t.QueryVoteResponse = t.QueryVoteRequest = t.QueryProposalsResponse = t.QueryProposalsRequest = t.QueryProposalResponse = t.QueryProposalRequest = t.protobufPackage = void 0;
            let n = r(62455),
                o = r(38792),
                i = r(28486),
                a = r(6476);

            function s() {
                return {
                    proposalId: BigInt(0)
                }
            }

            function d() {
                return {
                    proposal: n.Proposal.fromPartial({})
                }
            }

            function c() {
                return {
                    proposalStatus: 0,
                    voter: "",
                    depositor: "",
                    pagination: void 0
                }
            }

            function l() {
                return {
                    proposals: [],
                    pagination: void 0
                }
            }

            function u() {
                return {
                    proposalId: BigInt(0),
                    voter: ""
                }
            }

            function p() {
                return {
                    vote: n.Vote.fromPartial({})
                }
            }

            function m() {
                return {
                    proposalId: BigInt(0),
                    pagination: void 0
                }
            }

            function g() {
                return {
                    votes: [],
                    pagination: void 0
                }
            }

            function f() {
                return {
                    paramsType: ""
                }
            }

            function y() {
                return {
                    votingParams: n.VotingParams.fromPartial({}),
                    depositParams: n.DepositParams.fromPartial({}),
                    tallyParams: n.TallyParams.fromPartial({})
                }
            }

            function h() {
                return {
                    proposalId: BigInt(0),
                    depositor: ""
                }
            }

            function v() {
                return {
                    deposit: n.Deposit.fromPartial({})
                }
            }

            function b() {
                return {
                    proposalId: BigInt(0),
                    pagination: void 0
                }
            }

            function S() {
                return {
                    deposits: [],
                    pagination: void 0
                }
            }

            function k() {
                return {
                    proposalId: BigInt(0)
                }
            }

            function P() {
                return {
                    tally: n.TallyResult.fromPartial({})
                }
            }
            t.protobufPackage = "cosmos.gov.v1beta1", t.QueryProposalRequest = {
                typeUrl: "/cosmos.gov.v1beta1.QueryProposalRequest",
                encode: (e, t = i.BinaryWriter.create()) => (e.proposalId !== BigInt(0) && t.uint32(8).uint64(e.proposalId), t),
                decode(e, t) {
                    let r = e instanceof i.BinaryReader ? e : new i.BinaryReader(e),
                        n = void 0 === t ? r.len : r.pos + t,
                        o = s();
                    for (; r.pos < n;) {
                        let e = r.uint32();
                        e >>> 3 == 1 ? o.proposalId = r.uint64() : r.skipType(7 & e)
                    }
                    return o
                },
                fromJSON(e) {
                    let t = s();
                    return (0, a.isSet)(e.proposalId) && (t.proposalId = BigInt(e.proposalId.toString())), t
                },
                toJSON(e) {
                    let t = {};
                    return void 0 !== e.proposalId && (t.proposalId = (e.proposalId || BigInt(0)).toString()), t
                },
                fromPartial(e) {
                    let t = s();
                    return void 0 !== e.proposalId && null !== e.proposalId && (t.proposalId = BigInt(e.proposalId.toString())), t
                }
            }, t.QueryProposalResponse = {
                typeUrl: "/cosmos.gov.v1beta1.QueryProposalResponse",
                encode: (e, t = i.BinaryWriter.create()) => (void 0 !== e.proposal && n.Proposal.encode(e.proposal, t.uint32(10).fork()).ldelim(), t),
                decode(e, t) {
                    let r = e instanceof i.BinaryReader ? e : new i.BinaryReader(e),
                        o = void 0 === t ? r.len : r.pos + t,
                        a = d();
                    for (; r.pos < o;) {
                        let e = r.uint32();
                        e >>> 3 == 1 ? a.proposal = n.Proposal.decode(r, r.uint32()) : r.skipType(7 & e)
                    }
                    return a
                },
                fromJSON(e) {
                    let t = d();
                    return (0, a.isSet)(e.proposal) && (t.proposal = n.Proposal.fromJSON(e.proposal)), t
                },
                toJSON(e) {
                    let t = {};
                    return void 0 !== e.proposal && (t.proposal = e.proposal ? n.Proposal.toJSON(e.proposal) : void 0), t
                },
                fromPartial(e) {
                    let t = d();
                    return void 0 !== e.proposal && null !== e.proposal && (t.proposal = n.Proposal.fromPartial(e.proposal)), t
                }
            }, t.QueryProposalsRequest = {
                typeUrl: "/cosmos.gov.v1beta1.QueryProposalsRequest",
                encode: (e, t = i.BinaryWriter.create()) => (0 !== e.proposalStatus && t.uint32(8).int32(e.proposalStatus), "" !== e.voter && t.uint32(18).string(e.voter), "" !== e.depositor && t.uint32(26).string(e.depositor), void 0 !== e.pagination && o.PageRequest.encode(e.pagination, t.uint32(34).fork()).ldelim(), t),
                decode(e, t) {
                    let r = e instanceof i.BinaryReader ? e : new i.BinaryReader(e),
                        n = void 0 === t ? r.len : r.pos + t,
                        a = c();
                    for (; r.pos < n;) {
                        let e = r.uint32();
                        switch (e >>> 3) {
                            case 1:
                                a.proposalStatus = r.int32();
                                break;
                            case 2:
                                a.voter = r.string();
                                break;
                            case 3:
                                a.depositor = r.string();
                                break;
                            case 4:
                                a.pagination = o.PageRequest.decode(r, r.uint32());
                                break;
                            default:
                                r.skipType(7 & e)
                        }
                    }
                    return a
                },
                fromJSON(e) {
                    let t = c();
                    return (0, a.isSet)(e.proposalStatus) && (t.proposalStatus = (0, n.proposalStatusFromJSON)(e.proposalStatus)), (0, a.isSet)(e.voter) && (t.voter = String(e.voter)), (0, a.isSet)(e.depositor) && (t.depositor = String(e.depositor)), (0, a.isSet)(e.pagination) && (t.pagination = o.PageRequest.fromJSON(e.pagination)), t
                },
                toJSON(e) {
                    let t = {};
                    return void 0 !== e.proposalStatus && (t.proposalStatus = (0, n.proposalStatusToJSON)(e.proposalStatus)), void 0 !== e.voter && (t.voter = e.voter), void 0 !== e.depositor && (t.depositor = e.depositor), void 0 !== e.pagination && (t.pagination = e.pagination ? o.PageRequest.toJSON(e.pagination) : void 0), t
                },
                fromPartial(e) {
                    let t = c();
                    return t.proposalStatus = e.proposalStatus ? ? 0, t.voter = e.voter ? ? "", t.depositor = e.depositor ? ? "", void 0 !== e.pagination && null !== e.pagination && (t.pagination = o.PageRequest.fromPartial(e.pagination)), t
                }
            }, t.QueryProposalsResponse = {
                typeUrl: "/cosmos.gov.v1beta1.QueryProposalsResponse",
                encode(e, t = i.BinaryWriter.create()) {
                    for (let r of e.proposals) n.Proposal.encode(r, t.uint32(10).fork()).ldelim();
                    return void 0 !== e.pagination && o.PageResponse.encode(e.pagination, t.uint32(18).fork()).ldelim(), t
                },
                decode(e, t) {
                    let r = e instanceof i.BinaryReader ? e : new i.BinaryReader(e),
                        a = void 0 === t ? r.len : r.pos + t,
                        s = l();
                    for (; r.pos < a;) {
                        let e = r.uint32();
                        switch (e >>> 3) {
                            case 1:
                                s.proposals.push(n.Proposal.decode(r, r.uint32()));
                                break;
                            case 2:
                                s.pagination = o.PageResponse.decode(r, r.uint32());
                                break;
                            default:
                                r.skipType(7 & e)
                        }
                    }
                    return s
                },
                fromJSON(e) {
                    let t = l();
                    return Array.isArray(e ? .proposals) && (t.proposals = e.proposals.map(e => n.Proposal.fromJSON(e))), (0, a.isSet)(e.pagination) && (t.pagination = o.PageResponse.fromJSON(e.pagination)), t
                },
                toJSON(e) {
                    let t = {};
                    return e.proposals ? t.proposals = e.proposals.map(e => e ? n.Proposal.toJSON(e) : void 0) : t.proposals = [], void 0 !== e.pagination && (t.pagination = e.pagination ? o.PageResponse.toJSON(e.pagination) : void 0), t
                },
                fromPartial(e) {
                    let t = l();
                    return t.proposals = e.proposals ? .map(e => n.Proposal.fromPartial(e)) || [], void 0 !== e.pagination && null !== e.pagination && (t.pagination = o.PageResponse.fromPartial(e.pagination)), t
                }
            }, t.QueryVoteRequest = {
                typeUrl: "/cosmos.gov.v1beta1.QueryVoteRequest",
                encode: (e, t = i.BinaryWriter.create()) => (e.proposalId !== BigInt(0) && t.uint32(8).uint64(e.proposalId), "" !== e.voter && t.uint32(18).string(e.voter), t),
                decode(e, t) {
                    let r = e instanceof i.BinaryReader ? e : new i.BinaryReader(e),
                        n = void 0 === t ? r.len : r.pos + t,
                        o = u();
                    for (; r.pos < n;) {
                        let e = r.uint32();
                        switch (e >>> 3) {
                            case 1:
                                o.proposalId = r.uint64();
                                break;
                            case 2:
                                o.voter = r.string();
                                break;
                            default:
                                r.skipType(7 & e)
                        }
                    }
                    return o
                },
                fromJSON(e) {
                    let t = u();
                    return (0, a.isSet)(e.proposalId) && (t.proposalId = BigInt(e.proposalId.toString())), (0, a.isSet)(e.voter) && (t.voter = String(e.voter)), t
                },
                toJSON(e) {
                    let t = {};
                    return void 0 !== e.proposalId && (t.proposalId = (e.proposalId || BigInt(0)).toString()), void 0 !== e.voter && (t.voter = e.voter), t
                },
                fromPartial(e) {
                    let t = u();
                    return void 0 !== e.proposalId && null !== e.proposalId && (t.proposalId = BigInt(e.proposalId.toString())), t.voter = e.voter ? ? "", t
                }
            }, t.QueryVoteResponse = {
                typeUrl: "/cosmos.gov.v1beta1.QueryVoteResponse",
                encode: (e, t = i.BinaryWriter.create()) => (void 0 !== e.vote && n.Vote.encode(e.vote, t.uint32(10).fork()).ldelim(), t),
                decode(e, t) {
                    let r = e instanceof i.BinaryReader ? e : new i.BinaryReader(e),
                        o = void 0 === t ? r.len : r.pos + t,
                        a = p();
                    for (; r.pos < o;) {
                        let e = r.uint32();
                        e >>> 3 == 1 ? a.vote = n.Vote.decode(r, r.uint32()) : r.skipType(7 & e)
                    }
                    return a
                },
                fromJSON(e) {
                    let t = p();
                    return (0, a.isSet)(e.vote) && (t.vote = n.Vote.fromJSON(e.vote)), t
                },
                toJSON(e) {
                    let t = {};
                    return void 0 !== e.vote && (t.vote = e.vote ? n.Vote.toJSON(e.vote) : void 0), t
                },
                fromPartial(e) {
                    let t = p();
                    return void 0 !== e.vote && null !== e.vote && (t.vote = n.Vote.fromPartial(e.vote)), t
                }
            }, t.QueryVotesRequest = {
                typeUrl: "/cosmos.gov.v1beta1.QueryVotesRequest",
                encode: (e, t = i.BinaryWriter.create()) => (e.proposalId !== BigInt(0) && t.uint32(8).uint64(e.proposalId), void 0 !== e.pagination && o.PageRequest.encode(e.pagination, t.uint32(18).fork()).ldelim(), t),
                decode(e, t) {
                    let r = e instanceof i.BinaryReader ? e : new i.BinaryReader(e),
                        n = void 0 === t ? r.len : r.pos + t,
                        a = m();
                    for (; r.pos < n;) {
                        let e = r.uint32();
                        switch (e >>> 3) {
                            case 1:
                                a.proposalId = r.uint64();
                                break;
                            case 2:
                                a.pagination = o.PageRequest.decode(r, r.uint32());
                                break;
                            default:
                                r.skipType(7 & e)
                        }
                    }
                    return a
                },
                fromJSON(e) {
                    let t = m();
                    return (0, a.isSet)(e.proposalId) && (t.proposalId = BigInt(e.proposalId.toString())), (0, a.isSet)(e.pagination) && (t.pagination = o.PageRequest.fromJSON(e.pagination)), t
                },
                toJSON(e) {
                    let t = {};
                    return void 0 !== e.proposalId && (t.proposalId = (e.proposalId || BigInt(0)).toString()), void 0 !== e.pagination && (t.pagination = e.pagination ? o.PageRequest.toJSON(e.pagination) : void 0), t
                },
                fromPartial(e) {
                    let t = m();
                    return void 0 !== e.proposalId && null !== e.proposalId && (t.proposalId = BigInt(e.proposalId.toString())), void 0 !== e.pagination && null !== e.pagination && (t.pagination = o.PageRequest.fromPartial(e.pagination)), t
                }
            }, t.QueryVotesResponse = {
                typeUrl: "/cosmos.gov.v1beta1.QueryVotesResponse",
                encode(e, t = i.BinaryWriter.create()) {
                    for (let r of e.votes) n.Vote.encode(r, t.uint32(10).fork()).ldelim();
                    return void 0 !== e.pagination && o.PageResponse.encode(e.pagination, t.uint32(18).fork()).ldelim(), t
                },
                decode(e, t) {
                    let r = e instanceof i.BinaryReader ? e : new i.BinaryReader(e),
                        a = void 0 === t ? r.len : r.pos + t,
                        s = g();
                    for (; r.pos < a;) {
                        let e = r.uint32();
                        switch (e >>> 3) {
                            case 1:
                                s.votes.push(n.Vote.decode(r, r.uint32()));
                                break;
                            case 2:
                                s.pagination = o.PageResponse.decode(r, r.uint32());
                                break;
                            default:
                                r.skipType(7 & e)
                        }
                    }
                    return s
                },
                fromJSON(e) {
                    let t = g();
                    return Array.isArray(e ? .votes) && (t.votes = e.votes.map(e => n.Vote.fromJSON(e))), (0, a.isSet)(e.pagination) && (t.pagination = o.PageResponse.fromJSON(e.pagination)), t
                },
                toJSON(e) {
                    let t = {};
                    return e.votes ? t.votes = e.votes.map(e => e ? n.Vote.toJSON(e) : void 0) : t.votes = [], void 0 !== e.pagination && (t.pagination = e.pagination ? o.PageResponse.toJSON(e.pagination) : void 0), t
                },
                fromPartial(e) {
                    let t = g();
                    return t.votes = e.votes ? .map(e => n.Vote.fromPartial(e)) || [], void 0 !== e.pagination && null !== e.pagination && (t.pagination = o.PageResponse.fromPartial(e.pagination)), t
                }
            }, t.QueryParamsRequest = {
                typeUrl: "/cosmos.gov.v1beta1.QueryParamsRequest",
                encode: (e, t = i.BinaryWriter.create()) => ("" !== e.paramsType && t.uint32(10).string(e.paramsType), t),
                decode(e, t) {
                    let r = e instanceof i.BinaryReader ? e : new i.BinaryReader(e),
                        n = void 0 === t ? r.len : r.pos + t,
                        o = f();
                    for (; r.pos < n;) {
                        let e = r.uint32();
                        e >>> 3 == 1 ? o.paramsType = r.string() : r.skipType(7 & e)
                    }
                    return o
                },
                fromJSON(e) {
                    let t = f();
                    return (0, a.isSet)(e.paramsType) && (t.paramsType = String(e.paramsType)), t
                },
                toJSON(e) {
                    let t = {};
                    return void 0 !== e.paramsType && (t.paramsType = e.paramsType), t
                },
                fromPartial(e) {
                    let t = f();
                    return t.paramsType = e.paramsType ? ? "", t
                }
            }, t.QueryParamsResponse = {
                typeUrl: "/cosmos.gov.v1beta1.QueryParamsResponse",
                encode: (e, t = i.BinaryWriter.create()) => (void 0 !== e.votingParams && n.VotingParams.encode(e.votingParams, t.uint32(10).fork()).ldelim(), void 0 !== e.depositParams && n.DepositParams.encode(e.depositParams, t.uint32(18).fork()).ldelim(), void 0 !== e.tallyParams && n.TallyParams.encode(e.tallyParams, t.uint32(26).fork()).ldelim(), t),
                decode(e, t) {
                    let r = e instanceof i.BinaryReader ? e : new i.BinaryReader(e),
                        o = void 0 === t ? r.len : r.pos + t,
                        a = y();
                    for (; r.pos < o;) {
                        let e = r.uint32();
                        switch (e >>> 3) {
                            case 1:
                                a.votingParams = n.VotingParams.decode(r, r.uint32());
                                break;
                            case 2:
                                a.depositParams = n.DepositParams.decode(r, r.uint32());
                                break;
                            case 3:
                                a.tallyParams = n.TallyParams.decode(r, r.uint32());
                                break;
                            default:
                                r.skipType(7 & e)
                        }
                    }
                    return a
                },
                fromJSON(e) {
                    let t = y();
                    return (0, a.isSet)(e.votingParams) && (t.votingParams = n.VotingParams.fromJSON(e.votingParams)), (0, a.isSet)(e.depositParams) && (t.depositParams = n.DepositParams.fromJSON(e.depositParams)), (0, a.isSet)(e.tallyParams) && (t.tallyParams = n.TallyParams.fromJSON(e.tallyParams)), t
                },
                toJSON(e) {
                    let t = {};
                    return void 0 !== e.votingParams && (t.votingParams = e.votingParams ? n.VotingParams.toJSON(e.votingParams) : void 0), void 0 !== e.depositParams && (t.depositParams = e.depositParams ? n.DepositParams.toJSON(e.depositParams) : void 0), void 0 !== e.tallyParams && (t.tallyParams = e.tallyParams ? n.TallyParams.toJSON(e.tallyParams) : void 0), t
                },
                fromPartial(e) {
                    let t = y();
                    return void 0 !== e.votingParams && null !== e.votingParams && (t.votingParams = n.VotingParams.fromPartial(e.votingParams)), void 0 !== e.depositParams && null !== e.depositParams && (t.depositParams = n.DepositParams.fromPartial(e.depositParams)), void 0 !== e.tallyParams && null !== e.tallyParams && (t.tallyParams = n.TallyParams.fromPartial(e.tallyParams)), t
                }
            }, t.QueryDepositRequest = {
                typeUrl: "/cosmos.gov.v1beta1.QueryDepositRequest",
                encode: (e, t = i.BinaryWriter.create()) => (e.proposalId !== BigInt(0) && t.uint32(8).uint64(e.proposalId), "" !== e.depositor && t.uint32(18).string(e.depositor), t),
                decode(e, t) {
                    let r = e instanceof i.BinaryReader ? e : new i.BinaryReader(e),
                        n = void 0 === t ? r.len : r.pos + t,
                        o = h();
                    for (; r.pos < n;) {
                        let e = r.uint32();
                        switch (e >>> 3) {
                            case 1:
                                o.proposalId = r.uint64();
                                break;
                            case 2:
                                o.depositor = r.string();
                                break;
                            default:
                                r.skipType(7 & e)
                        }
                    }
                    return o
                },
                fromJSON(e) {
                    let t = h();
                    return (0, a.isSet)(e.proposalId) && (t.proposalId = BigInt(e.proposalId.toString())), (0, a.isSet)(e.depositor) && (t.depositor = String(e.depositor)), t
                },
                toJSON(e) {
                    let t = {};
                    return void 0 !== e.proposalId && (t.proposalId = (e.proposalId || BigInt(0)).toString()), void 0 !== e.depositor && (t.depositor = e.depositor), t
                },
                fromPartial(e) {
                    let t = h();
                    return void 0 !== e.proposalId && null !== e.proposalId && (t.proposalId = BigInt(e.proposalId.toString())), t.depositor = e.depositor ? ? "", t
                }
            }, t.QueryDepositResponse = {
                typeUrl: "/cosmos.gov.v1beta1.QueryDepositResponse",
                encode: (e, t = i.BinaryWriter.create()) => (void 0 !== e.deposit && n.Deposit.encode(e.deposit, t.uint32(10).fork()).ldelim(), t),
                decode(e, t) {
                    let r = e instanceof i.BinaryReader ? e : new i.BinaryReader(e),
                        o = void 0 === t ? r.len : r.pos + t,
                        a = v();
                    for (; r.pos < o;) {
                        let e = r.uint32();
                        e >>> 3 == 1 ? a.deposit = n.Deposit.decode(r, r.uint32()) : r.skipType(7 & e)
                    }
                    return a
                },
                fromJSON(e) {
                    let t = v();
                    return (0, a.isSet)(e.deposit) && (t.deposit = n.Deposit.fromJSON(e.deposit)), t
                },
                toJSON(e) {
                    let t = {};
                    return void 0 !== e.deposit && (t.deposit = e.deposit ? n.Deposit.toJSON(e.deposit) : void 0), t
                },
                fromPartial(e) {
                    let t = v();
                    return void 0 !== e.deposit && null !== e.deposit && (t.deposit = n.Deposit.fromPartial(e.deposit)), t
                }
            }, t.QueryDepositsRequest = {
                typeUrl: "/cosmos.gov.v1beta1.QueryDepositsRequest",
                encode: (e, t = i.BinaryWriter.create()) => (e.proposalId !== BigInt(0) && t.uint32(8).uint64(e.proposalId), void 0 !== e.pagination && o.PageRequest.encode(e.pagination, t.uint32(18).fork()).ldelim(), t),
                decode(e, t) {
                    let r = e instanceof i.BinaryReader ? e : new i.BinaryReader(e),
                        n = void 0 === t ? r.len : r.pos + t,
                        a = b();
                    for (; r.pos < n;) {
                        let e = r.uint32();
                        switch (e >>> 3) {
                            case 1:
                                a.proposalId = r.uint64();
                                break;
                            case 2:
                                a.pagination = o.PageRequest.decode(r, r.uint32());
                                break;
                            default:
                                r.skipType(7 & e)
                        }
                    }
                    return a
                },
                fromJSON(e) {
                    let t = b();
                    return (0, a.isSet)(e.proposalId) && (t.proposalId = BigInt(e.proposalId.toString())), (0, a.isSet)(e.pagination) && (t.pagination = o.PageRequest.fromJSON(e.pagination)), t
                },
                toJSON(e) {
                    let t = {};
                    return void 0 !== e.proposalId && (t.proposalId = (e.proposalId || BigInt(0)).toString()), void 0 !== e.pagination && (t.pagination = e.pagination ? o.PageRequest.toJSON(e.pagination) : void 0), t
                },
                fromPartial(e) {
                    let t = b();
                    return void 0 !== e.proposalId && null !== e.proposalId && (t.proposalId = BigInt(e.proposalId.toString())), void 0 !== e.pagination && null !== e.pagination && (t.pagination = o.PageRequest.fromPartial(e.pagination)), t
                }
            }, t.QueryDepositsResponse = {
                typeUrl: "/cosmos.gov.v1beta1.QueryDepositsResponse",
                encode(e, t = i.BinaryWriter.create()) {
                    for (let r of e.deposits) n.Deposit.encode(r, t.uint32(10).fork()).ldelim();
                    return void 0 !== e.pagination && o.PageResponse.encode(e.pagination, t.uint32(18).fork()).ldelim(), t
                },
                decode(e, t) {
                    let r = e instanceof i.BinaryReader ? e : new i.BinaryReader(e),
                        a = void 0 === t ? r.len : r.pos + t,
                        s = S();
                    for (; r.pos < a;) {
                        let e = r.uint32();
                        switch (e >>> 3) {
                            case 1:
                                s.deposits.push(n.Deposit.decode(r, r.uint32()));
                                break;
                            case 2:
                                s.pagination = o.PageResponse.decode(r, r.uint32());
                                break;
                            default:
                                r.skipType(7 & e)
                        }
                    }
                    return s
                },
                fromJSON(e) {
                    let t = S();
                    return Array.isArray(e ? .deposits) && (t.deposits = e.deposits.map(e => n.Deposit.fromJSON(e))), (0, a.isSet)(e.pagination) && (t.pagination = o.PageResponse.fromJSON(e.pagination)), t
                },
                toJSON(e) {
                    let t = {};
                    return e.deposits ? t.deposits = e.deposits.map(e => e ? n.Deposit.toJSON(e) : void 0) : t.deposits = [], void 0 !== e.pagination && (t.pagination = e.pagination ? o.PageResponse.toJSON(e.pagination) : void 0), t
                },
                fromPartial(e) {
                    let t = S();
                    return t.deposits = e.deposits ? .map(e => n.Deposit.fromPartial(e)) || [], void 0 !== e.pagination && null !== e.pagination && (t.pagination = o.PageResponse.fromPartial(e.pagination)), t
                }
            }, t.QueryTallyResultRequest = {
                typeUrl: "/cosmos.gov.v1beta1.QueryTallyResultRequest",
                encode: (e, t = i.BinaryWriter.create()) => (e.proposalId !== BigInt(0) && t.uint32(8).uint64(e.proposalId), t),
                decode(e, t) {
                    let r = e instanceof i.BinaryReader ? e : new i.BinaryReader(e),
                        n = void 0 === t ? r.len : r.pos + t,
                        o = k();
                    for (; r.pos < n;) {
                        let e = r.uint32();
                        e >>> 3 == 1 ? o.proposalId = r.uint64() : r.skipType(7 & e)
                    }
                    return o
                },
                fromJSON(e) {
                    let t = k();
                    return (0, a.isSet)(e.proposalId) && (t.proposalId = BigInt(e.proposalId.toString())), t
                },
                toJSON(e) {
                    let t = {};
                    return void 0 !== e.proposalId && (t.proposalId = (e.proposalId || BigInt(0)).toString()), t
                },
                fromPartial(e) {
                    let t = k();
                    return void 0 !== e.proposalId && null !== e.proposalId && (t.proposalId = BigInt(e.proposalId.toString())), t
                }
            }, t.QueryTallyResultResponse = {
                typeUrl: "/cosmos.gov.v1beta1.QueryTallyResultResponse",
                encode: (e, t = i.BinaryWriter.create()) => (void 0 !== e.tally && n.TallyResult.encode(e.tally, t.uint32(10).fork()).ldelim(), t),
                decode(e, t) {
                    let r = e instanceof i.BinaryReader ? e : new i.BinaryReader(e),
                        o = void 0 === t ? r.len : r.pos + t,
                        a = P();
                    for (; r.pos < o;) {
                        let e = r.uint32();
                        e >>> 3 == 1 ? a.tally = n.TallyResult.decode(r, r.uint32()) : r.skipType(7 & e)
                    }
                    return a
                },
                fromJSON(e) {
                    let t = P();
                    return (0, a.isSet)(e.tally) && (t.tally = n.TallyResult.fromJSON(e.tally)), t
                },
                toJSON(e) {
                    let t = {};
                    return void 0 !== e.tally && (t.tally = e.tally ? n.TallyResult.toJSON(e.tally) : void 0), t
                },
                fromPartial(e) {
                    let t = P();
                    return void 0 !== e.tally && null !== e.tally && (t.tally = n.TallyResult.fromPartial(e.tally)), t
                }
            };
            class _ {
                constructor(e) {
                    this.rpc = e, this.Proposal = this.Proposal.bind(this), this.Proposals = this.Proposals.bind(this), this.Vote = this.Vote.bind(this), this.Votes = this.Votes.bind(this), this.Params = this.Params.bind(this), this.Deposit = this.Deposit.bind(this), this.Deposits = this.Deposits.bind(this), this.TallyResult = this.TallyResult.bind(this)
                }
                Proposal(e) {
                    let r = t.QueryProposalRequest.encode(e).finish();
                    return this.rpc.request("cosmos.gov.v1beta1.Query", "Proposal", r).then(e => t.QueryProposalResponse.decode(new i.BinaryReader(e)))
                }
                Proposals(e) {
                    let r = t.QueryProposalsRequest.encode(e).finish();
                    return this.rpc.request("cosmos.gov.v1beta1.Query", "Proposals", r).then(e => t.QueryProposalsResponse.decode(new i.BinaryReader(e)))
                }
                Vote(e) {
                    let r = t.QueryVoteRequest.encode(e).finish();
                    return this.rpc.request("cosmos.gov.v1beta1.Query", "Vote", r).then(e => t.QueryVoteResponse.decode(new i.BinaryReader(e)))
                }
                Votes(e) {
                    let r = t.QueryVotesRequest.encode(e).finish();
                    return this.rpc.request("cosmos.gov.v1beta1.Query", "Votes", r).then(e => t.QueryVotesResponse.decode(new i.BinaryReader(e)))
                }
                Params(e) {
                    let r = t.QueryParamsRequest.encode(e).finish();
                    return this.rpc.request("cosmos.gov.v1beta1.Query", "Params", r).then(e => t.QueryParamsResponse.decode(new i.BinaryReader(e)))
                }
                Deposit(e) {
                    let r = t.QueryDepositRequest.encode(e).finish();
                    return this.rpc.request("cosmos.gov.v1beta1.Query", "Deposit", r).then(e => t.QueryDepositResponse.decode(new i.BinaryReader(e)))
                }
                Deposits(e) {
                    let r = t.QueryDepositsRequest.encode(e).finish();
                    return this.rpc.request("cosmos.gov.v1beta1.Query", "Deposits", r).then(e => t.QueryDepositsResponse.decode(new i.BinaryReader(e)))
                }
                TallyResult(e) {
                    let r = t.QueryTallyResultRequest.encode(e).finish();
                    return this.rpc.request("cosmos.gov.v1beta1.Query", "TallyResult", r).then(e => t.QueryTallyResultResponse.decode(new i.BinaryReader(e)))
                }
            }
            t.QueryClientImpl = _
        },
        26183: function(e, t, r) {
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: !0
            }), t.MsgClientImpl = t.MsgDepositResponse = t.MsgDeposit = t.MsgVoteWeightedResponse = t.MsgVoteWeighted = t.MsgVoteResponse = t.MsgVote = t.MsgSubmitProposalResponse = t.MsgSubmitProposal = t.protobufPackage = void 0;
            let n = r(65676),
                o = r(62809),
                i = r(62455),
                a = r(28486),
                s = r(6476);

            function d() {
                return {
                    content: void 0,
                    initialDeposit: [],
                    proposer: ""
                }
            }

            function c() {
                return {
                    proposalId: BigInt(0)
                }
            }

            function l() {
                return {
                    proposalId: BigInt(0),
                    voter: "",
                    option: 0
                }
            }

            function u() {
                return {
                    proposalId: BigInt(0),
                    voter: "",
                    options: []
                }
            }

            function p() {
                return {
                    proposalId: BigInt(0),
                    depositor: "",
                    amount: []
                }
            }
            t.protobufPackage = "cosmos.gov.v1beta1", t.MsgSubmitProposal = {
                typeUrl: "/cosmos.gov.v1beta1.MsgSubmitProposal",
                encode(e, t = a.BinaryWriter.create()) {
                    for (let r of (void 0 !== e.content && n.Any.encode(e.content, t.uint32(10).fork()).ldelim(), e.initialDeposit)) o.Coin.encode(r, t.uint32(18).fork()).ldelim();
                    return "" !== e.proposer && t.uint32(26).string(e.proposer), t
                },
                decode(e, t) {
                    let r = e instanceof a.BinaryReader ? e : new a.BinaryReader(e),
                        i = void 0 === t ? r.len : r.pos + t,
                        s = d();
                    for (; r.pos < i;) {
                        let e = r.uint32();
                        switch (e >>> 3) {
                            case 1:
                                s.content = n.Any.decode(r, r.uint32());
                                break;
                            case 2:
                                s.initialDeposit.push(o.Coin.decode(r, r.uint32()));
                                break;
                            case 3:
                                s.proposer = r.string();
                                break;
                            default:
                                r.skipType(7 & e)
                        }
                    }
                    return s
                },
                fromJSON(e) {
                    let t = d();
                    return (0, s.isSet)(e.content) && (t.content = n.Any.fromJSON(e.content)), Array.isArray(e ? .initialDeposit) && (t.initialDeposit = e.initialDeposit.map(e => o.Coin.fromJSON(e))), (0, s.isSet)(e.proposer) && (t.proposer = String(e.proposer)), t
                },
                toJSON(e) {
                    let t = {};
                    return void 0 !== e.content && (t.content = e.content ? n.Any.toJSON(e.content) : void 0), e.initialDeposit ? t.initialDeposit = e.initialDeposit.map(e => e ? o.Coin.toJSON(e) : void 0) : t.initialDeposit = [], void 0 !== e.proposer && (t.proposer = e.proposer), t
                },
                fromPartial(e) {
                    let t = d();
                    return void 0 !== e.content && null !== e.content && (t.content = n.Any.fromPartial(e.content)), t.initialDeposit = e.initialDeposit ? .map(e => o.Coin.fromPartial(e)) || [], t.proposer = e.proposer ? ? "", t
                }
            }, t.MsgSubmitProposalResponse = {
                typeUrl: "/cosmos.gov.v1beta1.MsgSubmitProposalResponse",
                encode: (e, t = a.BinaryWriter.create()) => (e.proposalId !== BigInt(0) && t.uint32(8).uint64(e.proposalId), t),
                decode(e, t) {
                    let r = e instanceof a.BinaryReader ? e : new a.BinaryReader(e),
                        n = void 0 === t ? r.len : r.pos + t,
                        o = c();
                    for (; r.pos < n;) {
                        let e = r.uint32();
                        e >>> 3 == 1 ? o.proposalId = r.uint64() : r.skipType(7 & e)
                    }
                    return o
                },
                fromJSON(e) {
                    let t = c();
                    return (0, s.isSet)(e.proposalId) && (t.proposalId = BigInt(e.proposalId.toString())), t
                },
                toJSON(e) {
                    let t = {};
                    return void 0 !== e.proposalId && (t.proposalId = (e.proposalId || BigInt(0)).toString()), t
                },
                fromPartial(e) {
                    let t = c();
                    return void 0 !== e.proposalId && null !== e.proposalId && (t.proposalId = BigInt(e.proposalId.toString())), t
                }
            }, t.MsgVote = {
                typeUrl: "/cosmos.gov.v1beta1.MsgVote",
                encode: (e, t = a.BinaryWriter.create()) => (e.proposalId !== BigInt(0) && t.uint32(8).uint64(e.proposalId), "" !== e.voter && t.uint32(18).string(e.voter), 0 !== e.option && t.uint32(24).int32(e.option), t),
                decode(e, t) {
                    let r = e instanceof a.BinaryReader ? e : new a.BinaryReader(e),
                        n = void 0 === t ? r.len : r.pos + t,
                        o = l();
                    for (; r.pos < n;) {
                        let e = r.uint32();
                        switch (e >>> 3) {
                            case 1:
                                o.proposalId = r.uint64();
                                break;
                            case 2:
                                o.voter = r.string();
                                break;
                            case 3:
                                o.option = r.int32();
                                break;
                            default:
                                r.skipType(7 & e)
                        }
                    }
                    return o
                },
                fromJSON(e) {
                    let t = l();
                    return (0, s.isSet)(e.proposalId) && (t.proposalId = BigInt(e.proposalId.toString())), (0, s.isSet)(e.voter) && (t.voter = String(e.voter)), (0, s.isSet)(e.option) && (t.option = (0, i.voteOptionFromJSON)(e.option)), t
                },
                toJSON(e) {
                    let t = {};
                    return void 0 !== e.proposalId && (t.proposalId = (e.proposalId || BigInt(0)).toString()), void 0 !== e.voter && (t.voter = e.voter), void 0 !== e.option && (t.option = (0, i.voteOptionToJSON)(e.option)), t
                },
                fromPartial(e) {
                    let t = l();
                    return void 0 !== e.proposalId && null !== e.proposalId && (t.proposalId = BigInt(e.proposalId.toString())), t.voter = e.voter ? ? "", t.option = e.option ? ? 0, t
                }
            }, t.MsgVoteResponse = {
                typeUrl: "/cosmos.gov.v1beta1.MsgVoteResponse",
                encode: (e, t = a.BinaryWriter.create()) => t,
                decode(e, t) {
                    let r = e instanceof a.BinaryReader ? e : new a.BinaryReader(e),
                        n = void 0 === t ? r.len : r.pos + t;
                    for (; r.pos < n;) {
                        let e = r.uint32();
                        r.skipType(7 & e)
                    }
                    return {}
                },
                fromJSON: e => ({}),
                toJSON: e => ({}),
                fromPartial: e => ({})
            }, t.MsgVoteWeighted = {
                typeUrl: "/cosmos.gov.v1beta1.MsgVoteWeighted",
                encode(e, t = a.BinaryWriter.create()) {
                    for (let r of (e.proposalId !== BigInt(0) && t.uint32(8).uint64(e.proposalId), "" !== e.voter && t.uint32(18).string(e.voter), e.options)) i.WeightedVoteOption.encode(r, t.uint32(26).fork()).ldelim();
                    return t
                },
                decode(e, t) {
                    let r = e instanceof a.BinaryReader ? e : new a.BinaryReader(e),
                        n = void 0 === t ? r.len : r.pos + t,
                        o = u();
                    for (; r.pos < n;) {
                        let e = r.uint32();
                        switch (e >>> 3) {
                            case 1:
                                o.proposalId = r.uint64();
                                break;
                            case 2:
                                o.voter = r.string();
                                break;
                            case 3:
                                o.options.push(i.WeightedVoteOption.decode(r, r.uint32()));
                                break;
                            default:
                                r.skipType(7 & e)
                        }
                    }
                    return o
                },
                fromJSON(e) {
                    let t = u();
                    return (0, s.isSet)(e.proposalId) && (t.proposalId = BigInt(e.proposalId.toString())), (0, s.isSet)(e.voter) && (t.voter = String(e.voter)), Array.isArray(e ? .options) && (t.options = e.options.map(e => i.WeightedVoteOption.fromJSON(e))), t
                },
                toJSON(e) {
                    let t = {};
                    return void 0 !== e.proposalId && (t.proposalId = (e.proposalId || BigInt(0)).toString()), void 0 !== e.voter && (t.voter = e.voter), e.options ? t.options = e.options.map(e => e ? i.WeightedVoteOption.toJSON(e) : void 0) : t.options = [], t
                },
                fromPartial(e) {
                    let t = u();
                    return void 0 !== e.proposalId && null !== e.proposalId && (t.proposalId = BigInt(e.proposalId.toString())), t.voter = e.voter ? ? "", t.options = e.options ? .map(e => i.WeightedVoteOption.fromPartial(e)) || [], t
                }
            }, t.MsgVoteWeightedResponse = {
                typeUrl: "/cosmos.gov.v1beta1.MsgVoteWeightedResponse",
                encode: (e, t = a.BinaryWriter.create()) => t,
                decode(e, t) {
                    let r = e instanceof a.BinaryReader ? e : new a.BinaryReader(e),
                        n = void 0 === t ? r.len : r.pos + t;
                    for (; r.pos < n;) {
                        let e = r.uint32();
                        r.skipType(7 & e)
                    }
                    return {}
                },
                fromJSON: e => ({}),
                toJSON: e => ({}),
                fromPartial: e => ({})
            }, t.MsgDeposit = {
                typeUrl: "/cosmos.gov.v1beta1.MsgDeposit",
                encode(e, t = a.BinaryWriter.create()) {
                    for (let r of (e.proposalId !== BigInt(0) && t.uint32(8).uint64(e.proposalId), "" !== e.depositor && t.uint32(18).string(e.depositor), e.amount)) o.Coin.encode(r, t.uint32(26).fork()).ldelim();
                    return t
                },
                decode(e, t) {
                    let r = e instanceof a.BinaryReader ? e : new a.BinaryReader(e),
                        n = void 0 === t ? r.len : r.pos + t,
                        i = p();
                    for (; r.pos < n;) {
                        let e = r.uint32();
                        switch (e >>> 3) {
                            case 1:
                                i.proposalId = r.uint64();
                                break;
                            case 2:
                                i.depositor = r.string();
                                break;
                            case 3:
                                i.amount.push(o.Coin.decode(r, r.uint32()));
                                break;
                            default:
                                r.skipType(7 & e)
                        }
                    }
                    return i
                },
                fromJSON(e) {
                    let t = p();
                    return (0, s.isSet)(e.proposalId) && (t.proposalId = BigInt(e.proposalId.toString())), (0, s.isSet)(e.depositor) && (t.depositor = String(e.depositor)), Array.isArray(e ? .amount) && (t.amount = e.amount.map(e => o.Coin.fromJSON(e))), t
                },
                toJSON(e) {
                    let t = {};
                    return void 0 !== e.proposalId && (t.proposalId = (e.proposalId || BigInt(0)).toString()), void 0 !== e.depositor && (t.depositor = e.depositor), e.amount ? t.amount = e.amount.map(e => e ? o.Coin.toJSON(e) : void 0) : t.amount = [], t
                },
                fromPartial(e) {
                    let t = p();
                    return void 0 !== e.proposalId && null !== e.proposalId && (t.proposalId = BigInt(e.proposalId.toString())), t.depositor = e.depositor ? ? "", t.amount = e.amount ? .map(e => o.Coin.fromPartial(e)) || [], t
                }
            }, t.MsgDepositResponse = {
                typeUrl: "/cosmos.gov.v1beta1.MsgDepositResponse",
                encode: (e, t = a.BinaryWriter.create()) => t,
                decode(e, t) {
                    let r = e instanceof a.BinaryReader ? e : new a.BinaryReader(e),
                        n = void 0 === t ? r.len : r.pos + t;
                    for (; r.pos < n;) {
                        let e = r.uint32();
                        r.skipType(7 & e)
                    }
                    return {}
                },
                fromJSON: e => ({}),
                toJSON: e => ({}),
                fromPartial: e => ({})
            };
            class m {
                constructor(e) {
                    this.rpc = e, this.SubmitProposal = this.SubmitProposal.bind(this), this.Vote = this.Vote.bind(this), this.VoteWeighted = this.VoteWeighted.bind(this), this.Deposit = this.Deposit.bind(this)
                }
                SubmitProposal(e) {
                    let r = t.MsgSubmitProposal.encode(e).finish();
                    return this.rpc.request("cosmos.gov.v1beta1.Msg", "SubmitProposal", r).then(e => t.MsgSubmitProposalResponse.decode(new a.BinaryReader(e)))
                }
                Vote(e) {
                    let r = t.MsgVote.encode(e).finish();
                    return this.rpc.request("cosmos.gov.v1beta1.Msg", "Vote", r).then(e => t.MsgVoteResponse.decode(new a.BinaryReader(e)))
                }
                VoteWeighted(e) {
                    let r = t.MsgVoteWeighted.encode(e).finish();
                    return this.rpc.request("cosmos.gov.v1beta1.Msg", "VoteWeighted", r).then(e => t.MsgVoteWeightedResponse.decode(new a.BinaryReader(e)))
                }
                Deposit(e) {
                    let r = t.MsgDeposit.encode(e).finish();
                    return this.rpc.request("cosmos.gov.v1beta1.Msg", "Deposit", r).then(e => t.MsgDepositResponse.decode(new a.BinaryReader(e)))
                }
            }
            t.MsgClientImpl = m
        },
        91640: function(e, t, r) {
            "use strict";
            var n, o;
            Object.defineProperty(t, "__esModule", {
                value: !0
            }), t.MsgClientImpl = t.MsgLeaveGroupResponse = t.MsgLeaveGroup = t.MsgExecResponse = t.MsgExec = t.MsgVoteResponse = t.MsgVote = t.MsgWithdrawProposalResponse = t.MsgWithdrawProposal = t.MsgSubmitProposalResponse = t.MsgSubmitProposal = t.MsgUpdateGroupPolicyMetadataResponse = t.MsgUpdateGroupPolicyMetadata = t.MsgUpdateGroupPolicyDecisionPolicyResponse = t.MsgUpdateGroupPolicyDecisionPolicy = t.MsgCreateGroupWithPolicyResponse = t.MsgCreateGroupWithPolicy = t.MsgUpdateGroupPolicyAdminResponse = t.MsgUpdateGroupPolicyAdmin = t.MsgCreateGroupPolicyResponse = t.MsgCreateGroupPolicy = t.MsgUpdateGroupMetadataResponse = t.MsgUpdateGroupMetadata = t.MsgUpdateGroupAdminResponse = t.MsgUpdateGroupAdmin = t.MsgUpdateGroupMembersResponse = t.MsgUpdateGroupMembers = t.MsgCreateGroupResponse = t.MsgCreateGroup = t.execToJSON = t.execFromJSON = t.Exec = t.protobufPackage = void 0;
            let i = r(66389),
                a = r(65676),
                s = r(28486),
                d = r(6476);

            function c(e) {
                switch (e) {
                    case 0:
                    case "EXEC_UNSPECIFIED":
                        return n.EXEC_UNSPECIFIED;
                    case 1:
                    case "EXEC_TRY":
                        return n.EXEC_TRY;
                    default:
                        return n.UNRECOGNIZED
                }
            }

            function l(e) {
                switch (e) {
                    case n.EXEC_UNSPECIFIED:
                        return "EXEC_UNSPECIFIED";
                    case n.EXEC_TRY:
                        return "EXEC_TRY";
                    case n.UNRECOGNIZED:
                    default:
                        return "UNRECOGNIZED"
                }
            }

            function u() {
                return {
                    admin: "",
                    members: [],
                    metadata: ""
                }
            }

            function p() {
                return {
                    groupId: BigInt(0)
                }
            }

            function m() {
                return {
                    admin: "",
                    groupId: BigInt(0),
                    memberUpdates: []
                }
            }

            function g() {
                return {
                    admin: "",
                    groupId: BigInt(0),
                    newAdmin: ""
                }
            }

            function f() {
                return {
                    admin: "",
                    groupId: BigInt(0),
                    metadata: ""
                }
            }

            function y() {
                return {
                    admin: "",
                    groupId: BigInt(0),
                    metadata: "",
                    decisionPolicy: void 0
                }
            }

            function h() {
                return {
                    address: ""
                }
            }

            function v() {
                return {
                    admin: "",
                    groupPolicyAddress: "",
                    newAdmin: ""
                }
            }

            function b() {
                return {
                    admin: "",
                    members: [],
                    groupMetadata: "",
                    groupPolicyMetadata: "",
                    groupPolicyAsAdmin: !1,
                    decisionPolicy: void 0
                }
            }

            function S() {
                return {
                    groupId: BigInt(0),
                    groupPolicyAddress: ""
                }
            }

            function k() {
                return {
                    admin: "",
                    groupPolicyAddress: "",
                    decisionPolicy: void 0
                }
            }

            function P() {
                return {
                    admin: "",
                    groupPolicyAddress: "",
                    metadata: ""
                }
            }

            function _() {
                return {
                    groupPolicyAddress: "",
                    proposers: [],
                    metadata: "",
                    messages: [],
                    exec: 0,
                    title: "",
                    summary: ""
                }
            }

            function B() {
                return {
                    proposalId: BigInt(0)
                }
            }

            function O() {
                return {
                    proposalId: BigInt(0),
                    address: ""
                }
            }

            function R() {
                return {
                    proposalId: BigInt(0),
                    voter: "",
                    option: 0,
                    metadata: "",
                    exec: 0
                }
            }

            function A() {
                return {
                    proposalId: BigInt(0),
                    executor: ""
                }
            }

            function I() {
                return {
                    result: 0
                }
            }

            function w() {
                return {
                    address: "",
                    groupId: BigInt(0)
                }
            }
            t.protobufPackage = "cosmos.group.v1", (o = n || (t.Exec = n = {}))[o.EXEC_UNSPECIFIED = 0] = "EXEC_UNSPECIFIED", o[o.EXEC_TRY = 1] = "EXEC_TRY", o[o.UNRECOGNIZED = -1] = "UNRECOGNIZED", t.execFromJSON = c, t.execToJSON = l, t.MsgCreateGroup = {
                typeUrl: "/cosmos.group.v1.MsgCreateGroup",
                encode(e, t = s.BinaryWriter.create()) {
                    for (let r of ("" !== e.admin && t.uint32(10).string(e.admin), e.members)) i.MemberRequest.encode(r, t.uint32(18).fork()).ldelim();
                    return "" !== e.metadata && t.uint32(26).string(e.metadata), t
                },
                decode(e, t) {
                    let r = e instanceof s.BinaryReader ? e : new s.BinaryReader(e),
                        n = void 0 === t ? r.len : r.pos + t,
                        o = u();
                    for (; r.pos < n;) {
                        let e = r.uint32();
                        switch (e >>> 3) {
                            case 1:
                                o.admin = r.string();
                                break;
                            case 2:
                                o.members.push(i.MemberRequest.decode(r, r.uint32()));
                                break;
                            case 3:
                                o.metadata = r.string();
                                break;
                            default:
                                r.skipType(7 & e)
                        }
                    }
                    return o
                },
                fromJSON(e) {
                    let t = u();
                    return (0, d.isSet)(e.admin) && (t.admin = String(e.admin)), Array.isArray(e ? .members) && (t.members = e.members.map(e => i.MemberRequest.fromJSON(e))), (0, d.isSet)(e.metadata) && (t.metadata = String(e.metadata)), t
                },
                toJSON(e) {
                    let t = {};
                    return void 0 !== e.admin && (t.admin = e.admin), e.members ? t.members = e.members.map(e => e ? i.MemberRequest.toJSON(e) : void 0) : t.members = [], void 0 !== e.metadata && (t.metadata = e.metadata), t
                },
                fromPartial(e) {
                    let t = u();
                    return t.admin = e.admin ? ? "", t.members = e.members ? .map(e => i.MemberRequest.fromPartial(e)) || [], t.metadata = e.metadata ? ? "", t
                }
            }, t.MsgCreateGroupResponse = {
                typeUrl: "/cosmos.group.v1.MsgCreateGroupResponse",
                encode: (e, t = s.BinaryWriter.create()) => (e.groupId !== BigInt(0) && t.uint32(8).uint64(e.groupId), t),
                decode(e, t) {
                    let r = e instanceof s.BinaryReader ? e : new s.BinaryReader(e),
                        n = void 0 === t ? r.len : r.pos + t,
                        o = p();
                    for (; r.pos < n;) {
                        let e = r.uint32();
                        e >>> 3 == 1 ? o.groupId = r.uint64() : r.skipType(7 & e)
                    }
                    return o
                },
                fromJSON(e) {
                    let t = p();
                    return (0, d.isSet)(e.groupId) && (t.groupId = BigInt(e.groupId.toString())), t
                },
                toJSON(e) {
                    let t = {};
                    return void 0 !== e.groupId && (t.groupId = (e.groupId || BigInt(0)).toString()), t
                },
                fromPartial(e) {
                    let t = p();
                    return void 0 !== e.groupId && null !== e.groupId && (t.groupId = BigInt(e.groupId.toString())), t
                }
            }, t.MsgUpdateGroupMembers = {
                typeUrl: "/cosmos.group.v1.MsgUpdateGroupMembers",
                encode(e, t = s.BinaryWriter.create()) {
                    for (let r of ("" !== e.admin && t.uint32(10).string(e.admin), e.groupId !== BigInt(0) && t.uint32(16).uint64(e.groupId), e.memberUpdates)) i.MemberRequest.encode(r, t.uint32(26).fork()).ldelim();
                    return t
                },
                decode(e, t) {
                    let r = e instanceof s.BinaryReader ? e : new s.BinaryReader(e),
                        n = void 0 === t ? r.len : r.pos + t,
                        o = m();
                    for (; r.pos < n;) {
                        let e = r.uint32();
                        switch (e >>> 3) {
                            case 1:
                                o.admin = r.string();
                                break;
                            case 2:
                                o.groupId = r.uint64();
                                break;
                            case 3:
                                o.memberUpdates.push(i.MemberRequest.decode(r, r.uint32()));
                                break;
                            default:
                                r.skipType(7 & e)
                        }
                    }
                    return o
                },
                fromJSON(e) {
                    let t = m();
                    return (0, d.isSet)(e.admin) && (t.admin = String(e.admin)), (0, d.isSet)(e.groupId) && (t.groupId = BigInt(e.groupId.toString())), Array.isArray(e ? .memberUpdates) && (t.memberUpdates = e.memberUpdates.map(e => i.MemberRequest.fromJSON(e))), t
                },
                toJSON(e) {
                    let t = {};
                    return void 0 !== e.admin && (t.admin = e.admin), void 0 !== e.groupId && (t.groupId = (e.groupId || BigInt(0)).toString()), e.memberUpdates ? t.memberUpdates = e.memberUpdates.map(e => e ? i.MemberRequest.toJSON(e) : void 0) : t.memberUpdates = [], t
                },
                fromPartial(e) {
                    let t = m();
                    return t.admin = e.admin ? ? "", void 0 !== e.groupId && null !== e.groupId && (t.groupId = BigInt(e.groupId.toString())), t.memberUpdates = e.memberUpdates ? .map(e => i.MemberRequest.fromPartial(e)) || [], t
                }
            }, t.MsgUpdateGroupMembersResponse = {
                typeUrl: "/cosmos.group.v1.MsgUpdateGroupMembersResponse",
                encode: (e, t = s.BinaryWriter.create()) => t,
                decode(e, t) {
                    let r = e instanceof s.BinaryReader ? e : new s.BinaryReader(e),
                        n = void 0 === t ? r.len : r.pos + t;
                    for (; r.pos < n;) {
                        let e = r.uint32();
                        r.skipType(7 & e)
                    }
                    return {}
                },
                fromJSON: e => ({}),
                toJSON: e => ({}),
                fromPartial: e => ({})
            }, t.MsgUpdateGroupAdmin = {
                typeUrl: "/cosmos.group.v1.MsgUpdateGroupAdmin",
                encode: (e, t = s.BinaryWriter.create()) => ("" !== e.admin && t.uint32(10).string(e.admin), e.groupId !== BigInt(0) && t.uint32(16).uint64(e.groupId), "" !== e.newAdmin && t.uint32(26).string(e.newAdmin), t),
                decode(e, t) {
                    let r = e instanceof s.BinaryReader ? e : new s.BinaryReader(e),
                        n = void 0 === t ? r.len : r.pos + t,
                        o = g();
                    for (; r.pos < n;) {
                        let e = r.uint32();
                        switch (e >>> 3) {
                            case 1:
                                o.admin = r.string();
                                break;
                            case 2:
                                o.groupId = r.uint64();
                                break;
                            case 3:
                                o.newAdmin = r.string();
                                break;
                            default:
                                r.skipType(7 & e)
                        }
                    }
                    return o
                },
                fromJSON(e) {
                    let t = g();
                    return (0, d.isSet)(e.admin) && (t.admin = String(e.admin)), (0, d.isSet)(e.groupId) && (t.groupId = BigInt(e.groupId.toString())), (0, d.isSet)(e.newAdmin) && (t.newAdmin = String(e.newAdmin)), t
                },
                toJSON(e) {
                    let t = {};
                    return void 0 !== e.admin && (t.admin = e.admin), void 0 !== e.groupId && (t.groupId = (e.groupId || BigInt(0)).toString()), void 0 !== e.newAdmin && (t.newAdmin = e.newAdmin), t
                },
                fromPartial(e) {
                    let t = g();
                    return t.admin = e.admin ? ? "", void 0 !== e.groupId && null !== e.groupId && (t.groupId = BigInt(e.groupId.toString())), t.newAdmin = e.newAdmin ? ? "", t
                }
            }, t.MsgUpdateGroupAdminResponse = {
                typeUrl: "/cosmos.group.v1.MsgUpdateGroupAdminResponse",
                encode: (e, t = s.BinaryWriter.create()) => t,
                decode(e, t) {
                    let r = e instanceof s.BinaryReader ? e : new s.BinaryReader(e),
                        n = void 0 === t ? r.len : r.pos + t;
                    for (; r.pos < n;) {
                        let e = r.uint32();
                        r.skipType(7 & e)
                    }
                    return {}
                },
                fromJSON: e => ({}),
                toJSON: e => ({}),
                fromPartial: e => ({})
            }, t.MsgUpdateGroupMetadata = {
                typeUrl: "/cosmos.group.v1.MsgUpdateGroupMetadata",
                encode: (e, t = s.BinaryWriter.create()) => ("" !== e.admin && t.uint32(10).string(e.admin), e.groupId !== BigInt(0) && t.uint32(16).uint64(e.groupId), "" !== e.metadata && t.uint32(26).string(e.metadata), t),
                decode(e, t) {
                    let r = e instanceof s.BinaryReader ? e : new s.BinaryReader(e),
                        n = void 0 === t ? r.len : r.pos + t,
                        o = f();
                    for (; r.pos < n;) {
                        let e = r.uint32();
                        switch (e >>> 3) {
                            case 1:
                                o.admin = r.string();
                                break;
                            case 2:
                                o.groupId = r.uint64();
                                break;
                            case 3:
                                o.metadata = r.string();
                                break;
                            default:
                                r.skipType(7 & e)
                        }
                    }
                    return o
                },
                fromJSON(e) {
                    let t = f();
                    return (0, d.isSet)(e.admin) && (t.admin = String(e.admin)), (0, d.isSet)(e.groupId) && (t.groupId = BigInt(e.groupId.toString())), (0, d.isSet)(e.metadata) && (t.metadata = String(e.metadata)), t
                },
                toJSON(e) {
                    let t = {};
                    return void 0 !== e.admin && (t.admin = e.admin), void 0 !== e.groupId && (t.groupId = (e.groupId || BigInt(0)).toString()), void 0 !== e.metadata && (t.metadata = e.metadata), t
                },
                fromPartial(e) {
                    let t = f();
                    return t.admin = e.admin ? ? "", void 0 !== e.groupId && null !== e.groupId && (t.groupId = BigInt(e.groupId.toString())), t.metadata = e.metadata ? ? "", t
                }
            }, t.MsgUpdateGroupMetadataResponse = {
                typeUrl: "/cosmos.group.v1.MsgUpdateGroupMetadataResponse",
                encode: (e, t = s.BinaryWriter.create()) => t,
                decode(e, t) {
                    let r = e instanceof s.BinaryReader ? e : new s.BinaryReader(e),
                        n = void 0 === t ? r.len : r.pos + t;
                    for (; r.pos < n;) {
                        let e = r.uint32();
                        r.skipType(7 & e)
                    }
                    return {}
                },
                fromJSON: e => ({}),
                toJSON: e => ({}),
                fromPartial: e => ({})
            }, t.MsgCreateGroupPolicy = {
                typeUrl: "/cosmos.group.v1.MsgCreateGroupPolicy",
                encode: (e, t = s.BinaryWriter.create()) => ("" !== e.admin && t.uint32(10).string(e.admin), e.groupId !== BigInt(0) && t.uint32(16).uint64(e.groupId), "" !== e.metadata && t.uint32(26).string(e.metadata), void 0 !== e.decisionPolicy && a.Any.encode(e.decisionPolicy, t.uint32(34).fork()).ldelim(), t),
                decode(e, t) {
                    let r = e instanceof s.BinaryReader ? e : new s.BinaryReader(e),
                        n = void 0 === t ? r.len : r.pos + t,
                        o = y();
                    for (; r.pos < n;) {
                        let e = r.uint32();
                        switch (e >>> 3) {
                            case 1:
                                o.admin = r.string();
                                break;
                            case 2:
                                o.groupId = r.uint64();
                                break;
                            case 3:
                                o.metadata = r.string();
                                break;
                            case 4:
                                o.decisionPolicy = a.Any.decode(r, r.uint32());
                                break;
                            default:
                                r.skipType(7 & e)
                        }
                    }
                    return o
                },
                fromJSON(e) {
                    let t = y();
                    return (0, d.isSet)(e.admin) && (t.admin = String(e.admin)), (0, d.isSet)(e.groupId) && (t.groupId = BigInt(e.groupId.toString())), (0, d.isSet)(e.metadata) && (t.metadata = String(e.metadata)), (0, d.isSet)(e.decisionPolicy) && (t.decisionPolicy = a.Any.fromJSON(e.decisionPolicy)), t
                },
                toJSON(e) {
                    let t = {};
                    return void 0 !== e.admin && (t.admin = e.admin), void 0 !== e.groupId && (t.groupId = (e.groupId || BigInt(0)).toString()), void 0 !== e.metadata && (t.metadata = e.metadata), void 0 !== e.decisionPolicy && (t.decisionPolicy = e.decisionPolicy ? a.Any.toJSON(e.decisionPolicy) : void 0), t
                },
                fromPartial(e) {
                    let t = y();
                    return t.admin = e.admin ? ? "", void 0 !== e.groupId && null !== e.groupId && (t.groupId = BigInt(e.groupId.toString())), t.metadata = e.metadata ? ? "", void 0 !== e.decisionPolicy && null !== e.decisionPolicy && (t.decisionPolicy = a.Any.fromPartial(e.decisionPolicy)), t
                }
            }, t.MsgCreateGroupPolicyResponse = {
                typeUrl: "/cosmos.group.v1.MsgCreateGroupPolicyResponse",
                encode: (e, t = s.BinaryWriter.create()) => ("" !== e.address && t.uint32(10).string(e.address), t),
                decode(e, t) {
                    let r = e instanceof s.BinaryReader ? e : new s.BinaryReader(e),
                        n = void 0 === t ? r.len : r.pos + t,
                        o = h();
                    for (; r.pos < n;) {
                        let e = r.uint32();
                        e >>> 3 == 1 ? o.address = r.string() : r.skipType(7 & e)
                    }
                    return o
                },
                fromJSON(e) {
                    let t = h();
                    return (0, d.isSet)(e.address) && (t.address = String(e.address)), t
                },
                toJSON(e) {
                    let t = {};
                    return void 0 !== e.address && (t.address = e.address), t
                },
                fromPartial(e) {
                    let t = h();
                    return t.address = e.address ? ? "", t
                }
            }, t.MsgUpdateGroupPolicyAdmin = {
                typeUrl: "/cosmos.group.v1.MsgUpdateGroupPolicyAdmin",
                encode: (e, t = s.BinaryWriter.create()) => ("" !== e.admin && t.uint32(10).string(e.admin), "" !== e.groupPolicyAddress && t.uint32(18).string(e.groupPolicyAddress), "" !== e.newAdmin && t.uint32(26).string(e.newAdmin), t),
                decode(e, t) {
                    let r = e instanceof s.BinaryReader ? e : new s.BinaryReader(e),
                        n = void 0 === t ? r.len : r.pos + t,
                        o = v();
                    for (; r.pos < n;) {
                        let e = r.uint32();
                        switch (e >>> 3) {
                            case 1:
                                o.admin = r.string();
                                break;
                            case 2:
                                o.groupPolicyAddress = r.string();
                                break;
                            case 3:
                                o.newAdmin = r.string();
                                break;
                            default:
                                r.skipType(7 & e)
                        }
                    }
                    return o
                },
                fromJSON(e) {
                    let t = v();
                    return (0, d.isSet)(e.admin) && (t.admin = String(e.admin)), (0, d.isSet)(e.groupPolicyAddress) && (t.groupPolicyAddress = String(e.groupPolicyAddress)), (0, d.isSet)(e.newAdmin) && (t.newAdmin = String(e.newAdmin)), t
                },
                toJSON(e) {
                    let t = {};
                    return void 0 !== e.admin && (t.admin = e.admin), void 0 !== e.groupPolicyAddress && (t.groupPolicyAddress = e.groupPolicyAddress), void 0 !== e.newAdmin && (t.newAdmin = e.newAdmin), t
                },
                fromPartial(e) {
                    let t = v();
                    return t.admin = e.admin ? ? "", t.groupPolicyAddress = e.groupPolicyAddress ? ? "", t.newAdmin = e.newAdmin ? ? "", t
                }
            }, t.MsgUpdateGroupPolicyAdminResponse = {
                typeUrl: "/cosmos.group.v1.MsgUpdateGroupPolicyAdminResponse",
                encode: (e, t = s.BinaryWriter.create()) => t,
                decode(e, t) {
                    let r = e instanceof s.BinaryReader ? e : new s.BinaryReader(e),
                        n = void 0 === t ? r.len : r.pos + t;
                    for (; r.pos < n;) {
                        let e = r.uint32();
                        r.skipType(7 & e)
                    }
                    return {}
                },
                fromJSON: e => ({}),
                toJSON: e => ({}),
                fromPartial: e => ({})
            }, t.MsgCreateGroupWithPolicy = {
                typeUrl: "/cosmos.group.v1.MsgCreateGroupWithPolicy",
                encode(e, t = s.BinaryWriter.create()) {
                    for (let r of ("" !== e.admin && t.uint32(10).string(e.admin), e.members)) i.MemberRequest.encode(r, t.uint32(18).fork()).ldelim();
                    return "" !== e.groupMetadata && t.uint32(26).string(e.groupMetadata), "" !== e.groupPolicyMetadata && t.uint32(34).string(e.groupPolicyMetadata), !0 === e.groupPolicyAsAdmin && t.uint32(40).bool(e.groupPolicyAsAdmin), void 0 !== e.decisionPolicy && a.Any.encode(e.decisionPolicy, t.uint32(50).fork()).ldelim(), t
                },
                decode(e, t) {
                    let r = e instanceof s.BinaryReader ? e : new s.BinaryReader(e),
                        n = void 0 === t ? r.len : r.pos + t,
                        o = b();
                    for (; r.pos < n;) {
                        let e = r.uint32();
                        switch (e >>> 3) {
                            case 1:
                                o.admin = r.string();
                                break;
                            case 2:
                                o.members.push(i.MemberRequest.decode(r, r.uint32()));
                                break;
                            case 3:
                                o.groupMetadata = r.string();
                                break;
                            case 4:
                                o.groupPolicyMetadata = r.string();
                                break;
                            case 5:
                                o.groupPolicyAsAdmin = r.bool();
                                break;
                            case 6:
                                o.decisionPolicy = a.Any.decode(r, r.uint32());
                                break;
                            default:
                                r.skipType(7 & e)
                        }
                    }
                    return o
                },
                fromJSON(e) {
                    let t = b();
                    return (0, d.isSet)(e.admin) && (t.admin = String(e.admin)), Array.isArray(e ? .members) && (t.members = e.members.map(e => i.MemberRequest.fromJSON(e))), (0, d.isSet)(e.groupMetadata) && (t.groupMetadata = String(e.groupMetadata)), (0, d.isSet)(e.groupPolicyMetadata) && (t.groupPolicyMetadata = String(e.groupPolicyMetadata)), (0, d.isSet)(e.groupPolicyAsAdmin) && (t.groupPolicyAsAdmin = !!e.groupPolicyAsAdmin), (0, d.isSet)(e.decisionPolicy) && (t.decisionPolicy = a.Any.fromJSON(e.decisionPolicy)), t
                },
                toJSON(e) {
                    let t = {};
                    return void 0 !== e.admin && (t.admin = e.admin), e.members ? t.members = e.members.map(e => e ? i.MemberRequest.toJSON(e) : void 0) : t.members = [], void 0 !== e.groupMetadata && (t.groupMetadata = e.groupMetadata), void 0 !== e.groupPolicyMetadata && (t.groupPolicyMetadata = e.groupPolicyMetadata), void 0 !== e.groupPolicyAsAdmin && (t.groupPolicyAsAdmin = e.groupPolicyAsAdmin), void 0 !== e.decisionPolicy && (t.decisionPolicy = e.decisionPolicy ? a.Any.toJSON(e.decisionPolicy) : void 0), t
                },
                fromPartial(e) {
                    let t = b();
                    return t.admin = e.admin ? ? "", t.members = e.members ? .map(e => i.MemberRequest.fromPartial(e)) || [], t.groupMetadata = e.groupMetadata ? ? "", t.groupPolicyMetadata = e.groupPolicyMetadata ? ? "", t.groupPolicyAsAdmin = e.groupPolicyAsAdmin ? ? !1, void 0 !== e.decisionPolicy && null !== e.decisionPolicy && (t.decisionPolicy = a.Any.fromPartial(e.decisionPolicy)), t
                }
            }, t.MsgCreateGroupWithPolicyResponse = {
                typeUrl: "/cosmos.group.v1.MsgCreateGroupWithPolicyResponse",
                encode: (e, t = s.BinaryWriter.create()) => (e.groupId !== BigInt(0) && t.uint32(8).uint64(e.groupId), "" !== e.groupPolicyAddress && t.uint32(18).string(e.groupPolicyAddress), t),
                decode(e, t) {
                    let r = e instanceof s.BinaryReader ? e : new s.BinaryReader(e),
                        n = void 0 === t ? r.len : r.pos + t,
                        o = S();
                    for (; r.pos < n;) {
                        let e = r.uint32();
                        switch (e >>> 3) {
                            case 1:
                                o.groupId = r.uint64();
                                break;
                            case 2:
                                o.groupPolicyAddress = r.string();
                                break;
                            default:
                                r.skipType(7 & e)
                        }
                    }
                    return o
                },
                fromJSON(e) {
                    let t = S();
                    return (0, d.isSet)(e.groupId) && (t.groupId = BigInt(e.groupId.toString())), (0, d.isSet)(e.groupPolicyAddress) && (t.groupPolicyAddress = String(e.groupPolicyAddress)), t
                },
                toJSON(e) {
                    let t = {};
                    return void 0 !== e.groupId && (t.groupId = (e.groupId || BigInt(0)).toString()), void 0 !== e.groupPolicyAddress && (t.groupPolicyAddress = e.groupPolicyAddress), t
                },
                fromPartial(e) {
                    let t = S();
                    return void 0 !== e.groupId && null !== e.groupId && (t.groupId = BigInt(e.groupId.toString())), t.groupPolicyAddress = e.groupPolicyAddress ? ? "", t
                }
            }, t.MsgUpdateGroupPolicyDecisionPolicy = {
                typeUrl: "/cosmos.group.v1.MsgUpdateGroupPolicyDecisionPolicy",
                encode: (e, t = s.BinaryWriter.create()) => ("" !== e.admin && t.uint32(10).string(e.admin), "" !== e.groupPolicyAddress && t.uint32(18).string(e.groupPolicyAddress), void 0 !== e.decisionPolicy && a.Any.encode(e.decisionPolicy, t.uint32(26).fork()).ldelim(), t),
                decode(e, t) {
                    let r = e instanceof s.BinaryReader ? e : new s.BinaryReader(e),
                        n = void 0 === t ? r.len : r.pos + t,
                        o = k();
                    for (; r.pos < n;) {
                        let e = r.uint32();
                        switch (e >>> 3) {
                            case 1:
                                o.admin = r.string();
                                break;
                            case 2:
                                o.groupPolicyAddress = r.string();
                                break;
                            case 3:
                                o.decisionPolicy = a.Any.decode(r, r.uint32());
                                break;
                            default:
                                r.skipType(7 & e)
                        }
                    }
                    return o
                },
                fromJSON(e) {
                    let t = k();
                    return (0, d.isSet)(e.admin) && (t.admin = String(e.admin)), (0, d.isSet)(e.groupPolicyAddress) && (t.groupPolicyAddress = String(e.groupPolicyAddress)), (0, d.isSet)(e.decisionPolicy) && (t.decisionPolicy = a.Any.fromJSON(e.decisionPolicy)), t
                },
                toJSON(e) {
                    let t = {};
                    return void 0 !== e.admin && (t.admin = e.admin), void 0 !== e.groupPolicyAddress && (t.groupPolicyAddress = e.groupPolicyAddress), void 0 !== e.decisionPolicy && (t.decisionPolicy = e.decisionPolicy ? a.Any.toJSON(e.decisionPolicy) : void 0), t
                },
                fromPartial(e) {
                    let t = k();
                    return t.admin = e.admin ? ? "", t.groupPolicyAddress = e.groupPolicyAddress ? ? "", void 0 !== e.decisionPolicy && null !== e.decisionPolicy && (t.decisionPolicy = a.Any.fromPartial(e.decisionPolicy)), t
                }
            }, t.MsgUpdateGroupPolicyDecisionPolicyResponse = {
                typeUrl: "/cosmos.group.v1.MsgUpdateGroupPolicyDecisionPolicyResponse",
                encode: (e, t = s.BinaryWriter.create()) => t,
                decode(e, t) {
                    let r = e instanceof s.BinaryReader ? e : new s.BinaryReader(e),
                        n = void 0 === t ? r.len : r.pos + t;
                    for (; r.pos < n;) {
                        let e = r.uint32();
                        r.skipType(7 & e)
                    }
                    return {}
                },
                fromJSON: e => ({}),
                toJSON: e => ({}),
                fromPartial: e => ({})
            }, t.MsgUpdateGroupPolicyMetadata = {
                typeUrl: "/cosmos.group.v1.MsgUpdateGroupPolicyMetadata",
                encode: (e, t = s.BinaryWriter.create()) => ("" !== e.admin && t.uint32(10).string(e.admin), "" !== e.groupPolicyAddress && t.uint32(18).string(e.groupPolicyAddress), "" !== e.metadata && t.uint32(26).string(e.metadata), t),
                decode(e, t) {
                    let r = e instanceof s.BinaryReader ? e : new s.BinaryReader(e),
                        n = void 0 === t ? r.len : r.pos + t,
                        o = P();
                    for (; r.pos < n;) {
                        let e = r.uint32();
                        switch (e >>> 3) {
                            case 1:
                                o.admin = r.string();
                                break;
                            case 2:
                                o.groupPolicyAddress = r.string();
                                break;
                            case 3:
                                o.metadata = r.string();
                                break;
                            default:
                                r.skipType(7 & e)
                        }
                    }
                    return o
                },
                fromJSON(e) {
                    let t = P();
                    return (0, d.isSet)(e.admin) && (t.admin = String(e.admin)), (0, d.isSet)(e.groupPolicyAddress) && (t.groupPolicyAddress = String(e.groupPolicyAddress)), (0, d.isSet)(e.metadata) && (t.metadata = String(e.metadata)), t
                },
                toJSON(e) {
                    let t = {};
                    return void 0 !== e.admin && (t.admin = e.admin), void 0 !== e.groupPolicyAddress && (t.groupPolicyAddress = e.groupPolicyAddress), void 0 !== e.metadata && (t.metadata = e.metadata), t
                },
                fromPartial(e) {
                    let t = P();
                    return t.admin = e.admin ? ? "", t.groupPolicyAddress = e.groupPolicyAddress ? ? "", t.metadata = e.metadata ? ? "", t
                }
            }, t.MsgUpdateGroupPolicyMetadataResponse = {
                typeUrl: "/cosmos.group.v1.MsgUpdateGroupPolicyMetadataResponse",
                encode: (e, t = s.BinaryWriter.create()) => t,
                decode(e, t) {
                    let r = e instanceof s.BinaryReader ? e : new s.BinaryReader(e),
                        n = void 0 === t ? r.len : r.pos + t;
                    for (; r.pos < n;) {
                        let e = r.uint32();
                        r.skipType(7 & e)
                    }
                    return {}
                },
                fromJSON: e => ({}),
                toJSON: e => ({}),
                fromPartial: e => ({})
            }, t.MsgSubmitProposal = {
                typeUrl: "/cosmos.group.v1.MsgSubmitProposal",
                encode(e, t = s.BinaryWriter.create()) {
                    for (let r of ("" !== e.groupPolicyAddress && t.uint32(10).string(e.groupPolicyAddress), e.proposers)) t.uint32(18).string(r);
                    for (let r of ("" !== e.metadata && t.uint32(26).string(e.metadata), e.messages)) a.Any.encode(r, t.uint32(34).fork()).ldelim();
                    return 0 !== e.exec && t.uint32(40).int32(e.exec), "" !== e.title && t.uint32(50).string(e.title), "" !== e.summary && t.uint32(58).string(e.summary), t
                },
                decode(e, t) {
                    let r = e instanceof s.BinaryReader ? e : new s.BinaryReader(e),
                        n = void 0 === t ? r.len : r.pos + t,
                        o = _();
                    for (; r.pos < n;) {
                        let e = r.uint32();
                        switch (e >>> 3) {
                            case 1:
                                o.groupPolicyAddress = r.string();
                                break;
                            case 2:
                                o.proposers.push(r.string());
                                break;
                            case 3:
                                o.metadata = r.string();
                                break;
                            case 4:
                                o.messages.push(a.Any.decode(r, r.uint32()));
                                break;
                            case 5:
                                o.exec = r.int32();
                                break;
                            case 6:
                                o.title = r.string();
                                break;
                            case 7:
                                o.summary = r.string();
                                break;
                            default:
                                r.skipType(7 & e)
                        }
                    }
                    return o
                },
                fromJSON(e) {
                    let t = _();
                    return (0, d.isSet)(e.groupPolicyAddress) && (t.groupPolicyAddress = String(e.groupPolicyAddress)), Array.isArray(e ? .proposers) && (t.proposers = e.proposers.map(e => String(e))), (0, d.isSet)(e.metadata) && (t.metadata = String(e.metadata)), Array.isArray(e ? .messages) && (t.messages = e.messages.map(e => a.Any.fromJSON(e))), (0, d.isSet)(e.exec) && (t.exec = c(e.exec)), (0, d.isSet)(e.title) && (t.title = String(e.title)), (0, d.isSet)(e.summary) && (t.summary = String(e.summary)), t
                },
                toJSON(e) {
                    let t = {};
                    return void 0 !== e.groupPolicyAddress && (t.groupPolicyAddress = e.groupPolicyAddress), e.proposers ? t.proposers = e.proposers.map(e => e) : t.proposers = [], void 0 !== e.metadata && (t.metadata = e.metadata), e.messages ? t.messages = e.messages.map(e => e ? a.Any.toJSON(e) : void 0) : t.messages = [], void 0 !== e.exec && (t.exec = l(e.exec)), void 0 !== e.title && (t.title = e.title), void 0 !== e.summary && (t.summary = e.summary), t
                },
                fromPartial(e) {
                    let t = _();
                    return t.groupPolicyAddress = e.groupPolicyAddress ? ? "", t.proposers = e.proposers ? .map(e => e) || [], t.metadata = e.metadata ? ? "", t.messages = e.messages ? .map(e => a.Any.fromPartial(e)) || [], t.exec = e.exec ? ? 0, t.title = e.title ? ? "", t.summary = e.summary ? ? "", t
                }
            }, t.MsgSubmitProposalResponse = {
                typeUrl: "/cosmos.group.v1.MsgSubmitProposalResponse",
                encode: (e, t = s.BinaryWriter.create()) => (e.proposalId !== BigInt(0) && t.uint32(8).uint64(e.proposalId), t),
                decode(e, t) {
                    let r = e instanceof s.BinaryReader ? e : new s.BinaryReader(e),
                        n = void 0 === t ? r.len : r.pos + t,
                        o = B();
                    for (; r.pos < n;) {
                        let e = r.uint32();
                        e >>> 3 == 1 ? o.proposalId = r.uint64() : r.skipType(7 & e)
                    }
                    return o
                },
                fromJSON(e) {
                    let t = B();
                    return (0, d.isSet)(e.proposalId) && (t.proposalId = BigInt(e.proposalId.toString())), t
                },
                toJSON(e) {
                    let t = {};
                    return void 0 !== e.proposalId && (t.proposalId = (e.proposalId || BigInt(0)).toString()), t
                },
                fromPartial(e) {
                    let t = B();
                    return void 0 !== e.proposalId && null !== e.proposalId && (t.proposalId = BigInt(e.proposalId.toString())), t
                }
            }, t.MsgWithdrawProposal = {
                typeUrl: "/cosmos.group.v1.MsgWithdrawProposal",
                encode: (e, t = s.BinaryWriter.create()) => (e.proposalId !== BigInt(0) && t.uint32(8).uint64(e.proposalId), "" !== e.address && t.uint32(18).string(e.address), t),
                decode(e, t) {
                    let r = e instanceof s.BinaryReader ? e : new s.BinaryReader(e),
                        n = void 0 === t ? r.len : r.pos + t,
                        o = O();
                    for (; r.pos < n;) {
                        let e = r.uint32();
                        switch (e >>> 3) {
                            case 1:
                                o.proposalId = r.uint64();
                                break;
                            case 2:
                                o.address = r.string();
                                break;
                            default:
                                r.skipType(7 & e)
                        }
                    }
                    return o
                },
                fromJSON(e) {
                    let t = O();
                    return (0, d.isSet)(e.proposalId) && (t.proposalId = BigInt(e.proposalId.toString())), (0, d.isSet)(e.address) && (t.address = String(e.address)), t
                },
                toJSON(e) {
                    let t = {};
                    return void 0 !== e.proposalId && (t.proposalId = (e.proposalId || BigInt(0)).toString()), void 0 !== e.address && (t.address = e.address), t
                },
                fromPartial(e) {
                    let t = O();
                    return void 0 !== e.proposalId && null !== e.proposalId && (t.proposalId = BigInt(e.proposalId.toString())), t.address = e.address ? ? "", t
                }
            }, t.MsgWithdrawProposalResponse = {
                typeUrl: "/cosmos.group.v1.MsgWithdrawProposalResponse",
                encode: (e, t = s.BinaryWriter.create()) => t,
                decode(e, t) {
                    let r = e instanceof s.BinaryReader ? e : new s.BinaryReader(e),
                        n = void 0 === t ? r.len : r.pos + t;
                    for (; r.pos < n;) {
                        let e = r.uint32();
                        r.skipType(7 & e)
                    }
                    return {}
                },
                fromJSON: e => ({}),
                toJSON: e => ({}),
                fromPartial: e => ({})
            }, t.MsgVote = {
                typeUrl: "/cosmos.group.v1.MsgVote",
                encode: (e, t = s.BinaryWriter.create()) => (e.proposalId !== BigInt(0) && t.uint32(8).uint64(e.proposalId), "" !== e.voter && t.uint32(18).string(e.voter), 0 !== e.option && t.uint32(24).int32(e.option), "" !== e.metadata && t.uint32(34).string(e.metadata), 0 !== e.exec && t.uint32(40).int32(e.exec), t),
                decode(e, t) {
                    let r = e instanceof s.BinaryReader ? e : new s.BinaryReader(e),
                        n = void 0 === t ? r.len : r.pos + t,
                        o = R();
                    for (; r.pos < n;) {
                        let e = r.uint32();
                        switch (e >>> 3) {
                            case 1:
                                o.proposalId = r.uint64();
                                break;
                            case 2:
                                o.voter = r.string();
                                break;
                            case 3:
                                o.option = r.int32();
                                break;
                            case 4:
                                o.metadata = r.string();
                                break;
                            case 5:
                                o.exec = r.int32();
                                break;
                            default:
                                r.skipType(7 & e)
                        }
                    }
                    return o
                },
                fromJSON(e) {
                    let t = R();
                    return (0, d.isSet)(e.proposalId) && (t.proposalId = BigInt(e.proposalId.toString())), (0, d.isSet)(e.voter) && (t.voter = String(e.voter)), (0, d.isSet)(e.option) && (t.option = (0, i.voteOptionFromJSON)(e.option)), (0, d.isSet)(e.metadata) && (t.metadata = String(e.metadata)), (0, d.isSet)(e.exec) && (t.exec = c(e.exec)), t
                },
                toJSON(e) {
                    let t = {};
                    return void 0 !== e.proposalId && (t.proposalId = (e.proposalId || BigInt(0)).toString()), void 0 !== e.voter && (t.voter = e.voter), void 0 !== e.option && (t.option = (0, i.voteOptionToJSON)(e.option)), void 0 !== e.metadata && (t.metadata = e.metadata), void 0 !== e.exec && (t.exec = l(e.exec)), t
                },
                fromPartial(e) {
                    let t = R();
                    return void 0 !== e.proposalId && null !== e.proposalId && (t.proposalId = BigInt(e.proposalId.toString())), t.voter = e.voter ? ? "", t.option = e.option ? ? 0, t.metadata = e.metadata ? ? "", t.exec = e.exec ? ? 0, t
                }
            }, t.MsgVoteResponse = {
                typeUrl: "/cosmos.group.v1.MsgVoteResponse",
                encode: (e, t = s.BinaryWriter.create()) => t,
                decode(e, t) {
                    let r = e instanceof s.BinaryReader ? e : new s.BinaryReader(e),
                        n = void 0 === t ? r.len : r.pos + t;
                    for (; r.pos < n;) {
                        let e = r.uint32();
                        r.skipType(7 & e)
                    }
                    return {}
                },
                fromJSON: e => ({}),
                toJSON: e => ({}),
                fromPartial: e => ({})
            }, t.MsgExec = {
                typeUrl: "/cosmos.group.v1.MsgExec",
                encode: (e, t = s.BinaryWriter.create()) => (e.proposalId !== BigInt(0) && t.uint32(8).uint64(e.proposalId), "" !== e.executor && t.uint32(18).string(e.executor), t),
                decode(e, t) {
                    let r = e instanceof s.BinaryReader ? e : new s.BinaryReader(e),
                        n = void 0 === t ? r.len : r.pos + t,
                        o = A();
                    for (; r.pos < n;) {
                        let e = r.uint32();
                        switch (e >>> 3) {
                            case 1:
                                o.proposalId = r.uint64();
                                break;
                            case 2:
                                o.executor = r.string();
                                break;
                            default:
                                r.skipType(7 & e)
                        }
                    }
                    return o
                },
                fromJSON(e) {
                    let t = A();
                    return (0, d.isSet)(e.proposalId) && (t.proposalId = BigInt(e.proposalId.toString())), (0, d.isSet)(e.executor) && (t.executor = String(e.executor)), t
                },
                toJSON(e) {
                    let t = {};
                    return void 0 !== e.proposalId && (t.proposalId = (e.proposalId || BigInt(0)).toString()), void 0 !== e.executor && (t.executor = e.executor), t
                },
                fromPartial(e) {
                    let t = A();
                    return void 0 !== e.proposalId && null !== e.proposalId && (t.proposalId = BigInt(e.proposalId.toString())), t.executor = e.executor ? ? "", t
                }
            }, t.MsgExecResponse = {
                typeUrl: "/cosmos.group.v1.MsgExecResponse",
                encode: (e, t = s.BinaryWriter.create()) => (0 !== e.result && t.uint32(16).int32(e.result), t),
                decode(e, t) {
                    let r = e instanceof s.BinaryReader ? e : new s.BinaryReader(e),
                        n = void 0 === t ? r.len : r.pos + t,
                        o = I();
                    for (; r.pos < n;) {
                        let e = r.uint32();
                        e >>> 3 == 2 ? o.result = r.int32() : r.skipType(7 & e)
                    }
                    return o
                },
                fromJSON(e) {
                    let t = I();
                    return (0, d.isSet)(e.result) && (t.result = (0, i.proposalExecutorResultFromJSON)(e.result)), t
                },
                toJSON(e) {
                    let t = {};
                    return void 0 !== e.result && (t.result = (0, i.proposalExecutorResultToJSON)(e.result)), t
                },
                fromPartial(e) {
                    let t = I();
                    return t.result = e.result ? ? 0, t
                }
            }, t.MsgLeaveGroup = {
                typeUrl: "/cosmos.group.v1.MsgLeaveGroup",
                encode: (e, t = s.BinaryWriter.create()) => ("" !== e.address && t.uint32(10).string(e.address), e.groupId !== BigInt(0) && t.uint32(16).uint64(e.groupId), t),
                decode(e, t) {
                    let r = e instanceof s.BinaryReader ? e : new s.BinaryReader(e),
                        n = void 0 === t ? r.len : r.pos + t,
                        o = w();
                    for (; r.pos < n;) {
                        let e = r.uint32();
                        switch (e >>> 3) {
                            case 1:
                                o.address = r.string();
                                break;
                            case 2:
                                o.groupId = r.uint64();
                                break;
                            default:
                                r.skipType(7 & e)
                        }
                    }
                    return o
                },
                fromJSON(e) {
                    let t = w();
                    return (0, d.isSet)(e.address) && (t.address = String(e.address)), (0, d.isSet)(e.groupId) && (t.groupId = BigInt(e.groupId.toString())), t
                },
                toJSON(e) {
                    let t = {};
                    return void 0 !== e.address && (t.address = e.address), void 0 !== e.groupId && (t.groupId = (e.groupId || BigInt(0)).toString()), t
                },
                fromPartial(e) {
                    let t = w();
                    return t.address = e.address ? ? "", void 0 !== e.groupId && null !== e.groupId && (t.groupId = BigInt(e.groupId.toString())), t
                }
            }, t.MsgLeaveGroupResponse = {
                typeUrl: "/cosmos.group.v1.MsgLeaveGroupResponse",
                encode: (e, t = s.BinaryWriter.create()) => t,
                decode(e, t) {
                    let r = e instanceof s.BinaryReader ? e : new s.BinaryReader(e),
                        n = void 0 === t ? r.len : r.pos + t;
                    for (; r.pos < n;) {
                        let e = r.uint32();
                        r.skipType(7 & e)
                    }
                    return {}
                },
                fromJSON: e => ({}),
                toJSON: e => ({}),
                fromPartial: e => ({})
            };
            class T {
                constructor(e) {
                    this.rpc = e, this.CreateGroup = this.CreateGroup.bind(this), this.UpdateGroupMembers = this.UpdateGroupMembers.bind(this), this.UpdateGroupAdmin = this.UpdateGroupAdmin.bind(this), this.UpdateGroupMetadata = this.UpdateGroupMetadata.bind(this), this.CreateGroupPolicy = this.CreateGroupPolicy.bind(this), this.CreateGroupWithPolicy = this.CreateGroupWithPolicy.bind(this), this.UpdateGroupPolicyAdmin = this.UpdateGroupPolicyAdmin.bind(this), this.UpdateGroupPolicyDecisionPolicy = this.UpdateGroupPolicyDecisionPolicy.bind(this), this.UpdateGroupPolicyMetadata = this.UpdateGroupPolicyMetadata.bind(this), this.SubmitProposal = this.SubmitProposal.bind(this), this.WithdrawProposal = this.WithdrawProposal.bind(this), this.Vote = this.Vote.bind(this), this.Exec = this.Exec.bind(this), this.LeaveGroup = this.LeaveGroup.bind(this)
                }
                CreateGroup(e) {
                    let r = t.MsgCreateGroup.encode(e).finish();
                    return this.rpc.request("cosmos.group.v1.Msg", "CreateGroup", r).then(e => t.MsgCreateGroupResponse.decode(new s.BinaryReader(e)))
                }
                UpdateGroupMembers(e) {
                    let r = t.MsgUpdateGroupMembers.encode(e).finish();
                    return this.rpc.request("cosmos.group.v1.Msg", "UpdateGroupMembers", r).then(e => t.MsgUpdateGroupMembersResponse.decode(new s.BinaryReader(e)))
                }
                UpdateGroupAdmin(e) {
                    let r = t.MsgUpdateGroupAdmin.encode(e).finish();
                    return this.rpc.request("cosmos.group.v1.Msg", "UpdateGroupAdmin", r).then(e => t.MsgUpdateGroupAdminResponse.decode(new s.BinaryReader(e)))
                }
                UpdateGroupMetadata(e) {
                    let r = t.MsgUpdateGroupMetadata.encode(e).finish();
                    return this.rpc.request("cosmos.group.v1.Msg", "UpdateGroupMetadata", r).then(e => t.MsgUpdateGroupMetadataResponse.decode(new s.BinaryReader(e)))
                }
                CreateGroupPolicy(e) {
                    let r = t.MsgCreateGroupPolicy.encode(e).finish();
                    return this.rpc.request("cosmos.group.v1.Msg", "CreateGroupPolicy", r).then(e => t.MsgCreateGroupPolicyResponse.decode(new s.BinaryReader(e)))
                }
                CreateGroupWithPolicy(e) {
                    let r = t.MsgCreateGroupWithPolicy.encode(e).finish();
                    return this.rpc.request("cosmos.group.v1.Msg", "CreateGroupWithPolicy", r).then(e => t.MsgCreateGroupWithPolicyResponse.decode(new s.BinaryReader(e)))
                }
                UpdateGroupPolicyAdmin(e) {
                    let r = t.MsgUpdateGroupPolicyAdmin.encode(e).finish();
                    return this.rpc.request("cosmos.group.v1.Msg", "UpdateGroupPolicyAdmin", r).then(e => t.MsgUpdateGroupPolicyAdminResponse.decode(new s.BinaryReader(e)))
                }
                UpdateGroupPolicyDecisionPolicy(e) {
                    let r = t.MsgUpdateGroupPolicyDecisionPolicy.encode(e).finish();
                    return this.rpc.request("cosmos.group.v1.Msg", "UpdateGroupPolicyDecisionPolicy", r).then(e => t.MsgUpdateGroupPolicyDecisionPolicyResponse.decode(new s.BinaryReader(e)))
                }
                UpdateGroupPolicyMetadata(e) {
                    let r = t.MsgUpdateGroupPolicyMetadata.encode(e).finish();
                    return this.rpc.request("cosmos.group.v1.Msg", "UpdateGroupPolicyMetadata", r).then(e => t.MsgUpdateGroupPolicyMetadataResponse.decode(new s.BinaryReader(e)))
                }
                SubmitProposal(e) {
                    let r = t.MsgSubmitProposal.encode(e).finish();
                    return this.rpc.request("cosmos.group.v1.Msg", "SubmitProposal", r).then(e => t.MsgSubmitProposalResponse.decode(new s.BinaryReader(e)))
                }
                WithdrawProposal(e) {
                    let r = t.MsgWithdrawProposal.encode(e).finish();
                    return this.rpc.request("cosmos.group.v1.Msg", "WithdrawProposal", r).then(e => t.MsgWithdrawProposalResponse.decode(new s.BinaryReader(e)))
                }
                Vote(e) {
                    let r = t.MsgVote.encode(e).finish();
                    return this.rpc.request("cosmos.group.v1.Msg", "Vote", r).then(e => t.MsgVoteResponse.decode(new s.BinaryReader(e)))
                }
                Exec(e) {
                    let r = t.MsgExec.encode(e).finish();
                    return this.rpc.request("cosmos.group.v1.Msg", "Exec", r).then(e => t.MsgExecResponse.decode(new s.BinaryReader(e)))
                }
                LeaveGroup(e) {
                    let r = t.MsgLeaveGroup.encode(e).finish();
                    return this.rpc.request("cosmos.group.v1.Msg", "LeaveGroup", r).then(e => t.MsgLeaveGroupResponse.decode(new s.BinaryReader(e)))
                }
            }
            t.MsgClientImpl = T
        },
        66389: function(e, t, r) {
            "use strict";
            var n, o, i, a, s, d;
            Object.defineProperty(t, "__esModule", {
                value: !0
            }), t.Vote = t.TallyResult = t.Proposal = t.GroupPolicyInfo = t.GroupMember = t.GroupInfo = t.DecisionPolicyWindows = t.PercentageDecisionPolicy = t.ThresholdDecisionPolicy = t.MemberRequest = t.Member = t.proposalExecutorResultToJSON = t.proposalExecutorResultFromJSON = t.ProposalExecutorResult = t.proposalStatusToJSON = t.proposalStatusFromJSON = t.ProposalStatus = t.voteOptionToJSON = t.voteOptionFromJSON = t.VoteOption = t.protobufPackage = void 0;
            let c = r(90614),
                l = r(69441),
                u = r(65676),
                p = r(28486),
                m = r(6476);

            function g(e) {
                switch (e) {
                    case 0:
                    case "VOTE_OPTION_UNSPECIFIED":
                        return n.VOTE_OPTION_UNSPECIFIED;
                    case 1:
                    case "VOTE_OPTION_YES":
                        return n.VOTE_OPTION_YES;
                    case 2:
                    case "VOTE_OPTION_ABSTAIN":
                        return n.VOTE_OPTION_ABSTAIN;
                    case 3:
                    case "VOTE_OPTION_NO":
                        return n.VOTE_OPTION_NO;
                    case 4:
                    case "VOTE_OPTION_NO_WITH_VETO":
                        return n.VOTE_OPTION_NO_WITH_VETO;
                    default:
                        return n.UNRECOGNIZED
                }
            }

            function f(e) {
                switch (e) {
                    case n.VOTE_OPTION_UNSPECIFIED:
                        return "VOTE_OPTION_UNSPECIFIED";
                    case n.VOTE_OPTION_YES:
                        return "VOTE_OPTION_YES";
                    case n.VOTE_OPTION_ABSTAIN:
                        return "VOTE_OPTION_ABSTAIN";
                    case n.VOTE_OPTION_NO:
                        return "VOTE_OPTION_NO";
                    case n.VOTE_OPTION_NO_WITH_VETO:
                        return "VOTE_OPTION_NO_WITH_VETO";
                    case n.UNRECOGNIZED:
                    default:
                        return "UNRECOGNIZED"
                }
            }

            function y(e) {
                switch (e) {
                    case 0:
                    case "PROPOSAL_STATUS_UNSPECIFIED":
                        return o.PROPOSAL_STATUS_UNSPECIFIED;
                    case 1:
                    case "PROPOSAL_STATUS_SUBMITTED":
                        return o.PROPOSAL_STATUS_SUBMITTED;
                    case 2:
                    case "PROPOSAL_STATUS_ACCEPTED":
                        return o.PROPOSAL_STATUS_ACCEPTED;
                    case 3:
                    case "PROPOSAL_STATUS_REJECTED":
                        return o.PROPOSAL_STATUS_REJECTED;
                    case 4:
                    case "PROPOSAL_STATUS_ABORTED":
                        return o.PROPOSAL_STATUS_ABORTED;
                    case 5:
                    case "PROPOSAL_STATUS_WITHDRAWN":
                        return o.PROPOSAL_STATUS_WITHDRAWN;
                    default:
                        return o.UNRECOGNIZED
                }
            }

            function h(e) {
                switch (e) {
                    case o.PROPOSAL_STATUS_UNSPECIFIED:
                        return "PROPOSAL_STATUS_UNSPECIFIED";
                    case o.PROPOSAL_STATUS_SUBMITTED:
                        return "PROPOSAL_STATUS_SUBMITTED";
                    case o.PROPOSAL_STATUS_ACCEPTED:
                        return "PROPOSAL_STATUS_ACCEPTED";
                    case o.PROPOSAL_STATUS_REJECTED:
                        return "PROPOSAL_STATUS_REJECTED";
                    case o.PROPOSAL_STATUS_ABORTED:
                        return "PROPOSAL_STATUS_ABORTED";
                    case o.PROPOSAL_STATUS_WITHDRAWN:
                        return "PROPOSAL_STATUS_WITHDRAWN";
                    case o.UNRECOGNIZED:
                    default:
                        return "UNRECOGNIZED"
                }
            }

            function v(e) {
                switch (e) {
                    case 0:
                    case "PROPOSAL_EXECUTOR_RESULT_UNSPECIFIED":
                        return i.PROPOSAL_EXECUTOR_RESULT_UNSPECIFIED;
                    case 1:
                    case "PROPOSAL_EXECUTOR_RESULT_NOT_RUN":
                        return i.PROPOSAL_EXECUTOR_RESULT_NOT_RUN;
                    case 2:
                    case "PROPOSAL_EXECUTOR_RESULT_SUCCESS":
                        return i.PROPOSAL_EXECUTOR_RESULT_SUCCESS;
                    case 3:
                    case "PROPOSAL_EXECUTOR_RESULT_FAILURE":
                        return i.PROPOSAL_EXECUTOR_RESULT_FAILURE;
                    default:
                        return i.UNRECOGNIZED
                }
            }

            function b(e) {
                switch (e) {
                    case i.PROPOSAL_EXECUTOR_RESULT_UNSPECIFIED:
                        return "PROPOSAL_EXECUTOR_RESULT_UNSPECIFIED";
                    case i.PROPOSAL_EXECUTOR_RESULT_NOT_RUN:
                        return "PROPOSAL_EXECUTOR_RESULT_NOT_RUN";
                    case i.PROPOSAL_EXECUTOR_RESULT_SUCCESS:
                        return "PROPOSAL_EXECUTOR_RESULT_SUCCESS";
                    case i.PROPOSAL_EXECUTOR_RESULT_FAILURE:
                        return "PROPOSAL_EXECUTOR_RESULT_FAILURE";
                    case i.UNRECOGNIZED:
                    default:
                        return "UNRECOGNIZED"
                }
            }

            function S() {
                return {
                    address: "",
                    weight: "",
                    metadata: "",
                    addedAt: c.Timestamp.fromPartial({})
                }
            }

            function k() {
                return {
                    address: "",
                    weight: "",
                    metadata: ""
                }
            }

            function P() {
                return {
                    threshold: "",
                    windows: void 0
                }
            }

            function _() {
                return {
                    percentage: "",
                    windows: void 0
                }
            }

            function B() {
                return {
                    votingPeriod: l.Duration.fromPartial({}),
                    minExecutionPeriod: l.Duration.fromPartial({})
                }
            }

            function O() {
                return {
                    id: BigInt(0),
                    admin: "",
                    metadata: "",
                    version: BigInt(0),
                    totalWeight: "",
                    createdAt: c.Timestamp.fromPartial({})
                }
            }

            function R() {
                return {
                    groupId: BigInt(0),
                    member: void 0
                }
            }

            function A() {
                return {
                    address: "",
                    groupId: BigInt(0),
                    admin: "",
                    metadata: "",
                    version: BigInt(0),
                    decisionPolicy: void 0,
                    createdAt: c.Timestamp.fromPartial({})
                }
            }

            function I() {
                return {
                    id: BigInt(0),
                    groupPolicyAddress: "",
                    metadata: "",
                    proposers: [],
                    submitTime: c.Timestamp.fromPartial({}),
                    groupVersion: BigInt(0),
                    groupPolicyVersion: BigInt(0),
                    status: 0,
                    finalTallyResult: t.TallyResult.fromPartial({}),
                    votingPeriodEnd: c.Timestamp.fromPartial({}),
                    executorResult: 0,
                    messages: [],
                    title: "",
                    summary: ""
                }
            }

            function w() {
                return {
                    yesCount: "",
                    abstainCount: "",
                    noCount: "",
                    noWithVetoCount: ""
                }
            }

            function T() {
                return {
                    proposalId: BigInt(0),
                    voter: "",
                    option: 0,
                    metadata: "",
                    submitTime: c.Timestamp.fromPartial({})
                }
            }
            t.protobufPackage = "cosmos.group.v1", (a = n || (t.VoteOption = n = {}))[a.VOTE_OPTION_UNSPECIFIED = 0] = "VOTE_OPTION_UNSPECIFIED", a[a.VOTE_OPTION_YES = 1] = "VOTE_OPTION_YES", a[a.VOTE_OPTION_ABSTAIN = 2] = "VOTE_OPTION_ABSTAIN", a[a.VOTE_OPTION_NO = 3] = "VOTE_OPTION_NO", a[a.VOTE_OPTION_NO_WITH_VETO = 4] = "VOTE_OPTION_NO_WITH_VETO", a[a.UNRECOGNIZED = -1] = "UNRECOGNIZED", t.voteOptionFromJSON = g, t.voteOptionToJSON = f, (s = o || (t.ProposalStatus = o = {}))[s.PROPOSAL_STATUS_UNSPECIFIED = 0] = "PROPOSAL_STATUS_UNSPECIFIED", s[s.PROPOSAL_STATUS_SUBMITTED = 1] = "PROPOSAL_STATUS_SUBMITTED", s[s.PROPOSAL_STATUS_ACCEPTED = 2] = "PROPOSAL_STATUS_ACCEPTED", s[s.PROPOSAL_STATUS_REJECTED = 3] = "PROPOSAL_STATUS_REJECTED", s[s.PROPOSAL_STATUS_ABORTED = 4] = "PROPOSAL_STATUS_ABORTED", s[s.PROPOSAL_STATUS_WITHDRAWN = 5] = "PROPOSAL_STATUS_WITHDRAWN", s[s.UNRECOGNIZED = -1] = "UNRECOGNIZED", t.proposalStatusFromJSON = y, t.proposalStatusToJSON = h, (d = i || (t.ProposalExecutorResult = i = {}))[d.PROPOSAL_EXECUTOR_RESULT_UNSPECIFIED = 0] = "PROPOSAL_EXECUTOR_RESULT_UNSPECIFIED", d[d.PROPOSAL_EXECUTOR_RESULT_NOT_RUN = 1] = "PROPOSAL_EXECUTOR_RESULT_NOT_RUN", d[d.PROPOSAL_EXECUTOR_RESULT_SUCCESS = 2] = "PROPOSAL_EXECUTOR_RESULT_SUCCESS", d[d.PROPOSAL_EXECUTOR_RESULT_FAILURE = 3] = "PROPOSAL_EXECUTOR_RESULT_FAILURE", d[d.UNRECOGNIZED = -1] = "UNRECOGNIZED", t.proposalExecutorResultFromJSON = v, t.proposalExecutorResultToJSON = b, t.Member = {
                typeUrl: "/cosmos.group.v1.Member",
                encode: (e, t = p.BinaryWriter.create()) => ("" !== e.address && t.uint32(10).string(e.address), "" !== e.weight && t.uint32(18).string(e.weight), "" !== e.metadata && t.uint32(26).string(e.metadata), void 0 !== e.addedAt && c.Timestamp.encode(e.addedAt, t.uint32(34).fork()).ldelim(), t),
                decode(e, t) {
                    let r = e instanceof p.BinaryReader ? e : new p.BinaryReader(e),
                        n = void 0 === t ? r.len : r.pos + t,
                        o = S();
                    for (; r.pos < n;) {
                        let e = r.uint32();
                        switch (e >>> 3) {
                            case 1:
                                o.address = r.string();
                                break;
                            case 2:
                                o.weight = r.string();
                                break;
                            case 3:
                                o.metadata = r.string();
                                break;
                            case 4:
                                o.addedAt = c.Timestamp.decode(r, r.uint32());
                                break;
                            default:
                                r.skipType(7 & e)
                        }
                    }
                    return o
                },
                fromJSON(e) {
                    let t = S();
                    return (0, m.isSet)(e.address) && (t.address = String(e.address)), (0, m.isSet)(e.weight) && (t.weight = String(e.weight)), (0, m.isSet)(e.metadata) && (t.metadata = String(e.metadata)), (0, m.isSet)(e.addedAt) && (t.addedAt = (0, m.fromJsonTimestamp)(e.addedAt)), t
                },
                toJSON(e) {
                    let t = {};
                    return void 0 !== e.address && (t.address = e.address), void 0 !== e.weight && (t.weight = e.weight), void 0 !== e.metadata && (t.metadata = e.metadata), void 0 !== e.addedAt && (t.addedAt = (0, m.fromTimestamp)(e.addedAt).toISOString()), t
                },
                fromPartial(e) {
                    let t = S();
                    return t.address = e.address ? ? "", t.weight = e.weight ? ? "", t.metadata = e.metadata ? ? "", void 0 !== e.addedAt && null !== e.addedAt && (t.addedAt = c.Timestamp.fromPartial(e.addedAt)), t
                }
            }, t.MemberRequest = {
                typeUrl: "/cosmos.group.v1.MemberRequest",
                encode: (e, t = p.BinaryWriter.create()) => ("" !== e.address && t.uint32(10).string(e.address), "" !== e.weight && t.uint32(18).string(e.weight), "" !== e.metadata && t.uint32(26).string(e.metadata), t),
                decode(e, t) {
                    let r = e instanceof p.BinaryReader ? e : new p.BinaryReader(e),
                        n = void 0 === t ? r.len : r.pos + t,
                        o = k();
                    for (; r.pos < n;) {
                        let e = r.uint32();
                        switch (e >>> 3) {
                            case 1:
                                o.address = r.string();
                                break;
                            case 2:
                                o.weight = r.string();
                                break;
                            case 3:
                                o.metadata = r.string();
                                break;
                            default:
                                r.skipType(7 & e)
                        }
                    }
                    return o
                },
                fromJSON(e) {
                    let t = k();
                    return (0, m.isSet)(e.address) && (t.address = String(e.address)), (0, m.isSet)(e.weight) && (t.weight = String(e.weight)), (0, m.isSet)(e.metadata) && (t.metadata = String(e.metadata)), t
                },
                toJSON(e) {
                    let t = {};
                    return void 0 !== e.address && (t.address = e.address), void 0 !== e.weight && (t.weight = e.weight), void 0 !== e.metadata && (t.metadata = e.metadata), t
                },
                fromPartial(e) {
                    let t = k();
                    return t.address = e.address ? ? "", t.weight = e.weight ? ? "", t.metadata = e.metadata ? ? "", t
                }
            }, t.ThresholdDecisionPolicy = {
                typeUrl: "/cosmos.group.v1.ThresholdDecisionPolicy",
                encode: (e, r = p.BinaryWriter.create()) => ("" !== e.threshold && r.uint32(10).string(e.threshold), void 0 !== e.windows && t.DecisionPolicyWindows.encode(e.windows, r.uint32(18).fork()).ldelim(), r),
                decode(e, r) {
                    let n = e instanceof p.BinaryReader ? e : new p.BinaryReader(e),
                        o = void 0 === r ? n.len : n.pos + r,
                        i = P();
                    for (; n.pos < o;) {
                        let e = n.uint32();
                        switch (e >>> 3) {
                            case 1:
                                i.threshold = n.string();
                                break;
                            case 2:
                                i.windows = t.DecisionPolicyWindows.decode(n, n.uint32());
                                break;
                            default:
                                n.skipType(7 & e)
                        }
                    }
                    return i
                },
                fromJSON(e) {
                    let r = P();
                    return (0, m.isSet)(e.threshold) && (r.threshold = String(e.threshold)), (0, m.isSet)(e.windows) && (r.windows = t.DecisionPolicyWindows.fromJSON(e.windows)), r
                },
                toJSON(e) {
                    let r = {};
                    return void 0 !== e.threshold && (r.threshold = e.threshold), void 0 !== e.windows && (r.windows = e.windows ? t.DecisionPolicyWindows.toJSON(e.windows) : void 0), r
                },
                fromPartial(e) {
                    let r = P();
                    return r.threshold = e.threshold ? ? "", void 0 !== e.windows && null !== e.windows && (r.windows = t.DecisionPolicyWindows.fromPartial(e.windows)), r
                }
            }, t.PercentageDecisionPolicy = {
                typeUrl: "/cosmos.group.v1.PercentageDecisionPolicy",
                encode: (e, r = p.BinaryWriter.create()) => ("" !== e.percentage && r.uint32(10).string(e.percentage), void 0 !== e.windows && t.DecisionPolicyWindows.encode(e.windows, r.uint32(18).fork()).ldelim(), r),
                decode(e, r) {
                    let n = e instanceof p.BinaryReader ? e : new p.BinaryReader(e),
                        o = void 0 === r ? n.len : n.pos + r,
                        i = _();
                    for (; n.pos < o;) {
                        let e = n.uint32();
                        switch (e >>> 3) {
                            case 1:
                                i.percentage = n.string();
                                break;
                            case 2:
                                i.windows = t.DecisionPolicyWindows.decode(n, n.uint32());
                                break;
                            default:
                                n.skipType(7 & e)
                        }
                    }
                    return i
                },
                fromJSON(e) {
                    let r = _();
                    return (0, m.isSet)(e.percentage) && (r.percentage = String(e.percentage)), (0, m.isSet)(e.windows) && (r.windows = t.DecisionPolicyWindows.fromJSON(e.windows)), r
                },
                toJSON(e) {
                    let r = {};
                    return void 0 !== e.percentage && (r.percentage = e.percentage), void 0 !== e.windows && (r.windows = e.windows ? t.DecisionPolicyWindows.toJSON(e.windows) : void 0), r
                },
                fromPartial(e) {
                    let r = _();
                    return r.percentage = e.percentage ? ? "", void 0 !== e.windows && null !== e.windows && (r.windows = t.DecisionPolicyWindows.fromPartial(e.windows)), r
                }
            }, t.DecisionPolicyWindows = {
                typeUrl: "/cosmos.group.v1.DecisionPolicyWindows",
                encode: (e, t = p.BinaryWriter.create()) => (void 0 !== e.votingPeriod && l.Duration.encode(e.votingPeriod, t.uint32(10).fork()).ldelim(), void 0 !== e.minExecutionPeriod && l.Duration.encode(e.minExecutionPeriod, t.uint32(18).fork()).ldelim(), t),
                decode(e, t) {
                    let r = e instanceof p.BinaryReader ? e : new p.BinaryReader(e),
                        n = void 0 === t ? r.len : r.pos + t,
                        o = B();
                    for (; r.pos < n;) {
                        let e = r.uint32();
                        switch (e >>> 3) {
                            case 1:
                                o.votingPeriod = l.Duration.decode(r, r.uint32());
                                break;
                            case 2:
                                o.minExecutionPeriod = l.Duration.decode(r, r.uint32());
                                break;
                            default:
                                r.skipType(7 & e)
                        }
                    }
                    return o
                },
                fromJSON(e) {
                    let t = B();
                    return (0, m.isSet)(e.votingPeriod) && (t.votingPeriod = l.Duration.fromJSON(e.votingPeriod)), (0, m.isSet)(e.minExecutionPeriod) && (t.minExecutionPeriod = l.Duration.fromJSON(e.minExecutionPeriod)), t
                },
                toJSON(e) {
                    let t = {};
                    return void 0 !== e.votingPeriod && (t.votingPeriod = e.votingPeriod ? l.Duration.toJSON(e.votingPeriod) : void 0), void 0 !== e.minExecutionPeriod && (t.minExecutionPeriod = e.minExecutionPeriod ? l.Duration.toJSON(e.minExecutionPeriod) : void 0), t
                },
                fromPartial(e) {
                    let t = B();
                    return void 0 !== e.votingPeriod && null !== e.votingPeriod && (t.votingPeriod = l.Duration.fromPartial(e.votingPeriod)), void 0 !== e.minExecutionPeriod && null !== e.minExecutionPeriod && (t.minExecutionPeriod = l.Duration.fromPartial(e.minExecutionPeriod)), t
                }
            }, t.GroupInfo = {
                typeUrl: "/cosmos.group.v1.GroupInfo",
                encode: (e, t = p.BinaryWriter.create()) => (e.id !== BigInt(0) && t.uint32(8).uint64(e.id), "" !== e.admin && t.uint32(18).string(e.admin), "" !== e.metadata && t.uint32(26).string(e.metadata), e.version !== BigInt(0) && t.uint32(32).uint64(e.version), "" !== e.totalWeight && t.uint32(42).string(e.totalWeight), void 0 !== e.createdAt && c.Timestamp.encode(e.createdAt, t.uint32(50).fork()).ldelim(), t),
                decode(e, t) {
                    let r = e instanceof p.BinaryReader ? e : new p.BinaryReader(e),
                        n = void 0 === t ? r.len : r.pos + t,
                        o = O();
                    for (; r.pos < n;) {
                        let e = r.uint32();
                        switch (e >>> 3) {
                            case 1:
                                o.id = r.uint64();
                                break;
                            case 2:
                                o.admin = r.string();
                                break;
                            case 3:
                                o.metadata = r.string();
                                break;
                            case 4:
                                o.version = r.uint64();
                                break;
                            case 5:
                                o.totalWeight = r.string();
                                break;
                            case 6:
                                o.createdAt = c.Timestamp.decode(r, r.uint32());
                                break;
                            default:
                                r.skipType(7 & e)
                        }
                    }
                    return o
                },
                fromJSON(e) {
                    let t = O();
                    return (0, m.isSet)(e.id) && (t.id = BigInt(e.id.toString())), (0, m.isSet)(e.admin) && (t.admin = String(e.admin)), (0, m.isSet)(e.metadata) && (t.metadata = String(e.metadata)), (0, m.isSet)(e.version) && (t.version = BigInt(e.version.toString())), (0, m.isSet)(e.totalWeight) && (t.totalWeight = String(e.totalWeight)), (0, m.isSet)(e.createdAt) && (t.createdAt = (0, m.fromJsonTimestamp)(e.createdAt)), t
                },
                toJSON(e) {
                    let t = {};
                    return void 0 !== e.id && (t.id = (e.id || BigInt(0)).toString()), void 0 !== e.admin && (t.admin = e.admin), void 0 !== e.metadata && (t.metadata = e.metadata), void 0 !== e.version && (t.version = (e.version || BigInt(0)).toString()), void 0 !== e.totalWeight && (t.totalWeight = e.totalWeight), void 0 !== e.createdAt && (t.createdAt = (0, m.fromTimestamp)(e.createdAt).toISOString()), t
                },
                fromPartial(e) {
                    let t = O();
                    return void 0 !== e.id && null !== e.id && (t.id = BigInt(e.id.toString())), t.admin = e.admin ? ? "", t.metadata = e.metadata ? ? "", void 0 !== e.version && null !== e.version && (t.version = BigInt(e.version.toString())), t.totalWeight = e.totalWeight ? ? "", void 0 !== e.createdAt && null !== e.createdAt && (t.createdAt = c.Timestamp.fromPartial(e.createdAt)), t
                }
            }, t.GroupMember = {
                typeUrl: "/cosmos.group.v1.GroupMember",
                encode: (e, r = p.BinaryWriter.create()) => (e.groupId !== BigInt(0) && r.uint32(8).uint64(e.groupId), void 0 !== e.member && t.Member.encode(e.member, r.uint32(18).fork()).ldelim(), r),
                decode(e, r) {
                    let n = e instanceof p.BinaryReader ? e : new p.BinaryReader(e),
                        o = void 0 === r ? n.len : n.pos + r,
                        i = R();
                    for (; n.pos < o;) {
                        let e = n.uint32();
                        switch (e >>> 3) {
                            case 1:
                                i.groupId = n.uint64();
                                break;
                            case 2:
                                i.member = t.Member.decode(n, n.uint32());
                                break;
                            default:
                                n.skipType(7 & e)
                        }
                    }
                    return i
                },
                fromJSON(e) {
                    let r = R();
                    return (0, m.isSet)(e.groupId) && (r.groupId = BigInt(e.groupId.toString())), (0, m.isSet)(e.member) && (r.member = t.Member.fromJSON(e.member)), r
                },
                toJSON(e) {
                    let r = {};
                    return void 0 !== e.groupId && (r.groupId = (e.groupId || BigInt(0)).toString()), void 0 !== e.member && (r.member = e.member ? t.Member.toJSON(e.member) : void 0), r
                },
                fromPartial(e) {
                    let r = R();
                    return void 0 !== e.groupId && null !== e.groupId && (r.groupId = BigInt(e.groupId.toString())), void 0 !== e.member && null !== e.member && (r.member = t.Member.fromPartial(e.member)), r
                }
            }, t.GroupPolicyInfo = {
                typeUrl: "/cosmos.group.v1.GroupPolicyInfo",
                encode: (e, t = p.BinaryWriter.create()) => ("" !== e.address && t.uint32(10).string(e.address), e.groupId !== BigInt(0) && t.uint32(16).uint64(e.groupId), "" !== e.admin && t.uint32(26).string(e.admin), "" !== e.metadata && t.uint32(34).string(e.metadata), e.version !== BigInt(0) && t.uint32(40).uint64(e.version), void 0 !== e.decisionPolicy && u.Any.encode(e.decisionPolicy, t.uint32(50).fork()).ldelim(), void 0 !== e.createdAt && c.Timestamp.encode(e.createdAt, t.uint32(58).fork()).ldelim(), t),
                decode(e, t) {
                    let r = e instanceof p.BinaryReader ? e : new p.BinaryReader(e),
                        n = void 0 === t ? r.len : r.pos + t,
                        o = A();
                    for (; r.pos < n;) {
                        let e = r.uint32();
                        switch (e >>> 3) {
                            case 1:
                                o.address = r.string();
                                break;
                            case 2:
                                o.groupId = r.uint64();
                                break;
                            case 3:
                                o.admin = r.string();
                                break;
                            case 4:
                                o.metadata = r.string();
                                break;
                            case 5:
                                o.version = r.uint64();
                                break;
                            case 6:
                                o.decisionPolicy = u.Any.decode(r, r.uint32());
                                break;
                            case 7:
                                o.createdAt = c.Timestamp.decode(r, r.uint32());
                                break;
                            default:
                                r.skipType(7 & e)
                        }
                    }
                    return o
                },
                fromJSON(e) {
                    let t = A();
                    return (0, m.isSet)(e.address) && (t.address = String(e.address)), (0, m.isSet)(e.groupId) && (t.groupId = BigInt(e.groupId.toString())), (0, m.isSet)(e.admin) && (t.admin = String(e.admin)), (0, m.isSet)(e.metadata) && (t.metadata = String(e.metadata)), (0, m.isSet)(e.version) && (t.version = BigInt(e.version.toString())), (0, m.isSet)(e.decisionPolicy) && (t.decisionPolicy = u.Any.fromJSON(e.decisionPolicy)), (0, m.isSet)(e.createdAt) && (t.createdAt = (0, m.fromJsonTimestamp)(e.createdAt)), t
                },
                toJSON(e) {
                    let t = {};
                    return void 0 !== e.address && (t.address = e.address), void 0 !== e.groupId && (t.groupId = (e.groupId || BigInt(0)).toString()), void 0 !== e.admin && (t.admin = e.admin), void 0 !== e.metadata && (t.metadata = e.metadata), void 0 !== e.version && (t.version = (e.version || BigInt(0)).toString()), void 0 !== e.decisionPolicy && (t.decisionPolicy = e.decisionPolicy ? u.Any.toJSON(e.decisionPolicy) : void 0), void 0 !== e.createdAt && (t.createdAt = (0, m.fromTimestamp)(e.createdAt).toISOString()), t
                },
                fromPartial(e) {
                    let t = A();
                    return t.address = e.address ? ? "", void 0 !== e.groupId && null !== e.groupId && (t.groupId = BigInt(e.groupId.toString())), t.admin = e.admin ? ? "", t.metadata = e.metadata ? ? "", void 0 !== e.version && null !== e.version && (t.version = BigInt(e.version.toString())), void 0 !== e.decisionPolicy && null !== e.decisionPolicy && (t.decisionPolicy = u.Any.fromPartial(e.decisionPolicy)), void 0 !== e.createdAt && null !== e.createdAt && (t.createdAt = c.Timestamp.fromPartial(e.createdAt)), t
                }
            }, t.Proposal = {
                typeUrl: "/cosmos.group.v1.Proposal",
                encode(e, r = p.BinaryWriter.create()) {
                    for (let t of (e.id !== BigInt(0) && r.uint32(8).uint64(e.id), "" !== e.groupPolicyAddress && r.uint32(18).string(e.groupPolicyAddress), "" !== e.metadata && r.uint32(26).string(e.metadata), e.proposers)) r.uint32(34).string(t);
                    for (let n of (void 0 !== e.submitTime && c.Timestamp.encode(e.submitTime, r.uint32(42).fork()).ldelim(), e.groupVersion !== BigInt(0) && r.uint32(48).uint64(e.groupVersion), e.groupPolicyVersion !== BigInt(0) && r.uint32(56).uint64(e.groupPolicyVersion), 0 !== e.status && r.uint32(64).int32(e.status), void 0 !== e.finalTallyResult && t.TallyResult.encode(e.finalTallyResult, r.uint32(74).fork()).ldelim(), void 0 !== e.votingPeriodEnd && c.Timestamp.encode(e.votingPeriodEnd, r.uint32(82).fork()).ldelim(), 0 !== e.executorResult && r.uint32(88).int32(e.executorResult), e.messages)) u.Any.encode(n, r.uint32(98).fork()).ldelim();
                    return "" !== e.title && r.uint32(106).string(e.title), "" !== e.summary && r.uint32(114).string(e.summary), r
                },
                decode(e, r) {
                    let n = e instanceof p.BinaryReader ? e : new p.BinaryReader(e),
                        o = void 0 === r ? n.len : n.pos + r,
                        i = I();
                    for (; n.pos < o;) {
                        let e = n.uint32();
                        switch (e >>> 3) {
                            case 1:
                                i.id = n.uint64();
                                break;
                            case 2:
                                i.groupPolicyAddress = n.string();
                                break;
                            case 3:
                                i.metadata = n.string();
                                break;
                            case 4:
                                i.proposers.push(n.string());
                                break;
                            case 5:
                                i.submitTime = c.Timestamp.decode(n, n.uint32());
                                break;
                            case 6:
                                i.groupVersion = n.uint64();
                                break;
                            case 7:
                                i.groupPolicyVersion = n.uint64();
                                break;
                            case 8:
                                i.status = n.int32();
                                break;
                            case 9:
                                i.finalTallyResult = t.TallyResult.decode(n, n.uint32());
                                break;
                            case 10:
                                i.votingPeriodEnd = c.Timestamp.decode(n, n.uint32());
                                break;
                            case 11:
                                i.executorResult = n.int32();
                                break;
                            case 12:
                                i.messages.push(u.Any.decode(n, n.uint32()));
                                break;
                            case 13:
                                i.title = n.string();
                                break;
                            case 14:
                                i.summary = n.string();
                                break;
                            default:
                                n.skipType(7 & e)
                        }
                    }
                    return i
                },
                fromJSON(e) {
                    let r = I();
                    return (0, m.isSet)(e.id) && (r.id = BigInt(e.id.toString())), (0, m.isSet)(e.groupPolicyAddress) && (r.groupPolicyAddress = String(e.groupPolicyAddress)), (0, m.isSet)(e.metadata) && (r.metadata = String(e.metadata)), Array.isArray(e ? .proposers) && (r.proposers = e.proposers.map(e => String(e))), (0, m.isSet)(e.submitTime) && (r.submitTime = (0, m.fromJsonTimestamp)(e.submitTime)), (0, m.isSet)(e.groupVersion) && (r.groupVersion = BigInt(e.groupVersion.toString())), (0, m.isSet)(e.groupPolicyVersion) && (r.groupPolicyVersion = BigInt(e.groupPolicyVersion.toString())), (0, m.isSet)(e.status) && (r.status = y(e.status)), (0, m.isSet)(e.finalTallyResult) && (r.finalTallyResult = t.TallyResult.fromJSON(e.finalTallyResult)), (0, m.isSet)(e.votingPeriodEnd) && (r.votingPeriodEnd = (0, m.fromJsonTimestamp)(e.votingPeriodEnd)), (0, m.isSet)(e.executorResult) && (r.executorResult = v(e.executorResult)), Array.isArray(e ? .messages) && (r.messages = e.messages.map(e => u.Any.fromJSON(e))), (0, m.isSet)(e.title) && (r.title = String(e.title)), (0, m.isSet)(e.summary) && (r.summary = String(e.summary)), r
                },
                toJSON(e) {
                    let r = {};
                    return void 0 !== e.id && (r.id = (e.id || BigInt(0)).toString()), void 0 !== e.groupPolicyAddress && (r.groupPolicyAddress = e.groupPolicyAddress), void 0 !== e.metadata && (r.metadata = e.metadata), e.proposers ? r.proposers = e.proposers.map(e => e) : r.proposers = [], void 0 !== e.submitTime && (r.submitTime = (0, m.fromTimestamp)(e.submitTime).toISOString()), void 0 !== e.groupVersion && (r.groupVersion = (e.groupVersion || BigInt(0)).toString()), void 0 !== e.groupPolicyVersion && (r.groupPolicyVersion = (e.groupPolicyVersion || BigInt(0)).toString()), void 0 !== e.status && (r.status = h(e.status)), void 0 !== e.finalTallyResult && (r.finalTallyResult = e.finalTallyResult ? t.TallyResult.toJSON(e.finalTallyResult) : void 0), void 0 !== e.votingPeriodEnd && (r.votingPeriodEnd = (0, m.fromTimestamp)(e.votingPeriodEnd).toISOString()), void 0 !== e.executorResult && (r.executorResult = b(e.executorResult)), e.messages ? r.messages = e.messages.map(e => e ? u.Any.toJSON(e) : void 0) : r.messages = [], void 0 !== e.title && (r.title = e.title), void 0 !== e.summary && (r.summary = e.summary), r
                },
                fromPartial(e) {
                    let r = I();
                    return void 0 !== e.id && null !== e.id && (r.id = BigInt(e.id.toString())), r.groupPolicyAddress = e.groupPolicyAddress ? ? "", r.metadata = e.metadata ? ? "", r.proposers = e.proposers ? .map(e => e) || [], void 0 !== e.submitTime && null !== e.submitTime && (r.submitTime = c.Timestamp.fromPartial(e.submitTime)), void 0 !== e.groupVersion && null !== e.groupVersion && (r.groupVersion = BigInt(e.groupVersion.toString())), void 0 !== e.groupPolicyVersion && null !== e.groupPolicyVersion && (r.groupPolicyVersion = BigInt(e.groupPolicyVersion.toString())), r.status = e.status ? ? 0, void 0 !== e.finalTallyResult && null !== e.finalTallyResult && (r.finalTallyResult = t.TallyResult.fromPartial(e.finalTallyResult)), void 0 !== e.votingPeriodEnd && null !== e.votingPeriodEnd && (r.votingPeriodEnd = c.Timestamp.fromPartial(e.votingPeriodEnd)), r.executorResult = e.executorResult ? ? 0, r.messages = e.messages ? .map(e => u.Any.fromPartial(e)) || [], r.title = e.title ? ? "", r.summary = e.summary ? ? "", r
                }
            }, t.TallyResult = {
                typeUrl: "/cosmos.group.v1.TallyResult",
                encode: (e, t = p.BinaryWriter.create()) => ("" !== e.yesCount && t.uint32(10).string(e.yesCount), "" !== e.abstainCount && t.uint32(18).string(e.abstainCount), "" !== e.noCount && t.uint32(26).string(e.noCount), "" !== e.noWithVetoCount && t.uint32(34).string(e.noWithVetoCount), t),
                decode(e, t) {
                    let r = e instanceof p.BinaryReader ? e : new p.BinaryReader(e),
                        n = void 0 === t ? r.len : r.pos + t,
                        o = w();
                    for (; r.pos < n;) {
                        let e = r.uint32();
                        switch (e >>> 3) {
                            case 1:
                                o.yesCount = r.string();
                                break;
                            case 2:
                                o.abstainCount = r.string();
                                break;
                            case 3:
                                o.noCount = r.string();
                                break;
                            case 4:
                                o.noWithVetoCount = r.string();
                                break;
                            default:
                                r.skipType(7 & e)
                        }
                    }
                    return o
                },
                fromJSON(e) {
                    let t = w();
                    return (0, m.isSet)(e.yesCount) && (t.yesCount = String(e.yesCount)), (0, m.isSet)(e.abstainCount) && (t.abstainCount = String(e.abstainCount)), (0, m.isSet)(e.noCount) && (t.noCount = String(e.noCount)), (0, m.isSet)(e.noWithVetoCount) && (t.noWithVetoCount = String(e.noWithVetoCount)), t
                },
                toJSON(e) {
                    let t = {};
                    return void 0 !== e.yesCount && (t.yesCount = e.yesCount), void 0 !== e.abstainCount && (t.abstainCount = e.abstainCount), void 0 !== e.noCount && (t.noCount = e.noCount), void 0 !== e.noWithVetoCount && (t.noWithVetoCount = e.noWithVetoCount), t
                },
                fromPartial(e) {
                    let t = w();
                    return t.yesCount = e.yesCount ? ? "", t.abstainCount = e.abstainCount ? ? "", t.noCount = e.noCount ? ? "", t.noWithVetoCount = e.noWithVetoCount ? ? "", t
                }
            }, t.Vote = {
                typeUrl: "/cosmos.group.v1.Vote",
                encode: (e, t = p.BinaryWriter.create()) => (e.proposalId !== BigInt(0) && t.uint32(8).uint64(e.proposalId), "" !== e.voter && t.uint32(18).string(e.voter), 0 !== e.option && t.uint32(24).int32(e.option), "" !== e.metadata && t.uint32(34).string(e.metadata), void 0 !== e.submitTime && c.Timestamp.encode(e.submitTime, t.uint32(42).fork()).ldelim(), t),
                decode(e, t) {
                    let r = e instanceof p.BinaryReader ? e : new p.BinaryReader(e),
                        n = void 0 === t ? r.len : r.pos + t,
                        o = T();
                    for (; r.pos < n;) {
                        let e = r.uint32();
                        switch (e >>> 3) {
                            case 1:
                                o.proposalId = r.uint64();
                                break;
                            case 2:
                                o.voter = r.string();
                                break;
                            case 3:
                                o.option = r.int32();
                                break;
                            case 4:
                                o.metadata = r.string();
                                break;
                            case 5:
                                o.submitTime = c.Timestamp.decode(r, r.uint32());
                                break;
                            default:
                                r.skipType(7 & e)
                        }
                    }
                    return o
                },
                fromJSON(e) {
                    let t = T();
                    return (0, m.isSet)(e.proposalId) && (t.proposalId = BigInt(e.proposalId.toString())), (0, m.isSet)(e.voter) && (t.voter = String(e.voter)), (0, m.isSet)(e.option) && (t.option = g(e.option)), (0, m.isSet)(e.metadata) && (t.metadata = String(e.metadata)), (0, m.isSet)(e.submitTime) && (t.submitTime = (0, m.fromJsonTimestamp)(e.submitTime)), t
                },
                toJSON(e) {
                    let t = {};
                    return void 0 !== e.proposalId && (t.proposalId = (e.proposalId || BigInt(0)).toString()), void 0 !== e.voter && (t.voter = e.voter), void 0 !== e.option && (t.option = f(e.option)), void 0 !== e.metadata && (t.metadata = e.metadata), void 0 !== e.submitTime && (t.submitTime = (0, m.fromTimestamp)(e.submitTime).toISOString()), t
                },
                fromPartial(e) {
                    let t = T();
                    return void 0 !== e.proposalId && null !== e.proposalId && (t.proposalId = BigInt(e.proposalId.toString())), t.voter = e.voter ? ? "", t.option = e.option ? ? 0, t.metadata = e.metadata ? ? "", void 0 !== e.submitTime && null !== e.submitTime && (t.submitTime = c.Timestamp.fromPartial(e.submitTime)), t
                }
            }
        },
        51570: function(e, t, r) {
            "use strict";
            var n, o, i, a;
            Object.defineProperty(t, "__esModule", {
                value: !0
            }), t.CompressedNonExistenceProof = t.CompressedExistenceProof = t.CompressedBatchEntry = t.CompressedBatchProof = t.BatchEntry = t.BatchProof = t.InnerSpec = t.ProofSpec = t.InnerOp = t.LeafOp = t.CommitmentProof = t.NonExistenceProof = t.ExistenceProof = t.lengthOpToJSON = t.lengthOpFromJSON = t.LengthOp = t.hashOpToJSON = t.hashOpFromJSON = t.HashOp = t.protobufPackage = void 0;
            let s = r(28486),
                d = r(6476);

            function c(e) {
                switch (e) {
                    case 0:
                    case "NO_HASH":
                        return n.NO_HASH;
                    case 1:
                    case "SHA256":
                        return n.SHA256;
                    case 2:
                    case "SHA512":
                        return n.SHA512;
                    case 3:
                    case "KECCAK":
                        return n.KECCAK;
                    case 4:
                    case "RIPEMD160":
                        return n.RIPEMD160;
                    case 5:
                    case "BITCOIN":
                        return n.BITCOIN;
                    case 6:
                    case "SHA512_256":
                        return n.SHA512_256;
                    default:
                        return n.UNRECOGNIZED
                }
            }

            function l(e) {
                switch (e) {
                    case n.NO_HASH:
                        return "NO_HASH";
                    case n.SHA256:
                        return "SHA256";
                    case n.SHA512:
                        return "SHA512";
                    case n.KECCAK:
                        return "KECCAK";
                    case n.RIPEMD160:
                        return "RIPEMD160";
                    case n.BITCOIN:
                        return "BITCOIN";
                    case n.SHA512_256:
                        return "SHA512_256";
                    case n.UNRECOGNIZED:
                    default:
                        return "UNRECOGNIZED"
                }
            }

            function u(e) {
                switch (e) {
                    case 0:
                    case "NO_PREFIX":
                        return o.NO_PREFIX;
                    case 1:
                    case "VAR_PROTO":
                        return o.VAR_PROTO;
                    case 2:
                    case "VAR_RLP":
                        return o.VAR_RLP;
                    case 3:
                    case "FIXED32_BIG":
                        return o.FIXED32_BIG;
                    case 4:
                    case "FIXED32_LITTLE":
                        return o.FIXED32_LITTLE;
                    case 5:
                    case "FIXED64_BIG":
                        return o.FIXED64_BIG;
                    case 6:
                    case "FIXED64_LITTLE":
                        return o.FIXED64_LITTLE;
                    case 7:
                    case "REQUIRE_32_BYTES":
                        return o.REQUIRE_32_BYTES;
                    case 8:
                    case "REQUIRE_64_BYTES":
                        return o.REQUIRE_64_BYTES;
                    default:
                        return o.UNRECOGNIZED
                }
            }

            function p(e) {
                switch (e) {
                    case o.NO_PREFIX:
                        return "NO_PREFIX";
                    case o.VAR_PROTO:
                        return "VAR_PROTO";
                    case o.VAR_RLP:
                        return "VAR_RLP";
                    case o.FIXED32_BIG:
                        return "FIXED32_BIG";
                    case o.FIXED32_LITTLE:
                        return "FIXED32_LITTLE";
                    case o.FIXED64_BIG:
                        return "FIXED64_BIG";
                    case o.FIXED64_LITTLE:
                        return "FIXED64_LITTLE";
                    case o.REQUIRE_32_BYTES:
                        return "REQUIRE_32_BYTES";
                    case o.REQUIRE_64_BYTES:
                        return "REQUIRE_64_BYTES";
                    case o.UNRECOGNIZED:
                    default:
                        return "UNRECOGNIZED"
                }
            }

            function m() {
                return {
                    key: new Uint8Array,
                    value: new Uint8Array,
                    leaf: void 0,
                    path: []
                }
            }

            function g() {
                return {
                    key: new Uint8Array,
                    left: void 0,
                    right: void 0
                }
            }

            function f() {
                return {
                    exist: void 0,
                    nonexist: void 0,
                    batch: void 0,
                    compressed: void 0
                }
            }

            function y() {
                return {
                    hash: 0,
                    prehashKey: 0,
                    prehashValue: 0,
                    length: 0,
                    prefix: new Uint8Array
                }
            }

            function h() {
                return {
                    hash: 0,
                    prefix: new Uint8Array,
                    suffix: new Uint8Array
                }
            }

            function v() {
                return {
                    leafSpec: void 0,
                    innerSpec: void 0,
                    maxDepth: 0,
                    minDepth: 0
                }
            }

            function b() {
                return {
                    childOrder: [],
                    childSize: 0,
                    minPrefixLength: 0,
                    maxPrefixLength: 0,
                    emptyChild: new Uint8Array,
                    hash: 0
                }
            }

            function S() {
                return {
                    entries: []
                }
            }

            function k() {
                return {
                    exist: void 0,
                    nonexist: void 0
                }
            }

            function P() {
                return {
                    entries: [],
                    lookupInners: []
                }
            }

            function _() {
                return {
                    exist: void 0,
                    nonexist: void 0
                }
            }

            function B() {
                return {
                    key: new Uint8Array,
                    value: new Uint8Array,
                    leaf: void 0,
                    path: []
                }
            }

            function O() {
                return {
                    key: new Uint8Array,
                    left: void 0,
                    right: void 0
                }
            }
            t.protobufPackage = "cosmos.ics23.v1", (i = n || (t.HashOp = n = {}))[i.NO_HASH = 0] = "NO_HASH", i[i.SHA256 = 1] = "SHA256", i[i.SHA512 = 2] = "SHA512", i[i.KECCAK = 3] = "KECCAK", i[i.RIPEMD160 = 4] = "RIPEMD160", i[i.BITCOIN = 5] = "BITCOIN", i[i.SHA512_256 = 6] = "SHA512_256", i[i.UNRECOGNIZED = -1] = "UNRECOGNIZED", t.hashOpFromJSON = c, t.hashOpToJSON = l, (a = o || (t.LengthOp = o = {}))[a.NO_PREFIX = 0] = "NO_PREFIX", a[a.VAR_PROTO = 1] = "VAR_PROTO", a[a.VAR_RLP = 2] = "VAR_RLP", a[a.FIXED32_BIG = 3] = "FIXED32_BIG", a[a.FIXED32_LITTLE = 4] = "FIXED32_LITTLE", a[a.FIXED64_BIG = 5] = "FIXED64_BIG", a[a.FIXED64_LITTLE = 6] = "FIXED64_LITTLE", a[a.REQUIRE_32_BYTES = 7] = "REQUIRE_32_BYTES", a[a.REQUIRE_64_BYTES = 8] = "REQUIRE_64_BYTES", a[a.UNRECOGNIZED = -1] = "UNRECOGNIZED", t.lengthOpFromJSON = u, t.lengthOpToJSON = p, t.ExistenceProof = {
                typeUrl: "/cosmos.ics23.v1.ExistenceProof",
                encode(e, r = s.BinaryWriter.create()) {
                    for (let n of (0 !== e.key.length && r.uint32(10).bytes(e.key), 0 !== e.value.length && r.uint32(18).bytes(e.value), void 0 !== e.leaf && t.LeafOp.encode(e.leaf, r.uint32(26).fork()).ldelim(), e.path)) t.InnerOp.encode(n, r.uint32(34).fork()).ldelim();
                    return r
                },
                decode(e, r) {
                    let n = e instanceof s.BinaryReader ? e : new s.BinaryReader(e),
                        o = void 0 === r ? n.len : n.pos + r,
                        i = m();
                    for (; n.pos < o;) {
                        let e = n.uint32();
                        switch (e >>> 3) {
                            case 1:
                                i.key = n.bytes();
                                break;
                            case 2:
                                i.value = n.bytes();
                                break;
                            case 3:
                                i.leaf = t.LeafOp.decode(n, n.uint32());
                                break;
                            case 4:
                                i.path.push(t.InnerOp.decode(n, n.uint32()));
                                break;
                            default:
                                n.skipType(7 & e)
                        }
                    }
                    return i
                },
                fromJSON(e) {
                    let r = m();
                    return (0, d.isSet)(e.key) && (r.key = (0, d.bytesFromBase64)(e.key)), (0, d.isSet)(e.value) && (r.value = (0, d.bytesFromBase64)(e.value)), (0, d.isSet)(e.leaf) && (r.leaf = t.LeafOp.fromJSON(e.leaf)), Array.isArray(e ? .path) && (r.path = e.path.map(e => t.InnerOp.fromJSON(e))), r
                },
                toJSON(e) {
                    let r = {};
                    return void 0 !== e.key && (r.key = (0, d.base64FromBytes)(void 0 !== e.key ? e.key : new Uint8Array)), void 0 !== e.value && (r.value = (0, d.base64FromBytes)(void 0 !== e.value ? e.value : new Uint8Array)), void 0 !== e.leaf && (r.leaf = e.leaf ? t.LeafOp.toJSON(e.leaf) : void 0), e.path ? r.path = e.path.map(e => e ? t.InnerOp.toJSON(e) : void 0) : r.path = [], r
                },
                fromPartial(e) {
                    let r = m();
                    return r.key = e.key ? ? new Uint8Array, r.value = e.value ? ? new Uint8Array, void 0 !== e.leaf && null !== e.leaf && (r.leaf = t.LeafOp.fromPartial(e.leaf)), r.path = e.path ? .map(e => t.InnerOp.fromPartial(e)) || [], r
                }
            }, t.NonExistenceProof = {
                typeUrl: "/cosmos.ics23.v1.NonExistenceProof",
                encode: (e, r = s.BinaryWriter.create()) => (0 !== e.key.length && r.uint32(10).bytes(e.key), void 0 !== e.left && t.ExistenceProof.encode(e.left, r.uint32(18).fork()).ldelim(), void 0 !== e.right && t.ExistenceProof.encode(e.right, r.uint32(26).fork()).ldelim(), r),
                decode(e, r) {
                    let n = e instanceof s.BinaryReader ? e : new s.BinaryReader(e),
                        o = void 0 === r ? n.len : n.pos + r,
                        i = g();
                    for (; n.pos < o;) {
                        let e = n.uint32();
                        switch (e >>> 3) {
                            case 1:
                                i.key = n.bytes();
                                break;
                            case 2:
                                i.left = t.ExistenceProof.decode(n, n.uint32());
                                break;
                            case 3:
                                i.right = t.ExistenceProof.decode(n, n.uint32());
                                break;
                            default:
                                n.skipType(7 & e)
                        }
                    }
                    return i
                },
                fromJSON(e) {
                    let r = g();
                    return (0, d.isSet)(e.key) && (r.key = (0, d.bytesFromBase64)(e.key)), (0, d.isSet)(e.left) && (r.left = t.ExistenceProof.fromJSON(e.left)), (0, d.isSet)(e.right) && (r.right = t.ExistenceProof.fromJSON(e.right)), r
                },
                toJSON(e) {
                    let r = {};
                    return void 0 !== e.key && (r.key = (0, d.base64FromBytes)(void 0 !== e.key ? e.key : new Uint8Array)), void 0 !== e.left && (r.left = e.left ? t.ExistenceProof.toJSON(e.left) : void 0), void 0 !== e.right && (r.right = e.right ? t.ExistenceProof.toJSON(e.right) : void 0), r
                },
                fromPartial(e) {
                    let r = g();
                    return r.key = e.key ? ? new Uint8Array, void 0 !== e.left && null !== e.left && (r.left = t.ExistenceProof.fromPartial(e.left)), void 0 !== e.right && null !== e.right && (r.right = t.ExistenceProof.fromPartial(e.right)), r
                }
            }, t.CommitmentProof = {
                typeUrl: "/cosmos.ics23.v1.CommitmentProof",
                encode: (e, r = s.BinaryWriter.create()) => (void 0 !== e.exist && t.ExistenceProof.encode(e.exist, r.uint32(10).fork()).ldelim(), void 0 !== e.nonexist && t.NonExistenceProof.encode(e.nonexist, r.uint32(18).fork()).ldelim(), void 0 !== e.batch && t.BatchProof.encode(e.batch, r.uint32(26).fork()).ldelim(), void 0 !== e.compressed && t.CompressedBatchProof.encode(e.compressed, r.uint32(34).fork()).ldelim(), r),
                decode(e, r) {
                    let n = e instanceof s.BinaryReader ? e : new s.BinaryReader(e),
                        o = void 0 === r ? n.len : n.pos + r,
                        i = f();
                    for (; n.pos < o;) {
                        let e = n.uint32();
                        switch (e >>> 3) {
                            case 1:
                                i.exist = t.ExistenceProof.decode(n, n.uint32());
                                break;
                            case 2:
                                i.nonexist = t.NonExistenceProof.decode(n, n.uint32());
                                break;
                            case 3:
                                i.batch = t.BatchProof.decode(n, n.uint32());
                                break;
                            case 4:
                                i.compressed = t.CompressedBatchProof.decode(n, n.uint32());
                                break;
                            default:
                                n.skipType(7 & e)
                        }
                    }
                    return i
                },
                fromJSON(e) {
                    let r = f();
                    return (0, d.isSet)(e.exist) && (r.exist = t.ExistenceProof.fromJSON(e.exist)), (0, d.isSet)(e.nonexist) && (r.nonexist = t.NonExistenceProof.fromJSON(e.nonexist)), (0, d.isSet)(e.batch) && (r.batch = t.BatchProof.fromJSON(e.batch)), (0, d.isSet)(e.compressed) && (r.compressed = t.CompressedBatchProof.fromJSON(e.compressed)), r
                },
                toJSON(e) {
                    let r = {};
                    return void 0 !== e.exist && (r.exist = e.exist ? t.ExistenceProof.toJSON(e.exist) : void 0), void 0 !== e.nonexist && (r.nonexist = e.nonexist ? t.NonExistenceProof.toJSON(e.nonexist) : void 0), void 0 !== e.batch && (r.batch = e.batch ? t.BatchProof.toJSON(e.batch) : void 0), void 0 !== e.compressed && (r.compressed = e.compressed ? t.CompressedBatchProof.toJSON(e.compressed) : void 0), r
                },
                fromPartial(e) {
                    let r = f();
                    return void 0 !== e.exist && null !== e.exist && (r.exist = t.ExistenceProof.fromPartial(e.exist)), void 0 !== e.nonexist && null !== e.nonexist && (r.nonexist = t.NonExistenceProof.fromPartial(e.nonexist)), void 0 !== e.batch && null !== e.batch && (r.batch = t.BatchProof.fromPartial(e.batch)), void 0 !== e.compressed && null !== e.compressed && (r.compressed = t.CompressedBatchProof.fromPartial(e.compressed)), r
                }
            }, t.LeafOp = {
                typeUrl: "/cosmos.ics23.v1.LeafOp",
                encode: (e, t = s.BinaryWriter.create()) => (0 !== e.hash && t.uint32(8).int32(e.hash), 0 !== e.prehashKey && t.uint32(16).int32(e.prehashKey), 0 !== e.prehashValue && t.uint32(24).int32(e.prehashValue), 0 !== e.length && t.uint32(32).int32(e.length), 0 !== e.prefix.length && t.uint32(42).bytes(e.prefix), t),
                decode(e, t) {
                    let r = e instanceof s.BinaryReader ? e : new s.BinaryReader(e),
                        n = void 0 === t ? r.len : r.pos + t,
                        o = y();
                    for (; r.pos < n;) {
                        let e = r.uint32();
                        switch (e >>> 3) {
                            case 1:
                                o.hash = r.int32();
                                break;
                            case 2:
                                o.prehashKey = r.int32();
                                break;
                            case 3:
                                o.prehashValue = r.int32();
                                break;
                            case 4:
                                o.length = r.int32();
                                break;
                            case 5:
                                o.prefix = r.bytes();
                                break;
                            default:
                                r.skipType(7 & e)
                        }
                    }
                    return o
                },
                fromJSON(e) {
                    let t = y();
                    return (0, d.isSet)(e.hash) && (t.hash = c(e.hash)), (0, d.isSet)(e.prehashKey) && (t.prehashKey = c(e.prehashKey)), (0, d.isSet)(e.prehashValue) && (t.prehashValue = c(e.prehashValue)), (0, d.isSet)(e.length) && (t.length = u(e.length)), (0, d.isSet)(e.prefix) && (t.prefix = (0, d.bytesFromBase64)(e.prefix)), t
                },
                toJSON(e) {
                    let t = {};
                    return void 0 !== e.hash && (t.hash = l(e.hash)), void 0 !== e.prehashKey && (t.prehashKey = l(e.prehashKey)), void 0 !== e.prehashValue && (t.prehashValue = l(e.prehashValue)), void 0 !== e.length && (t.length = p(e.length)), void 0 !== e.prefix && (t.prefix = (0, d.base64FromBytes)(void 0 !== e.prefix ? e.prefix : new Uint8Array)), t
                },
                fromPartial(e) {
                    let t = y();
                    return t.hash = e.hash ? ? 0, t.prehashKey = e.prehashKey ? ? 0, t.prehashValue = e.prehashValue ? ? 0, t.length = e.length ? ? 0, t.prefix = e.prefix ? ? new Uint8Array, t
                }
            }, t.InnerOp = {
                typeUrl: "/cosmos.ics23.v1.InnerOp",
                encode: (e, t = s.BinaryWriter.create()) => (0 !== e.hash && t.uint32(8).int32(e.hash), 0 !== e.prefix.length && t.uint32(18).bytes(e.prefix), 0 !== e.suffix.length && t.uint32(26).bytes(e.suffix), t),
                decode(e, t) {
                    let r = e instanceof s.BinaryReader ? e : new s.BinaryReader(e),
                        n = void 0 === t ? r.len : r.pos + t,
                        o = h();
                    for (; r.pos < n;) {
                        let e = r.uint32();
                        switch (e >>> 3) {
                            case 1:
                                o.hash = r.int32();
                                break;
                            case 2:
                                o.prefix = r.bytes();
                                break;
                            case 3:
                                o.suffix = r.bytes();
                                break;
                            default:
                                r.skipType(7 & e)
                        }
                    }
                    return o
                },
                fromJSON(e) {
                    let t = h();
                    return (0, d.isSet)(e.hash) && (t.hash = c(e.hash)), (0, d.isSet)(e.prefix) && (t.prefix = (0, d.bytesFromBase64)(e.prefix)), (0, d.isSet)(e.suffix) && (t.suffix = (0, d.bytesFromBase64)(e.suffix)), t
                },
                toJSON(e) {
                    let t = {};
                    return void 0 !== e.hash && (t.hash = l(e.hash)), void 0 !== e.prefix && (t.prefix = (0, d.base64FromBytes)(void 0 !== e.prefix ? e.prefix : new Uint8Array)), void 0 !== e.suffix && (t.suffix = (0, d.base64FromBytes)(void 0 !== e.suffix ? e.suffix : new Uint8Array)), t
                },
                fromPartial(e) {
                    let t = h();
                    return t.hash = e.hash ? ? 0, t.prefix = e.prefix ? ? new Uint8Array, t.suffix = e.suffix ? ? new Uint8Array, t
                }
            }, t.ProofSpec = {
                typeUrl: "/cosmos.ics23.v1.ProofSpec",
                encode: (e, r = s.BinaryWriter.create()) => (void 0 !== e.leafSpec && t.LeafOp.encode(e.leafSpec, r.uint32(10).fork()).ldelim(), void 0 !== e.innerSpec && t.InnerSpec.encode(e.innerSpec, r.uint32(18).fork()).ldelim(), 0 !== e.maxDepth && r.uint32(24).int32(e.maxDepth), 0 !== e.minDepth && r.uint32(32).int32(e.minDepth), r),
                decode(e, r) {
                    let n = e instanceof s.BinaryReader ? e : new s.BinaryReader(e),
                        o = void 0 === r ? n.len : n.pos + r,
                        i = v();
                    for (; n.pos < o;) {
                        let e = n.uint32();
                        switch (e >>> 3) {
                            case 1:
                                i.leafSpec = t.LeafOp.decode(n, n.uint32());
                                break;
                            case 2:
                                i.innerSpec = t.InnerSpec.decode(n, n.uint32());
                                break;
                            case 3:
                                i.maxDepth = n.int32();
                                break;
                            case 4:
                                i.minDepth = n.int32();
                                break;
                            default:
                                n.skipType(7 & e)
                        }
                    }
                    return i
                },
                fromJSON(e) {
                    let r = v();
                    return (0, d.isSet)(e.leafSpec) && (r.leafSpec = t.LeafOp.fromJSON(e.leafSpec)), (0, d.isSet)(e.innerSpec) && (r.innerSpec = t.InnerSpec.fromJSON(e.innerSpec)), (0, d.isSet)(e.maxDepth) && (r.maxDepth = Number(e.maxDepth)), (0, d.isSet)(e.minDepth) && (r.minDepth = Number(e.minDepth)), r
                },
                toJSON(e) {
                    let r = {};
                    return void 0 !== e.leafSpec && (r.leafSpec = e.leafSpec ? t.LeafOp.toJSON(e.leafSpec) : void 0), void 0 !== e.innerSpec && (r.innerSpec = e.innerSpec ? t.InnerSpec.toJSON(e.innerSpec) : void 0), void 0 !== e.maxDepth && (r.maxDepth = Math.round(e.maxDepth)), void 0 !== e.minDepth && (r.minDepth = Math.round(e.minDepth)), r
                },
                fromPartial(e) {
                    let r = v();
                    return void 0 !== e.leafSpec && null !== e.leafSpec && (r.leafSpec = t.LeafOp.fromPartial(e.leafSpec)), void 0 !== e.innerSpec && null !== e.innerSpec && (r.innerSpec = t.InnerSpec.fromPartial(e.innerSpec)), r.maxDepth = e.maxDepth ? ? 0, r.minDepth = e.minDepth ? ? 0, r
                }
            }, t.InnerSpec = {
                typeUrl: "/cosmos.ics23.v1.InnerSpec",
                encode(e, t = s.BinaryWriter.create()) {
                    for (let r of (t.uint32(10).fork(), e.childOrder)) t.int32(r);
                    return t.ldelim(), 0 !== e.childSize && t.uint32(16).int32(e.childSize), 0 !== e.minPrefixLength && t.uint32(24).int32(e.minPrefixLength), 0 !== e.maxPrefixLength && t.uint32(32).int32(e.maxPrefixLength), 0 !== e.emptyChild.length && t.uint32(42).bytes(e.emptyChild), 0 !== e.hash && t.uint32(48).int32(e.hash), t
                },
                decode(e, t) {
                    let r = e instanceof s.BinaryReader ? e : new s.BinaryReader(e),
                        n = void 0 === t ? r.len : r.pos + t,
                        o = b();
                    for (; r.pos < n;) {
                        let e = r.uint32();
                        switch (e >>> 3) {
                            case 1:
                                if ((7 & e) == 2) {
                                    let e = r.uint32() + r.pos;
                                    for (; r.pos < e;) o.childOrder.push(r.int32())
                                } else o.childOrder.push(r.int32());
                                break;
                            case 2:
                                o.childSize = r.int32();
                                break;
                            case 3:
                                o.minPrefixLength = r.int32();
                                break;
                            case 4:
                                o.maxPrefixLength = r.int32();
                                break;
                            case 5:
                                o.emptyChild = r.bytes();
                                break;
                            case 6:
                                o.hash = r.int32();
                                break;
                            default:
                                r.skipType(7 & e)
                        }
                    }
                    return o
                },
                fromJSON(e) {
                    let t = b();
                    return Array.isArray(e ? .childOrder) && (t.childOrder = e.childOrder.map(e => Number(e))), (0, d.isSet)(e.childSize) && (t.childSize = Number(e.childSize)), (0, d.isSet)(e.minPrefixLength) && (t.minPrefixLength = Number(e.minPrefixLength)), (0, d.isSet)(e.maxPrefixLength) && (t.maxPrefixLength = Number(e.maxPrefixLength)), (0, d.isSet)(e.emptyChild) && (t.emptyChild = (0, d.bytesFromBase64)(e.emptyChild)), (0, d.isSet)(e.hash) && (t.hash = c(e.hash)), t
                },
                toJSON(e) {
                    let t = {};
                    return e.childOrder ? t.childOrder = e.childOrder.map(e => Math.round(e)) : t.childOrder = [], void 0 !== e.childSize && (t.childSize = Math.round(e.childSize)), void 0 !== e.minPrefixLength && (t.minPrefixLength = Math.round(e.minPrefixLength)), void 0 !== e.maxPrefixLength && (t.maxPrefixLength = Math.round(e.maxPrefixLength)), void 0 !== e.emptyChild && (t.emptyChild = (0, d.base64FromBytes)(void 0 !== e.emptyChild ? e.emptyChild : new Uint8Array)), void 0 !== e.hash && (t.hash = l(e.hash)), t
                },
                fromPartial(e) {
                    let t = b();
                    return t.childOrder = e.childOrder ? .map(e => e) || [], t.childSize = e.childSize ? ? 0, t.minPrefixLength = e.minPrefixLength ? ? 0, t.maxPrefixLength = e.maxPrefixLength ? ? 0, t.emptyChild = e.emptyChild ? ? new Uint8Array, t.hash = e.hash ? ? 0, t
                }
            }, t.BatchProof = {
                typeUrl: "/cosmos.ics23.v1.BatchProof",
                encode(e, r = s.BinaryWriter.create()) {
                    for (let n of e.entries) t.BatchEntry.encode(n, r.uint32(10).fork()).ldelim();
                    return r
                },
                decode(e, r) {
                    let n = e instanceof s.BinaryReader ? e : new s.BinaryReader(e),
                        o = void 0 === r ? n.len : n.pos + r,
                        i = S();
                    for (; n.pos < o;) {
                        let e = n.uint32();
                        e >>> 3 == 1 ? i.entries.push(t.BatchEntry.decode(n, n.uint32())) : n.skipType(7 & e)
                    }
                    return i
                },
                fromJSON(e) {
                    let r = S();
                    return Array.isArray(e ? .entries) && (r.entries = e.entries.map(e => t.BatchEntry.fromJSON(e))), r
                },
                toJSON(e) {
                    let r = {};
                    return e.entries ? r.entries = e.entries.map(e => e ? t.BatchEntry.toJSON(e) : void 0) : r.entries = [], r
                },
                fromPartial(e) {
                    let r = S();
                    return r.entries = e.entries ? .map(e => t.BatchEntry.fromPartial(e)) || [], r
                }
            }, t.BatchEntry = {
                typeUrl: "/cosmos.ics23.v1.BatchEntry",
                encode: (e, r = s.BinaryWriter.create()) => (void 0 !== e.exist && t.ExistenceProof.encode(e.exist, r.uint32(10).fork()).ldelim(), void 0 !== e.nonexist && t.NonExistenceProof.encode(e.nonexist, r.uint32(18).fork()).ldelim(), r),
                decode(e, r) {
                    let n = e instanceof s.BinaryReader ? e : new s.BinaryReader(e),
                        o = void 0 === r ? n.len : n.pos + r,
                        i = k();
                    for (; n.pos < o;) {
                        let e = n.uint32();
                        switch (e >>> 3) {
                            case 1:
                                i.exist = t.ExistenceProof.decode(n, n.uint32());
                                break;
                            case 2:
                                i.nonexist = t.NonExistenceProof.decode(n, n.uint32());
                                break;
                            default:
                                n.skipType(7 & e)
                        }
                    }
                    return i
                },
                fromJSON(e) {
                    let r = k();
                    return (0, d.isSet)(e.exist) && (r.exist = t.ExistenceProof.fromJSON(e.exist)), (0, d.isSet)(e.nonexist) && (r.nonexist = t.NonExistenceProof.fromJSON(e.nonexist)), r
                },
                toJSON(e) {
                    let r = {};
                    return void 0 !== e.exist && (r.exist = e.exist ? t.ExistenceProof.toJSON(e.exist) : void 0), void 0 !== e.nonexist && (r.nonexist = e.nonexist ? t.NonExistenceProof.toJSON(e.nonexist) : void 0), r
                },
                fromPartial(e) {
                    let r = k();
                    return void 0 !== e.exist && null !== e.exist && (r.exist = t.ExistenceProof.fromPartial(e.exist)), void 0 !== e.nonexist && null !== e.nonexist && (r.nonexist = t.NonExistenceProof.fromPartial(e.nonexist)), r
                }
            }, t.CompressedBatchProof = {
                typeUrl: "/cosmos.ics23.v1.CompressedBatchProof",
                encode(e, r = s.BinaryWriter.create()) {
                    for (let n of e.entries) t.CompressedBatchEntry.encode(n, r.uint32(10).fork()).ldelim();
                    for (let n of e.lookupInners) t.InnerOp.encode(n, r.uint32(18).fork()).ldelim();
                    return r
                },
                decode(e, r) {
                    let n = e instanceof s.BinaryReader ? e : new s.BinaryReader(e),
                        o = void 0 === r ? n.len : n.pos + r,
                        i = P();
                    for (; n.pos < o;) {
                        let e = n.uint32();
                        switch (e >>> 3) {
                            case 1:
                                i.entries.push(t.CompressedBatchEntry.decode(n, n.uint32()));
                                break;
                            case 2:
                                i.lookupInners.push(t.InnerOp.decode(n, n.uint32()));
                                break;
                            default:
                                n.skipType(7 & e)
                        }
                    }
                    return i
                },
                fromJSON(e) {
                    let r = P();
                    return Array.isArray(e ? .entries) && (r.entries = e.entries.map(e => t.CompressedBatchEntry.fromJSON(e))), Array.isArray(e ? .lookupInners) && (r.lookupInners = e.lookupInners.map(e => t.InnerOp.fromJSON(e))), r
                },
                toJSON(e) {
                    let r = {};
                    return e.entries ? r.entries = e.entries.map(e => e ? t.CompressedBatchEntry.toJSON(e) : void 0) : r.entries = [], e.lookupInners ? r.lookupInners = e.lookupInners.map(e => e ? t.InnerOp.toJSON(e) : void 0) : r.lookupInners = [], r
                },
                fromPartial(e) {
                    let r = P();
                    return r.entries = e.entries ? .map(e => t.CompressedBatchEntry.fromPartial(e)) || [], r.lookupInners = e.lookupInners ? .map(e => t.InnerOp.fromPartial(e)) || [], r
                }
            }, t.CompressedBatchEntry = {
                typeUrl: "/cosmos.ics23.v1.CompressedBatchEntry",
                encode: (e, r = s.BinaryWriter.create()) => (void 0 !== e.exist && t.CompressedExistenceProof.encode(e.exist, r.uint32(10).fork()).ldelim(), void 0 !== e.nonexist && t.CompressedNonExistenceProof.encode(e.nonexist, r.uint32(18).fork()).ldelim(), r),
                decode(e, r) {
                    let n = e instanceof s.BinaryReader ? e : new s.BinaryReader(e),
                        o = void 0 === r ? n.len : n.pos + r,
                        i = _();
                    for (; n.pos < o;) {
                        let e = n.uint32();
                        switch (e >>> 3) {
                            case 1:
                                i.exist = t.CompressedExistenceProof.decode(n, n.uint32());
                                break;
                            case 2:
                                i.nonexist = t.CompressedNonExistenceProof.decode(n, n.uint32());
                                break;
                            default:
                                n.skipType(7 & e)
                        }
                    }
                    return i
                },
                fromJSON(e) {
                    let r = _();
                    return (0, d.isSet)(e.exist) && (r.exist = t.CompressedExistenceProof.fromJSON(e.exist)), (0, d.isSet)(e.nonexist) && (r.nonexist = t.CompressedNonExistenceProof.fromJSON(e.nonexist)), r
                },
                toJSON(e) {
                    let r = {};
                    return void 0 !== e.exist && (r.exist = e.exist ? t.CompressedExistenceProof.toJSON(e.exist) : void 0), void 0 !== e.nonexist && (r.nonexist = e.nonexist ? t.CompressedNonExistenceProof.toJSON(e.nonexist) : void 0), r
                },
                fromPartial(e) {
                    let r = _();
                    return void 0 !== e.exist && null !== e.exist && (r.exist = t.CompressedExistenceProof.fromPartial(e.exist)), void 0 !== e.nonexist && null !== e.nonexist && (r.nonexist = t.CompressedNonExistenceProof.fromPartial(e.nonexist)), r
                }
            }, t.CompressedExistenceProof = {
                typeUrl: "/cosmos.ics23.v1.CompressedExistenceProof",
                encode(e, r = s.BinaryWriter.create()) {
                    for (let n of (0 !== e.key.length && r.uint32(10).bytes(e.key), 0 !== e.value.length && r.uint32(18).bytes(e.value), void 0 !== e.leaf && t.LeafOp.encode(e.leaf, r.uint32(26).fork()).ldelim(), r.uint32(34).fork(), e.path)) r.int32(n);
                    return r.ldelim(), r
                },
                decode(e, r) {
                    let n = e instanceof s.BinaryReader ? e : new s.BinaryReader(e),
                        o = void 0 === r ? n.len : n.pos + r,
                        i = B();
                    for (; n.pos < o;) {
                        let e = n.uint32();
                        switch (e >>> 3) {
                            case 1:
                                i.key = n.bytes();
                                break;
                            case 2:
                                i.value = n.bytes();
                                break;
                            case 3:
                                i.leaf = t.LeafOp.decode(n, n.uint32());
                                break;
                            case 4:
                                if ((7 & e) == 2) {
                                    let e = n.uint32() + n.pos;
                                    for (; n.pos < e;) i.path.push(n.int32())
                                } else i.path.push(n.int32());
                                break;
                            default:
                                n.skipType(7 & e)
                        }
                    }
                    return i
                },
                fromJSON(e) {
                    let r = B();
                    return (0, d.isSet)(e.key) && (r.key = (0, d.bytesFromBase64)(e.key)), (0, d.isSet)(e.value) && (r.value = (0, d.bytesFromBase64)(e.value)), (0, d.isSet)(e.leaf) && (r.leaf = t.LeafOp.fromJSON(e.leaf)), Array.isArray(e ? .path) && (r.path = e.path.map(e => Number(e))), r
                },
                toJSON(e) {
                    let r = {};
                    return void 0 !== e.key && (r.key = (0, d.base64FromBytes)(void 0 !== e.key ? e.key : new Uint8Array)), void 0 !== e.value && (r.value = (0, d.base64FromBytes)(void 0 !== e.value ? e.value : new Uint8Array)), void 0 !== e.leaf && (r.leaf = e.leaf ? t.LeafOp.toJSON(e.leaf) : void 0), e.path ? r.path = e.path.map(e => Math.round(e)) : r.path = [], r
                },
                fromPartial(e) {
                    let r = B();
                    return r.key = e.key ? ? new Uint8Array, r.value = e.value ? ? new Uint8Array, void 0 !== e.leaf && null !== e.leaf && (r.leaf = t.LeafOp.fromPartial(e.leaf)), r.path = e.path ? .map(e => e) || [], r
                }
            }, t.CompressedNonExistenceProof = {
                typeUrl: "/cosmos.ics23.v1.CompressedNonExistenceProof",
                encode: (e, r = s.BinaryWriter.create()) => (0 !== e.key.length && r.uint32(10).bytes(e.key), void 0 !== e.left && t.CompressedExistenceProof.encode(e.left, r.uint32(18).fork()).ldelim(), void 0 !== e.right && t.CompressedExistenceProof.encode(e.right, r.uint32(26).fork()).ldelim(), r),
                decode(e, r) {
                    let n = e instanceof s.BinaryReader ? e : new s.BinaryReader(e),
                        o = void 0 === r ? n.len : n.pos + r,
                        i = O();
                    for (; n.pos < o;) {
                        let e = n.uint32();
                        switch (e >>> 3) {
                            case 1:
                                i.key = n.bytes();
                                break;
                            case 2:
                                i.left = t.CompressedExistenceProof.decode(n, n.uint32());
                                break;
                            case 3:
                                i.right = t.CompressedExistenceProof.decode(n, n.uint32());
                                break;
                            default:
                                n.skipType(7 & e)
                        }
                    }
                    return i
                },
                fromJSON(e) {
                    let r = O();
                    return (0, d.isSet)(e.key) && (r.key = (0, d.bytesFromBase64)(e.key)), (0, d.isSet)(e.left) && (r.left = t.CompressedExistenceProof.fromJSON(e.left)), (0, d.isSet)(e.right) && (r.right = t.CompressedExistenceProof.fromJSON(e.right)), r
                },
                toJSON(e) {
                    let r = {};
                    return void 0 !== e.key && (r.key = (0, d.base64FromBytes)(void 0 !== e.key ? e.key : new Uint8Array)), void 0 !== e.left && (r.left = e.left ? t.CompressedExistenceProof.toJSON(e.left) : void 0), void 0 !== e.right && (r.right = e.right ? t.CompressedExistenceProof.toJSON(e.right) : void 0), r
                },
                fromPartial(e) {
                    let r = O();
                    return r.key = e.key ? ? new Uint8Array, void 0 !== e.left && null !== e.left && (r.left = t.CompressedExistenceProof.fromPartial(e.left)), void 0 !== e.right && null !== e.right && (r.right = t.CompressedExistenceProof.fromPartial(e.right)), r
                }
            }
        },
        88714: function(e, t, r) {
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: !0
            }), t.Params = t.Minter = t.protobufPackage = void 0;
            let n = r(28486),
                o = r(6476);

            function i() {
                return {
                    inflation: "",
                    annualProvisions: ""
                }
            }

            function a() {
                return {
                    mintDenom: "",
                    inflationRateChange: "",
                    inflationMax: "",
                    inflationMin: "",
                    goalBonded: "",
                    blocksPerYear: BigInt(0)
                }
            }
            t.protobufPackage = "cosmos.mint.v1beta1", t.Minter = {
                typeUrl: "/cosmos.mint.v1beta1.Minter",
                encode: (e, t = n.BinaryWriter.create()) => ("" !== e.inflation && t.uint32(10).string(e.inflation), "" !== e.annualProvisions && t.uint32(18).string(e.annualProvisions), t),
                decode(e, t) {
                    let r = e instanceof n.BinaryReader ? e : new n.BinaryReader(e),
                        o = void 0 === t ? r.len : r.pos + t,
                        a = i();
                    for (; r.pos < o;) {
                        let e = r.uint32();
                        switch (e >>> 3) {
                            case 1:
                                a.inflation = r.string();
                                break;
                            case 2:
                                a.annualProvisions = r.string();
                                break;
                            default:
                                r.skipType(7 & e)
                        }
                    }
                    return a
                },
                fromJSON(e) {
                    let t = i();
                    return (0, o.isSet)(e.inflation) && (t.inflation = String(e.inflation)), (0, o.isSet)(e.annualProvisions) && (t.annualProvisions = String(e.annualProvisions)), t
                },
                toJSON(e) {
                    let t = {};
                    return void 0 !== e.inflation && (t.inflation = e.inflation), void 0 !== e.annualProvisions && (t.annualProvisions = e.annualProvisions), t
                },
                fromPartial(e) {
                    let t = i();
                    return t.inflation = e.inflation ? ? "", t.annualProvisions = e.annualProvisions ? ? "", t
                }
            }, t.Params = {
                typeUrl: "/cosmos.mint.v1beta1.Params",
                encode: (e, t = n.BinaryWriter.create()) => ("" !== e.mintDenom && t.uint32(10).string(e.mintDenom), "" !== e.inflationRateChange && t.uint32(18).string(e.inflationRateChange), "" !== e.inflationMax && t.uint32(26).string(e.inflationMax), "" !== e.inflationMin && t.uint32(34).string(e.inflationMin), "" !== e.goalBonded && t.uint32(42).string(e.goalBonded), e.blocksPerYear !== BigInt(0) && t.uint32(48).uint64(e.blocksPerYear), t),
                decode(e, t) {
                    let r = e instanceof n.BinaryReader ? e : new n.BinaryReader(e),
                        o = void 0 === t ? r.len : r.pos + t,
                        i = a();
                    for (; r.pos < o;) {
                        let e = r.uint32();
                        switch (e >>> 3) {
                            case 1:
                                i.mintDenom = r.string();
                                break;
                            case 2:
                                i.inflationRateChange = r.string();
                                break;
                            case 3:
                                i.inflationMax = r.string();
                                break;
                            case 4:
                                i.inflationMin = r.string();
                                break;
                            case 5:
                                i.goalBonded = r.string();
                                break;
                            case 6:
                                i.blocksPerYear = r.uint64();
                                break;
                            default:
                                r.skipType(7 & e)
                        }
                    }
                    return i
                },
                fromJSON(e) {
                    let t = a();
                    return (0, o.isSet)(e.mintDenom) && (t.mintDenom = String(e.mintDenom)), (0, o.isSet)(e.inflationRateChange) && (t.inflationRateChange = String(e.inflationRateChange)), (0, o.isSet)(e.inflationMax) && (t.inflationMax = String(e.inflationMax)), (0, o.isSet)(e.inflationMin) && (t.inflationMin = String(e.inflationMin)), (0, o.isSet)(e.goalBonded) && (t.goalBonded = String(e.goalBonded)), (0, o.isSet)(e.blocksPerYear) && (t.blocksPerYear = BigInt(e.blocksPerYear.toString())), t
                },
                toJSON(e) {
                    let t = {};
                    return void 0 !== e.mintDenom && (t.mintDenom = e.mintDenom), void 0 !== e.inflationRateChange && (t.inflationRateChange = e.inflationRateChange), void 0 !== e.inflationMax && (t.inflationMax = e.inflationMax), void 0 !== e.inflationMin && (t.inflationMin = e.inflationMin), void 0 !== e.goalBonded && (t.goalBonded = e.goalBonded), void 0 !== e.blocksPerYear && (t.blocksPerYear = (e.blocksPerYear || BigInt(0)).toString()), t
                },
                fromPartial(e) {
                    let t = a();
                    return t.mintDenom = e.mintDenom ? ? "", t.inflationRateChange = e.inflationRateChange ? ? "", t.inflationMax = e.inflationMax ? ? "", t.inflationMin = e.inflationMin ? ? "", t.goalBonded = e.goalBonded ? ? "", void 0 !== e.blocksPerYear && null !== e.blocksPerYear && (t.blocksPerYear = BigInt(e.blocksPerYear.toString())), t
                }
            }
        },
        79375: function(e, t, r) {
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: !0
            }), t.QueryClientImpl = t.QueryAnnualProvisionsResponse = t.QueryAnnualProvisionsRequest = t.QueryInflationResponse = t.QueryInflationRequest = t.QueryParamsResponse = t.QueryParamsRequest = t.protobufPackage = void 0;
            let n = r(88714),
                o = r(28486),
                i = r(6476);

            function a() {
                return {
                    params: n.Params.fromPartial({})
                }
            }

            function s() {
                return {
                    inflation: new Uint8Array
                }
            }

            function d() {
                return {
                    annualProvisions: new Uint8Array
                }
            }
            t.protobufPackage = "cosmos.mint.v1beta1", t.QueryParamsRequest = {
                typeUrl: "/cosmos.mint.v1beta1.QueryParamsRequest",
                encode: (e, t = o.BinaryWriter.create()) => t,
                decode(e, t) {
                    let r = e instanceof o.BinaryReader ? e : new o.BinaryReader(e),
                        n = void 0 === t ? r.len : r.pos + t;
                    for (; r.pos < n;) {
                        let e = r.uint32();
                        r.skipType(7 & e)
                    }
                    return {}
                },
                fromJSON: e => ({}),
                toJSON: e => ({}),
                fromPartial: e => ({})
            }, t.QueryParamsResponse = {
                typeUrl: "/cosmos.mint.v1beta1.QueryParamsResponse",
                encode: (e, t = o.BinaryWriter.create()) => (void 0 !== e.params && n.Params.encode(e.params, t.uint32(10).fork()).ldelim(), t),
                decode(e, t) {
                    let r = e instanceof o.BinaryReader ? e : new o.BinaryReader(e),
                        i = void 0 === t ? r.len : r.pos + t,
                        s = a();
                    for (; r.pos < i;) {
                        let e = r.uint32();
                        e >>> 3 == 1 ? s.params = n.Params.decode(r, r.uint32()) : r.skipType(7 & e)
                    }
                    return s
                },
                fromJSON(e) {
                    let t = a();
                    return (0, i.isSet)(e.params) && (t.params = n.Params.fromJSON(e.params)), t
                },
                toJSON(e) {
                    let t = {};
                    return void 0 !== e.params && (t.params = e.params ? n.Params.toJSON(e.params) : void 0), t
                },
                fromPartial(e) {
                    let t = a();
                    return void 0 !== e.params && null !== e.params && (t.params = n.Params.fromPartial(e.params)), t
                }
            }, t.QueryInflationRequest = {
                typeUrl: "/cosmos.mint.v1beta1.QueryInflationRequest",
                encode: (e, t = o.BinaryWriter.create()) => t,
                decode(e, t) {
                    let r = e instanceof o.BinaryReader ? e : new o.BinaryReader(e),
                        n = void 0 === t ? r.len : r.pos + t;
                    for (; r.pos < n;) {
                        let e = r.uint32();
                        r.skipType(7 & e)
                    }
                    return {}
                },
                fromJSON: e => ({}),
                toJSON: e => ({}),
                fromPartial: e => ({})
            }, t.QueryInflationResponse = {
                typeUrl: "/cosmos.mint.v1beta1.QueryInflationResponse",
                encode: (e, t = o.BinaryWriter.create()) => (0 !== e.inflation.length && t.uint32(10).bytes(e.inflation), t),
                decode(e, t) {
                    let r = e instanceof o.BinaryReader ? e : new o.BinaryReader(e),
                        n = void 0 === t ? r.len : r.pos + t,
                        i = s();
                    for (; r.pos < n;) {
                        let e = r.uint32();
                        e >>> 3 == 1 ? i.inflation = r.bytes() : r.skipType(7 & e)
                    }
                    return i
                },
                fromJSON(e) {
                    let t = s();
                    return (0, i.isSet)(e.inflation) && (t.inflation = (0, i.bytesFromBase64)(e.inflation)), t
                },
                toJSON(e) {
                    let t = {};
                    return void 0 !== e.inflation && (t.inflation = (0, i.base64FromBytes)(void 0 !== e.inflation ? e.inflation : new Uint8Array)), t
                },
                fromPartial(e) {
                    let t = s();
                    return t.inflation = e.inflation ? ? new Uint8Array, t
                }
            }, t.QueryAnnualProvisionsRequest = {
                typeUrl: "/cosmos.mint.v1beta1.QueryAnnualProvisionsRequest",
                encode: (e, t = o.BinaryWriter.create()) => t,
                decode(e, t) {
                    let r = e instanceof o.BinaryReader ? e : new o.BinaryReader(e),
                        n = void 0 === t ? r.len : r.pos + t;
                    for (; r.pos < n;) {
                        let e = r.uint32();
                        r.skipType(7 & e)
                    }
                    return {}
                },
                fromJSON: e => ({}),
                toJSON: e => ({}),
                fromPartial: e => ({})
            }, t.QueryAnnualProvisionsResponse = {
                typeUrl: "/cosmos.mint.v1beta1.QueryAnnualProvisionsResponse",
                encode: (e, t = o.BinaryWriter.create()) => (0 !== e.annualProvisions.length && t.uint32(10).bytes(e.annualProvisions), t),
                decode(e, t) {
                    let r = e instanceof o.BinaryReader ? e : new o.BinaryReader(e),
                        n = void 0 === t ? r.len : r.pos + t,
                        i = d();
                    for (; r.pos < n;) {
                        let e = r.uint32();
                        e >>> 3 == 1 ? i.annualProvisions = r.bytes() : r.skipType(7 & e)
                    }
                    return i
                },
                fromJSON(e) {
                    let t = d();
                    return (0, i.isSet)(e.annualProvisions) && (t.annualProvisions = (0, i.bytesFromBase64)(e.annualProvisions)), t
                },
                toJSON(e) {
                    let t = {};
                    return void 0 !== e.annualProvisions && (t.annualProvisions = (0, i.base64FromBytes)(void 0 !== e.annualProvisions ? e.annualProvisions : new Uint8Array)), t
                },
                fromPartial(e) {
                    let t = d();
                    return t.annualProvisions = e.annualProvisions ? ? new Uint8Array, t
                }
            };
            class c {
                constructor(e) {
                    this.rpc = e, this.Params = this.Params.bind(this), this.Inflation = this.Inflation.bind(this), this.AnnualProvisions = this.AnnualProvisions.bind(this)
                }
                Params(e = {}) {
                    let r = t.QueryParamsRequest.encode(e).finish();
                    return this.rpc.request("cosmos.mint.v1beta1.Query", "Params", r).then(e => t.QueryParamsResponse.decode(new o.BinaryReader(e)))
                }
                Inflation(e = {}) {
                    let r = t.QueryInflationRequest.encode(e).finish();
                    return this.rpc.request("cosmos.mint.v1beta1.Query", "Inflation", r).then(e => t.QueryInflationResponse.decode(new o.BinaryReader(e)))
                }
                AnnualProvisions(e = {}) {
                    let r = t.QueryAnnualProvisionsRequest.encode(e).finish();
                    return this.rpc.request("cosmos.mint.v1beta1.Query", "AnnualProvisions", r).then(e => t.QueryAnnualProvisionsResponse.decode(new o.BinaryReader(e)))
                }
            }
            t.QueryClientImpl = c
        },
        75591: function(e, t, r) {
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: !0
            }), t.QueryClientImpl = t.QuerySigningInfosResponse = t.QuerySigningInfosRequest = t.QuerySigningInfoResponse = t.QuerySigningInfoRequest = t.QueryParamsResponse = t.QueryParamsRequest = t.protobufPackage = void 0;
            let n = r(38792),
                o = r(28016),
                i = r(28486),
                a = r(6476);

            function s() {
                return {
                    params: o.Params.fromPartial({})
                }
            }

            function d() {
                return {
                    consAddress: ""
                }
            }

            function c() {
                return {
                    valSigningInfo: o.ValidatorSigningInfo.fromPartial({})
                }
            }

            function l() {
                return {
                    pagination: void 0
                }
            }

            function u() {
                return {
                    info: [],
                    pagination: void 0
                }
            }
            t.protobufPackage = "cosmos.slashing.v1beta1", t.QueryParamsRequest = {
                typeUrl: "/cosmos.slashing.v1beta1.QueryParamsRequest",
                encode: (e, t = i.BinaryWriter.create()) => t,
                decode(e, t) {
                    let r = e instanceof i.BinaryReader ? e : new i.BinaryReader(e),
                        n = void 0 === t ? r.len : r.pos + t;
                    for (; r.pos < n;) {
                        let e = r.uint32();
                        r.skipType(7 & e)
                    }
                    return {}
                },
                fromJSON: e => ({}),
                toJSON: e => ({}),
                fromPartial: e => ({})
            }, t.QueryParamsResponse = {
                typeUrl: "/cosmos.slashing.v1beta1.QueryParamsResponse",
                encode: (e, t = i.BinaryWriter.create()) => (void 0 !== e.params && o.Params.encode(e.params, t.uint32(10).fork()).ldelim(), t),
                decode(e, t) {
                    let r = e instanceof i.BinaryReader ? e : new i.BinaryReader(e),
                        n = void 0 === t ? r.len : r.pos + t,
                        a = s();
                    for (; r.pos < n;) {
                        let e = r.uint32();
                        e >>> 3 == 1 ? a.params = o.Params.decode(r, r.uint32()) : r.skipType(7 & e)
                    }
                    return a
                },
                fromJSON(e) {
                    let t = s();
                    return (0, a.isSet)(e.params) && (t.params = o.Params.fromJSON(e.params)), t
                },
                toJSON(e) {
                    let t = {};
                    return void 0 !== e.params && (t.params = e.params ? o.Params.toJSON(e.params) : void 0), t
                },
                fromPartial(e) {
                    let t = s();
                    return void 0 !== e.params && null !== e.params && (t.params = o.Params.fromPartial(e.params)), t
                }
            }, t.QuerySigningInfoRequest = {
                typeUrl: "/cosmos.slashing.v1beta1.QuerySigningInfoRequest",
                encode: (e, t = i.BinaryWriter.create()) => ("" !== e.consAddress && t.uint32(10).string(e.consAddress), t),
                decode(e, t) {
                    let r = e instanceof i.BinaryReader ? e : new i.BinaryReader(e),
                        n = void 0 === t ? r.len : r.pos + t,
                        o = d();
                    for (; r.pos < n;) {
                        let e = r.uint32();
                        e >>> 3 == 1 ? o.consAddress = r.string() : r.skipType(7 & e)
                    }
                    return o
                },
                fromJSON(e) {
                    let t = d();
                    return (0, a.isSet)(e.consAddress) && (t.consAddress = String(e.consAddress)), t
                },
                toJSON(e) {
                    let t = {};
                    return void 0 !== e.consAddress && (t.consAddress = e.consAddress), t
                },
                fromPartial(e) {
                    let t = d();
                    return t.consAddress = e.consAddress ? ? "", t
                }
            }, t.QuerySigningInfoResponse = {
                typeUrl: "/cosmos.slashing.v1beta1.QuerySigningInfoResponse",
                encode: (e, t = i.BinaryWriter.create()) => (void 0 !== e.valSigningInfo && o.ValidatorSigningInfo.encode(e.valSigningInfo, t.uint32(10).fork()).ldelim(), t),
                decode(e, t) {
                    let r = e instanceof i.BinaryReader ? e : new i.BinaryReader(e),
                        n = void 0 === t ? r.len : r.pos + t,
                        a = c();
                    for (; r.pos < n;) {
                        let e = r.uint32();
                        e >>> 3 == 1 ? a.valSigningInfo = o.ValidatorSigningInfo.decode(r, r.uint32()) : r.skipType(7 & e)
                    }
                    return a
                },
                fromJSON(e) {
                    let t = c();
                    return (0, a.isSet)(e.valSigningInfo) && (t.valSigningInfo = o.ValidatorSigningInfo.fromJSON(e.valSigningInfo)), t
                },
                toJSON(e) {
                    let t = {};
                    return void 0 !== e.valSigningInfo && (t.valSigningInfo = e.valSigningInfo ? o.ValidatorSigningInfo.toJSON(e.valSigningInfo) : void 0), t
                },
                fromPartial(e) {
                    let t = c();
                    return void 0 !== e.valSigningInfo && null !== e.valSigningInfo && (t.valSigningInfo = o.ValidatorSigningInfo.fromPartial(e.valSigningInfo)), t
                }
            }, t.QuerySigningInfosRequest = {
                typeUrl: "/cosmos.slashing.v1beta1.QuerySigningInfosRequest",
                encode: (e, t = i.BinaryWriter.create()) => (void 0 !== e.pagination && n.PageRequest.encode(e.pagination, t.uint32(10).fork()).ldelim(), t),
                decode(e, t) {
                    let r = e instanceof i.BinaryReader ? e : new i.BinaryReader(e),
                        o = void 0 === t ? r.len : r.pos + t,
                        a = l();
                    for (; r.pos < o;) {
                        let e = r.uint32();
                        e >>> 3 == 1 ? a.pagination = n.PageRequest.decode(r, r.uint32()) : r.skipType(7 & e)
                    }
                    return a
                },
                fromJSON(e) {
                    let t = l();
                    return (0, a.isSet)(e.pagination) && (t.pagination = n.PageRequest.fromJSON(e.pagination)), t
                },
                toJSON(e) {
                    let t = {};
                    return void 0 !== e.pagination && (t.pagination = e.pagination ? n.PageRequest.toJSON(e.pagination) : void 0), t
                },
                fromPartial(e) {
                    let t = l();
                    return void 0 !== e.pagination && null !== e.pagination && (t.pagination = n.PageRequest.fromPartial(e.pagination)), t
                }
            }, t.QuerySigningInfosResponse = {
                typeUrl: "/cosmos.slashing.v1beta1.QuerySigningInfosResponse",
                encode(e, t = i.BinaryWriter.create()) {
                    for (let r of e.info) o.ValidatorSigningInfo.encode(r, t.uint32(10).fork()).ldelim();
                    return void 0 !== e.pagination && n.PageResponse.encode(e.pagination, t.uint32(18).fork()).ldelim(), t
                },
                decode(e, t) {
                    let r = e instanceof i.BinaryReader ? e : new i.BinaryReader(e),
                        a = void 0 === t ? r.len : r.pos + t,
                        s = u();
                    for (; r.pos < a;) {
                        let e = r.uint32();
                        switch (e >>> 3) {
                            case 1:
                                s.info.push(o.ValidatorSigningInfo.decode(r, r.uint32()));
                                break;
                            case 2:
                                s.pagination = n.PageResponse.decode(r, r.uint32());
                                break;
                            default:
                                r.skipType(7 & e)
                        }
                    }
                    return s
                },
                fromJSON(e) {
                    let t = u();
                    return Array.isArray(e ? .info) && (t.info = e.info.map(e => o.ValidatorSigningInfo.fromJSON(e))), (0, a.isSet)(e.pagination) && (t.pagination = n.PageResponse.fromJSON(e.pagination)), t
                },
                toJSON(e) {
                    let t = {};
                    return e.info ? t.info = e.info.map(e => e ? o.ValidatorSigningInfo.toJSON(e) : void 0) : t.info = [], void 0 !== e.pagination && (t.pagination = e.pagination ? n.PageResponse.toJSON(e.pagination) : void 0), t
                },
                fromPartial(e) {
                    let t = u();
                    return t.info = e.info ? .map(e => o.ValidatorSigningInfo.fromPartial(e)) || [], void 0 !== e.pagination && null !== e.pagination && (t.pagination = n.PageResponse.fromPartial(e.pagination)), t
                }
            };
            class p {
                constructor(e) {
                    this.rpc = e, this.Params = this.Params.bind(this), this.SigningInfo = this.SigningInfo.bind(this), this.SigningInfos = this.SigningInfos.bind(this)
                }
                Params(e = {}) {
                    let r = t.QueryParamsRequest.encode(e).finish();
                    return this.rpc.request("cosmos.slashing.v1beta1.Query", "Params", r).then(e => t.QueryParamsResponse.decode(new i.BinaryReader(e)))
                }
                SigningInfo(e) {
                    let r = t.QuerySigningInfoRequest.encode(e).finish();
                    return this.rpc.request("cosmos.slashing.v1beta1.Query", "SigningInfo", r).then(e => t.QuerySigningInfoResponse.decode(new i.BinaryReader(e)))
                }
                SigningInfos(e = {
                    pagination: n.PageRequest.fromPartial({})
                }) {
                    let r = t.QuerySigningInfosRequest.encode(e).finish();
                    return this.rpc.request("cosmos.slashing.v1beta1.Query", "SigningInfos", r).then(e => t.QuerySigningInfosResponse.decode(new i.BinaryReader(e)))
                }
            }
            t.QueryClientImpl = p
        },
        28016: function(e, t, r) {
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: !0
            }), t.Params = t.ValidatorSigningInfo = t.protobufPackage = void 0;
            let n = r(90614),
                o = r(69441),
                i = r(28486),
                a = r(6476);

            function s() {
                return {
                    address: "",
                    startHeight: BigInt(0),
                    indexOffset: BigInt(0),
                    jailedUntil: n.Timestamp.fromPartial({}),
                    tombstoned: !1,
                    missedBlocksCounter: BigInt(0)
                }
            }

            function d() {
                return {
                    signedBlocksWindow: BigInt(0),
                    minSignedPerWindow: new Uint8Array,
                    downtimeJailDuration: o.Duration.fromPartial({}),
                    slashFractionDoubleSign: new Uint8Array,
                    slashFractionDowntime: new Uint8Array
                }
            }
            t.protobufPackage = "cosmos.slashing.v1beta1", t.ValidatorSigningInfo = {
                typeUrl: "/cosmos.slashing.v1beta1.ValidatorSigningInfo",
                encode: (e, t = i.BinaryWriter.create()) => ("" !== e.address && t.uint32(10).string(e.address), e.startHeight !== BigInt(0) && t.uint32(16).int64(e.startHeight), e.indexOffset !== BigInt(0) && t.uint32(24).int64(e.indexOffset), void 0 !== e.jailedUntil && n.Timestamp.encode(e.jailedUntil, t.uint32(34).fork()).ldelim(), !0 === e.tombstoned && t.uint32(40).bool(e.tombstoned), e.missedBlocksCounter !== BigInt(0) && t.uint32(48).int64(e.missedBlocksCounter), t),
                decode(e, t) {
                    let r = e instanceof i.BinaryReader ? e : new i.BinaryReader(e),
                        o = void 0 === t ? r.len : r.pos + t,
                        a = s();
                    for (; r.pos < o;) {
                        let e = r.uint32();
                        switch (e >>> 3) {
                            case 1:
                                a.address = r.string();
                                break;
                            case 2:
                                a.startHeight = r.int64();
                                break;
                            case 3:
                                a.indexOffset = r.int64();
                                break;
                            case 4:
                                a.jailedUntil = n.Timestamp.decode(r, r.uint32());
                                break;
                            case 5:
                                a.tombstoned = r.bool();
                                break;
                            case 6:
                                a.missedBlocksCounter = r.int64();
                                break;
                            default:
                                r.skipType(7 & e)
                        }
                    }
                    return a
                },
                fromJSON(e) {
                    let t = s();
                    return (0, a.isSet)(e.address) && (t.address = String(e.address)), (0, a.isSet)(e.startHeight) && (t.startHeight = BigInt(e.startHeight.toString())), (0, a.isSet)(e.indexOffset) && (t.indexOffset = BigInt(e.indexOffset.toString())), (0, a.isSet)(e.jailedUntil) && (t.jailedUntil = (0, a.fromJsonTimestamp)(e.jailedUntil)), (0, a.isSet)(e.tombstoned) && (t.tombstoned = !!e.tombstoned), (0, a.isSet)(e.missedBlocksCounter) && (t.missedBlocksCounter = BigInt(e.missedBlocksCounter.toString())), t
                },
                toJSON(e) {
                    let t = {};
                    return void 0 !== e.address && (t.address = e.address), void 0 !== e.startHeight && (t.startHeight = (e.startHeight || BigInt(0)).toString()), void 0 !== e.indexOffset && (t.indexOffset = (e.indexOffset || BigInt(0)).toString()), void 0 !== e.jailedUntil && (t.jailedUntil = (0, a.fromTimestamp)(e.jailedUntil).toISOString()), void 0 !== e.tombstoned && (t.tombstoned = e.tombstoned), void 0 !== e.missedBlocksCounter && (t.missedBlocksCounter = (e.missedBlocksCounter || BigInt(0)).toString()), t
                },
                fromPartial(e) {
                    let t = s();
                    return t.address = e.address ? ? "", void 0 !== e.startHeight && null !== e.startHeight && (t.startHeight = BigInt(e.startHeight.toString())), void 0 !== e.indexOffset && null !== e.indexOffset && (t.indexOffset = BigInt(e.indexOffset.toString())), void 0 !== e.jailedUntil && null !== e.jailedUntil && (t.jailedUntil = n.Timestamp.fromPartial(e.jailedUntil)), t.tombstoned = e.tombstoned ? ? !1, void 0 !== e.missedBlocksCounter && null !== e.missedBlocksCounter && (t.missedBlocksCounter = BigInt(e.missedBlocksCounter.toString())), t
                }
            }, t.Params = {
                typeUrl: "/cosmos.slashing.v1beta1.Params",
                encode: (e, t = i.BinaryWriter.create()) => (e.signedBlocksWindow !== BigInt(0) && t.uint32(8).int64(e.signedBlocksWindow), 0 !== e.minSignedPerWindow.length && t.uint32(18).bytes(e.minSignedPerWindow), void 0 !== e.downtimeJailDuration && o.Duration.encode(e.downtimeJailDuration, t.uint32(26).fork()).ldelim(), 0 !== e.slashFractionDoubleSign.length && t.uint32(34).bytes(e.slashFractionDoubleSign), 0 !== e.slashFractionDowntime.length && t.uint32(42).bytes(e.slashFractionDowntime), t),
                decode(e, t) {
                    let r = e instanceof i.BinaryReader ? e : new i.BinaryReader(e),
                        n = void 0 === t ? r.len : r.pos + t,
                        a = d();
                    for (; r.pos < n;) {
                        let e = r.uint32();
                        switch (e >>> 3) {
                            case 1:
                                a.signedBlocksWindow = r.int64();
                                break;
                            case 2:
                                a.minSignedPerWindow = r.bytes();
                                break;
                            case 3:
                                a.downtimeJailDuration = o.Duration.decode(r, r.uint32());
                                break;
                            case 4:
                                a.slashFractionDoubleSign = r.bytes();
                                break;
                            case 5:
                                a.slashFractionDowntime = r.bytes();
                                break;
                            default:
                                r.skipType(7 & e)
                        }
                    }
                    return a
                },
                fromJSON(e) {
                    let t = d();
                    return (0, a.isSet)(e.signedBlocksWindow) && (t.signedBlocksWindow = BigInt(e.signedBlocksWindow.toString())), (0, a.isSet)(e.minSignedPerWindow) && (t.minSignedPerWindow = (0, a.bytesFromBase64)(e.minSignedPerWindow)), (0, a.isSet)(e.downtimeJailDuration) && (t.downtimeJailDuration = o.Duration.fromJSON(e.downtimeJailDuration)), (0, a.isSet)(e.slashFractionDoubleSign) && (t.slashFractionDoubleSign = (0, a.bytesFromBase64)(e.slashFractionDoubleSign)), (0, a.isSet)(e.slashFractionDowntime) && (t.slashFractionDowntime = (0, a.bytesFromBase64)(e.slashFractionDowntime)), t
                },
                toJSON(e) {
                    let t = {};
                    return void 0 !== e.signedBlocksWindow && (t.signedBlocksWindow = (e.signedBlocksWindow || BigInt(0)).toString()), void 0 !== e.minSignedPerWindow && (t.minSignedPerWindow = (0, a.base64FromBytes)(void 0 !== e.minSignedPerWindow ? e.minSignedPerWindow : new Uint8Array)), void 0 !== e.downtimeJailDuration && (t.downtimeJailDuration = e.downtimeJailDuration ? o.Duration.toJSON(e.downtimeJailDuration) : void 0), void 0 !== e.slashFractionDoubleSign && (t.slashFractionDoubleSign = (0, a.base64FromBytes)(void 0 !== e.slashFractionDoubleSign ? e.slashFractionDoubleSign : new Uint8Array)), void 0 !== e.slashFractionDowntime && (t.slashFractionDowntime = (0, a.base64FromBytes)(void 0 !== e.slashFractionDowntime ? e.slashFractionDowntime : new Uint8Array)), t
                },
                fromPartial(e) {
                    let t = d();
                    return void 0 !== e.signedBlocksWindow && null !== e.signedBlocksWindow && (t.signedBlocksWindow = BigInt(e.signedBlocksWindow.toString())), t.minSignedPerWindow = e.minSignedPerWindow ? ? new Uint8Array, void 0 !== e.downtimeJailDuration && null !== e.downtimeJailDuration && (t.downtimeJailDuration = o.Duration.fromPartial(e.downtimeJailDuration)), t.slashFractionDoubleSign = e.slashFractionDoubleSign ? ? new Uint8Array, t.slashFractionDowntime = e.slashFractionDowntime ? ? new Uint8Array, t
                }
            }
        },
        4642: function(e, t, r) {
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: !0
            }), t.QueryClientImpl = t.QueryParamsResponse = t.QueryParamsRequest = t.QueryPoolResponse = t.QueryPoolRequest = t.QueryHistoricalInfoResponse = t.QueryHistoricalInfoRequest = t.QueryDelegatorValidatorResponse = t.QueryDelegatorValidatorRequest = t.QueryDelegatorValidatorsResponse = t.QueryDelegatorValidatorsRequest = t.QueryRedelegationsResponse = t.QueryRedelegationsRequest = t.QueryDelegatorUnbondingDelegationsResponse = t.QueryDelegatorUnbondingDelegationsRequest = t.QueryDelegatorDelegationsResponse = t.QueryDelegatorDelegationsRequest = t.QueryUnbondingDelegationResponse = t.QueryUnbondingDelegationRequest = t.QueryDelegationResponse = t.QueryDelegationRequest = t.QueryValidatorUnbondingDelegationsResponse = t.QueryValidatorUnbondingDelegationsRequest = t.QueryValidatorDelegationsResponse = t.QueryValidatorDelegationsRequest = t.QueryValidatorResponse = t.QueryValidatorRequest = t.QueryValidatorsResponse = t.QueryValidatorsRequest = t.protobufPackage = void 0;
            let n = r(38792),
                o = r(93508),
                i = r(28486),
                a = r(6476);

            function s() {
                return {
                    status: "",
                    pagination: void 0
                }
            }

            function d() {
                return {
                    validators: [],
                    pagination: void 0
                }
            }

            function c() {
                return {
                    validatorAddr: ""
                }
            }

            function l() {
                return {
                    validator: o.Validator.fromPartial({})
                }
            }

            function u() {
                return {
                    validatorAddr: "",
                    pagination: void 0
                }
            }

            function p() {
                return {
                    delegationResponses: [],
                    pagination: void 0
                }
            }

            function m() {
                return {
                    validatorAddr: "",
                    pagination: void 0
                }
            }

            function g() {
                return {
                    unbondingResponses: [],
                    pagination: void 0
                }
            }

            function f() {
                return {
                    delegatorAddr: "",
                    validatorAddr: ""
                }
            }

            function y() {
                return {
                    delegationResponse: void 0
                }
            }

            function h() {
                return {
                    delegatorAddr: "",
                    validatorAddr: ""
                }
            }

            function v() {
                return {
                    unbond: o.UnbondingDelegation.fromPartial({})
                }
            }

            function b() {
                return {
                    delegatorAddr: "",
                    pagination: void 0
                }
            }

            function S() {
                return {
                    delegationResponses: [],
                    pagination: void 0
                }
            }

            function k() {
                return {
                    delegatorAddr: "",
                    pagination: void 0
                }
            }

            function P() {
                return {
                    unbondingResponses: [],
                    pagination: void 0
                }
            }

            function _() {
                return {
                    delegatorAddr: "",
                    srcValidatorAddr: "",
                    dstValidatorAddr: "",
                    pagination: void 0
                }
            }

            function B() {
                return {
                    redelegationResponses: [],
                    pagination: void 0
                }
            }

            function O() {
                return {
                    delegatorAddr: "",
                    pagination: void 0
                }
            }

            function R() {
                return {
                    validators: [],
                    pagination: void 0
                }
            }

            function A() {
                return {
                    delegatorAddr: "",
                    validatorAddr: ""
                }
            }

            function I() {
                return {
                    validator: o.Validator.fromPartial({})
                }
            }

            function w() {
                return {
                    height: BigInt(0)
                }
            }

            function T() {
                return {
                    hist: void 0
                }
            }

            function N() {
                return {
                    pool: o.Pool.fromPartial({})
                }
            }

            function C() {
                return {
                    params: o.Params.fromPartial({})
                }
            }
            t.protobufPackage = "cosmos.staking.v1beta1", t.QueryValidatorsRequest = {
                typeUrl: "/cosmos.staking.v1beta1.QueryValidatorsRequest",
                encode: (e, t = i.BinaryWriter.create()) => ("" !== e.status && t.uint32(10).string(e.status), void 0 !== e.pagination && n.PageRequest.encode(e.pagination, t.uint32(18).fork()).ldelim(), t),
                decode(e, t) {
                    let r = e instanceof i.BinaryReader ? e : new i.BinaryReader(e),
                        o = void 0 === t ? r.len : r.pos + t,
                        a = s();
                    for (; r.pos < o;) {
                        let e = r.uint32();
                        switch (e >>> 3) {
                            case 1:
                                a.status = r.string();
                                break;
                            case 2:
                                a.pagination = n.PageRequest.decode(r, r.uint32());
                                break;
                            default:
                                r.skipType(7 & e)
                        }
                    }
                    return a
                },
                fromJSON(e) {
                    let t = s();
                    return (0, a.isSet)(e.status) && (t.status = String(e.status)), (0, a.isSet)(e.pagination) && (t.pagination = n.PageRequest.fromJSON(e.pagination)), t
                },
                toJSON(e) {
                    let t = {};
                    return void 0 !== e.status && (t.status = e.status), void 0 !== e.pagination && (t.pagination = e.pagination ? n.PageRequest.toJSON(e.pagination) : void 0), t
                },
                fromPartial(e) {
                    let t = s();
                    return t.status = e.status ? ? "", void 0 !== e.pagination && null !== e.pagination && (t.pagination = n.PageRequest.fromPartial(e.pagination)), t
                }
            }, t.QueryValidatorsResponse = {
                typeUrl: "/cosmos.staking.v1beta1.QueryValidatorsResponse",
                encode(e, t = i.BinaryWriter.create()) {
                    for (let r of e.validators) o.Validator.encode(r, t.uint32(10).fork()).ldelim();
                    return void 0 !== e.pagination && n.PageResponse.encode(e.pagination, t.uint32(18).fork()).ldelim(), t
                },
                decode(e, t) {
                    let r = e instanceof i.BinaryReader ? e : new i.BinaryReader(e),
                        a = void 0 === t ? r.len : r.pos + t,
                        s = d();
                    for (; r.pos < a;) {
                        let e = r.uint32();
                        switch (e >>> 3) {
                            case 1:
                                s.validators.push(o.Validator.decode(r, r.uint32()));
                                break;
                            case 2:
                                s.pagination = n.PageResponse.decode(r, r.uint32());
                                break;
                            default:
                                r.skipType(7 & e)
                        }
                    }
                    return s
                },
                fromJSON(e) {
                    let t = d();
                    return Array.isArray(e ? .validators) && (t.validators = e.validators.map(e => o.Validator.fromJSON(e))), (0, a.isSet)(e.pagination) && (t.pagination = n.PageResponse.fromJSON(e.pagination)), t
                },
                toJSON(e) {
                    let t = {};
                    return e.validators ? t.validators = e.validators.map(e => e ? o.Validator.toJSON(e) : void 0) : t.validators = [], void 0 !== e.pagination && (t.pagination = e.pagination ? n.PageResponse.toJSON(e.pagination) : void 0), t
                },
                fromPartial(e) {
                    let t = d();
                    return t.validators = e.validators ? .map(e => o.Validator.fromPartial(e)) || [], void 0 !== e.pagination && null !== e.pagination && (t.pagination = n.PageResponse.fromPartial(e.pagination)), t
                }
            }, t.QueryValidatorRequest = {
                typeUrl: "/cosmos.staking.v1beta1.QueryValidatorRequest",
                encode: (e, t = i.BinaryWriter.create()) => ("" !== e.validatorAddr && t.uint32(10).string(e.validatorAddr), t),
                decode(e, t) {
                    let r = e instanceof i.BinaryReader ? e : new i.BinaryReader(e),
                        n = void 0 === t ? r.len : r.pos + t,
                        o = c();
                    for (; r.pos < n;) {
                        let e = r.uint32();
                        e >>> 3 == 1 ? o.validatorAddr = r.string() : r.skipType(7 & e)
                    }
                    return o
                },
                fromJSON(e) {
                    let t = c();
                    return (0, a.isSet)(e.validatorAddr) && (t.validatorAddr = String(e.validatorAddr)), t
                },
                toJSON(e) {
                    let t = {};
                    return void 0 !== e.validatorAddr && (t.validatorAddr = e.validatorAddr), t
                },
                fromPartial(e) {
                    let t = c();
                    return t.validatorAddr = e.validatorAddr ? ? "", t
                }
            }, t.QueryValidatorResponse = {
                typeUrl: "/cosmos.staking.v1beta1.QueryValidatorResponse",
                encode: (e, t = i.BinaryWriter.create()) => (void 0 !== e.validator && o.Validator.encode(e.validator, t.uint32(10).fork()).ldelim(), t),
                decode(e, t) {
                    let r = e instanceof i.BinaryReader ? e : new i.BinaryReader(e),
                        n = void 0 === t ? r.len : r.pos + t,
                        a = l();
                    for (; r.pos < n;) {
                        let e = r.uint32();
                        e >>> 3 == 1 ? a.validator = o.Validator.decode(r, r.uint32()) : r.skipType(7 & e)
                    }
                    return a
                },
                fromJSON(e) {
                    let t = l();
                    return (0, a.isSet)(e.validator) && (t.validator = o.Validator.fromJSON(e.validator)), t
                },
                toJSON(e) {
                    let t = {};
                    return void 0 !== e.validator && (t.validator = e.validator ? o.Validator.toJSON(e.validator) : void 0), t
                },
                fromPartial(e) {
                    let t = l();
                    return void 0 !== e.validator && null !== e.validator && (t.validator = o.Validator.fromPartial(e.validator)), t
                }
            }, t.QueryValidatorDelegationsRequest = {
                typeUrl: "/cosmos.staking.v1beta1.QueryValidatorDelegationsRequest",
                encode: (e, t = i.BinaryWriter.create()) => ("" !== e.validatorAddr && t.uint32(10).string(e.validatorAddr), void 0 !== e.pagination && n.PageRequest.encode(e.pagination, t.uint32(18).fork()).ldelim(), t),
                decode(e, t) {
                    let r = e instanceof i.BinaryReader ? e : new i.BinaryReader(e),
                        o = void 0 === t ? r.len : r.pos + t,
                        a = u();
                    for (; r.pos < o;) {
                        let e = r.uint32();
                        switch (e >>> 3) {
                            case 1:
                                a.validatorAddr = r.string();
                                break;
                            case 2:
                                a.pagination = n.PageRequest.decode(r, r.uint32());
                                break;
                            default:
                                r.skipType(7 & e)
                        }
                    }
                    return a
                },
                fromJSON(e) {
                    let t = u();
                    return (0, a.isSet)(e.validatorAddr) && (t.validatorAddr = String(e.validatorAddr)), (0, a.isSet)(e.pagination) && (t.pagination = n.PageRequest.fromJSON(e.pagination)), t
                },
                toJSON(e) {
                    let t = {};
                    return void 0 !== e.validatorAddr && (t.validatorAddr = e.validatorAddr), void 0 !== e.pagination && (t.pagination = e.pagination ? n.PageRequest.toJSON(e.pagination) : void 0), t
                },
                fromPartial(e) {
                    let t = u();
                    return t.validatorAddr = e.validatorAddr ? ? "", void 0 !== e.pagination && null !== e.pagination && (t.pagination = n.PageRequest.fromPartial(e.pagination)), t
                }
            }, t.QueryValidatorDelegationsResponse = {
                typeUrl: "/cosmos.staking.v1beta1.QueryValidatorDelegationsResponse",
                encode(e, t = i.BinaryWriter.create()) {
                    for (let r of e.delegationResponses) o.DelegationResponse.encode(r, t.uint32(10).fork()).ldelim();
                    return void 0 !== e.pagination && n.PageResponse.encode(e.pagination, t.uint32(18).fork()).ldelim(), t
                },
                decode(e, t) {
                    let r = e instanceof i.BinaryReader ? e : new i.BinaryReader(e),
                        a = void 0 === t ? r.len : r.pos + t,
                        s = p();
                    for (; r.pos < a;) {
                        let e = r.uint32();
                        switch (e >>> 3) {
                            case 1:
                                s.delegationResponses.push(o.DelegationResponse.decode(r, r.uint32()));
                                break;
                            case 2:
                                s.pagination = n.PageResponse.decode(r, r.uint32());
                                break;
                            default:
                                r.skipType(7 & e)
                        }
                    }
                    return s
                },
                fromJSON(e) {
                    let t = p();
                    return Array.isArray(e ? .delegationResponses) && (t.delegationResponses = e.delegationResponses.map(e => o.DelegationResponse.fromJSON(e))), (0, a.isSet)(e.pagination) && (t.pagination = n.PageResponse.fromJSON(e.pagination)), t
                },
                toJSON(e) {
                    let t = {};
                    return e.delegationResponses ? t.delegationResponses = e.delegationResponses.map(e => e ? o.DelegationResponse.toJSON(e) : void 0) : t.delegationResponses = [], void 0 !== e.pagination && (t.pagination = e.pagination ? n.PageResponse.toJSON(e.pagination) : void 0), t
                },
                fromPartial(e) {
                    let t = p();
                    return t.delegationResponses = e.delegationResponses ? .map(e => o.DelegationResponse.fromPartial(e)) || [], void 0 !== e.pagination && null !== e.pagination && (t.pagination = n.PageResponse.fromPartial(e.pagination)), t
                }
            }, t.QueryValidatorUnbondingDelegationsRequest = {
                typeUrl: "/cosmos.staking.v1beta1.QueryValidatorUnbondingDelegationsRequest",
                encode: (e, t = i.BinaryWriter.create()) => ("" !== e.validatorAddr && t.uint32(10).string(e.validatorAddr), void 0 !== e.pagination && n.PageRequest.encode(e.pagination, t.uint32(18).fork()).ldelim(), t),
                decode(e, t) {
                    let r = e instanceof i.BinaryReader ? e : new i.BinaryReader(e),
                        o = void 0 === t ? r.len : r.pos + t,
                        a = m();
                    for (; r.pos < o;) {
                        let e = r.uint32();
                        switch (e >>> 3) {
                            case 1:
                                a.validatorAddr = r.string();
                                break;
                            case 2:
                                a.pagination = n.PageRequest.decode(r, r.uint32());
                                break;
                            default:
                                r.skipType(7 & e)
                        }
                    }
                    return a
                },
                fromJSON(e) {
                    let t = m();
                    return (0, a.isSet)(e.validatorAddr) && (t.validatorAddr = String(e.validatorAddr)), (0, a.isSet)(e.pagination) && (t.pagination = n.PageRequest.fromJSON(e.pagination)), t
                },
                toJSON(e) {
                    let t = {};
                    return void 0 !== e.validatorAddr && (t.validatorAddr = e.validatorAddr), void 0 !== e.pagination && (t.pagination = e.pagination ? n.PageRequest.toJSON(e.pagination) : void 0), t
                },
                fromPartial(e) {
                    let t = m();
                    return t.validatorAddr = e.validatorAddr ? ? "", void 0 !== e.pagination && null !== e.pagination && (t.pagination = n.PageRequest.fromPartial(e.pagination)), t
                }
            }, t.QueryValidatorUnbondingDelegationsResponse = {
                typeUrl: "/cosmos.staking.v1beta1.QueryValidatorUnbondingDelegationsResponse",
                encode(e, t = i.BinaryWriter.create()) {
                    for (let r of e.unbondingResponses) o.UnbondingDelegation.encode(r, t.uint32(10).fork()).ldelim();
                    return void 0 !== e.pagination && n.PageResponse.encode(e.pagination, t.uint32(18).fork()).ldelim(), t
                },
                decode(e, t) {
                    let r = e instanceof i.BinaryReader ? e : new i.BinaryReader(e),
                        a = void 0 === t ? r.len : r.pos + t,
                        s = g();
                    for (; r.pos < a;) {
                        let e = r.uint32();
                        switch (e >>> 3) {
                            case 1:
                                s.unbondingResponses.push(o.UnbondingDelegation.decode(r, r.uint32()));
                                break;
                            case 2:
                                s.pagination = n.PageResponse.decode(r, r.uint32());
                                break;
                            default:
                                r.skipType(7 & e)
                        }
                    }
                    return s
                },
                fromJSON(e) {
                    let t = g();
                    return Array.isArray(e ? .unbondingResponses) && (t.unbondingResponses = e.unbondingResponses.map(e => o.UnbondingDelegation.fromJSON(e))), (0, a.isSet)(e.pagination) && (t.pagination = n.PageResponse.fromJSON(e.pagination)), t
                },
                toJSON(e) {
                    let t = {};
                    return e.unbondingResponses ? t.unbondingResponses = e.unbondingResponses.map(e => e ? o.UnbondingDelegation.toJSON(e) : void 0) : t.unbondingResponses = [], void 0 !== e.pagination && (t.pagination = e.pagination ? n.PageResponse.toJSON(e.pagination) : void 0), t
                },
                fromPartial(e) {
                    let t = g();
                    return t.unbondingResponses = e.unbondingResponses ? .map(e => o.UnbondingDelegation.fromPartial(e)) || [], void 0 !== e.pagination && null !== e.pagination && (t.pagination = n.PageResponse.fromPartial(e.pagination)), t
                }
            }, t.QueryDelegationRequest = {
                typeUrl: "/cosmos.staking.v1beta1.QueryDelegationRequest",
                encode: (e, t = i.BinaryWriter.create()) => ("" !== e.delegatorAddr && t.uint32(10).string(e.delegatorAddr), "" !== e.validatorAddr && t.uint32(18).string(e.validatorAddr), t),
                decode(e, t) {
                    let r = e instanceof i.BinaryReader ? e : new i.BinaryReader(e),
                        n = void 0 === t ? r.len : r.pos + t,
                        o = f();
                    for (; r.pos < n;) {
                        let e = r.uint32();
                        switch (e >>> 3) {
                            case 1:
                                o.delegatorAddr = r.string();
                                break;
                            case 2:
                                o.validatorAddr = r.string();
                                break;
                            default:
                                r.skipType(7 & e)
                        }
                    }
                    return o
                },
                fromJSON(e) {
                    let t = f();
                    return (0, a.isSet)(e.delegatorAddr) && (t.delegatorAddr = String(e.delegatorAddr)), (0, a.isSet)(e.validatorAddr) && (t.validatorAddr = String(e.validatorAddr)), t
                },
                toJSON(e) {
                    let t = {};
                    return void 0 !== e.delegatorAddr && (t.delegatorAddr = e.delegatorAddr), void 0 !== e.validatorAddr && (t.validatorAddr = e.validatorAddr), t
                },
                fromPartial(e) {
                    let t = f();
                    return t.delegatorAddr = e.delegatorAddr ? ? "", t.validatorAddr = e.validatorAddr ? ? "", t
                }
            }, t.QueryDelegationResponse = {
                typeUrl: "/cosmos.staking.v1beta1.QueryDelegationResponse",
                encode: (e, t = i.BinaryWriter.create()) => (void 0 !== e.delegationResponse && o.DelegationResponse.encode(e.delegationResponse, t.uint32(10).fork()).ldelim(), t),
                decode(e, t) {
                    let r = e instanceof i.BinaryReader ? e : new i.BinaryReader(e),
                        n = void 0 === t ? r.len : r.pos + t,
                        a = y();
                    for (; r.pos < n;) {
                        let e = r.uint32();
                        e >>> 3 == 1 ? a.delegationResponse = o.DelegationResponse.decode(r, r.uint32()) : r.skipType(7 & e)
                    }
                    return a
                },
                fromJSON(e) {
                    let t = y();
                    return (0, a.isSet)(e.delegationResponse) && (t.delegationResponse = o.DelegationResponse.fromJSON(e.delegationResponse)), t
                },
                toJSON(e) {
                    let t = {};
                    return void 0 !== e.delegationResponse && (t.delegationResponse = e.delegationResponse ? o.DelegationResponse.toJSON(e.delegationResponse) : void 0), t
                },
                fromPartial(e) {
                    let t = y();
                    return void 0 !== e.delegationResponse && null !== e.delegationResponse && (t.delegationResponse = o.DelegationResponse.fromPartial(e.delegationResponse)), t
                }
            }, t.QueryUnbondingDelegationRequest = {
                typeUrl: "/cosmos.staking.v1beta1.QueryUnbondingDelegationRequest",
                encode: (e, t = i.BinaryWriter.create()) => ("" !== e.delegatorAddr && t.uint32(10).string(e.delegatorAddr), "" !== e.validatorAddr && t.uint32(18).string(e.validatorAddr), t),
                decode(e, t) {
                    let r = e instanceof i.BinaryReader ? e : new i.BinaryReader(e),
                        n = void 0 === t ? r.len : r.pos + t,
                        o = h();
                    for (; r.pos < n;) {
                        let e = r.uint32();
                        switch (e >>> 3) {
                            case 1:
                                o.delegatorAddr = r.string();
                                break;
                            case 2:
                                o.validatorAddr = r.string();
                                break;
                            default:
                                r.skipType(7 & e)
                        }
                    }
                    return o
                },
                fromJSON(e) {
                    let t = h();
                    return (0, a.isSet)(e.delegatorAddr) && (t.delegatorAddr = String(e.delegatorAddr)), (0, a.isSet)(e.validatorAddr) && (t.validatorAddr = String(e.validatorAddr)), t
                },
                toJSON(e) {
                    let t = {};
                    return void 0 !== e.delegatorAddr && (t.delegatorAddr = e.delegatorAddr), void 0 !== e.validatorAddr && (t.validatorAddr = e.validatorAddr), t
                },
                fromPartial(e) {
                    let t = h();
                    return t.delegatorAddr = e.delegatorAddr ? ? "", t.validatorAddr = e.validatorAddr ? ? "", t
                }
            }, t.QueryUnbondingDelegationResponse = {
                typeUrl: "/cosmos.staking.v1beta1.QueryUnbondingDelegationResponse",
                encode: (e, t = i.BinaryWriter.create()) => (void 0 !== e.unbond && o.UnbondingDelegation.encode(e.unbond, t.uint32(10).fork()).ldelim(), t),
                decode(e, t) {
                    let r = e instanceof i.BinaryReader ? e : new i.BinaryReader(e),
                        n = void 0 === t ? r.len : r.pos + t,
                        a = v();
                    for (; r.pos < n;) {
                        let e = r.uint32();
                        e >>> 3 == 1 ? a.unbond = o.UnbondingDelegation.decode(r, r.uint32()) : r.skipType(7 & e)
                    }
                    return a
                },
                fromJSON(e) {
                    let t = v();
                    return (0, a.isSet)(e.unbond) && (t.unbond = o.UnbondingDelegation.fromJSON(e.unbond)), t
                },
                toJSON(e) {
                    let t = {};
                    return void 0 !== e.unbond && (t.unbond = e.unbond ? o.UnbondingDelegation.toJSON(e.unbond) : void 0), t
                },
                fromPartial(e) {
                    let t = v();
                    return void 0 !== e.unbond && null !== e.unbond && (t.unbond = o.UnbondingDelegation.fromPartial(e.unbond)), t
                }
            }, t.QueryDelegatorDelegationsRequest = {
                typeUrl: "/cosmos.staking.v1beta1.QueryDelegatorDelegationsRequest",
                encode: (e, t = i.BinaryWriter.create()) => ("" !== e.delegatorAddr && t.uint32(10).string(e.delegatorAddr), void 0 !== e.pagination && n.PageRequest.encode(e.pagination, t.uint32(18).fork()).ldelim(), t),
                decode(e, t) {
                    let r = e instanceof i.BinaryReader ? e : new i.BinaryReader(e),
                        o = void 0 === t ? r.len : r.pos + t,
                        a = b();
                    for (; r.pos < o;) {
                        let e = r.uint32();
                        switch (e >>> 3) {
                            case 1:
                                a.delegatorAddr = r.string();
                                break;
                            case 2:
                                a.pagination = n.PageRequest.decode(r, r.uint32());
                                break;
                            default:
                                r.skipType(7 & e)
                        }
                    }
                    return a
                },
                fromJSON(e) {
                    let t = b();
                    return (0, a.isSet)(e.delegatorAddr) && (t.delegatorAddr = String(e.delegatorAddr)), (0, a.isSet)(e.pagination) && (t.pagination = n.PageRequest.fromJSON(e.pagination)), t
                },
                toJSON(e) {
                    let t = {};
                    return void 0 !== e.delegatorAddr && (t.delegatorAddr = e.delegatorAddr), void 0 !== e.pagination && (t.pagination = e.pagination ? n.PageRequest.toJSON(e.pagination) : void 0), t
                },
                fromPartial(e) {
                    let t = b();
                    return t.delegatorAddr = e.delegatorAddr ? ? "", void 0 !== e.pagination && null !== e.pagination && (t.pagination = n.PageRequest.fromPartial(e.pagination)), t
                }
            }, t.QueryDelegatorDelegationsResponse = {
                typeUrl: "/cosmos.staking.v1beta1.QueryDelegatorDelegationsResponse",
                encode(e, t = i.BinaryWriter.create()) {
                    for (let r of e.delegationResponses) o.DelegationResponse.encode(r, t.uint32(10).fork()).ldelim();
                    return void 0 !== e.pagination && n.PageResponse.encode(e.pagination, t.uint32(18).fork()).ldelim(), t
                },
                decode(e, t) {
                    let r = e instanceof i.BinaryReader ? e : new i.BinaryReader(e),
                        a = void 0 === t ? r.len : r.pos + t,
                        s = S();
                    for (; r.pos < a;) {
                        let e = r.uint32();
                        switch (e >>> 3) {
                            case 1:
                                s.delegationResponses.push(o.DelegationResponse.decode(r, r.uint32()));
                                break;
                            case 2:
                                s.pagination = n.PageResponse.decode(r, r.uint32());
                                break;
                            default:
                                r.skipType(7 & e)
                        }
                    }
                    return s
                },
                fromJSON(e) {
                    let t = S();
                    return Array.isArray(e ? .delegationResponses) && (t.delegationResponses = e.delegationResponses.map(e => o.DelegationResponse.fromJSON(e))), (0, a.isSet)(e.pagination) && (t.pagination = n.PageResponse.fromJSON(e.pagination)), t
                },
                toJSON(e) {
                    let t = {};
                    return e.delegationResponses ? t.delegationResponses = e.delegationResponses.map(e => e ? o.DelegationResponse.toJSON(e) : void 0) : t.delegationResponses = [], void 0 !== e.pagination && (t.pagination = e.pagination ? n.PageResponse.toJSON(e.pagination) : void 0), t
                },
                fromPartial(e) {
                    let t = S();
                    return t.delegationResponses = e.delegationResponses ? .map(e => o.DelegationResponse.fromPartial(e)) || [], void 0 !== e.pagination && null !== e.pagination && (t.pagination = n.PageResponse.fromPartial(e.pagination)), t
                }
            }, t.QueryDelegatorUnbondingDelegationsRequest = {
                typeUrl: "/cosmos.staking.v1beta1.QueryDelegatorUnbondingDelegationsRequest",
                encode: (e, t = i.BinaryWriter.create()) => ("" !== e.delegatorAddr && t.uint32(10).string(e.delegatorAddr), void 0 !== e.pagination && n.PageRequest.encode(e.pagination, t.uint32(18).fork()).ldelim(), t),
                decode(e, t) {
                    let r = e instanceof i.BinaryReader ? e : new i.BinaryReader(e),
                        o = void 0 === t ? r.len : r.pos + t,
                        a = k();
                    for (; r.pos < o;) {
                        let e = r.uint32();
                        switch (e >>> 3) {
                            case 1:
                                a.delegatorAddr = r.string();
                                break;
                            case 2:
                                a.pagination = n.PageRequest.decode(r, r.uint32());
                                break;
                            default:
                                r.skipType(7 & e)
                        }
                    }
                    return a
                },
                fromJSON(e) {
                    let t = k();
                    return (0, a.isSet)(e.delegatorAddr) && (t.delegatorAddr = String(e.delegatorAddr)), (0, a.isSet)(e.pagination) && (t.pagination = n.PageRequest.fromJSON(e.pagination)), t
                },
                toJSON(e) {
                    let t = {};
                    return void 0 !== e.delegatorAddr && (t.delegatorAddr = e.delegatorAddr), void 0 !== e.pagination && (t.pagination = e.pagination ? n.PageRequest.toJSON(e.pagination) : void 0), t
                },
                fromPartial(e) {
                    let t = k();
                    return t.delegatorAddr = e.delegatorAddr ? ? "", void 0 !== e.pagination && null !== e.pagination && (t.pagination = n.PageRequest.fromPartial(e.pagination)), t
                }
            }, t.QueryDelegatorUnbondingDelegationsResponse = {
                typeUrl: "/cosmos.staking.v1beta1.QueryDelegatorUnbondingDelegationsResponse",
                encode(e, t = i.BinaryWriter.create()) {
                    for (let r of e.unbondingResponses) o.UnbondingDelegation.encode(r, t.uint32(10).fork()).ldelim();
                    return void 0 !== e.pagination && n.PageResponse.encode(e.pagination, t.uint32(18).fork()).ldelim(), t
                },
                decode(e, t) {
                    let r = e instanceof i.BinaryReader ? e : new i.BinaryReader(e),
                        a = void 0 === t ? r.len : r.pos + t,
                        s = P();
                    for (; r.pos < a;) {
                        let e = r.uint32();
                        switch (e >>> 3) {
                            case 1:
                                s.unbondingResponses.push(o.UnbondingDelegation.decode(r, r.uint32()));
                                break;
                            case 2:
                                s.pagination = n.PageResponse.decode(r, r.uint32());
                                break;
                            default:
                                r.skipType(7 & e)
                        }
                    }
                    return s
                },
                fromJSON(e) {
                    let t = P();
                    return Array.isArray(e ? .unbondingResponses) && (t.unbondingResponses = e.unbondingResponses.map(e => o.UnbondingDelegation.fromJSON(e))), (0, a.isSet)(e.pagination) && (t.pagination = n.PageResponse.fromJSON(e.pagination)), t
                },
                toJSON(e) {
                    let t = {};
                    return e.unbondingResponses ? t.unbondingResponses = e.unbondingResponses.map(e => e ? o.UnbondingDelegation.toJSON(e) : void 0) : t.unbondingResponses = [], void 0 !== e.pagination && (t.pagination = e.pagination ? n.PageResponse.toJSON(e.pagination) : void 0), t
                },
                fromPartial(e) {
                    let t = P();
                    return t.unbondingResponses = e.unbondingResponses ? .map(e => o.UnbondingDelegation.fromPartial(e)) || [], void 0 !== e.pagination && null !== e.pagination && (t.pagination = n.PageResponse.fromPartial(e.pagination)), t
                }
            }, t.QueryRedelegationsRequest = {
                typeUrl: "/cosmos.staking.v1beta1.QueryRedelegationsRequest",
                encode: (e, t = i.BinaryWriter.create()) => ("" !== e.delegatorAddr && t.uint32(10).string(e.delegatorAddr), "" !== e.srcValidatorAddr && t.uint32(18).string(e.srcValidatorAddr), "" !== e.dstValidatorAddr && t.uint32(26).string(e.dstValidatorAddr), void 0 !== e.pagination && n.PageRequest.encode(e.pagination, t.uint32(34).fork()).ldelim(), t),
                decode(e, t) {
                    let r = e instanceof i.BinaryReader ? e : new i.BinaryReader(e),
                        o = void 0 === t ? r.len : r.pos + t,
                        a = _();
                    for (; r.pos < o;) {
                        let e = r.uint32();
                        switch (e >>> 3) {
                            case 1:
                                a.delegatorAddr = r.string();
                                break;
                            case 2:
                                a.srcValidatorAddr = r.string();
                                break;
                            case 3:
                                a.dstValidatorAddr = r.string();
                                break;
                            case 4:
                                a.pagination = n.PageRequest.decode(r, r.uint32());
                                break;
                            default:
                                r.skipType(7 & e)
                        }
                    }
                    return a
                },
                fromJSON(e) {
                    let t = _();
                    return (0, a.isSet)(e.delegatorAddr) && (t.delegatorAddr = String(e.delegatorAddr)), (0, a.isSet)(e.srcValidatorAddr) && (t.srcValidatorAddr = String(e.srcValidatorAddr)), (0, a.isSet)(e.dstValidatorAddr) && (t.dstValidatorAddr = String(e.dstValidatorAddr)), (0, a.isSet)(e.pagination) && (t.pagination = n.PageRequest.fromJSON(e.pagination)), t
                },
                toJSON(e) {
                    let t = {};
                    return void 0 !== e.delegatorAddr && (t.delegatorAddr = e.delegatorAddr), void 0 !== e.srcValidatorAddr && (t.srcValidatorAddr = e.srcValidatorAddr), void 0 !== e.dstValidatorAddr && (t.dstValidatorAddr = e.dstValidatorAddr), void 0 !== e.pagination && (t.pagination = e.pagination ? n.PageRequest.toJSON(e.pagination) : void 0), t
                },
                fromPartial(e) {
                    let t = _();
                    return t.delegatorAddr = e.delegatorAddr ? ? "", t.srcValidatorAddr = e.srcValidatorAddr ? ? "", t.dstValidatorAddr = e.dstValidatorAddr ? ? "", void 0 !== e.pagination && null !== e.pagination && (t.pagination = n.PageRequest.fromPartial(e.pagination)), t
                }
            }, t.QueryRedelegationsResponse = {
                typeUrl: "/cosmos.staking.v1beta1.QueryRedelegationsResponse",
                encode(e, t = i.BinaryWriter.create()) {
                    for (let r of e.redelegationResponses) o.RedelegationResponse.encode(r, t.uint32(10).fork()).ldelim();
                    return void 0 !== e.pagination && n.PageResponse.encode(e.pagination, t.uint32(18).fork()).ldelim(), t
                },
                decode(e, t) {
                    let r = e instanceof i.BinaryReader ? e : new i.BinaryReader(e),
                        a = void 0 === t ? r.len : r.pos + t,
                        s = B();
                    for (; r.pos < a;) {
                        let e = r.uint32();
                        switch (e >>> 3) {
                            case 1:
                                s.redelegationResponses.push(o.RedelegationResponse.decode(r, r.uint32()));
                                break;
                            case 2:
                                s.pagination = n.PageResponse.decode(r, r.uint32());
                                break;
                            default:
                                r.skipType(7 & e)
                        }
                    }
                    return s
                },
                fromJSON(e) {
                    let t = B();
                    return Array.isArray(e ? .redelegationResponses) && (t.redelegationResponses = e.redelegationResponses.map(e => o.RedelegationResponse.fromJSON(e))), (0, a.isSet)(e.pagination) && (t.pagination = n.PageResponse.fromJSON(e.pagination)), t
                },
                toJSON(e) {
                    let t = {};
                    return e.redelegationResponses ? t.redelegationResponses = e.redelegationResponses.map(e => e ? o.RedelegationResponse.toJSON(e) : void 0) : t.redelegationResponses = [], void 0 !== e.pagination && (t.pagination = e.pagination ? n.PageResponse.toJSON(e.pagination) : void 0), t
                },
                fromPartial(e) {
                    let t = B();
                    return t.redelegationResponses = e.redelegationResponses ? .map(e => o.RedelegationResponse.fromPartial(e)) || [], void 0 !== e.pagination && null !== e.pagination && (t.pagination = n.PageResponse.fromPartial(e.pagination)), t
                }
            }, t.QueryDelegatorValidatorsRequest = {
                typeUrl: "/cosmos.staking.v1beta1.QueryDelegatorValidatorsRequest",
                encode: (e, t = i.BinaryWriter.create()) => ("" !== e.delegatorAddr && t.uint32(10).string(e.delegatorAddr), void 0 !== e.pagination && n.PageRequest.encode(e.pagination, t.uint32(18).fork()).ldelim(), t),
                decode(e, t) {
                    let r = e instanceof i.BinaryReader ? e : new i.BinaryReader(e),
                        o = void 0 === t ? r.len : r.pos + t,
                        a = O();
                    for (; r.pos < o;) {
                        let e = r.uint32();
                        switch (e >>> 3) {
                            case 1:
                                a.delegatorAddr = r.string();
                                break;
                            case 2:
                                a.pagination = n.PageRequest.decode(r, r.uint32());
                                break;
                            default:
                                r.skipType(7 & e)
                        }
                    }
                    return a
                },
                fromJSON(e) {
                    let t = O();
                    return (0, a.isSet)(e.delegatorAddr) && (t.delegatorAddr = String(e.delegatorAddr)), (0, a.isSet)(e.pagination) && (t.pagination = n.PageRequest.fromJSON(e.pagination)), t
                },
                toJSON(e) {
                    let t = {};
                    return void 0 !== e.delegatorAddr && (t.delegatorAddr = e.delegatorAddr), void 0 !== e.pagination && (t.pagination = e.pagination ? n.PageRequest.toJSON(e.pagination) : void 0), t
                },
                fromPartial(e) {
                    let t = O();
                    return t.delegatorAddr = e.delegatorAddr ? ? "", void 0 !== e.pagination && null !== e.pagination && (t.pagination = n.PageRequest.fromPartial(e.pagination)), t
                }
            }, t.QueryDelegatorValidatorsResponse = {
                typeUrl: "/cosmos.staking.v1beta1.QueryDelegatorValidatorsResponse",
                encode(e, t = i.BinaryWriter.create()) {
                    for (let r of e.validators) o.Validator.encode(r, t.uint32(10).fork()).ldelim();
                    return void 0 !== e.pagination && n.PageResponse.encode(e.pagination, t.uint32(18).fork()).ldelim(), t
                },
                decode(e, t) {
                    let r = e instanceof i.BinaryReader ? e : new i.BinaryReader(e),
                        a = void 0 === t ? r.len : r.pos + t,
                        s = R();
                    for (; r.pos < a;) {
                        let e = r.uint32();
                        switch (e >>> 3) {
                            case 1:
                                s.validators.push(o.Validator.decode(r, r.uint32()));
                                break;
                            case 2:
                                s.pagination = n.PageResponse.decode(r, r.uint32());
                                break;
                            default:
                                r.skipType(7 & e)
                        }
                    }
                    return s
                },
                fromJSON(e) {
                    let t = R();
                    return Array.isArray(e ? .validators) && (t.validators = e.validators.map(e => o.Validator.fromJSON(e))), (0, a.isSet)(e.pagination) && (t.pagination = n.PageResponse.fromJSON(e.pagination)), t
                },
                toJSON(e) {
                    let t = {};
                    return e.validators ? t.validators = e.validators.map(e => e ? o.Validator.toJSON(e) : void 0) : t.validators = [], void 0 !== e.pagination && (t.pagination = e.pagination ? n.PageResponse.toJSON(e.pagination) : void 0), t
                },
                fromPartial(e) {
                    let t = R();
                    return t.validators = e.validators ? .map(e => o.Validator.fromPartial(e)) || [], void 0 !== e.pagination && null !== e.pagination && (t.pagination = n.PageResponse.fromPartial(e.pagination)), t
                }
            }, t.QueryDelegatorValidatorRequest = {
                typeUrl: "/cosmos.staking.v1beta1.QueryDelegatorValidatorRequest",
                encode: (e, t = i.BinaryWriter.create()) => ("" !== e.delegatorAddr && t.uint32(10).string(e.delegatorAddr), "" !== e.validatorAddr && t.uint32(18).string(e.validatorAddr), t),
                decode(e, t) {
                    let r = e instanceof i.BinaryReader ? e : new i.BinaryReader(e),
                        n = void 0 === t ? r.len : r.pos + t,
                        o = A();
                    for (; r.pos < n;) {
                        let e = r.uint32();
                        switch (e >>> 3) {
                            case 1:
                                o.delegatorAddr = r.string();
                                break;
                            case 2:
                                o.validatorAddr = r.string();
                                break;
                            default:
                                r.skipType(7 & e)
                        }
                    }
                    return o
                },
                fromJSON(e) {
                    let t = A();
                    return (0, a.isSet)(e.delegatorAddr) && (t.delegatorAddr = String(e.delegatorAddr)), (0, a.isSet)(e.validatorAddr) && (t.validatorAddr = String(e.validatorAddr)), t
                },
                toJSON(e) {
                    let t = {};
                    return void 0 !== e.delegatorAddr && (t.delegatorAddr = e.delegatorAddr), void 0 !== e.validatorAddr && (t.validatorAddr = e.validatorAddr), t
                },
                fromPartial(e) {
                    let t = A();
                    return t.delegatorAddr = e.delegatorAddr ? ? "", t.validatorAddr = e.validatorAddr ? ? "", t
                }
            }, t.QueryDelegatorValidatorResponse = {
                typeUrl: "/cosmos.staking.v1beta1.QueryDelegatorValidatorResponse",
                encode: (e, t = i.BinaryWriter.create()) => (void 0 !== e.validator && o.Validator.encode(e.validator, t.uint32(10).fork()).ldelim(), t),
                decode(e, t) {
                    let r = e instanceof i.BinaryReader ? e : new i.BinaryReader(e),
                        n = void 0 === t ? r.len : r.pos + t,
                        a = I();
                    for (; r.pos < n;) {
                        let e = r.uint32();
                        e >>> 3 == 1 ? a.validator = o.Validator.decode(r, r.uint32()) : r.skipType(7 & e)
                    }
                    return a
                },
                fromJSON(e) {
                    let t = I();
                    return (0, a.isSet)(e.validator) && (t.validator = o.Validator.fromJSON(e.validator)), t
                },
                toJSON(e) {
                    let t = {};
                    return void 0 !== e.validator && (t.validator = e.validator ? o.Validator.toJSON(e.validator) : void 0), t
                },
                fromPartial(e) {
                    let t = I();
                    return void 0 !== e.validator && null !== e.validator && (t.validator = o.Validator.fromPartial(e.validator)), t
                }
            }, t.QueryHistoricalInfoRequest = {
                typeUrl: "/cosmos.staking.v1beta1.QueryHistoricalInfoRequest",
                encode: (e, t = i.BinaryWriter.create()) => (e.height !== BigInt(0) && t.uint32(8).int64(e.height), t),
                decode(e, t) {
                    let r = e instanceof i.BinaryReader ? e : new i.BinaryReader(e),
                        n = void 0 === t ? r.len : r.pos + t,
                        o = w();
                    for (; r.pos < n;) {
                        let e = r.uint32();
                        e >>> 3 == 1 ? o.height = r.int64() : r.skipType(7 & e)
                    }
                    return o
                },
                fromJSON(e) {
                    let t = w();
                    return (0, a.isSet)(e.height) && (t.height = BigInt(e.height.toString())), t
                },
                toJSON(e) {
                    let t = {};
                    return void 0 !== e.height && (t.height = (e.height || BigInt(0)).toString()), t
                },
                fromPartial(e) {
                    let t = w();
                    return void 0 !== e.height && null !== e.height && (t.height = BigInt(e.height.toString())), t
                }
            }, t.QueryHistoricalInfoResponse = {
                typeUrl: "/cosmos.staking.v1beta1.QueryHistoricalInfoResponse",
                encode: (e, t = i.BinaryWriter.create()) => (void 0 !== e.hist && o.HistoricalInfo.encode(e.hist, t.uint32(10).fork()).ldelim(), t),
                decode(e, t) {
                    let r = e instanceof i.BinaryReader ? e : new i.BinaryReader(e),
                        n = void 0 === t ? r.len : r.pos + t,
                        a = T();
                    for (; r.pos < n;) {
                        let e = r.uint32();
                        e >>> 3 == 1 ? a.hist = o.HistoricalInfo.decode(r, r.uint32()) : r.skipType(7 & e)
                    }
                    return a
                },
                fromJSON(e) {
                    let t = T();
                    return (0, a.isSet)(e.hist) && (t.hist = o.HistoricalInfo.fromJSON(e.hist)), t
                },
                toJSON(e) {
                    let t = {};
                    return void 0 !== e.hist && (t.hist = e.hist ? o.HistoricalInfo.toJSON(e.hist) : void 0), t
                },
                fromPartial(e) {
                    let t = T();
                    return void 0 !== e.hist && null !== e.hist && (t.hist = o.HistoricalInfo.fromPartial(e.hist)), t
                }
            }, t.QueryPoolRequest = {
                typeUrl: "/cosmos.staking.v1beta1.QueryPoolRequest",
                encode: (e, t = i.BinaryWriter.create()) => t,
                decode(e, t) {
                    let r = e instanceof i.BinaryReader ? e : new i.BinaryReader(e),
                        n = void 0 === t ? r.len : r.pos + t;
                    for (; r.pos < n;) {
                        let e = r.uint32();
                        r.skipType(7 & e)
                    }
                    return {}
                },
                fromJSON: e => ({}),
                toJSON: e => ({}),
                fromPartial: e => ({})
            }, t.QueryPoolResponse = {
                typeUrl: "/cosmos.staking.v1beta1.QueryPoolResponse",
                encode: (e, t = i.BinaryWriter.create()) => (void 0 !== e.pool && o.Pool.encode(e.pool, t.uint32(10).fork()).ldelim(), t),
                decode(e, t) {
                    let r = e instanceof i.BinaryReader ? e : new i.BinaryReader(e),
                        n = void 0 === t ? r.len : r.pos + t,
                        a = N();
                    for (; r.pos < n;) {
                        let e = r.uint32();
                        e >>> 3 == 1 ? a.pool = o.Pool.decode(r, r.uint32()) : r.skipType(7 & e)
                    }
                    return a
                },
                fromJSON(e) {
                    let t = N();
                    return (0, a.isSet)(e.pool) && (t.pool = o.Pool.fromJSON(e.pool)), t
                },
                toJSON(e) {
                    let t = {};
                    return void 0 !== e.pool && (t.pool = e.pool ? o.Pool.toJSON(e.pool) : void 0), t
                },
                fromPartial(e) {
                    let t = N();
                    return void 0 !== e.pool && null !== e.pool && (t.pool = o.Pool.fromPartial(e.pool)), t
                }
            }, t.QueryParamsRequest = {
                typeUrl: "/cosmos.staking.v1beta1.QueryParamsRequest",
                encode: (e, t = i.BinaryWriter.create()) => t,
                decode(e, t) {
                    let r = e instanceof i.BinaryReader ? e : new i.BinaryReader(e),
                        n = void 0 === t ? r.len : r.pos + t;
                    for (; r.pos < n;) {
                        let e = r.uint32();
                        r.skipType(7 & e)
                    }
                    return {}
                },
                fromJSON: e => ({}),
                toJSON: e => ({}),
                fromPartial: e => ({})
            }, t.QueryParamsResponse = {
                typeUrl: "/cosmos.staking.v1beta1.QueryParamsResponse",
                encode: (e, t = i.BinaryWriter.create()) => (void 0 !== e.params && o.Params.encode(e.params, t.uint32(10).fork()).ldelim(), t),
                decode(e, t) {
                    let r = e instanceof i.BinaryReader ? e : new i.BinaryReader(e),
                        n = void 0 === t ? r.len : r.pos + t,
                        a = C();
                    for (; r.pos < n;) {
                        let e = r.uint32();
                        e >>> 3 == 1 ? a.params = o.Params.decode(r, r.uint32()) : r.skipType(7 & e)
                    }
                    return a
                },
                fromJSON(e) {
                    let t = C();
                    return (0, a.isSet)(e.params) && (t.params = o.Params.fromJSON(e.params)), t
                },
                toJSON(e) {
                    let t = {};
                    return void 0 !== e.params && (t.params = e.params ? o.Params.toJSON(e.params) : void 0), t
                },
                fromPartial(e) {
                    let t = C();
                    return void 0 !== e.params && null !== e.params && (t.params = o.Params.fromPartial(e.params)), t
                }
            };
            class E {
                constructor(e) {
                    this.rpc = e, this.Validators = this.Validators.bind(this), this.Validator = this.Validator.bind(this), this.ValidatorDelegations = this.ValidatorDelegations.bind(this), this.ValidatorUnbondingDelegations = this.ValidatorUnbondingDelegations.bind(this), this.Delegation = this.Delegation.bind(this), this.UnbondingDelegation = this.UnbondingDelegation.bind(this), this.DelegatorDelegations = this.DelegatorDelegations.bind(this), this.DelegatorUnbondingDelegations = this.DelegatorUnbondingDelegations.bind(this), this.Redelegations = this.Redelegations.bind(this), this.DelegatorValidators = this.DelegatorValidators.bind(this), this.DelegatorValidator = this.DelegatorValidator.bind(this), this.HistoricalInfo = this.HistoricalInfo.bind(this), this.Pool = this.Pool.bind(this), this.Params = this.Params.bind(this)
                }
                Validators(e) {
                    let r = t.QueryValidatorsRequest.encode(e).finish();
                    return this.rpc.request("cosmos.staking.v1beta1.Query", "Validators", r).then(e => t.QueryValidatorsResponse.decode(new i.BinaryReader(e)))
                }
                Validator(e) {
                    let r = t.QueryValidatorRequest.encode(e).finish();
                    return this.rpc.request("cosmos.staking.v1beta1.Query", "Validator", r).then(e => t.QueryValidatorResponse.decode(new i.BinaryReader(e)))
                }
                ValidatorDelegations(e) {
                    let r = t.QueryValidatorDelegationsRequest.encode(e).finish();
                    return this.rpc.request("cosmos.staking.v1beta1.Query", "ValidatorDelegations", r).then(e => t.QueryValidatorDelegationsResponse.decode(new i.BinaryReader(e)))
                }
                ValidatorUnbondingDelegations(e) {
                    let r = t.QueryValidatorUnbondingDelegationsRequest.encode(e).finish();
                    return this.rpc.request("cosmos.staking.v1beta1.Query", "ValidatorUnbondingDelegations", r).then(e => t.QueryValidatorUnbondingDelegationsResponse.decode(new i.BinaryReader(e)))
                }
                Delegation(e) {
                    let r = t.QueryDelegationRequest.encode(e).finish();
                    return this.rpc.request("cosmos.staking.v1beta1.Query", "Delegation", r).then(e => t.QueryDelegationResponse.decode(new i.BinaryReader(e)))
                }
                UnbondingDelegation(e) {
                    let r = t.QueryUnbondingDelegationRequest.encode(e).finish();
                    return this.rpc.request("cosmos.staking.v1beta1.Query", "UnbondingDelegation", r).then(e => t.QueryUnbondingDelegationResponse.decode(new i.BinaryReader(e)))
                }
                DelegatorDelegations(e) {
                    let r = t.QueryDelegatorDelegationsRequest.encode(e).finish();
                    return this.rpc.request("cosmos.staking.v1beta1.Query", "DelegatorDelegations", r).then(e => t.QueryDelegatorDelegationsResponse.decode(new i.BinaryReader(e)))
                }
                DelegatorUnbondingDelegations(e) {
                    let r = t.QueryDelegatorUnbondingDelegationsRequest.encode(e).finish();
                    return this.rpc.request("cosmos.staking.v1beta1.Query", "DelegatorUnbondingDelegations", r).then(e => t.QueryDelegatorUnbondingDelegationsResponse.decode(new i.BinaryReader(e)))
                }
                Redelegations(e) {
                    let r = t.QueryRedelegationsRequest.encode(e).finish();
                    return this.rpc.request("cosmos.staking.v1beta1.Query", "Redelegations", r).then(e => t.QueryRedelegationsResponse.decode(new i.BinaryReader(e)))
                }
                DelegatorValidators(e) {
                    let r = t.QueryDelegatorValidatorsRequest.encode(e).finish();
                    return this.rpc.request("cosmos.staking.v1beta1.Query", "DelegatorValidators", r).then(e => t.QueryDelegatorValidatorsResponse.decode(new i.BinaryReader(e)))
                }
                DelegatorValidator(e) {
                    let r = t.QueryDelegatorValidatorRequest.encode(e).finish();
                    return this.rpc.request("cosmos.staking.v1beta1.Query", "DelegatorValidator", r).then(e => t.QueryDelegatorValidatorResponse.decode(new i.BinaryReader(e)))
                }
                HistoricalInfo(e) {
                    let r = t.QueryHistoricalInfoRequest.encode(e).finish();
                    return this.rpc.request("cosmos.staking.v1beta1.Query", "HistoricalInfo", r).then(e => t.QueryHistoricalInfoResponse.decode(new i.BinaryReader(e)))
                }
                Pool(e = {}) {
                    let r = t.QueryPoolRequest.encode(e).finish();
                    return this.rpc.request("cosmos.staking.v1beta1.Query", "Pool", r).then(e => t.QueryPoolResponse.decode(new i.BinaryReader(e)))
                }
                Params(e = {}) {
                    let r = t.QueryParamsRequest.encode(e).finish();
                    return this.rpc.request("cosmos.staking.v1beta1.Query", "Params", r).then(e => t.QueryParamsResponse.decode(new i.BinaryReader(e)))
                }
            }
            t.QueryClientImpl = E
        },
        93508: function(e, t, r) {
            "use strict";
            var n, o, i, a;
            Object.defineProperty(t, "__esModule", {
                value: !0
            }), t.ValidatorUpdates = t.Pool = t.RedelegationResponse = t.RedelegationEntryResponse = t.DelegationResponse = t.Params = t.Redelegation = t.RedelegationEntry = t.UnbondingDelegationEntry = t.UnbondingDelegation = t.Delegation = t.DVVTriplets = t.DVVTriplet = t.DVPairs = t.DVPair = t.ValAddresses = t.Validator = t.Description = t.Commission = t.CommissionRates = t.HistoricalInfo = t.infractionToJSON = t.infractionFromJSON = t.Infraction = t.bondStatusToJSON = t.bondStatusFromJSON = t.BondStatus = t.protobufPackage = void 0;
            let s = r(64255),
                d = r(90614),
                c = r(65676),
                l = r(69441),
                u = r(62809),
                p = r(50783),
                m = r(28486),
                g = r(6476);

            function f(e) {
                switch (e) {
                    case 0:
                    case "BOND_STATUS_UNSPECIFIED":
                        return n.BOND_STATUS_UNSPECIFIED;
                    case 1:
                    case "BOND_STATUS_UNBONDED":
                        return n.BOND_STATUS_UNBONDED;
                    case 2:
                    case "BOND_STATUS_UNBONDING":
                        return n.BOND_STATUS_UNBONDING;
                    case 3:
                    case "BOND_STATUS_BONDED":
                        return n.BOND_STATUS_BONDED;
                    default:
                        return n.UNRECOGNIZED
                }
            }

            function y(e) {
                switch (e) {
                    case n.BOND_STATUS_UNSPECIFIED:
                        return "BOND_STATUS_UNSPECIFIED";
                    case n.BOND_STATUS_UNBONDED:
                        return "BOND_STATUS_UNBONDED";
                    case n.BOND_STATUS_UNBONDING:
                        return "BOND_STATUS_UNBONDING";
                    case n.BOND_STATUS_BONDED:
                        return "BOND_STATUS_BONDED";
                    case n.UNRECOGNIZED:
                    default:
                        return "UNRECOGNIZED"
                }
            }

            function h() {
                return {
                    header: s.Header.fromPartial({}),
                    valset: []
                }
            }

            function v() {
                return {
                    rate: "",
                    maxRate: "",
                    maxChangeRate: ""
                }
            }

            function b() {
                return {
                    commissionRates: t.CommissionRates.fromPartial({}),
                    updateTime: d.Timestamp.fromPartial({})
                }
            }

            function S() {
                return {
                    moniker: "",
                    identity: "",
                    website: "",
                    securityContact: "",
                    details: ""
                }
            }

            function k() {
                return {
                    operatorAddress: "",
                    consensusPubkey: void 0,
                    jailed: !1,
                    status: 0,
                    tokens: "",
                    delegatorShares: "",
                    description: t.Description.fromPartial({}),
                    unbondingHeight: BigInt(0),
                    unbondingTime: d.Timestamp.fromPartial({}),
                    commission: t.Commission.fromPartial({}),
                    minSelfDelegation: "",
                    unbondingOnHoldRefCount: BigInt(0),
                    unbondingIds: []
                }
            }

            function P() {
                return {
                    addresses: []
                }
            }

            function _() {
                return {
                    delegatorAddress: "",
                    validatorAddress: ""
                }
            }

            function B() {
                return {
                    pairs: []
                }
            }

            function O() {
                return {
                    delegatorAddress: "",
                    validatorSrcAddress: "",
                    validatorDstAddress: ""
                }
            }

            function R() {
                return {
                    triplets: []
                }
            }

            function A() {
                return {
                    delegatorAddress: "",
                    validatorAddress: "",
                    shares: ""
                }
            }

            function I() {
                return {
                    delegatorAddress: "",
                    validatorAddress: "",
                    entries: []
                }
            }

            function w() {
                return {
                    creationHeight: BigInt(0),
                    completionTime: d.Timestamp.fromPartial({}),
                    initialBalance: "",
                    balance: "",
                    unbondingId: BigInt(0),
                    unbondingOnHoldRefCount: BigInt(0)
                }
            }

            function T() {
                return {
                    creationHeight: BigInt(0),
                    completionTime: d.Timestamp.fromPartial({}),
                    initialBalance: "",
                    sharesDst: "",
                    unbondingId: BigInt(0),
                    unbondingOnHoldRefCount: BigInt(0)
                }
            }

            function N() {
                return {
                    delegatorAddress: "",
                    validatorSrcAddress: "",
                    validatorDstAddress: "",
                    entries: []
                }
            }

            function C() {
                return {
                    unbondingTime: l.Duration.fromPartial({}),
                    maxValidators: 0,
                    maxEntries: 0,
                    historicalEntries: 0,
                    bondDenom: "",
                    minCommissionRate: ""
                }
            }

            function E() {
                return {
                    delegation: t.Delegation.fromPartial({}),
                    balance: u.Coin.fromPartial({})
                }
            }

            function x() {
                return {
                    redelegationEntry: t.RedelegationEntry.fromPartial({}),
                    balance: ""
                }
            }

            function U() {
                return {
                    redelegation: t.Redelegation.fromPartial({}),
                    entries: []
                }
            }

            function D() {
                return {
                    notBondedTokens: "",
                    bondedTokens: ""
                }
            }

            function M() {
                return {
                    updates: []
                }
            }
            t.protobufPackage = "cosmos.staking.v1beta1", (i = n || (t.BondStatus = n = {}))[i.BOND_STATUS_UNSPECIFIED = 0] = "BOND_STATUS_UNSPECIFIED", i[i.BOND_STATUS_UNBONDED = 1] = "BOND_STATUS_UNBONDED", i[i.BOND_STATUS_UNBONDING = 2] = "BOND_STATUS_UNBONDING", i[i.BOND_STATUS_BONDED = 3] = "BOND_STATUS_BONDED", i[i.UNRECOGNIZED = -1] = "UNRECOGNIZED", t.bondStatusFromJSON = f, t.bondStatusToJSON = y, (a = o || (t.Infraction = o = {}))[a.INFRACTION_UNSPECIFIED = 0] = "INFRACTION_UNSPECIFIED", a[a.INFRACTION_DOUBLE_SIGN = 1] = "INFRACTION_DOUBLE_SIGN", a[a.INFRACTION_DOWNTIME = 2] = "INFRACTION_DOWNTIME", a[a.UNRECOGNIZED = -1] = "UNRECOGNIZED", t.infractionFromJSON = function(e) {
                switch (e) {
                    case 0:
                    case "INFRACTION_UNSPECIFIED":
                        return o.INFRACTION_UNSPECIFIED;
                    case 1:
                    case "INFRACTION_DOUBLE_SIGN":
                        return o.INFRACTION_DOUBLE_SIGN;
                    case 2:
                    case "INFRACTION_DOWNTIME":
                        return o.INFRACTION_DOWNTIME;
                    default:
                        return o.UNRECOGNIZED
                }
            }, t.infractionToJSON = function(e) {
                switch (e) {
                    case o.INFRACTION_UNSPECIFIED:
                        return "INFRACTION_UNSPECIFIED";
                    case o.INFRACTION_DOUBLE_SIGN:
                        return "INFRACTION_DOUBLE_SIGN";
                    case o.INFRACTION_DOWNTIME:
                        return "INFRACTION_DOWNTIME";
                    case o.UNRECOGNIZED:
                    default:
                        return "UNRECOGNIZED"
                }
            }, t.HistoricalInfo = {
                typeUrl: "/cosmos.staking.v1beta1.HistoricalInfo",
                encode(e, r = m.BinaryWriter.create()) {
                    for (let n of (void 0 !== e.header && s.Header.encode(e.header, r.uint32(10).fork()).ldelim(), e.valset)) t.Validator.encode(n, r.uint32(18).fork()).ldelim();
                    return r
                },
                decode(e, r) {
                    let n = e instanceof m.BinaryReader ? e : new m.BinaryReader(e),
                        o = void 0 === r ? n.len : n.pos + r,
                        i = h();
                    for (; n.pos < o;) {
                        let e = n.uint32();
                        switch (e >>> 3) {
                            case 1:
                                i.header = s.Header.decode(n, n.uint32());
                                break;
                            case 2:
                                i.valset.push(t.Validator.decode(n, n.uint32()));
                                break;
                            default:
                                n.skipType(7 & e)
                        }
                    }
                    return i
                },
                fromJSON(e) {
                    let r = h();
                    return (0, g.isSet)(e.header) && (r.header = s.Header.fromJSON(e.header)), Array.isArray(e ? .valset) && (r.valset = e.valset.map(e => t.Validator.fromJSON(e))), r
                },
                toJSON(e) {
                    let r = {};
                    return void 0 !== e.header && (r.header = e.header ? s.Header.toJSON(e.header) : void 0), e.valset ? r.valset = e.valset.map(e => e ? t.Validator.toJSON(e) : void 0) : r.valset = [], r
                },
                fromPartial(e) {
                    let r = h();
                    return void 0 !== e.header && null !== e.header && (r.header = s.Header.fromPartial(e.header)), r.valset = e.valset ? .map(e => t.Validator.fromPartial(e)) || [], r
                }
            }, t.CommissionRates = {
                typeUrl: "/cosmos.staking.v1beta1.CommissionRates",
                encode: (e, t = m.BinaryWriter.create()) => ("" !== e.rate && t.uint32(10).string(e.rate), "" !== e.maxRate && t.uint32(18).string(e.maxRate), "" !== e.maxChangeRate && t.uint32(26).string(e.maxChangeRate), t),
                decode(e, t) {
                    let r = e instanceof m.BinaryReader ? e : new m.BinaryReader(e),
                        n = void 0 === t ? r.len : r.pos + t,
                        o = v();
                    for (; r.pos < n;) {
                        let e = r.uint32();
                        switch (e >>> 3) {
                            case 1:
                                o.rate = r.string();
                                break;
                            case 2:
                                o.maxRate = r.string();
                                break;
                            case 3:
                                o.maxChangeRate = r.string();
                                break;
                            default:
                                r.skipType(7 & e)
                        }
                    }
                    return o
                },
                fromJSON(e) {
                    let t = v();
                    return (0, g.isSet)(e.rate) && (t.rate = String(e.rate)), (0, g.isSet)(e.maxRate) && (t.maxRate = String(e.maxRate)), (0, g.isSet)(e.maxChangeRate) && (t.maxChangeRate = String(e.maxChangeRate)), t
                },
                toJSON(e) {
                    let t = {};
                    return void 0 !== e.rate && (t.rate = e.rate), void 0 !== e.maxRate && (t.maxRate = e.maxRate), void 0 !== e.maxChangeRate && (t.maxChangeRate = e.maxChangeRate), t
                },
                fromPartial(e) {
                    let t = v();
                    return t.rate = e.rate ? ? "", t.maxRate = e.maxRate ? ? "", t.maxChangeRate = e.maxChangeRate ? ? "", t
                }
            }, t.Commission = {
                typeUrl: "/cosmos.staking.v1beta1.Commission",
                encode: (e, r = m.BinaryWriter.create()) => (void 0 !== e.commissionRates && t.CommissionRates.encode(e.commissionRates, r.uint32(10).fork()).ldelim(), void 0 !== e.updateTime && d.Timestamp.encode(e.updateTime, r.uint32(18).fork()).ldelim(), r),
                decode(e, r) {
                    let n = e instanceof m.BinaryReader ? e : new m.BinaryReader(e),
                        o = void 0 === r ? n.len : n.pos + r,
                        i = b();
                    for (; n.pos < o;) {
                        let e = n.uint32();
                        switch (e >>> 3) {
                            case 1:
                                i.commissionRates = t.CommissionRates.decode(n, n.uint32());
                                break;
                            case 2:
                                i.updateTime = d.Timestamp.decode(n, n.uint32());
                                break;
                            default:
                                n.skipType(7 & e)
                        }
                    }
                    return i
                },
                fromJSON(e) {
                    let r = b();
                    return (0, g.isSet)(e.commissionRates) && (r.commissionRates = t.CommissionRates.fromJSON(e.commissionRates)), (0, g.isSet)(e.updateTime) && (r.updateTime = (0, g.fromJsonTimestamp)(e.updateTime)), r
                },
                toJSON(e) {
                    let r = {};
                    return void 0 !== e.commissionRates && (r.commissionRates = e.commissionRates ? t.CommissionRates.toJSON(e.commissionRates) : void 0), void 0 !== e.updateTime && (r.updateTime = (0, g.fromTimestamp)(e.updateTime).toISOString()), r
                },
                fromPartial(e) {
                    let r = b();
                    return void 0 !== e.commissionRates && null !== e.commissionRates && (r.commissionRates = t.CommissionRates.fromPartial(e.commissionRates)), void 0 !== e.updateTime && null !== e.updateTime && (r.updateTime = d.Timestamp.fromPartial(e.updateTime)), r
                }
            }, t.Description = {
                typeUrl: "/cosmos.staking.v1beta1.Description",
                encode: (e, t = m.BinaryWriter.create()) => ("" !== e.moniker && t.uint32(10).string(e.moniker), "" !== e.identity && t.uint32(18).string(e.identity), "" !== e.website && t.uint32(26).string(e.website), "" !== e.securityContact && t.uint32(34).string(e.securityContact), "" !== e.details && t.uint32(42).string(e.details), t),
                decode(e, t) {
                    let r = e instanceof m.BinaryReader ? e : new m.BinaryReader(e),
                        n = void 0 === t ? r.len : r.pos + t,
                        o = S();
                    for (; r.pos < n;) {
                        let e = r.uint32();
                        switch (e >>> 3) {
                            case 1:
                                o.moniker = r.string();
                                break;
                            case 2:
                                o.identity = r.string();
                                break;
                            case 3:
                                o.website = r.string();
                                break;
                            case 4:
                                o.securityContact = r.string();
                                break;
                            case 5:
                                o.details = r.string();
                                break;
                            default:
                                r.skipType(7 & e)
                        }
                    }
                    return o
                },
                fromJSON(e) {
                    let t = S();
                    return (0, g.isSet)(e.moniker) && (t.moniker = String(e.moniker)), (0, g.isSet)(e.identity) && (t.identity = String(e.identity)), (0, g.isSet)(e.website) && (t.website = String(e.website)), (0, g.isSet)(e.securityContact) && (t.securityContact = String(e.securityContact)), (0, g.isSet)(e.details) && (t.details = String(e.details)), t
                },
                toJSON(e) {
                    let t = {};
                    return void 0 !== e.moniker && (t.moniker = e.moniker), void 0 !== e.identity && (t.identity = e.identity), void 0 !== e.website && (t.website = e.website), void 0 !== e.securityContact && (t.securityContact = e.securityContact), void 0 !== e.details && (t.details = e.details), t
                },
                fromPartial(e) {
                    let t = S();
                    return t.moniker = e.moniker ? ? "", t.identity = e.identity ? ? "", t.website = e.website ? ? "", t.securityContact = e.securityContact ? ? "", t.details = e.details ? ? "", t
                }
            }, t.Validator = {
                typeUrl: "/cosmos.staking.v1beta1.Validator",
                encode(e, r = m.BinaryWriter.create()) {
                    for (let n of ("" !== e.operatorAddress && r.uint32(10).string(e.operatorAddress), void 0 !== e.consensusPubkey && c.Any.encode(e.consensusPubkey, r.uint32(18).fork()).ldelim(), !0 === e.jailed && r.uint32(24).bool(e.jailed), 0 !== e.status && r.uint32(32).int32(e.status), "" !== e.tokens && r.uint32(42).string(e.tokens), "" !== e.delegatorShares && r.uint32(50).string(e.delegatorShares), void 0 !== e.description && t.Description.encode(e.description, r.uint32(58).fork()).ldelim(), e.unbondingHeight !== BigInt(0) && r.uint32(64).int64(e.unbondingHeight), void 0 !== e.unbondingTime && d.Timestamp.encode(e.unbondingTime, r.uint32(74).fork()).ldelim(), void 0 !== e.commission && t.Commission.encode(e.commission, r.uint32(82).fork()).ldelim(), "" !== e.minSelfDelegation && r.uint32(90).string(e.minSelfDelegation), e.unbondingOnHoldRefCount !== BigInt(0) && r.uint32(96).int64(e.unbondingOnHoldRefCount), r.uint32(106).fork(), e.unbondingIds)) r.uint64(n);
                    return r.ldelim(), r
                },
                decode(e, r) {
                    let n = e instanceof m.BinaryReader ? e : new m.BinaryReader(e),
                        o = void 0 === r ? n.len : n.pos + r,
                        i = k();
                    for (; n.pos < o;) {
                        let e = n.uint32();
                        switch (e >>> 3) {
                            case 1:
                                i.operatorAddress = n.string();
                                break;
                            case 2:
                                i.consensusPubkey = c.Any.decode(n, n.uint32());
                                break;
                            case 3:
                                i.jailed = n.bool();
                                break;
                            case 4:
                                i.status = n.int32();
                                break;
                            case 5:
                                i.tokens = n.string();
                                break;
                            case 6:
                                i.delegatorShares = n.string();
                                break;
                            case 7:
                                i.description = t.Description.decode(n, n.uint32());
                                break;
                            case 8:
                                i.unbondingHeight = n.int64();
                                break;
                            case 9:
                                i.unbondingTime = d.Timestamp.decode(n, n.uint32());
                                break;
                            case 10:
                                i.commission = t.Commission.decode(n, n.uint32());
                                break;
                            case 11:
                                i.minSelfDelegation = n.string();
                                break;
                            case 12:
                                i.unbondingOnHoldRefCount = n.int64();
                                break;
                            case 13:
                                if ((7 & e) == 2) {
                                    let e = n.uint32() + n.pos;
                                    for (; n.pos < e;) i.unbondingIds.push(n.uint64())
                                } else i.unbondingIds.push(n.uint64());
                                break;
                            default:
                                n.skipType(7 & e)
                        }
                    }
                    return i
                },
                fromJSON(e) {
                    let r = k();
                    return (0, g.isSet)(e.operatorAddress) && (r.operatorAddress = String(e.operatorAddress)), (0, g.isSet)(e.consensusPubkey) && (r.consensusPubkey = c.Any.fromJSON(e.consensusPubkey)), (0, g.isSet)(e.jailed) && (r.jailed = !!e.jailed), (0, g.isSet)(e.status) && (r.status = f(e.status)), (0, g.isSet)(e.tokens) && (r.tokens = String(e.tokens)), (0, g.isSet)(e.delegatorShares) && (r.delegatorShares = String(e.delegatorShares)), (0, g.isSet)(e.description) && (r.description = t.Description.fromJSON(e.description)), (0, g.isSet)(e.unbondingHeight) && (r.unbondingHeight = BigInt(e.unbondingHeight.toString())), (0, g.isSet)(e.unbondingTime) && (r.unbondingTime = (0, g.fromJsonTimestamp)(e.unbondingTime)), (0, g.isSet)(e.commission) && (r.commission = t.Commission.fromJSON(e.commission)), (0, g.isSet)(e.minSelfDelegation) && (r.minSelfDelegation = String(e.minSelfDelegation)), (0, g.isSet)(e.unbondingOnHoldRefCount) && (r.unbondingOnHoldRefCount = BigInt(e.unbondingOnHoldRefCount.toString())), Array.isArray(e ? .unbondingIds) && (r.unbondingIds = e.unbondingIds.map(e => BigInt(e.toString()))), r
                },
                toJSON(e) {
                    let r = {};
                    return void 0 !== e.operatorAddress && (r.operatorAddress = e.operatorAddress), void 0 !== e.consensusPubkey && (r.consensusPubkey = e.consensusPubkey ? c.Any.toJSON(e.consensusPubkey) : void 0), void 0 !== e.jailed && (r.jailed = e.jailed), void 0 !== e.status && (r.status = y(e.status)), void 0 !== e.tokens && (r.tokens = e.tokens), void 0 !== e.delegatorShares && (r.delegatorShares = e.delegatorShares), void 0 !== e.description && (r.description = e.description ? t.Description.toJSON(e.description) : void 0), void 0 !== e.unbondingHeight && (r.unbondingHeight = (e.unbondingHeight || BigInt(0)).toString()), void 0 !== e.unbondingTime && (r.unbondingTime = (0, g.fromTimestamp)(e.unbondingTime).toISOString()), void 0 !== e.commission && (r.commission = e.commission ? t.Commission.toJSON(e.commission) : void 0), void 0 !== e.minSelfDelegation && (r.minSelfDelegation = e.minSelfDelegation), void 0 !== e.unbondingOnHoldRefCount && (r.unbondingOnHoldRefCount = (e.unbondingOnHoldRefCount || BigInt(0)).toString()), e.unbondingIds ? r.unbondingIds = e.unbondingIds.map(e => (e || BigInt(0)).toString()) : r.unbondingIds = [], r
                },
                fromPartial(e) {
                    let r = k();
                    return r.operatorAddress = e.operatorAddress ? ? "", void 0 !== e.consensusPubkey && null !== e.consensusPubkey && (r.consensusPubkey = c.Any.fromPartial(e.consensusPubkey)), r.jailed = e.jailed ? ? !1, r.status = e.status ? ? 0, r.tokens = e.tokens ? ? "", r.delegatorShares = e.delegatorShares ? ? "", void 0 !== e.description && null !== e.description && (r.description = t.Description.fromPartial(e.description)), void 0 !== e.unbondingHeight && null !== e.unbondingHeight && (r.unbondingHeight = BigInt(e.unbondingHeight.toString())), void 0 !== e.unbondingTime && null !== e.unbondingTime && (r.unbondingTime = d.Timestamp.fromPartial(e.unbondingTime)), void 0 !== e.commission && null !== e.commission && (r.commission = t.Commission.fromPartial(e.commission)), r.minSelfDelegation = e.minSelfDelegation ? ? "", void 0 !== e.unbondingOnHoldRefCount && null !== e.unbondingOnHoldRefCount && (r.unbondingOnHoldRefCount = BigInt(e.unbondingOnHoldRefCount.toString())), r.unbondingIds = e.unbondingIds ? .map(e => BigInt(e.toString())) || [], r
                }
            }, t.ValAddresses = {
                typeUrl: "/cosmos.staking.v1beta1.ValAddresses",
                encode(e, t = m.BinaryWriter.create()) {
                    for (let r of e.addresses) t.uint32(10).string(r);
                    return t
                },
                decode(e, t) {
                    let r = e instanceof m.BinaryReader ? e : new m.BinaryReader(e),
                        n = void 0 === t ? r.len : r.pos + t,
                        o = P();
                    for (; r.pos < n;) {
                        let e = r.uint32();
                        e >>> 3 == 1 ? o.addresses.push(r.string()) : r.skipType(7 & e)
                    }
                    return o
                },
                fromJSON(e) {
                    let t = P();
                    return Array.isArray(e ? .addresses) && (t.addresses = e.addresses.map(e => String(e))), t
                },
                toJSON(e) {
                    let t = {};
                    return e.addresses ? t.addresses = e.addresses.map(e => e) : t.addresses = [], t
                },
                fromPartial(e) {
                    let t = P();
                    return t.addresses = e.addresses ? .map(e => e) || [], t
                }
            }, t.DVPair = {
                typeUrl: "/cosmos.staking.v1beta1.DVPair",
                encode: (e, t = m.BinaryWriter.create()) => ("" !== e.delegatorAddress && t.uint32(10).string(e.delegatorAddress), "" !== e.validatorAddress && t.uint32(18).string(e.validatorAddress), t),
                decode(e, t) {
                    let r = e instanceof m.BinaryReader ? e : new m.BinaryReader(e),
                        n = void 0 === t ? r.len : r.pos + t,
                        o = _();
                    for (; r.pos < n;) {
                        let e = r.uint32();
                        switch (e >>> 3) {
                            case 1:
                                o.delegatorAddress = r.string();
                                break;
                            case 2:
                                o.validatorAddress = r.string();
                                break;
                            default:
                                r.skipType(7 & e)
                        }
                    }
                    return o
                },
                fromJSON(e) {
                    let t = _();
                    return (0, g.isSet)(e.delegatorAddress) && (t.delegatorAddress = String(e.delegatorAddress)), (0, g.isSet)(e.validatorAddress) && (t.validatorAddress = String(e.validatorAddress)), t
                },
                toJSON(e) {
                    let t = {};
                    return void 0 !== e.delegatorAddress && (t.delegatorAddress = e.delegatorAddress), void 0 !== e.validatorAddress && (t.validatorAddress = e.validatorAddress), t
                },
                fromPartial(e) {
                    let t = _();
                    return t.delegatorAddress = e.delegatorAddress ? ? "", t.validatorAddress = e.validatorAddress ? ? "", t
                }
            }, t.DVPairs = {
                typeUrl: "/cosmos.staking.v1beta1.DVPairs",
                encode(e, r = m.BinaryWriter.create()) {
                    for (let n of e.pairs) t.DVPair.encode(n, r.uint32(10).fork()).ldelim();
                    return r
                },
                decode(e, r) {
                    let n = e instanceof m.BinaryReader ? e : new m.BinaryReader(e),
                        o = void 0 === r ? n.len : n.pos + r,
                        i = B();
                    for (; n.pos < o;) {
                        let e = n.uint32();
                        e >>> 3 == 1 ? i.pairs.push(t.DVPair.decode(n, n.uint32())) : n.skipType(7 & e)
                    }
                    return i
                },
                fromJSON(e) {
                    let r = B();
                    return Array.isArray(e ? .pairs) && (r.pairs = e.pairs.map(e => t.DVPair.fromJSON(e))), r
                },
                toJSON(e) {
                    let r = {};
                    return e.pairs ? r.pairs = e.pairs.map(e => e ? t.DVPair.toJSON(e) : void 0) : r.pairs = [], r
                },
                fromPartial(e) {
                    let r = B();
                    return r.pairs = e.pairs ? .map(e => t.DVPair.fromPartial(e)) || [], r
                }
            }, t.DVVTriplet = {
                typeUrl: "/cosmos.staking.v1beta1.DVVTriplet",
                encode: (e, t = m.BinaryWriter.create()) => ("" !== e.delegatorAddress && t.uint32(10).string(e.delegatorAddress), "" !== e.validatorSrcAddress && t.uint32(18).string(e.validatorSrcAddress), "" !== e.validatorDstAddress && t.uint32(26).string(e.validatorDstAddress), t),
                decode(e, t) {
                    let r = e instanceof m.BinaryReader ? e : new m.BinaryReader(e),
                        n = void 0 === t ? r.len : r.pos + t,
                        o = O();
                    for (; r.pos < n;) {
                        let e = r.uint32();
                        switch (e >>> 3) {
                            case 1:
                                o.delegatorAddress = r.string();
                                break;
                            case 2:
                                o.validatorSrcAddress = r.string();
                                break;
                            case 3:
                                o.validatorDstAddress = r.string();
                                break;
                            default:
                                r.skipType(7 & e)
                        }
                    }
                    return o
                },
                fromJSON(e) {
                    let t = O();
                    return (0, g.isSet)(e.delegatorAddress) && (t.delegatorAddress = String(e.delegatorAddress)), (0, g.isSet)(e.validatorSrcAddress) && (t.validatorSrcAddress = String(e.validatorSrcAddress)), (0, g.isSet)(e.validatorDstAddress) && (t.validatorDstAddress = String(e.validatorDstAddress)), t
                },
                toJSON(e) {
                    let t = {};
                    return void 0 !== e.delegatorAddress && (t.delegatorAddress = e.delegatorAddress), void 0 !== e.validatorSrcAddress && (t.validatorSrcAddress = e.validatorSrcAddress), void 0 !== e.validatorDstAddress && (t.validatorDstAddress = e.validatorDstAddress), t
                },
                fromPartial(e) {
                    let t = O();
                    return t.delegatorAddress = e.delegatorAddress ? ? "", t.validatorSrcAddress = e.validatorSrcAddress ? ? "", t.validatorDstAddress = e.validatorDstAddress ? ? "", t
                }
            }, t.DVVTriplets = {
                typeUrl: "/cosmos.staking.v1beta1.DVVTriplets",
                encode(e, r = m.BinaryWriter.create()) {
                    for (let n of e.triplets) t.DVVTriplet.encode(n, r.uint32(10).fork()).ldelim();
                    return r
                },
                decode(e, r) {
                    let n = e instanceof m.BinaryReader ? e : new m.BinaryReader(e),
                        o = void 0 === r ? n.len : n.pos + r,
                        i = R();
                    for (; n.pos < o;) {
                        let e = n.uint32();
                        e >>> 3 == 1 ? i.triplets.push(t.DVVTriplet.decode(n, n.uint32())) : n.skipType(7 & e)
                    }
                    return i
                },
                fromJSON(e) {
                    let r = R();
                    return Array.isArray(e ? .triplets) && (r.triplets = e.triplets.map(e => t.DVVTriplet.fromJSON(e))), r
                },
                toJSON(e) {
                    let r = {};
                    return e.triplets ? r.triplets = e.triplets.map(e => e ? t.DVVTriplet.toJSON(e) : void 0) : r.triplets = [], r
                },
                fromPartial(e) {
                    let r = R();
                    return r.triplets = e.triplets ? .map(e => t.DVVTriplet.fromPartial(e)) || [], r
                }
            }, t.Delegation = {
                typeUrl: "/cosmos.staking.v1beta1.Delegation",
                encode: (e, t = m.BinaryWriter.create()) => ("" !== e.delegatorAddress && t.uint32(10).string(e.delegatorAddress), "" !== e.validatorAddress && t.uint32(18).string(e.validatorAddress), "" !== e.shares && t.uint32(26).string(e.shares), t),
                decode(e, t) {
                    let r = e instanceof m.BinaryReader ? e : new m.BinaryReader(e),
                        n = void 0 === t ? r.len : r.pos + t,
                        o = A();
                    for (; r.pos < n;) {
                        let e = r.uint32();
                        switch (e >>> 3) {
                            case 1:
                                o.delegatorAddress = r.string();
                                break;
                            case 2:
                                o.validatorAddress = r.string();
                                break;
                            case 3:
                                o.shares = r.string();
                                break;
                            default:
                                r.skipType(7 & e)
                        }
                    }
                    return o
                },
                fromJSON(e) {
                    let t = A();
                    return (0, g.isSet)(e.delegatorAddress) && (t.delegatorAddress = String(e.delegatorAddress)), (0, g.isSet)(e.validatorAddress) && (t.validatorAddress = String(e.validatorAddress)), (0, g.isSet)(e.shares) && (t.shares = String(e.shares)), t
                },
                toJSON(e) {
                    let t = {};
                    return void 0 !== e.delegatorAddress && (t.delegatorAddress = e.delegatorAddress), void 0 !== e.validatorAddress && (t.validatorAddress = e.validatorAddress), void 0 !== e.shares && (t.shares = e.shares), t
                },
                fromPartial(e) {
                    let t = A();
                    return t.delegatorAddress = e.delegatorAddress ? ? "", t.validatorAddress = e.validatorAddress ? ? "", t.shares = e.shares ? ? "", t
                }
            }, t.UnbondingDelegation = {
                typeUrl: "/cosmos.staking.v1beta1.UnbondingDelegation",
                encode(e, r = m.BinaryWriter.create()) {
                    for (let n of ("" !== e.delegatorAddress && r.uint32(10).string(e.delegatorAddress), "" !== e.validatorAddress && r.uint32(18).string(e.validatorAddress), e.entries)) t.UnbondingDelegationEntry.encode(n, r.uint32(26).fork()).ldelim();
                    return r
                },
                decode(e, r) {
                    let n = e instanceof m.BinaryReader ? e : new m.BinaryReader(e),
                        o = void 0 === r ? n.len : n.pos + r,
                        i = I();
                    for (; n.pos < o;) {
                        let e = n.uint32();
                        switch (e >>> 3) {
                            case 1:
                                i.delegatorAddress = n.string();
                                break;
                            case 2:
                                i.validatorAddress = n.string();
                                break;
                            case 3:
                                i.entries.push(t.UnbondingDelegationEntry.decode(n, n.uint32()));
                                break;
                            default:
                                n.skipType(7 & e)
                        }
                    }
                    return i
                },
                fromJSON(e) {
                    let r = I();
                    return (0, g.isSet)(e.delegatorAddress) && (r.delegatorAddress = String(e.delegatorAddress)), (0, g.isSet)(e.validatorAddress) && (r.validatorAddress = String(e.validatorAddress)), Array.isArray(e ? .entries) && (r.entries = e.entries.map(e => t.UnbondingDelegationEntry.fromJSON(e))), r
                },
                toJSON(e) {
                    let r = {};
                    return void 0 !== e.delegatorAddress && (r.delegatorAddress = e.delegatorAddress), void 0 !== e.validatorAddress && (r.validatorAddress = e.validatorAddress), e.entries ? r.entries = e.entries.map(e => e ? t.UnbondingDelegationEntry.toJSON(e) : void 0) : r.entries = [], r
                },
                fromPartial(e) {
                    let r = I();
                    return r.delegatorAddress = e.delegatorAddress ? ? "", r.validatorAddress = e.validatorAddress ? ? "", r.entries = e.entries ? .map(e => t.UnbondingDelegationEntry.fromPartial(e)) || [], r
                }
            }, t.UnbondingDelegationEntry = {
                typeUrl: "/cosmos.staking.v1beta1.UnbondingDelegationEntry",
                encode: (e, t = m.BinaryWriter.create()) => (e.creationHeight !== BigInt(0) && t.uint32(8).int64(e.creationHeight), void 0 !== e.completionTime && d.Timestamp.encode(e.completionTime, t.uint32(18).fork()).ldelim(), "" !== e.initialBalance && t.uint32(26).string(e.initialBalance), "" !== e.balance && t.uint32(34).string(e.balance), e.unbondingId !== BigInt(0) && t.uint32(40).uint64(e.unbondingId), e.unbondingOnHoldRefCount !== BigInt(0) && t.uint32(48).int64(e.unbondingOnHoldRefCount), t),
                decode(e, t) {
                    let r = e instanceof m.BinaryReader ? e : new m.BinaryReader(e),
                        n = void 0 === t ? r.len : r.pos + t,
                        o = w();
                    for (; r.pos < n;) {
                        let e = r.uint32();
                        switch (e >>> 3) {
                            case 1:
                                o.creationHeight = r.int64();
                                break;
                            case 2:
                                o.completionTime = d.Timestamp.decode(r, r.uint32());
                                break;
                            case 3:
                                o.initialBalance = r.string();
                                break;
                            case 4:
                                o.balance = r.string();
                                break;
                            case 5:
                                o.unbondingId = r.uint64();
                                break;
                            case 6:
                                o.unbondingOnHoldRefCount = r.int64();
                                break;
                            default:
                                r.skipType(7 & e)
                        }
                    }
                    return o
                },
                fromJSON(e) {
                    let t = w();
                    return (0, g.isSet)(e.creationHeight) && (t.creationHeight = BigInt(e.creationHeight.toString())), (0, g.isSet)(e.completionTime) && (t.completionTime = (0, g.fromJsonTimestamp)(e.completionTime)), (0, g.isSet)(e.initialBalance) && (t.initialBalance = String(e.initialBalance)), (0, g.isSet)(e.balance) && (t.balance = String(e.balance)), (0, g.isSet)(e.unbondingId) && (t.unbondingId = BigInt(e.unbondingId.toString())), (0, g.isSet)(e.unbondingOnHoldRefCount) && (t.unbondingOnHoldRefCount = BigInt(e.unbondingOnHoldRefCount.toString())), t
                },
                toJSON(e) {
                    let t = {};
                    return void 0 !== e.creationHeight && (t.creationHeight = (e.creationHeight || BigInt(0)).toString()), void 0 !== e.completionTime && (t.completionTime = (0, g.fromTimestamp)(e.completionTime).toISOString()), void 0 !== e.initialBalance && (t.initialBalance = e.initialBalance), void 0 !== e.balance && (t.balance = e.balance), void 0 !== e.unbondingId && (t.unbondingId = (e.unbondingId || BigInt(0)).toString()), void 0 !== e.unbondingOnHoldRefCount && (t.unbondingOnHoldRefCount = (e.unbondingOnHoldRefCount || BigInt(0)).toString()), t
                },
                fromPartial(e) {
                    let t = w();
                    return void 0 !== e.creationHeight && null !== e.creationHeight && (t.creationHeight = BigInt(e.creationHeight.toString())), void 0 !== e.completionTime && null !== e.completionTime && (t.completionTime = d.Timestamp.fromPartial(e.completionTime)), t.initialBalance = e.initialBalance ? ? "", t.balance = e.balance ? ? "", void 0 !== e.unbondingId && null !== e.unbondingId && (t.unbondingId = BigInt(e.unbondingId.toString())), void 0 !== e.unbondingOnHoldRefCount && null !== e.unbondingOnHoldRefCount && (t.unbondingOnHoldRefCount = BigInt(e.unbondingOnHoldRefCount.toString())), t
                }
            }, t.RedelegationEntry = {
                typeUrl: "/cosmos.staking.v1beta1.RedelegationEntry",
                encode: (e, t = m.BinaryWriter.create()) => (e.creationHeight !== BigInt(0) && t.uint32(8).int64(e.creationHeight), void 0 !== e.completionTime && d.Timestamp.encode(e.completionTime, t.uint32(18).fork()).ldelim(), "" !== e.initialBalance && t.uint32(26).string(e.initialBalance), "" !== e.sharesDst && t.uint32(34).string(e.sharesDst), e.unbondingId !== BigInt(0) && t.uint32(40).uint64(e.unbondingId), e.unbondingOnHoldRefCount !== BigInt(0) && t.uint32(48).int64(e.unbondingOnHoldRefCount), t),
                decode(e, t) {
                    let r = e instanceof m.BinaryReader ? e : new m.BinaryReader(e),
                        n = void 0 === t ? r.len : r.pos + t,
                        o = T();
                    for (; r.pos < n;) {
                        let e = r.uint32();
                        switch (e >>> 3) {
                            case 1:
                                o.creationHeight = r.int64();
                                break;
                            case 2:
                                o.completionTime = d.Timestamp.decode(r, r.uint32());
                                break;
                            case 3:
                                o.initialBalance = r.string();
                                break;
                            case 4:
                                o.sharesDst = r.string();
                                break;
                            case 5:
                                o.unbondingId = r.uint64();
                                break;
                            case 6:
                                o.unbondingOnHoldRefCount = r.int64();
                                break;
                            default:
                                r.skipType(7 & e)
                        }
                    }
                    return o
                },
                fromJSON(e) {
                    let t = T();
                    return (0, g.isSet)(e.creationHeight) && (t.creationHeight = BigInt(e.creationHeight.toString())), (0, g.isSet)(e.completionTime) && (t.completionTime = (0, g.fromJsonTimestamp)(e.completionTime)), (0, g.isSet)(e.initialBalance) && (t.initialBalance = String(e.initialBalance)), (0, g.isSet)(e.sharesDst) && (t.sharesDst = String(e.sharesDst)), (0, g.isSet)(e.unbondingId) && (t.unbondingId = BigInt(e.unbondingId.toString())), (0, g.isSet)(e.unbondingOnHoldRefCount) && (t.unbondingOnHoldRefCount = BigInt(e.unbondingOnHoldRefCount.toString())), t
                },
                toJSON(e) {
                    let t = {};
                    return void 0 !== e.creationHeight && (t.creationHeight = (e.creationHeight || BigInt(0)).toString()), void 0 !== e.completionTime && (t.completionTime = (0, g.fromTimestamp)(e.completionTime).toISOString()), void 0 !== e.initialBalance && (t.initialBalance = e.initialBalance), void 0 !== e.sharesDst && (t.sharesDst = e.sharesDst), void 0 !== e.unbondingId && (t.unbondingId = (e.unbondingId || BigInt(0)).toString()), void 0 !== e.unbondingOnHoldRefCount && (t.unbondingOnHoldRefCount = (e.unbondingOnHoldRefCount || BigInt(0)).toString()), t
                },
                fromPartial(e) {
                    let t = T();
                    return void 0 !== e.creationHeight && null !== e.creationHeight && (t.creationHeight = BigInt(e.creationHeight.toString())), void 0 !== e.completionTime && null !== e.completionTime && (t.completionTime = d.Timestamp.fromPartial(e.completionTime)), t.initialBalance = e.initialBalance ? ? "", t.sharesDst = e.sharesDst ? ? "", void 0 !== e.unbondingId && null !== e.unbondingId && (t.unbondingId = BigInt(e.unbondingId.toString())), void 0 !== e.unbondingOnHoldRefCount && null !== e.unbondingOnHoldRefCount && (t.unbondingOnHoldRefCount = BigInt(e.unbondingOnHoldRefCount.toString())), t
                }
            }, t.Redelegation = {
                typeUrl: "/cosmos.staking.v1beta1.Redelegation",
                encode(e, r = m.BinaryWriter.create()) {
                    for (let n of ("" !== e.delegatorAddress && r.uint32(10).string(e.delegatorAddress), "" !== e.validatorSrcAddress && r.uint32(18).string(e.validatorSrcAddress), "" !== e.validatorDstAddress && r.uint32(26).string(e.validatorDstAddress), e.entries)) t.RedelegationEntry.encode(n, r.uint32(34).fork()).ldelim();
                    return r
                },
                decode(e, r) {
                    let n = e instanceof m.BinaryReader ? e : new m.BinaryReader(e),
                        o = void 0 === r ? n.len : n.pos + r,
                        i = N();
                    for (; n.pos < o;) {
                        let e = n.uint32();
                        switch (e >>> 3) {
                            case 1:
                                i.delegatorAddress = n.string();
                                break;
                            case 2:
                                i.validatorSrcAddress = n.string();
                                break;
                            case 3:
                                i.validatorDstAddress = n.string();
                                break;
                            case 4:
                                i.entries.push(t.RedelegationEntry.decode(n, n.uint32()));
                                break;
                            default:
                                n.skipType(7 & e)
                        }
                    }
                    return i
                },
                fromJSON(e) {
                    let r = N();
                    return (0, g.isSet)(e.delegatorAddress) && (r.delegatorAddress = String(e.delegatorAddress)), (0, g.isSet)(e.validatorSrcAddress) && (r.validatorSrcAddress = String(e.validatorSrcAddress)), (0, g.isSet)(e.validatorDstAddress) && (r.validatorDstAddress = String(e.validatorDstAddress)), Array.isArray(e ? .entries) && (r.entries = e.entries.map(e => t.RedelegationEntry.fromJSON(e))), r
                },
                toJSON(e) {
                    let r = {};
                    return void 0 !== e.delegatorAddress && (r.delegatorAddress = e.delegatorAddress), void 0 !== e.validatorSrcAddress && (r.validatorSrcAddress = e.validatorSrcAddress), void 0 !== e.validatorDstAddress && (r.validatorDstAddress = e.validatorDstAddress), e.entries ? r.entries = e.entries.map(e => e ? t.RedelegationEntry.toJSON(e) : void 0) : r.entries = [], r
                },
                fromPartial(e) {
                    let r = N();
                    return r.delegatorAddress = e.delegatorAddress ? ? "", r.validatorSrcAddress = e.validatorSrcAddress ? ? "", r.validatorDstAddress = e.validatorDstAddress ? ? "", r.entries = e.entries ? .map(e => t.RedelegationEntry.fromPartial(e)) || [], r
                }
            }, t.Params = {
                typeUrl: "/cosmos.staking.v1beta1.Params",
                encode: (e, t = m.BinaryWriter.create()) => (void 0 !== e.unbondingTime && l.Duration.encode(e.unbondingTime, t.uint32(10).fork()).ldelim(), 0 !== e.maxValidators && t.uint32(16).uint32(e.maxValidators), 0 !== e.maxEntries && t.uint32(24).uint32(e.maxEntries), 0 !== e.historicalEntries && t.uint32(32).uint32(e.historicalEntries), "" !== e.bondDenom && t.uint32(42).string(e.bondDenom), "" !== e.minCommissionRate && t.uint32(50).string(e.minCommissionRate), t),
                decode(e, t) {
                    let r = e instanceof m.BinaryReader ? e : new m.BinaryReader(e),
                        n = void 0 === t ? r.len : r.pos + t,
                        o = C();
                    for (; r.pos < n;) {
                        let e = r.uint32();
                        switch (e >>> 3) {
                            case 1:
                                o.unbondingTime = l.Duration.decode(r, r.uint32());
                                break;
                            case 2:
                                o.maxValidators = r.uint32();
                                break;
                            case 3:
                                o.maxEntries = r.uint32();
                                break;
                            case 4:
                                o.historicalEntries = r.uint32();
                                break;
                            case 5:
                                o.bondDenom = r.string();
                                break;
                            case 6:
                                o.minCommissionRate = r.string();
                                break;
                            default:
                                r.skipType(7 & e)
                        }
                    }
                    return o
                },
                fromJSON(e) {
                    let t = C();
                    return (0, g.isSet)(e.unbondingTime) && (t.unbondingTime = l.Duration.fromJSON(e.unbondingTime)), (0, g.isSet)(e.maxValidators) && (t.maxValidators = Number(e.maxValidators)), (0, g.isSet)(e.maxEntries) && (t.maxEntries = Number(e.maxEntries)), (0, g.isSet)(e.historicalEntries) && (t.historicalEntries = Number(e.historicalEntries)), (0, g.isSet)(e.bondDenom) && (t.bondDenom = String(e.bondDenom)), (0, g.isSet)(e.minCommissionRate) && (t.minCommissionRate = String(e.minCommissionRate)), t
                },
                toJSON(e) {
                    let t = {};
                    return void 0 !== e.unbondingTime && (t.unbondingTime = e.unbondingTime ? l.Duration.toJSON(e.unbondingTime) : void 0), void 0 !== e.maxValidators && (t.maxValidators = Math.round(e.maxValidators)), void 0 !== e.maxEntries && (t.maxEntries = Math.round(e.maxEntries)), void 0 !== e.historicalEntries && (t.historicalEntries = Math.round(e.historicalEntries)), void 0 !== e.bondDenom && (t.bondDenom = e.bondDenom), void 0 !== e.minCommissionRate && (t.minCommissionRate = e.minCommissionRate), t
                },
                fromPartial(e) {
                    let t = C();
                    return void 0 !== e.unbondingTime && null !== e.unbondingTime && (t.unbondingTime = l.Duration.fromPartial(e.unbondingTime)), t.maxValidators = e.maxValidators ? ? 0, t.maxEntries = e.maxEntries ? ? 0, t.historicalEntries = e.historicalEntries ? ? 0, t.bondDenom = e.bondDenom ? ? "", t.minCommissionRate = e.minCommissionRate ? ? "", t
                }
            }, t.DelegationResponse = {
                typeUrl: "/cosmos.staking.v1beta1.DelegationResponse",
                encode: (e, r = m.BinaryWriter.create()) => (void 0 !== e.delegation && t.Delegation.encode(e.delegation, r.uint32(10).fork()).ldelim(), void 0 !== e.balance && u.Coin.encode(e.balance, r.uint32(18).fork()).ldelim(), r),
                decode(e, r) {
                    let n = e instanceof m.BinaryReader ? e : new m.BinaryReader(e),
                        o = void 0 === r ? n.len : n.pos + r,
                        i = E();
                    for (; n.pos < o;) {
                        let e = n.uint32();
                        switch (e >>> 3) {
                            case 1:
                                i.delegation = t.Delegation.decode(n, n.uint32());
                                break;
                            case 2:
                                i.balance = u.Coin.decode(n, n.uint32());
                                break;
                            default:
                                n.skipType(7 & e)
                        }
                    }
                    return i
                },
                fromJSON(e) {
                    let r = E();
                    return (0, g.isSet)(e.delegation) && (r.delegation = t.Delegation.fromJSON(e.delegation)), (0, g.isSet)(e.balance) && (r.balance = u.Coin.fromJSON(e.balance)), r
                },
                toJSON(e) {
                    let r = {};
                    return void 0 !== e.delegation && (r.delegation = e.delegation ? t.Delegation.toJSON(e.delegation) : void 0), void 0 !== e.balance && (r.balance = e.balance ? u.Coin.toJSON(e.balance) : void 0), r
                },
                fromPartial(e) {
                    let r = E();
                    return void 0 !== e.delegation && null !== e.delegation && (r.delegation = t.Delegation.fromPartial(e.delegation)), void 0 !== e.balance && null !== e.balance && (r.balance = u.Coin.fromPartial(e.balance)), r
                }
            }, t.RedelegationEntryResponse = {
                typeUrl: "/cosmos.staking.v1beta1.RedelegationEntryResponse",
                encode: (e, r = m.BinaryWriter.create()) => (void 0 !== e.redelegationEntry && t.RedelegationEntry.encode(e.redelegationEntry, r.uint32(10).fork()).ldelim(), "" !== e.balance && r.uint32(34).string(e.balance), r),
                decode(e, r) {
                    let n = e instanceof m.BinaryReader ? e : new m.BinaryReader(e),
                        o = void 0 === r ? n.len : n.pos + r,
                        i = x();
                    for (; n.pos < o;) {
                        let e = n.uint32();
                        switch (e >>> 3) {
                            case 1:
                                i.redelegationEntry = t.RedelegationEntry.decode(n, n.uint32());
                                break;
                            case 4:
                                i.balance = n.string();
                                break;
                            default:
                                n.skipType(7 & e)
                        }
                    }
                    return i
                },
                fromJSON(e) {
                    let r = x();
                    return (0, g.isSet)(e.redelegationEntry) && (r.redelegationEntry = t.RedelegationEntry.fromJSON(e.redelegationEntry)), (0, g.isSet)(e.balance) && (r.balance = String(e.balance)), r
                },
                toJSON(e) {
                    let r = {};
                    return void 0 !== e.redelegationEntry && (r.redelegationEntry = e.redelegationEntry ? t.RedelegationEntry.toJSON(e.redelegationEntry) : void 0), void 0 !== e.balance && (r.balance = e.balance), r
                },
                fromPartial(e) {
                    let r = x();
                    return void 0 !== e.redelegationEntry && null !== e.redelegationEntry && (r.redelegationEntry = t.RedelegationEntry.fromPartial(e.redelegationEntry)), r.balance = e.balance ? ? "", r
                }
            }, t.RedelegationResponse = {
                typeUrl: "/cosmos.staking.v1beta1.RedelegationResponse",
                encode(e, r = m.BinaryWriter.create()) {
                    for (let n of (void 0 !== e.redelegation && t.Redelegation.encode(e.redelegation, r.uint32(10).fork()).ldelim(), e.entries)) t.RedelegationEntryResponse.encode(n, r.uint32(18).fork()).ldelim();
                    return r
                },
                decode(e, r) {
                    let n = e instanceof m.BinaryReader ? e : new m.BinaryReader(e),
                        o = void 0 === r ? n.len : n.pos + r,
                        i = U();
                    for (; n.pos < o;) {
                        let e = n.uint32();
                        switch (e >>> 3) {
                            case 1:
                                i.redelegation = t.Redelegation.decode(n, n.uint32());
                                break;
                            case 2:
                                i.entries.push(t.RedelegationEntryResponse.decode(n, n.uint32()));
                                break;
                            default:
                                n.skipType(7 & e)
                        }
                    }
                    return i
                },
                fromJSON(e) {
                    let r = U();
                    return (0, g.isSet)(e.redelegation) && (r.redelegation = t.Redelegation.fromJSON(e.redelegation)), Array.isArray(e ? .entries) && (r.entries = e.entries.map(e => t.RedelegationEntryResponse.fromJSON(e))), r
                },
                toJSON(e) {
                    let r = {};
                    return void 0 !== e.redelegation && (r.redelegation = e.redelegation ? t.Redelegation.toJSON(e.redelegation) : void 0), e.entries ? r.entries = e.entries.map(e => e ? t.RedelegationEntryResponse.toJSON(e) : void 0) : r.entries = [], r
                },
                fromPartial(e) {
                    let r = U();
                    return void 0 !== e.redelegation && null !== e.redelegation && (r.redelegation = t.Redelegation.fromPartial(e.redelegation)), r.entries = e.entries ? .map(e => t.RedelegationEntryResponse.fromPartial(e)) || [], r
                }
            }, t.Pool = {
                typeUrl: "/cosmos.staking.v1beta1.Pool",
                encode: (e, t = m.BinaryWriter.create()) => ("" !== e.notBondedTokens && t.uint32(10).string(e.notBondedTokens), "" !== e.bondedTokens && t.uint32(18).string(e.bondedTokens), t),
                decode(e, t) {
                    let r = e instanceof m.BinaryReader ? e : new m.BinaryReader(e),
                        n = void 0 === t ? r.len : r.pos + t,
                        o = D();
                    for (; r.pos < n;) {
                        let e = r.uint32();
                        switch (e >>> 3) {
                            case 1:
                                o.notBondedTokens = r.string();
                                break;
                            case 2:
                                o.bondedTokens = r.string();
                                break;
                            default:
                                r.skipType(7 & e)
                        }
                    }
                    return o
                },
                fromJSON(e) {
                    let t = D();
                    return (0, g.isSet)(e.notBondedTokens) && (t.notBondedTokens = String(e.notBondedTokens)), (0, g.isSet)(e.bondedTokens) && (t.bondedTokens = String(e.bondedTokens)), t
                },
                toJSON(e) {
                    let t = {};
                    return void 0 !== e.notBondedTokens && (t.notBondedTokens = e.notBondedTokens), void 0 !== e.bondedTokens && (t.bondedTokens = e.bondedTokens), t
                },
                fromPartial(e) {
                    let t = D();
                    return t.notBondedTokens = e.notBondedTokens ? ? "", t.bondedTokens = e.bondedTokens ? ? "", t
                }
            }, t.ValidatorUpdates = {
                typeUrl: "/cosmos.staking.v1beta1.ValidatorUpdates",
                encode(e, t = m.BinaryWriter.create()) {
                    for (let r of e.updates) p.ValidatorUpdate.encode(r, t.uint32(10).fork()).ldelim();
                    return t
                },
                decode(e, t) {
                    let r = e instanceof m.BinaryReader ? e : new m.BinaryReader(e),
                        n = void 0 === t ? r.len : r.pos + t,
                        o = M();
                    for (; r.pos < n;) {
                        let e = r.uint32();
                        e >>> 3 == 1 ? o.updates.push(p.ValidatorUpdate.decode(r, r.uint32())) : r.skipType(7 & e)
                    }
                    return o
                },
                fromJSON(e) {
                    let t = M();
                    return Array.isArray(e ? .updates) && (t.updates = e.updates.map(e => p.ValidatorUpdate.fromJSON(e))), t
                },
                toJSON(e) {
                    let t = {};
                    return e.updates ? t.updates = e.updates.map(e => e ? p.ValidatorUpdate.toJSON(e) : void 0) : t.updates = [], t
                },
                fromPartial(e) {
                    let t = M();
                    return t.updates = e.updates ? .map(e => p.ValidatorUpdate.fromPartial(e)) || [], t
                }
            }
        },
        7897: function(e, t, r) {
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: !0
            }), t.MsgClientImpl = t.MsgUpdateParamsResponse = t.MsgUpdateParams = t.MsgCancelUnbondingDelegationResponse = t.MsgCancelUnbondingDelegation = t.MsgUndelegateResponse = t.MsgUndelegate = t.MsgBeginRedelegateResponse = t.MsgBeginRedelegate = t.MsgDelegateResponse = t.MsgDelegate = t.MsgEditValidatorResponse = t.MsgEditValidator = t.MsgCreateValidatorResponse = t.MsgCreateValidator = t.protobufPackage = void 0;
            let n = r(93508),
                o = r(65676),
                i = r(62809),
                a = r(90614),
                s = r(28486),
                d = r(6476);

            function c() {
                return {
                    description: n.Description.fromPartial({}),
                    commission: n.CommissionRates.fromPartial({}),
                    minSelfDelegation: "",
                    delegatorAddress: "",
                    validatorAddress: "",
                    pubkey: void 0,
                    value: i.Coin.fromPartial({})
                }
            }

            function l() {
                return {
                    description: n.Description.fromPartial({}),
                    validatorAddress: "",
                    commissionRate: "",
                    minSelfDelegation: ""
                }
            }

            function u() {
                return {
                    delegatorAddress: "",
                    validatorAddress: "",
                    amount: i.Coin.fromPartial({})
                }
            }

            function p() {
                return {
                    delegatorAddress: "",
                    validatorSrcAddress: "",
                    validatorDstAddress: "",
                    amount: i.Coin.fromPartial({})
                }
            }

            function m() {
                return {
                    completionTime: a.Timestamp.fromPartial({})
                }
            }

            function g() {
                return {
                    delegatorAddress: "",
                    validatorAddress: "",
                    amount: i.Coin.fromPartial({})
                }
            }

            function f() {
                return {
                    completionTime: a.Timestamp.fromPartial({})
                }
            }

            function y() {
                return {
                    delegatorAddress: "",
                    validatorAddress: "",
                    amount: i.Coin.fromPartial({}),
                    creationHeight: BigInt(0)
                }
            }

            function h() {
                return {
                    authority: "",
                    params: n.Params.fromPartial({})
                }
            }
            t.protobufPackage = "cosmos.staking.v1beta1", t.MsgCreateValidator = {
                typeUrl: "/cosmos.staking.v1beta1.MsgCreateValidator",
                encode: (e, t = s.BinaryWriter.create()) => (void 0 !== e.description && n.Description.encode(e.description, t.uint32(10).fork()).ldelim(), void 0 !== e.commission && n.CommissionRates.encode(e.commission, t.uint32(18).fork()).ldelim(), "" !== e.minSelfDelegation && t.uint32(26).string(e.minSelfDelegation), "" !== e.delegatorAddress && t.uint32(34).string(e.delegatorAddress), "" !== e.validatorAddress && t.uint32(42).string(e.validatorAddress), void 0 !== e.pubkey && o.Any.encode(e.pubkey, t.uint32(50).fork()).ldelim(), void 0 !== e.value && i.Coin.encode(e.value, t.uint32(58).fork()).ldelim(), t),
                decode(e, t) {
                    let r = e instanceof s.BinaryReader ? e : new s.BinaryReader(e),
                        a = void 0 === t ? r.len : r.pos + t,
                        d = c();
                    for (; r.pos < a;) {
                        let e = r.uint32();
                        switch (e >>> 3) {
                            case 1:
                                d.description = n.Description.decode(r, r.uint32());
                                break;
                            case 2:
                                d.commission = n.CommissionRates.decode(r, r.uint32());
                                break;
                            case 3:
                                d.minSelfDelegation = r.string();
                                break;
                            case 4:
                                d.delegatorAddress = r.string();
                                break;
                            case 5:
                                d.validatorAddress = r.string();
                                break;
                            case 6:
                                d.pubkey = o.Any.decode(r, r.uint32());
                                break;
                            case 7:
                                d.value = i.Coin.decode(r, r.uint32());
                                break;
                            default:
                                r.skipType(7 & e)
                        }
                    }
                    return d
                },
                fromJSON(e) {
                    let t = c();
                    return (0, d.isSet)(e.description) && (t.description = n.Description.fromJSON(e.description)), (0, d.isSet)(e.commission) && (t.commission = n.CommissionRates.fromJSON(e.commission)), (0, d.isSet)(e.minSelfDelegation) && (t.minSelfDelegation = String(e.minSelfDelegation)), (0, d.isSet)(e.delegatorAddress) && (t.delegatorAddress = String(e.delegatorAddress)), (0, d.isSet)(e.validatorAddress) && (t.validatorAddress = String(e.validatorAddress)), (0, d.isSet)(e.pubkey) && (t.pubkey = o.Any.fromJSON(e.pubkey)), (0, d.isSet)(e.value) && (t.value = i.Coin.fromJSON(e.value)), t
                },
                toJSON(e) {
                    let t = {};
                    return void 0 !== e.description && (t.description = e.description ? n.Description.toJSON(e.description) : void 0), void 0 !== e.commission && (t.commission = e.commission ? n.CommissionRates.toJSON(e.commission) : void 0), void 0 !== e.minSelfDelegation && (t.minSelfDelegation = e.minSelfDelegation), void 0 !== e.delegatorAddress && (t.delegatorAddress = e.delegatorAddress), void 0 !== e.validatorAddress && (t.validatorAddress = e.validatorAddress), void 0 !== e.pubkey && (t.pubkey = e.pubkey ? o.Any.toJSON(e.pubkey) : void 0), void 0 !== e.value && (t.value = e.value ? i.Coin.toJSON(e.value) : void 0), t
                },
                fromPartial(e) {
                    let t = c();
                    return void 0 !== e.description && null !== e.description && (t.description = n.Description.fromPartial(e.description)), void 0 !== e.commission && null !== e.commission && (t.commission = n.CommissionRates.fromPartial(e.commission)), t.minSelfDelegation = e.minSelfDelegation ? ? "", t.delegatorAddress = e.delegatorAddress ? ? "", t.validatorAddress = e.validatorAddress ? ? "", void 0 !== e.pubkey && null !== e.pubkey && (t.pubkey = o.Any.fromPartial(e.pubkey)), void 0 !== e.value && null !== e.value && (t.value = i.Coin.fromPartial(e.value)), t
                }
            }, t.MsgCreateValidatorResponse = {
                typeUrl: "/cosmos.staking.v1beta1.MsgCreateValidatorResponse",
                encode: (e, t = s.BinaryWriter.create()) => t,
                decode(e, t) {
                    let r = e instanceof s.BinaryReader ? e : new s.BinaryReader(e),
                        n = void 0 === t ? r.len : r.pos + t;
                    for (; r.pos < n;) {
                        let e = r.uint32();
                        r.skipType(7 & e)
                    }
                    return {}
                },
                fromJSON: e => ({}),
                toJSON: e => ({}),
                fromPartial: e => ({})
            }, t.MsgEditValidator = {
                typeUrl: "/cosmos.staking.v1beta1.MsgEditValidator",
                encode: (e, t = s.BinaryWriter.create()) => (void 0 !== e.description && n.Description.encode(e.description, t.uint32(10).fork()).ldelim(), "" !== e.validatorAddress && t.uint32(18).string(e.validatorAddress), "" !== e.commissionRate && t.uint32(26).string(e.commissionRate), "" !== e.minSelfDelegation && t.uint32(34).string(e.minSelfDelegation), t),
                decode(e, t) {
                    let r = e instanceof s.BinaryReader ? e : new s.BinaryReader(e),
                        o = void 0 === t ? r.len : r.pos + t,
                        i = l();
                    for (; r.pos < o;) {
                        let e = r.uint32();
                        switch (e >>> 3) {
                            case 1:
                                i.description = n.Description.decode(r, r.uint32());
                                break;
                            case 2:
                                i.validatorAddress = r.string();
                                break;
                            case 3:
                                i.commissionRate = r.string();
                                break;
                            case 4:
                                i.minSelfDelegation = r.string();
                                break;
                            default:
                                r.skipType(7 & e)
                        }
                    }
                    return i
                },
                fromJSON(e) {
                    let t = l();
                    return (0, d.isSet)(e.description) && (t.description = n.Description.fromJSON(e.description)), (0, d.isSet)(e.validatorAddress) && (t.validatorAddress = String(e.validatorAddress)), (0, d.isSet)(e.commissionRate) && (t.commissionRate = String(e.commissionRate)), (0, d.isSet)(e.minSelfDelegation) && (t.minSelfDelegation = String(e.minSelfDelegation)), t
                },
                toJSON(e) {
                    let t = {};
                    return void 0 !== e.description && (t.description = e.description ? n.Description.toJSON(e.description) : void 0), void 0 !== e.validatorAddress && (t.validatorAddress = e.validatorAddress), void 0 !== e.commissionRate && (t.commissionRate = e.commissionRate), void 0 !== e.minSelfDelegation && (t.minSelfDelegation = e.minSelfDelegation), t
                },
                fromPartial(e) {
                    let t = l();
                    return void 0 !== e.description && null !== e.description && (t.description = n.Description.fromPartial(e.description)), t.validatorAddress = e.validatorAddress ? ? "", t.commissionRate = e.commissionRate ? ? "", t.minSelfDelegation = e.minSelfDelegation ? ? "", t
                }
            }, t.MsgEditValidatorResponse = {
                typeUrl: "/cosmos.staking.v1beta1.MsgEditValidatorResponse",
                encode: (e, t = s.BinaryWriter.create()) => t,
                decode(e, t) {
                    let r = e instanceof s.BinaryReader ? e : new s.BinaryReader(e),
                        n = void 0 === t ? r.len : r.pos + t;
                    for (; r.pos < n;) {
                        let e = r.uint32();
                        r.skipType(7 & e)
                    }
                    return {}
                },
                fromJSON: e => ({}),
                toJSON: e => ({}),
                fromPartial: e => ({})
            }, t.MsgDelegate = {
                typeUrl: "/cosmos.staking.v1beta1.MsgDelegate",
                encode: (e, t = s.BinaryWriter.create()) => ("" !== e.delegatorAddress && t.uint32(10).string(e.delegatorAddress), "" !== e.validatorAddress && t.uint32(18).string(e.validatorAddress), void 0 !== e.amount && i.Coin.encode(e.amount, t.uint32(26).fork()).ldelim(), t),
                decode(e, t) {
                    let r = e instanceof s.BinaryReader ? e : new s.BinaryReader(e),
                        n = void 0 === t ? r.len : r.pos + t,
                        o = u();
                    for (; r.pos < n;) {
                        let e = r.uint32();
                        switch (e >>> 3) {
                            case 1:
                                o.delegatorAddress = r.string();
                                break;
                            case 2:
                                o.validatorAddress = r.string();
                                break;
                            case 3:
                                o.amount = i.Coin.decode(r, r.uint32());
                                break;
                            default:
                                r.skipType(7 & e)
                        }
                    }
                    return o
                },
                fromJSON(e) {
                    let t = u();
                    return (0, d.isSet)(e.delegatorAddress) && (t.delegatorAddress = String(e.delegatorAddress)), (0, d.isSet)(e.validatorAddress) && (t.validatorAddress = String(e.validatorAddress)), (0, d.isSet)(e.amount) && (t.amount = i.Coin.fromJSON(e.amount)), t
                },
                toJSON(e) {
                    let t = {};
                    return void 0 !== e.delegatorAddress && (t.delegatorAddress = e.delegatorAddress), void 0 !== e.validatorAddress && (t.validatorAddress = e.validatorAddress), void 0 !== e.amount && (t.amount = e.amount ? i.Coin.toJSON(e.amount) : void 0), t
                },
                fromPartial(e) {
                    let t = u();
                    return t.delegatorAddress = e.delegatorAddress ? ? "", t.validatorAddress = e.validatorAddress ? ? "", void 0 !== e.amount && null !== e.amount && (t.amount = i.Coin.fromPartial(e.amount)), t
                }
            }, t.MsgDelegateResponse = {
                typeUrl: "/cosmos.staking.v1beta1.MsgDelegateResponse",
                encode: (e, t = s.BinaryWriter.create()) => t,
                decode(e, t) {
                    let r = e instanceof s.BinaryReader ? e : new s.BinaryReader(e),
                        n = void 0 === t ? r.len : r.pos + t;
                    for (; r.pos < n;) {
                        let e = r.uint32();
                        r.skipType(7 & e)
                    }
                    return {}
                },
                fromJSON: e => ({}),
                toJSON: e => ({}),
                fromPartial: e => ({})
            }, t.MsgBeginRedelegate = {
                typeUrl: "/cosmos.staking.v1beta1.MsgBeginRedelegate",
                encode: (e, t = s.BinaryWriter.create()) => ("" !== e.delegatorAddress && t.uint32(10).string(e.delegatorAddress), "" !== e.validatorSrcAddress && t.uint32(18).string(e.validatorSrcAddress), "" !== e.validatorDstAddress && t.uint32(26).string(e.validatorDstAddress), void 0 !== e.amount && i.Coin.encode(e.amount, t.uint32(34).fork()).ldelim(), t),
                decode(e, t) {
                    let r = e instanceof s.BinaryReader ? e : new s.BinaryReader(e),
                        n = void 0 === t ? r.len : r.pos + t,
                        o = p();
                    for (; r.pos < n;) {
                        let e = r.uint32();
                        switch (e >>> 3) {
                            case 1:
                                o.delegatorAddress = r.string();
                                break;
                            case 2:
                                o.validatorSrcAddress = r.string();
                                break;
                            case 3:
                                o.validatorDstAddress = r.string();
                                break;
                            case 4:
                                o.amount = i.Coin.decode(r, r.uint32());
                                break;
                            default:
                                r.skipType(7 & e)
                        }
                    }
                    return o
                },
                fromJSON(e) {
                    let t = p();
                    return (0, d.isSet)(e.delegatorAddress) && (t.delegatorAddress = String(e.delegatorAddress)), (0, d.isSet)(e.validatorSrcAddress) && (t.validatorSrcAddress = String(e.validatorSrcAddress)), (0, d.isSet)(e.validatorDstAddress) && (t.validatorDstAddress = String(e.validatorDstAddress)), (0, d.isSet)(e.amount) && (t.amount = i.Coin.fromJSON(e.amount)), t
                },
                toJSON(e) {
                    let t = {};
                    return void 0 !== e.delegatorAddress && (t.delegatorAddress = e.delegatorAddress), void 0 !== e.validatorSrcAddress && (t.validatorSrcAddress = e.validatorSrcAddress), void 0 !== e.validatorDstAddress && (t.validatorDstAddress = e.validatorDstAddress), void 0 !== e.amount && (t.amount = e.amount ? i.Coin.toJSON(e.amount) : void 0), t
                },
                fromPartial(e) {
                    let t = p();
                    return t.delegatorAddress = e.delegatorAddress ? ? "", t.validatorSrcAddress = e.validatorSrcAddress ? ? "", t.validatorDstAddress = e.validatorDstAddress ? ? "", void 0 !== e.amount && null !== e.amount && (t.amount = i.Coin.fromPartial(e.amount)), t
                }
            }, t.MsgBeginRedelegateResponse = {
                typeUrl: "/cosmos.staking.v1beta1.MsgBeginRedelegateResponse",
                encode: (e, t = s.BinaryWriter.create()) => (void 0 !== e.completionTime && a.Timestamp.encode(e.completionTime, t.uint32(10).fork()).ldelim(), t),
                decode(e, t) {
                    let r = e instanceof s.BinaryReader ? e : new s.BinaryReader(e),
                        n = void 0 === t ? r.len : r.pos + t,
                        o = m();
                    for (; r.pos < n;) {
                        let e = r.uint32();
                        e >>> 3 == 1 ? o.completionTime = a.Timestamp.decode(r, r.uint32()) : r.skipType(7 & e)
                    }
                    return o
                },
                fromJSON(e) {
                    let t = m();
                    return (0, d.isSet)(e.completionTime) && (t.completionTime = (0, d.fromJsonTimestamp)(e.completionTime)), t
                },
                toJSON(e) {
                    let t = {};
                    return void 0 !== e.completionTime && (t.completionTime = (0, d.fromTimestamp)(e.completionTime).toISOString()), t
                },
                fromPartial(e) {
                    let t = m();
                    return void 0 !== e.completionTime && null !== e.completionTime && (t.completionTime = a.Timestamp.fromPartial(e.completionTime)), t
                }
            }, t.MsgUndelegate = {
                typeUrl: "/cosmos.staking.v1beta1.MsgUndelegate",
                encode: (e, t = s.BinaryWriter.create()) => ("" !== e.delegatorAddress && t.uint32(10).string(e.delegatorAddress), "" !== e.validatorAddress && t.uint32(18).string(e.validatorAddress), void 0 !== e.amount && i.Coin.encode(e.amount, t.uint32(26).fork()).ldelim(), t),
                decode(e, t) {
                    let r = e instanceof s.BinaryReader ? e : new s.BinaryReader(e),
                        n = void 0 === t ? r.len : r.pos + t,
                        o = g();
                    for (; r.pos < n;) {
                        let e = r.uint32();
                        switch (e >>> 3) {
                            case 1:
                                o.delegatorAddress = r.string();
                                break;
                            case 2:
                                o.validatorAddress = r.string();
                                break;
                            case 3:
                                o.amount = i.Coin.decode(r, r.uint32());
                                break;
                            default:
                                r.skipType(7 & e)
                        }
                    }
                    return o
                },
                fromJSON(e) {
                    let t = g();
                    return (0, d.isSet)(e.delegatorAddress) && (t.delegatorAddress = String(e.delegatorAddress)), (0, d.isSet)(e.validatorAddress) && (t.validatorAddress = String(e.validatorAddress)), (0, d.isSet)(e.amount) && (t.amount = i.Coin.fromJSON(e.amount)), t
                },
                toJSON(e) {
                    let t = {};
                    return void 0 !== e.delegatorAddress && (t.delegatorAddress = e.delegatorAddress), void 0 !== e.validatorAddress && (t.validatorAddress = e.validatorAddress), void 0 !== e.amount && (t.amount = e.amount ? i.Coin.toJSON(e.amount) : void 0), t
                },
                fromPartial(e) {
                    let t = g();
                    return t.delegatorAddress = e.delegatorAddress ? ? "", t.validatorAddress = e.validatorAddress ? ? "", void 0 !== e.amount && null !== e.amount && (t.amount = i.Coin.fromPartial(e.amount)), t
                }
            }, t.MsgUndelegateResponse = {
                typeUrl: "/cosmos.staking.v1beta1.MsgUndelegateResponse",
                encode: (e, t = s.BinaryWriter.create()) => (void 0 !== e.completionTime && a.Timestamp.encode(e.completionTime, t.uint32(10).fork()).ldelim(), t),
                decode(e, t) {
                    let r = e instanceof s.BinaryReader ? e : new s.BinaryReader(e),
                        n = void 0 === t ? r.len : r.pos + t,
                        o = f();
                    for (; r.pos < n;) {
                        let e = r.uint32();
                        e >>> 3 == 1 ? o.completionTime = a.Timestamp.decode(r, r.uint32()) : r.skipType(7 & e)
                    }
                    return o
                },
                fromJSON(e) {
                    let t = f();
                    return (0, d.isSet)(e.completionTime) && (t.completionTime = (0, d.fromJsonTimestamp)(e.completionTime)), t
                },
                toJSON(e) {
                    let t = {};
                    return void 0 !== e.completionTime && (t.completionTime = (0, d.fromTimestamp)(e.completionTime).toISOString()), t
                },
                fromPartial(e) {
                    let t = f();
                    return void 0 !== e.completionTime && null !== e.completionTime && (t.completionTime = a.Timestamp.fromPartial(e.completionTime)), t
                }
            }, t.MsgCancelUnbondingDelegation = {
                typeUrl: "/cosmos.staking.v1beta1.MsgCancelUnbondingDelegation",
                encode: (e, t = s.BinaryWriter.create()) => ("" !== e.delegatorAddress && t.uint32(10).string(e.delegatorAddress), "" !== e.validatorAddress && t.uint32(18).string(e.validatorAddress), void 0 !== e.amount && i.Coin.encode(e.amount, t.uint32(26).fork()).ldelim(), e.creationHeight !== BigInt(0) && t.uint32(32).int64(e.creationHeight), t),
                decode(e, t) {
                    let r = e instanceof s.BinaryReader ? e : new s.BinaryReader(e),
                        n = void 0 === t ? r.len : r.pos + t,
                        o = y();
                    for (; r.pos < n;) {
                        let e = r.uint32();
                        switch (e >>> 3) {
                            case 1:
                                o.delegatorAddress = r.string();
                                break;
                            case 2:
                                o.validatorAddress = r.string();
                                break;
                            case 3:
                                o.amount = i.Coin.decode(r, r.uint32());
                                break;
                            case 4:
                                o.creationHeight = r.int64();
                                break;
                            default:
                                r.skipType(7 & e)
                        }
                    }
                    return o
                },
                fromJSON(e) {
                    let t = y();
                    return (0, d.isSet)(e.delegatorAddress) && (t.delegatorAddress = String(e.delegatorAddress)), (0, d.isSet)(e.validatorAddress) && (t.validatorAddress = String(e.validatorAddress)), (0, d.isSet)(e.amount) && (t.amount = i.Coin.fromJSON(e.amount)), (0, d.isSet)(e.creationHeight) && (t.creationHeight = BigInt(e.creationHeight.toString())), t
                },
                toJSON(e) {
                    let t = {};
                    return void 0 !== e.delegatorAddress && (t.delegatorAddress = e.delegatorAddress), void 0 !== e.validatorAddress && (t.validatorAddress = e.validatorAddress), void 0 !== e.amount && (t.amount = e.amount ? i.Coin.toJSON(e.amount) : void 0), void 0 !== e.creationHeight && (t.creationHeight = (e.creationHeight || BigInt(0)).toString()), t
                },
                fromPartial(e) {
                    let t = y();
                    return t.delegatorAddress = e.delegatorAddress ? ? "", t.validatorAddress = e.validatorAddress ? ? "", void 0 !== e.amount && null !== e.amount && (t.amount = i.Coin.fromPartial(e.amount)), void 0 !== e.creationHeight && null !== e.creationHeight && (t.creationHeight = BigInt(e.creationHeight.toString())), t
                }
            }, t.MsgCancelUnbondingDelegationResponse = {
                typeUrl: "/cosmos.staking.v1beta1.MsgCancelUnbondingDelegationResponse",
                encode: (e, t = s.BinaryWriter.create()) => t,
                decode(e, t) {
                    let r = e instanceof s.BinaryReader ? e : new s.BinaryReader(e),
                        n = void 0 === t ? r.len : r.pos + t;
                    for (; r.pos < n;) {
                        let e = r.uint32();
                        r.skipType(7 & e)
                    }
                    return {}
                },
                fromJSON: e => ({}),
                toJSON: e => ({}),
                fromPartial: e => ({})
            }, t.MsgUpdateParams = {
                typeUrl: "/cosmos.staking.v1beta1.MsgUpdateParams",
                encode: (e, t = s.BinaryWriter.create()) => ("" !== e.authority && t.uint32(10).string(e.authority), void 0 !== e.params && n.Params.encode(e.params, t.uint32(18).fork()).ldelim(), t),
                decode(e, t) {
                    let r = e instanceof s.BinaryReader ? e : new s.BinaryReader(e),
                        o = void 0 === t ? r.len : r.pos + t,
                        i = h();
                    for (; r.pos < o;) {
                        let e = r.uint32();
                        switch (e >>> 3) {
                            case 1:
                                i.authority = r.string();
                                break;
                            case 2:
                                i.params = n.Params.decode(r, r.uint32());
                                break;
                            default:
                                r.skipType(7 & e)
                        }
                    }
                    return i
                },
                fromJSON(e) {
                    let t = h();
                    return (0, d.isSet)(e.authority) && (t.authority = String(e.authority)), (0, d.isSet)(e.params) && (t.params = n.Params.fromJSON(e.params)), t
                },
                toJSON(e) {
                    let t = {};
                    return void 0 !== e.authority && (t.authority = e.authority), void 0 !== e.params && (t.params = e.params ? n.Params.toJSON(e.params) : void 0), t
                },
                fromPartial(e) {
                    let t = h();
                    return t.authority = e.authority ? ? "", void 0 !== e.params && null !== e.params && (t.params = n.Params.fromPartial(e.params)), t
                }
            }, t.MsgUpdateParamsResponse = {
                typeUrl: "/cosmos.staking.v1beta1.MsgUpdateParamsResponse",
                encode: (e, t = s.BinaryWriter.create()) => t,
                decode(e, t) {
                    let r = e instanceof s.BinaryReader ? e : new s.BinaryReader(e),
                        n = void 0 === t ? r.len : r.pos + t;
                    for (; r.pos < n;) {
                        let e = r.uint32();
                        r.skipType(7 & e)
                    }
                    return {}
                },
                fromJSON: e => ({}),
                toJSON: e => ({}),
                fromPartial: e => ({})
            };
            class v {
                constructor(e) {
                    this.rpc = e, this.CreateValidator = this.CreateValidator.bind(this), this.EditValidator = this.EditValidator.bind(this), this.Delegate = this.Delegate.bind(this), this.BeginRedelegate = this.BeginRedelegate.bind(this), this.Undelegate = this.Undelegate.bind(this), this.CancelUnbondingDelegation = this.CancelUnbondingDelegation.bind(this), this.UpdateParams = this.UpdateParams.bind(this)
                }
                CreateValidator(e) {
                    let r = t.MsgCreateValidator.encode(e).finish();
                    return this.rpc.request("cosmos.staking.v1beta1.Msg", "CreateValidator", r).then(e => t.MsgCreateValidatorResponse.decode(new s.BinaryReader(e)))
                }
                EditValidator(e) {
                    let r = t.MsgEditValidator.encode(e).finish();
                    return this.rpc.request("cosmos.staking.v1beta1.Msg", "EditValidator", r).then(e => t.MsgEditValidatorResponse.decode(new s.BinaryReader(e)))
                }
                Delegate(e) {
                    let r = t.MsgDelegate.encode(e).finish();
                    return this.rpc.request("cosmos.staking.v1beta1.Msg", "Delegate", r).then(e => t.MsgDelegateResponse.decode(new s.BinaryReader(e)))
                }
                BeginRedelegate(e) {
                    let r = t.MsgBeginRedelegate.encode(e).finish();
                    return this.rpc.request("cosmos.staking.v1beta1.Msg", "BeginRedelegate", r).then(e => t.MsgBeginRedelegateResponse.decode(new s.BinaryReader(e)))
                }
                Undelegate(e) {
                    let r = t.MsgUndelegate.encode(e).finish();
                    return this.rpc.request("cosmos.staking.v1beta1.Msg", "Undelegate", r).then(e => t.MsgUndelegateResponse.decode(new s.BinaryReader(e)))
                }
                CancelUnbondingDelegation(e) {
                    let r = t.MsgCancelUnbondingDelegation.encode(e).finish();
                    return this.rpc.request("cosmos.staking.v1beta1.Msg", "CancelUnbondingDelegation", r).then(e => t.MsgCancelUnbondingDelegationResponse.decode(new s.BinaryReader(e)))
                }
                UpdateParams(e) {
                    let r = t.MsgUpdateParams.encode(e).finish();
                    return this.rpc.request("cosmos.staking.v1beta1.Msg", "UpdateParams", r).then(e => t.MsgUpdateParamsResponse.decode(new s.BinaryReader(e)))
                }
            }
            t.MsgClientImpl = v
        },
        43062: function(e, t, r) {
            "use strict";
            var n, o;
            Object.defineProperty(t, "__esModule", {
                value: !0
            }), t.SignatureDescriptor_Data_Multi = t.SignatureDescriptor_Data_Single = t.SignatureDescriptor_Data = t.SignatureDescriptor = t.SignatureDescriptors = t.signModeToJSON = t.signModeFromJSON = t.SignMode = t.protobufPackage = void 0;
            let i = r(96947),
                a = r(65676),
                s = r(28486),
                d = r(6476);

            function c(e) {
                switch (e) {
                    case 0:
                    case "SIGN_MODE_UNSPECIFIED":
                        return n.SIGN_MODE_UNSPECIFIED;
                    case 1:
                    case "SIGN_MODE_DIRECT":
                        return n.SIGN_MODE_DIRECT;
                    case 2:
                    case "SIGN_MODE_TEXTUAL":
                        return n.SIGN_MODE_TEXTUAL;
                    case 3:
                    case "SIGN_MODE_DIRECT_AUX":
                        return n.SIGN_MODE_DIRECT_AUX;
                    case 127:
                    case "SIGN_MODE_LEGACY_AMINO_JSON":
                        return n.SIGN_MODE_LEGACY_AMINO_JSON;
                    case 191:
                    case "SIGN_MODE_EIP_191":
                        return n.SIGN_MODE_EIP_191;
                    default:
                        return n.UNRECOGNIZED
                }
            }

            function l(e) {
                switch (e) {
                    case n.SIGN_MODE_UNSPECIFIED:
                        return "SIGN_MODE_UNSPECIFIED";
                    case n.SIGN_MODE_DIRECT:
                        return "SIGN_MODE_DIRECT";
                    case n.SIGN_MODE_TEXTUAL:
                        return "SIGN_MODE_TEXTUAL";
                    case n.SIGN_MODE_DIRECT_AUX:
                        return "SIGN_MODE_DIRECT_AUX";
                    case n.SIGN_MODE_LEGACY_AMINO_JSON:
                        return "SIGN_MODE_LEGACY_AMINO_JSON";
                    case n.SIGN_MODE_EIP_191:
                        return "SIGN_MODE_EIP_191";
                    case n.UNRECOGNIZED:
                    default:
                        return "UNRECOGNIZED"
                }
            }

            function u() {
                return {
                    signatures: []
                }
            }

            function p() {
                return {
                    publicKey: void 0,
                    data: void 0,
                    sequence: BigInt(0)
                }
            }

            function m() {
                return {
                    single: void 0,
                    multi: void 0
                }
            }

            function g() {
                return {
                    mode: 0,
                    signature: new Uint8Array
                }
            }

            function f() {
                return {
                    bitarray: void 0,
                    signatures: []
                }
            }
            t.protobufPackage = "cosmos.tx.signing.v1beta1", (o = n || (t.SignMode = n = {}))[o.SIGN_MODE_UNSPECIFIED = 0] = "SIGN_MODE_UNSPECIFIED", o[o.SIGN_MODE_DIRECT = 1] = "SIGN_MODE_DIRECT", o[o.SIGN_MODE_TEXTUAL = 2] = "SIGN_MODE_TEXTUAL", o[o.SIGN_MODE_DIRECT_AUX = 3] = "SIGN_MODE_DIRECT_AUX", o[o.SIGN_MODE_LEGACY_AMINO_JSON = 127] = "SIGN_MODE_LEGACY_AMINO_JSON", o[o.SIGN_MODE_EIP_191 = 191] = "SIGN_MODE_EIP_191", o[o.UNRECOGNIZED = -1] = "UNRECOGNIZED", t.signModeFromJSON = c, t.signModeToJSON = l, t.SignatureDescriptors = {
                typeUrl: "/cosmos.tx.signing.v1beta1.SignatureDescriptors",
                encode(e, r = s.BinaryWriter.create()) {
                    for (let n of e.signatures) t.SignatureDescriptor.encode(n, r.uint32(10).fork()).ldelim();
                    return r
                },
                decode(e, r) {
                    let n = e instanceof s.BinaryReader ? e : new s.BinaryReader(e),
                        o = void 0 === r ? n.len : n.pos + r,
                        i = u();
                    for (; n.pos < o;) {
                        let e = n.uint32();
                        e >>> 3 == 1 ? i.signatures.push(t.SignatureDescriptor.decode(n, n.uint32())) : n.skipType(7 & e)
                    }
                    return i
                },
                fromJSON(e) {
                    let r = u();
                    return Array.isArray(e ? .signatures) && (r.signatures = e.signatures.map(e => t.SignatureDescriptor.fromJSON(e))), r
                },
                toJSON(e) {
                    let r = {};
                    return e.signatures ? r.signatures = e.signatures.map(e => e ? t.SignatureDescriptor.toJSON(e) : void 0) : r.signatures = [], r
                },
                fromPartial(e) {
                    let r = u();
                    return r.signatures = e.signatures ? .map(e => t.SignatureDescriptor.fromPartial(e)) || [], r
                }
            }, t.SignatureDescriptor = {
                typeUrl: "/cosmos.tx.signing.v1beta1.SignatureDescriptor",
                encode: (e, r = s.BinaryWriter.create()) => (void 0 !== e.publicKey && a.Any.encode(e.publicKey, r.uint32(10).fork()).ldelim(), void 0 !== e.data && t.SignatureDescriptor_Data.encode(e.data, r.uint32(18).fork()).ldelim(), e.sequence !== BigInt(0) && r.uint32(24).uint64(e.sequence), r),
                decode(e, r) {
                    let n = e instanceof s.BinaryReader ? e : new s.BinaryReader(e),
                        o = void 0 === r ? n.len : n.pos + r,
                        i = p();
                    for (; n.pos < o;) {
                        let e = n.uint32();
                        switch (e >>> 3) {
                            case 1:
                                i.publicKey = a.Any.decode(n, n.uint32());
                                break;
                            case 2:
                                i.data = t.SignatureDescriptor_Data.decode(n, n.uint32());
                                break;
                            case 3:
                                i.sequence = n.uint64();
                                break;
                            default:
                                n.skipType(7 & e)
                        }
                    }
                    return i
                },
                fromJSON(e) {
                    let r = p();
                    return (0, d.isSet)(e.publicKey) && (r.publicKey = a.Any.fromJSON(e.publicKey)), (0, d.isSet)(e.data) && (r.data = t.SignatureDescriptor_Data.fromJSON(e.data)), (0, d.isSet)(e.sequence) && (r.sequence = BigInt(e.sequence.toString())), r
                },
                toJSON(e) {
                    let r = {};
                    return void 0 !== e.publicKey && (r.publicKey = e.publicKey ? a.Any.toJSON(e.publicKey) : void 0), void 0 !== e.data && (r.data = e.data ? t.SignatureDescriptor_Data.toJSON(e.data) : void 0), void 0 !== e.sequence && (r.sequence = (e.sequence || BigInt(0)).toString()), r
                },
                fromPartial(e) {
                    let r = p();
                    return void 0 !== e.publicKey && null !== e.publicKey && (r.publicKey = a.Any.fromPartial(e.publicKey)), void 0 !== e.data && null !== e.data && (r.data = t.SignatureDescriptor_Data.fromPartial(e.data)), void 0 !== e.sequence && null !== e.sequence && (r.sequence = BigInt(e.sequence.toString())), r
                }
            }, t.SignatureDescriptor_Data = {
                typeUrl: "/cosmos.tx.signing.v1beta1.Data",
                encode: (e, r = s.BinaryWriter.create()) => (void 0 !== e.single && t.SignatureDescriptor_Data_Single.encode(e.single, r.uint32(10).fork()).ldelim(), void 0 !== e.multi && t.SignatureDescriptor_Data_Multi.encode(e.multi, r.uint32(18).fork()).ldelim(), r),
                decode(e, r) {
                    let n = e instanceof s.BinaryReader ? e : new s.BinaryReader(e),
                        o = void 0 === r ? n.len : n.pos + r,
                        i = m();
                    for (; n.pos < o;) {
                        let e = n.uint32();
                        switch (e >>> 3) {
                            case 1:
                                i.single = t.SignatureDescriptor_Data_Single.decode(n, n.uint32());
                                break;
                            case 2:
                                i.multi = t.SignatureDescriptor_Data_Multi.decode(n, n.uint32());
                                break;
                            default:
                                n.skipType(7 & e)
                        }
                    }
                    return i
                },
                fromJSON(e) {
                    let r = m();
                    return (0, d.isSet)(e.single) && (r.single = t.SignatureDescriptor_Data_Single.fromJSON(e.single)), (0, d.isSet)(e.multi) && (r.multi = t.SignatureDescriptor_Data_Multi.fromJSON(e.multi)), r
                },
                toJSON(e) {
                    let r = {};
                    return void 0 !== e.single && (r.single = e.single ? t.SignatureDescriptor_Data_Single.toJSON(e.single) : void 0), void 0 !== e.multi && (r.multi = e.multi ? t.SignatureDescriptor_Data_Multi.toJSON(e.multi) : void 0), r
                },
                fromPartial(e) {
                    let r = m();
                    return void 0 !== e.single && null !== e.single && (r.single = t.SignatureDescriptor_Data_Single.fromPartial(e.single)), void 0 !== e.multi && null !== e.multi && (r.multi = t.SignatureDescriptor_Data_Multi.fromPartial(e.multi)), r
                }
            }, t.SignatureDescriptor_Data_Single = {
                typeUrl: "/cosmos.tx.signing.v1beta1.Single",
                encode: (e, t = s.BinaryWriter.create()) => (0 !== e.mode && t.uint32(8).int32(e.mode), 0 !== e.signature.length && t.uint32(18).bytes(e.signature), t),
                decode(e, t) {
                    let r = e instanceof s.BinaryReader ? e : new s.BinaryReader(e),
                        n = void 0 === t ? r.len : r.pos + t,
                        o = g();
                    for (; r.pos < n;) {
                        let e = r.uint32();
                        switch (e >>> 3) {
                            case 1:
                                o.mode = r.int32();
                                break;
                            case 2:
                                o.signature = r.bytes();
                                break;
                            default:
                                r.skipType(7 & e)
                        }
                    }
                    return o
                },
                fromJSON(e) {
                    let t = g();
                    return (0, d.isSet)(e.mode) && (t.mode = c(e.mode)), (0, d.isSet)(e.signature) && (t.signature = (0, d.bytesFromBase64)(e.signature)), t
                },
                toJSON(e) {
                    let t = {};
                    return void 0 !== e.mode && (t.mode = l(e.mode)), void 0 !== e.signature && (t.signature = (0, d.base64FromBytes)(void 0 !== e.signature ? e.signature : new Uint8Array)), t
                },
                fromPartial(e) {
                    let t = g();
                    return t.mode = e.mode ? ? 0, t.signature = e.signature ? ? new Uint8Array, t
                }
            }, t.SignatureDescriptor_Data_Multi = {
                typeUrl: "/cosmos.tx.signing.v1beta1.Multi",
                encode(e, r = s.BinaryWriter.create()) {
                    for (let n of (void 0 !== e.bitarray && i.CompactBitArray.encode(e.bitarray, r.uint32(10).fork()).ldelim(), e.signatures)) t.SignatureDescriptor_Data.encode(n, r.uint32(18).fork()).ldelim();
                    return r
                },
                decode(e, r) {
                    let n = e instanceof s.BinaryReader ? e : new s.BinaryReader(e),
                        o = void 0 === r ? n.len : n.pos + r,
                        a = f();
                    for (; n.pos < o;) {
                        let e = n.uint32();
                        switch (e >>> 3) {
                            case 1:
                                a.bitarray = i.CompactBitArray.decode(n, n.uint32());
                                break;
                            case 2:
                                a.signatures.push(t.SignatureDescriptor_Data.decode(n, n.uint32()));
                                break;
                            default:
                                n.skipType(7 & e)
                        }
                    }
                    return a
                },
                fromJSON(e) {
                    let r = f();
                    return (0, d.isSet)(e.bitarray) && (r.bitarray = i.CompactBitArray.fromJSON(e.bitarray)), Array.isArray(e ? .signatures) && (r.signatures = e.signatures.map(e => t.SignatureDescriptor_Data.fromJSON(e))), r
                },
                toJSON(e) {
                    let r = {};
                    return void 0 !== e.bitarray && (r.bitarray = e.bitarray ? i.CompactBitArray.toJSON(e.bitarray) : void 0), e.signatures ? r.signatures = e.signatures.map(e => e ? t.SignatureDescriptor_Data.toJSON(e) : void 0) : r.signatures = [], r
                },
                fromPartial(e) {
                    let r = f();
                    return void 0 !== e.bitarray && null !== e.bitarray && (r.bitarray = i.CompactBitArray.fromPartial(e.bitarray)), r.signatures = e.signatures ? .map(e => t.SignatureDescriptor_Data.fromPartial(e)) || [], r
                }
            }
        },
        3639: function(e, t, r) {
            "use strict";
            var n, o, i, a;
            Object.defineProperty(t, "__esModule", {
                value: !0
            }), t.ServiceClientImpl = t.TxDecodeAminoResponse = t.TxDecodeAminoRequest = t.TxEncodeAminoResponse = t.TxEncodeAminoRequest = t.TxEncodeResponse = t.TxEncodeRequest = t.TxDecodeResponse = t.TxDecodeRequest = t.GetBlockWithTxsResponse = t.GetBlockWithTxsRequest = t.GetTxResponse = t.GetTxRequest = t.SimulateResponse = t.SimulateRequest = t.BroadcastTxResponse = t.BroadcastTxRequest = t.GetTxsEventResponse = t.GetTxsEventRequest = t.broadcastModeToJSON = t.broadcastModeFromJSON = t.BroadcastMode = t.orderByToJSON = t.orderByFromJSON = t.OrderBy = t.protobufPackage = void 0;
            let s = r(93739),
                d = r(38792),
                c = r(6916),
                l = r(64255),
                u = r(55042),
                p = r(28486),
                m = r(6476);

            function g(e) {
                switch (e) {
                    case 0:
                    case "ORDER_BY_UNSPECIFIED":
                        return n.ORDER_BY_UNSPECIFIED;
                    case 1:
                    case "ORDER_BY_ASC":
                        return n.ORDER_BY_ASC;
                    case 2:
                    case "ORDER_BY_DESC":
                        return n.ORDER_BY_DESC;
                    default:
                        return n.UNRECOGNIZED
                }
            }

            function f(e) {
                switch (e) {
                    case n.ORDER_BY_UNSPECIFIED:
                        return "ORDER_BY_UNSPECIFIED";
                    case n.ORDER_BY_ASC:
                        return "ORDER_BY_ASC";
                    case n.ORDER_BY_DESC:
                        return "ORDER_BY_DESC";
                    case n.UNRECOGNIZED:
                    default:
                        return "UNRECOGNIZED"
                }
            }

            function y(e) {
                switch (e) {
                    case 0:
                    case "BROADCAST_MODE_UNSPECIFIED":
                        return o.BROADCAST_MODE_UNSPECIFIED;
                    case 1:
                    case "BROADCAST_MODE_BLOCK":
                        return o.BROADCAST_MODE_BLOCK;
                    case 2:
                    case "BROADCAST_MODE_SYNC":
                        return o.BROADCAST_MODE_SYNC;
                    case 3:
                    case "BROADCAST_MODE_ASYNC":
                        return o.BROADCAST_MODE_ASYNC;
                    default:
                        return o.UNRECOGNIZED
                }
            }

            function h(e) {
                switch (e) {
                    case o.BROADCAST_MODE_UNSPECIFIED:
                        return "BROADCAST_MODE_UNSPECIFIED";
                    case o.BROADCAST_MODE_BLOCK:
                        return "BROADCAST_MODE_BLOCK";
                    case o.BROADCAST_MODE_SYNC:
                        return "BROADCAST_MODE_SYNC";
                    case o.BROADCAST_MODE_ASYNC:
                        return "BROADCAST_MODE_ASYNC";
                    case o.UNRECOGNIZED:
                    default:
                        return "UNRECOGNIZED"
                }
            }

            function v() {
                return {
                    events: [],
                    pagination: void 0,
                    orderBy: 0,
                    page: BigInt(0),
                    limit: BigInt(0)
                }
            }

            function b() {
                return {
                    txs: [],
                    txResponses: [],
                    pagination: void 0,
                    total: BigInt(0)
                }
            }

            function S() {
                return {
                    txBytes: new Uint8Array,
                    mode: 0
                }
            }

            function k() {
                return {
                    txResponse: void 0
                }
            }

            function P() {
                return {
                    tx: void 0,
                    txBytes: new Uint8Array
                }
            }

            function _() {
                return {
                    gasInfo: void 0,
                    result: void 0
                }
            }

            function B() {
                return {
                    hash: ""
                }
            }

            function O() {
                return {
                    tx: void 0,
                    txResponse: void 0
                }
            }

            function R() {
                return {
                    height: BigInt(0),
                    pagination: void 0
                }
            }

            function A() {
                return {
                    txs: [],
                    blockId: void 0,
                    block: void 0,
                    pagination: void 0
                }
            }

            function I() {
                return {
                    txBytes: new Uint8Array
                }
            }

            function w() {
                return {
                    tx: void 0
                }
            }

            function T() {
                return {
                    tx: void 0
                }
            }

            function N() {
                return {
                    txBytes: new Uint8Array
                }
            }

            function C() {
                return {
                    aminoJson: ""
                }
            }

            function E() {
                return {
                    aminoBinary: new Uint8Array
                }
            }

            function x() {
                return {
                    aminoBinary: new Uint8Array
                }
            }

            function U() {
                return {
                    aminoJson: ""
                }
            }
            t.protobufPackage = "cosmos.tx.v1beta1", (i = n || (t.OrderBy = n = {}))[i.ORDER_BY_UNSPECIFIED = 0] = "ORDER_BY_UNSPECIFIED", i[i.ORDER_BY_ASC = 1] = "ORDER_BY_ASC", i[i.ORDER_BY_DESC = 2] = "ORDER_BY_DESC", i[i.UNRECOGNIZED = -1] = "UNRECOGNIZED", t.orderByFromJSON = g, t.orderByToJSON = f, (a = o || (t.BroadcastMode = o = {}))[a.BROADCAST_MODE_UNSPECIFIED = 0] = "BROADCAST_MODE_UNSPECIFIED", a[a.BROADCAST_MODE_BLOCK = 1] = "BROADCAST_MODE_BLOCK", a[a.BROADCAST_MODE_SYNC = 2] = "BROADCAST_MODE_SYNC", a[a.BROADCAST_MODE_ASYNC = 3] = "BROADCAST_MODE_ASYNC", a[a.UNRECOGNIZED = -1] = "UNRECOGNIZED", t.broadcastModeFromJSON = y, t.broadcastModeToJSON = h, t.GetTxsEventRequest = {
                typeUrl: "/cosmos.tx.v1beta1.GetTxsEventRequest",
                encode(e, t = p.BinaryWriter.create()) {
                    for (let r of e.events) t.uint32(10).string(r);
                    return void 0 !== e.pagination && d.PageRequest.encode(e.pagination, t.uint32(18).fork()).ldelim(), 0 !== e.orderBy && t.uint32(24).int32(e.orderBy), e.page !== BigInt(0) && t.uint32(32).uint64(e.page), e.limit !== BigInt(0) && t.uint32(40).uint64(e.limit), t
                },
                decode(e, t) {
                    let r = e instanceof p.BinaryReader ? e : new p.BinaryReader(e),
                        n = void 0 === t ? r.len : r.pos + t,
                        o = v();
                    for (; r.pos < n;) {
                        let e = r.uint32();
                        switch (e >>> 3) {
                            case 1:
                                o.events.push(r.string());
                                break;
                            case 2:
                                o.pagination = d.PageRequest.decode(r, r.uint32());
                                break;
                            case 3:
                                o.orderBy = r.int32();
                                break;
                            case 4:
                                o.page = r.uint64();
                                break;
                            case 5:
                                o.limit = r.uint64();
                                break;
                            default:
                                r.skipType(7 & e)
                        }
                    }
                    return o
                },
                fromJSON(e) {
                    let t = v();
                    return Array.isArray(e ? .events) && (t.events = e.events.map(e => String(e))), (0, m.isSet)(e.pagination) && (t.pagination = d.PageRequest.fromJSON(e.pagination)), (0, m.isSet)(e.orderBy) && (t.orderBy = g(e.orderBy)), (0, m.isSet)(e.page) && (t.page = BigInt(e.page.toString())), (0, m.isSet)(e.limit) && (t.limit = BigInt(e.limit.toString())), t
                },
                toJSON(e) {
                    let t = {};
                    return e.events ? t.events = e.events.map(e => e) : t.events = [], void 0 !== e.pagination && (t.pagination = e.pagination ? d.PageRequest.toJSON(e.pagination) : void 0), void 0 !== e.orderBy && (t.orderBy = f(e.orderBy)), void 0 !== e.page && (t.page = (e.page || BigInt(0)).toString()), void 0 !== e.limit && (t.limit = (e.limit || BigInt(0)).toString()), t
                },
                fromPartial(e) {
                    let t = v();
                    return t.events = e.events ? .map(e => e) || [], void 0 !== e.pagination && null !== e.pagination && (t.pagination = d.PageRequest.fromPartial(e.pagination)), t.orderBy = e.orderBy ? ? 0, void 0 !== e.page && null !== e.page && (t.page = BigInt(e.page.toString())), void 0 !== e.limit && null !== e.limit && (t.limit = BigInt(e.limit.toString())), t
                }
            }, t.GetTxsEventResponse = {
                typeUrl: "/cosmos.tx.v1beta1.GetTxsEventResponse",
                encode(e, t = p.BinaryWriter.create()) {
                    for (let r of e.txs) s.Tx.encode(r, t.uint32(10).fork()).ldelim();
                    for (let r of e.txResponses) c.TxResponse.encode(r, t.uint32(18).fork()).ldelim();
                    return void 0 !== e.pagination && d.PageResponse.encode(e.pagination, t.uint32(26).fork()).ldelim(), e.total !== BigInt(0) && t.uint32(32).uint64(e.total), t
                },
                decode(e, t) {
                    let r = e instanceof p.BinaryReader ? e : new p.BinaryReader(e),
                        n = void 0 === t ? r.len : r.pos + t,
                        o = b();
                    for (; r.pos < n;) {
                        let e = r.uint32();
                        switch (e >>> 3) {
                            case 1:
                                o.txs.push(s.Tx.decode(r, r.uint32()));
                                break;
                            case 2:
                                o.txResponses.push(c.TxResponse.decode(r, r.uint32()));
                                break;
                            case 3:
                                o.pagination = d.PageResponse.decode(r, r.uint32());
                                break;
                            case 4:
                                o.total = r.uint64();
                                break;
                            default:
                                r.skipType(7 & e)
                        }
                    }
                    return o
                },
                fromJSON(e) {
                    let t = b();
                    return Array.isArray(e ? .txs) && (t.txs = e.txs.map(e => s.Tx.fromJSON(e))), Array.isArray(e ? .txResponses) && (t.txResponses = e.txResponses.map(e => c.TxResponse.fromJSON(e))), (0, m.isSet)(e.pagination) && (t.pagination = d.PageResponse.fromJSON(e.pagination)), (0, m.isSet)(e.total) && (t.total = BigInt(e.total.toString())), t
                },
                toJSON(e) {
                    let t = {};
                    return e.txs ? t.txs = e.txs.map(e => e ? s.Tx.toJSON(e) : void 0) : t.txs = [], e.txResponses ? t.txResponses = e.txResponses.map(e => e ? c.TxResponse.toJSON(e) : void 0) : t.txResponses = [], void 0 !== e.pagination && (t.pagination = e.pagination ? d.PageResponse.toJSON(e.pagination) : void 0), void 0 !== e.total && (t.total = (e.total || BigInt(0)).toString()), t
                },
                fromPartial(e) {
                    let t = b();
                    return t.txs = e.txs ? .map(e => s.Tx.fromPartial(e)) || [], t.txResponses = e.txResponses ? .map(e => c.TxResponse.fromPartial(e)) || [], void 0 !== e.pagination && null !== e.pagination && (t.pagination = d.PageResponse.fromPartial(e.pagination)), void 0 !== e.total && null !== e.total && (t.total = BigInt(e.total.toString())), t
                }
            }, t.BroadcastTxRequest = {
                typeUrl: "/cosmos.tx.v1beta1.BroadcastTxRequest",
                encode: (e, t = p.BinaryWriter.create()) => (0 !== e.txBytes.length && t.uint32(10).bytes(e.txBytes), 0 !== e.mode && t.uint32(16).int32(e.mode), t),
                decode(e, t) {
                    let r = e instanceof p.BinaryReader ? e : new p.BinaryReader(e),
                        n = void 0 === t ? r.len : r.pos + t,
                        o = S();
                    for (; r.pos < n;) {
                        let e = r.uint32();
                        switch (e >>> 3) {
                            case 1:
                                o.txBytes = r.bytes();
                                break;
                            case 2:
                                o.mode = r.int32();
                                break;
                            default:
                                r.skipType(7 & e)
                        }
                    }
                    return o
                },
                fromJSON(e) {
                    let t = S();
                    return (0, m.isSet)(e.txBytes) && (t.txBytes = (0, m.bytesFromBase64)(e.txBytes)), (0, m.isSet)(e.mode) && (t.mode = y(e.mode)), t
                },
                toJSON(e) {
                    let t = {};
                    return void 0 !== e.txBytes && (t.txBytes = (0, m.base64FromBytes)(void 0 !== e.txBytes ? e.txBytes : new Uint8Array)), void 0 !== e.mode && (t.mode = h(e.mode)), t
                },
                fromPartial(e) {
                    let t = S();
                    return t.txBytes = e.txBytes ? ? new Uint8Array, t.mode = e.mode ? ? 0, t
                }
            }, t.BroadcastTxResponse = {
                typeUrl: "/cosmos.tx.v1beta1.BroadcastTxResponse",
                encode: (e, t = p.BinaryWriter.create()) => (void 0 !== e.txResponse && c.TxResponse.encode(e.txResponse, t.uint32(10).fork()).ldelim(), t),
                decode(e, t) {
                    let r = e instanceof p.BinaryReader ? e : new p.BinaryReader(e),
                        n = void 0 === t ? r.len : r.pos + t,
                        o = k();
                    for (; r.pos < n;) {
                        let e = r.uint32();
                        e >>> 3 == 1 ? o.txResponse = c.TxResponse.decode(r, r.uint32()) : r.skipType(7 & e)
                    }
                    return o
                },
                fromJSON(e) {
                    let t = k();
                    return (0, m.isSet)(e.txResponse) && (t.txResponse = c.TxResponse.fromJSON(e.txResponse)), t
                },
                toJSON(e) {
                    let t = {};
                    return void 0 !== e.txResponse && (t.txResponse = e.txResponse ? c.TxResponse.toJSON(e.txResponse) : void 0), t
                },
                fromPartial(e) {
                    let t = k();
                    return void 0 !== e.txResponse && null !== e.txResponse && (t.txResponse = c.TxResponse.fromPartial(e.txResponse)), t
                }
            }, t.SimulateRequest = {
                typeUrl: "/cosmos.tx.v1beta1.SimulateRequest",
                encode: (e, t = p.BinaryWriter.create()) => (void 0 !== e.tx && s.Tx.encode(e.tx, t.uint32(10).fork()).ldelim(), 0 !== e.txBytes.length && t.uint32(18).bytes(e.txBytes), t),
                decode(e, t) {
                    let r = e instanceof p.BinaryReader ? e : new p.BinaryReader(e),
                        n = void 0 === t ? r.len : r.pos + t,
                        o = P();
                    for (; r.pos < n;) {
                        let e = r.uint32();
                        switch (e >>> 3) {
                            case 1:
                                o.tx = s.Tx.decode(r, r.uint32());
                                break;
                            case 2:
                                o.txBytes = r.bytes();
                                break;
                            default:
                                r.skipType(7 & e)
                        }
                    }
                    return o
                },
                fromJSON(e) {
                    let t = P();
                    return (0, m.isSet)(e.tx) && (t.tx = s.Tx.fromJSON(e.tx)), (0, m.isSet)(e.txBytes) && (t.txBytes = (0, m.bytesFromBase64)(e.txBytes)), t
                },
                toJSON(e) {
                    let t = {};
                    return void 0 !== e.tx && (t.tx = e.tx ? s.Tx.toJSON(e.tx) : void 0), void 0 !== e.txBytes && (t.txBytes = (0, m.base64FromBytes)(void 0 !== e.txBytes ? e.txBytes : new Uint8Array)), t
                },
                fromPartial(e) {
                    let t = P();
                    return void 0 !== e.tx && null !== e.tx && (t.tx = s.Tx.fromPartial(e.tx)), t.txBytes = e.txBytes ? ? new Uint8Array, t
                }
            }, t.SimulateResponse = {
                typeUrl: "/cosmos.tx.v1beta1.SimulateResponse",
                encode: (e, t = p.BinaryWriter.create()) => (void 0 !== e.gasInfo && c.GasInfo.encode(e.gasInfo, t.uint32(10).fork()).ldelim(), void 0 !== e.result && c.Result.encode(e.result, t.uint32(18).fork()).ldelim(), t),
                decode(e, t) {
                    let r = e instanceof p.BinaryReader ? e : new p.BinaryReader(e),
                        n = void 0 === t ? r.len : r.pos + t,
                        o = _();
                    for (; r.pos < n;) {
                        let e = r.uint32();
                        switch (e >>> 3) {
                            case 1:
                                o.gasInfo = c.GasInfo.decode(r, r.uint32());
                                break;
                            case 2:
                                o.result = c.Result.decode(r, r.uint32());
                                break;
                            default:
                                r.skipType(7 & e)
                        }
                    }
                    return o
                },
                fromJSON(e) {
                    let t = _();
                    return (0, m.isSet)(e.gasInfo) && (t.gasInfo = c.GasInfo.fromJSON(e.gasInfo)), (0, m.isSet)(e.result) && (t.result = c.Result.fromJSON(e.result)), t
                },
                toJSON(e) {
                    let t = {};
                    return void 0 !== e.gasInfo && (t.gasInfo = e.gasInfo ? c.GasInfo.toJSON(e.gasInfo) : void 0), void 0 !== e.result && (t.result = e.result ? c.Result.toJSON(e.result) : void 0), t
                },
                fromPartial(e) {
                    let t = _();
                    return void 0 !== e.gasInfo && null !== e.gasInfo && (t.gasInfo = c.GasInfo.fromPartial(e.gasInfo)), void 0 !== e.result && null !== e.result && (t.result = c.Result.fromPartial(e.result)), t
                }
            }, t.GetTxRequest = {
                typeUrl: "/cosmos.tx.v1beta1.GetTxRequest",
                encode: (e, t = p.BinaryWriter.create()) => ("" !== e.hash && t.uint32(10).string(e.hash), t),
                decode(e, t) {
                    let r = e instanceof p.BinaryReader ? e : new p.BinaryReader(e),
                        n = void 0 === t ? r.len : r.pos + t,
                        o = B();
                    for (; r.pos < n;) {
                        let e = r.uint32();
                        e >>> 3 == 1 ? o.hash = r.string() : r.skipType(7 & e)
                    }
                    return o
                },
                fromJSON(e) {
                    let t = B();
                    return (0, m.isSet)(e.hash) && (t.hash = String(e.hash)), t
                },
                toJSON(e) {
                    let t = {};
                    return void 0 !== e.hash && (t.hash = e.hash), t
                },
                fromPartial(e) {
                    let t = B();
                    return t.hash = e.hash ? ? "", t
                }
            }, t.GetTxResponse = {
                typeUrl: "/cosmos.tx.v1beta1.GetTxResponse",
                encode: (e, t = p.BinaryWriter.create()) => (void 0 !== e.tx && s.Tx.encode(e.tx, t.uint32(10).fork()).ldelim(), void 0 !== e.txResponse && c.TxResponse.encode(e.txResponse, t.uint32(18).fork()).ldelim(), t),
                decode(e, t) {
                    let r = e instanceof p.BinaryReader ? e : new p.BinaryReader(e),
                        n = void 0 === t ? r.len : r.pos + t,
                        o = O();
                    for (; r.pos < n;) {
                        let e = r.uint32();
                        switch (e >>> 3) {
                            case 1:
                                o.tx = s.Tx.decode(r, r.uint32());
                                break;
                            case 2:
                                o.txResponse = c.TxResponse.decode(r, r.uint32());
                                break;
                            default:
                                r.skipType(7 & e)
                        }
                    }
                    return o
                },
                fromJSON(e) {
                    let t = O();
                    return (0, m.isSet)(e.tx) && (t.tx = s.Tx.fromJSON(e.tx)), (0, m.isSet)(e.txResponse) && (t.txResponse = c.TxResponse.fromJSON(e.txResponse)), t
                },
                toJSON(e) {
                    let t = {};
                    return void 0 !== e.tx && (t.tx = e.tx ? s.Tx.toJSON(e.tx) : void 0), void 0 !== e.txResponse && (t.txResponse = e.txResponse ? c.TxResponse.toJSON(e.txResponse) : void 0), t
                },
                fromPartial(e) {
                    let t = O();
                    return void 0 !== e.tx && null !== e.tx && (t.tx = s.Tx.fromPartial(e.tx)), void 0 !== e.txResponse && null !== e.txResponse && (t.txResponse = c.TxResponse.fromPartial(e.txResponse)), t
                }
            }, t.GetBlockWithTxsRequest = {
                typeUrl: "/cosmos.tx.v1beta1.GetBlockWithTxsRequest",
                encode: (e, t = p.BinaryWriter.create()) => (e.height !== BigInt(0) && t.uint32(8).int64(e.height), void 0 !== e.pagination && d.PageRequest.encode(e.pagination, t.uint32(18).fork()).ldelim(), t),
                decode(e, t) {
                    let r = e instanceof p.BinaryReader ? e : new p.BinaryReader(e),
                        n = void 0 === t ? r.len : r.pos + t,
                        o = R();
                    for (; r.pos < n;) {
                        let e = r.uint32();
                        switch (e >>> 3) {
                            case 1:
                                o.height = r.int64();
                                break;
                            case 2:
                                o.pagination = d.PageRequest.decode(r, r.uint32());
                                break;
                            default:
                                r.skipType(7 & e)
                        }
                    }
                    return o
                },
                fromJSON(e) {
                    let t = R();
                    return (0, m.isSet)(e.height) && (t.height = BigInt(e.height.toString())), (0, m.isSet)(e.pagination) && (t.pagination = d.PageRequest.fromJSON(e.pagination)), t
                },
                toJSON(e) {
                    let t = {};
                    return void 0 !== e.height && (t.height = (e.height || BigInt(0)).toString()), void 0 !== e.pagination && (t.pagination = e.pagination ? d.PageRequest.toJSON(e.pagination) : void 0), t
                },
                fromPartial(e) {
                    let t = R();
                    return void 0 !== e.height && null !== e.height && (t.height = BigInt(e.height.toString())), void 0 !== e.pagination && null !== e.pagination && (t.pagination = d.PageRequest.fromPartial(e.pagination)), t
                }
            }, t.GetBlockWithTxsResponse = {
                typeUrl: "/cosmos.tx.v1beta1.GetBlockWithTxsResponse",
                encode(e, t = p.BinaryWriter.create()) {
                    for (let r of e.txs) s.Tx.encode(r, t.uint32(10).fork()).ldelim();
                    return void 0 !== e.blockId && l.BlockID.encode(e.blockId, t.uint32(18).fork()).ldelim(), void 0 !== e.block && u.Block.encode(e.block, t.uint32(26).fork()).ldelim(), void 0 !== e.pagination && d.PageResponse.encode(e.pagination, t.uint32(34).fork()).ldelim(), t
                },
                decode(e, t) {
                    let r = e instanceof p.BinaryReader ? e : new p.BinaryReader(e),
                        n = void 0 === t ? r.len : r.pos + t,
                        o = A();
                    for (; r.pos < n;) {
                        let e = r.uint32();
                        switch (e >>> 3) {
                            case 1:
                                o.txs.push(s.Tx.decode(r, r.uint32()));
                                break;
                            case 2:
                                o.blockId = l.BlockID.decode(r, r.uint32());
                                break;
                            case 3:
                                o.block = u.Block.decode(r, r.uint32());
                                break;
                            case 4:
                                o.pagination = d.PageResponse.decode(r, r.uint32());
                                break;
                            default:
                                r.skipType(7 & e)
                        }
                    }
                    return o
                },
                fromJSON(e) {
                    let t = A();
                    return Array.isArray(e ? .txs) && (t.txs = e.txs.map(e => s.Tx.fromJSON(e))), (0, m.isSet)(e.blockId) && (t.blockId = l.BlockID.fromJSON(e.blockId)), (0, m.isSet)(e.block) && (t.block = u.Block.fromJSON(e.block)), (0, m.isSet)(e.pagination) && (t.pagination = d.PageResponse.fromJSON(e.pagination)), t
                },
                toJSON(e) {
                    let t = {};
                    return e.txs ? t.txs = e.txs.map(e => e ? s.Tx.toJSON(e) : void 0) : t.txs = [], void 0 !== e.blockId && (t.blockId = e.blockId ? l.BlockID.toJSON(e.blockId) : void 0), void 0 !== e.block && (t.block = e.block ? u.Block.toJSON(e.block) : void 0), void 0 !== e.pagination && (t.pagination = e.pagination ? d.PageResponse.toJSON(e.pagination) : void 0), t
                },
                fromPartial(e) {
                    let t = A();
                    return t.txs = e.txs ? .map(e => s.Tx.fromPartial(e)) || [], void 0 !== e.blockId && null !== e.blockId && (t.blockId = l.BlockID.fromPartial(e.blockId)), void 0 !== e.block && null !== e.block && (t.block = u.Block.fromPartial(e.block)), void 0 !== e.pagination && null !== e.pagination && (t.pagination = d.PageResponse.fromPartial(e.pagination)), t
                }
            }, t.TxDecodeRequest = {
                typeUrl: "/cosmos.tx.v1beta1.TxDecodeRequest",
                encode: (e, t = p.BinaryWriter.create()) => (0 !== e.txBytes.length && t.uint32(10).bytes(e.txBytes), t),
                decode(e, t) {
                    let r = e instanceof p.BinaryReader ? e : new p.BinaryReader(e),
                        n = void 0 === t ? r.len : r.pos + t,
                        o = I();
                    for (; r.pos < n;) {
                        let e = r.uint32();
                        e >>> 3 == 1 ? o.txBytes = r.bytes() : r.skipType(7 & e)
                    }
                    return o
                },
                fromJSON(e) {
                    let t = I();
                    return (0, m.isSet)(e.txBytes) && (t.txBytes = (0, m.bytesFromBase64)(e.txBytes)), t
                },
                toJSON(e) {
                    let t = {};
                    return void 0 !== e.txBytes && (t.txBytes = (0, m.base64FromBytes)(void 0 !== e.txBytes ? e.txBytes : new Uint8Array)), t
                },
                fromPartial(e) {
                    let t = I();
                    return t.txBytes = e.txBytes ? ? new Uint8Array, t
                }
            }, t.TxDecodeResponse = {
                typeUrl: "/cosmos.tx.v1beta1.TxDecodeResponse",
                encode: (e, t = p.BinaryWriter.create()) => (void 0 !== e.tx && s.Tx.encode(e.tx, t.uint32(10).fork()).ldelim(), t),
                decode(e, t) {
                    let r = e instanceof p.BinaryReader ? e : new p.BinaryReader(e),
                        n = void 0 === t ? r.len : r.pos + t,
                        o = w();
                    for (; r.pos < n;) {
                        let e = r.uint32();
                        e >>> 3 == 1 ? o.tx = s.Tx.decode(r, r.uint32()) : r.skipType(7 & e)
                    }
                    return o
                },
                fromJSON(e) {
                    let t = w();
                    return (0, m.isSet)(e.tx) && (t.tx = s.Tx.fromJSON(e.tx)), t
                },
                toJSON(e) {
                    let t = {};
                    return void 0 !== e.tx && (t.tx = e.tx ? s.Tx.toJSON(e.tx) : void 0), t
                },
                fromPartial(e) {
                    let t = w();
                    return void 0 !== e.tx && null !== e.tx && (t.tx = s.Tx.fromPartial(e.tx)), t
                }
            }, t.TxEncodeRequest = {
                typeUrl: "/cosmos.tx.v1beta1.TxEncodeRequest",
                encode: (e, t = p.BinaryWriter.create()) => (void 0 !== e.tx && s.Tx.encode(e.tx, t.uint32(10).fork()).ldelim(), t),
                decode(e, t) {
                    let r = e instanceof p.BinaryReader ? e : new p.BinaryReader(e),
                        n = void 0 === t ? r.len : r.pos + t,
                        o = T();
                    for (; r.pos < n;) {
                        let e = r.uint32();
                        e >>> 3 == 1 ? o.tx = s.Tx.decode(r, r.uint32()) : r.skipType(7 & e)
                    }
                    return o
                },
                fromJSON(e) {
                    let t = T();
                    return (0, m.isSet)(e.tx) && (t.tx = s.Tx.fromJSON(e.tx)), t
                },
                toJSON(e) {
                    let t = {};
                    return void 0 !== e.tx && (t.tx = e.tx ? s.Tx.toJSON(e.tx) : void 0), t
                },
                fromPartial(e) {
                    let t = T();
                    return void 0 !== e.tx && null !== e.tx && (t.tx = s.Tx.fromPartial(e.tx)), t
                }
            }, t.TxEncodeResponse = {
                typeUrl: "/cosmos.tx.v1beta1.TxEncodeResponse",
                encode: (e, t = p.BinaryWriter.create()) => (0 !== e.txBytes.length && t.uint32(10).bytes(e.txBytes), t),
                decode(e, t) {
                    let r = e instanceof p.BinaryReader ? e : new p.BinaryReader(e),
                        n = void 0 === t ? r.len : r.pos + t,
                        o = N();
                    for (; r.pos < n;) {
                        let e = r.uint32();
                        e >>> 3 == 1 ? o.txBytes = r.bytes() : r.skipType(7 & e)
                    }
                    return o
                },
                fromJSON(e) {
                    let t = N();
                    return (0, m.isSet)(e.txBytes) && (t.txBytes = (0, m.bytesFromBase64)(e.txBytes)), t
                },
                toJSON(e) {
                    let t = {};
                    return void 0 !== e.txBytes && (t.txBytes = (0, m.base64FromBytes)(void 0 !== e.txBytes ? e.txBytes : new Uint8Array)), t
                },
                fromPartial(e) {
                    let t = N();
                    return t.txBytes = e.txBytes ? ? new Uint8Array, t
                }
            }, t.TxEncodeAminoRequest = {
                typeUrl: "/cosmos.tx.v1beta1.TxEncodeAminoRequest",
                encode: (e, t = p.BinaryWriter.create()) => ("" !== e.aminoJson && t.uint32(10).string(e.aminoJson), t),
                decode(e, t) {
                    let r = e instanceof p.BinaryReader ? e : new p.BinaryReader(e),
                        n = void 0 === t ? r.len : r.pos + t,
                        o = C();
                    for (; r.pos < n;) {
                        let e = r.uint32();
                        e >>> 3 == 1 ? o.aminoJson = r.string() : r.skipType(7 & e)
                    }
                    return o
                },
                fromJSON(e) {
                    let t = C();
                    return (0, m.isSet)(e.aminoJson) && (t.aminoJson = String(e.aminoJson)), t
                },
                toJSON(e) {
                    let t = {};
                    return void 0 !== e.aminoJson && (t.aminoJson = e.aminoJson), t
                },
                fromPartial(e) {
                    let t = C();
                    return t.aminoJson = e.aminoJson ? ? "", t
                }
            }, t.TxEncodeAminoResponse = {
                typeUrl: "/cosmos.tx.v1beta1.TxEncodeAminoResponse",
                encode: (e, t = p.BinaryWriter.create()) => (0 !== e.aminoBinary.length && t.uint32(10).bytes(e.aminoBinary), t),
                decode(e, t) {
                    let r = e instanceof p.BinaryReader ? e : new p.BinaryReader(e),
                        n = void 0 === t ? r.len : r.pos + t,
                        o = E();
                    for (; r.pos < n;) {
                        let e = r.uint32();
                        e >>> 3 == 1 ? o.aminoBinary = r.bytes() : r.skipType(7 & e)
                    }
                    return o
                },
                fromJSON(e) {
                    let t = E();
                    return (0, m.isSet)(e.aminoBinary) && (t.aminoBinary = (0, m.bytesFromBase64)(e.aminoBinary)), t
                },
                toJSON(e) {
                    let t = {};
                    return void 0 !== e.aminoBinary && (t.aminoBinary = (0, m.base64FromBytes)(void 0 !== e.aminoBinary ? e.aminoBinary : new Uint8Array)), t
                },
                fromPartial(e) {
                    let t = E();
                    return t.aminoBinary = e.aminoBinary ? ? new Uint8Array, t
                }
            }, t.TxDecodeAminoRequest = {
                typeUrl: "/cosmos.tx.v1beta1.TxDecodeAminoRequest",
                encode: (e, t = p.BinaryWriter.create()) => (0 !== e.aminoBinary.length && t.uint32(10).bytes(e.aminoBinary), t),
                decode(e, t) {
                    let r = e instanceof p.BinaryReader ? e : new p.BinaryReader(e),
                        n = void 0 === t ? r.len : r.pos + t,
                        o = x();
                    for (; r.pos < n;) {
                        let e = r.uint32();
                        e >>> 3 == 1 ? o.aminoBinary = r.bytes() : r.skipType(7 & e)
                    }
                    return o
                },
                fromJSON(e) {
                    let t = x();
                    return (0, m.isSet)(e.aminoBinary) && (t.aminoBinary = (0, m.bytesFromBase64)(e.aminoBinary)), t
                },
                toJSON(e) {
                    let t = {};
                    return void 0 !== e.aminoBinary && (t.aminoBinary = (0, m.base64FromBytes)(void 0 !== e.aminoBinary ? e.aminoBinary : new Uint8Array)), t
                },
                fromPartial(e) {
                    let t = x();
                    return t.aminoBinary = e.aminoBinary ? ? new Uint8Array, t
                }
            }, t.TxDecodeAminoResponse = {
                typeUrl: "/cosmos.tx.v1beta1.TxDecodeAminoResponse",
                encode: (e, t = p.BinaryWriter.create()) => ("" !== e.aminoJson && t.uint32(10).string(e.aminoJson), t),
                decode(e, t) {
                    let r = e instanceof p.BinaryReader ? e : new p.BinaryReader(e),
                        n = void 0 === t ? r.len : r.pos + t,
                        o = U();
                    for (; r.pos < n;) {
                        let e = r.uint32();
                        e >>> 3 == 1 ? o.aminoJson = r.string() : r.skipType(7 & e)
                    }
                    return o
                },
                fromJSON(e) {
                    let t = U();
                    return (0, m.isSet)(e.aminoJson) && (t.aminoJson = String(e.aminoJson)), t
                },
                toJSON(e) {
                    let t = {};
                    return void 0 !== e.aminoJson && (t.aminoJson = e.aminoJson), t
                },
                fromPartial(e) {
                    let t = U();
                    return t.aminoJson = e.aminoJson ? ? "", t
                }
            };
            class D {
                constructor(e) {
                    this.rpc = e, this.Simulate = this.Simulate.bind(this), this.GetTx = this.GetTx.bind(this), this.BroadcastTx = this.BroadcastTx.bind(this), this.GetTxsEvent = this.GetTxsEvent.bind(this), this.GetBlockWithTxs = this.GetBlockWithTxs.bind(this), this.TxDecode = this.TxDecode.bind(this), this.TxEncode = this.TxEncode.bind(this), this.TxEncodeAmino = this.TxEncodeAmino.bind(this), this.TxDecodeAmino = this.TxDecodeAmino.bind(this)
                }
                Simulate(e) {
                    let r = t.SimulateRequest.encode(e).finish();
                    return this.rpc.request("cosmos.tx.v1beta1.Service", "Simulate", r).then(e => t.SimulateResponse.decode(new p.BinaryReader(e)))
                }
                GetTx(e) {
                    let r = t.GetTxRequest.encode(e).finish();
                    return this.rpc.request("cosmos.tx.v1beta1.Service", "GetTx", r).then(e => t.GetTxResponse.decode(new p.BinaryReader(e)))
                }
                BroadcastTx(e) {
                    let r = t.BroadcastTxRequest.encode(e).finish();
                    return this.rpc.request("cosmos.tx.v1beta1.Service", "BroadcastTx", r).then(e => t.BroadcastTxResponse.decode(new p.BinaryReader(e)))
                }
                GetTxsEvent(e) {
                    let r = t.GetTxsEventRequest.encode(e).finish();
                    return this.rpc.request("cosmos.tx.v1beta1.Service", "GetTxsEvent", r).then(e => t.GetTxsEventResponse.decode(new p.BinaryReader(e)))
                }
                GetBlockWithTxs(e) {
                    let r = t.GetBlockWithTxsRequest.encode(e).finish();
                    return this.rpc.request("cosmos.tx.v1beta1.Service", "GetBlockWithTxs", r).then(e => t.GetBlockWithTxsResponse.decode(new p.BinaryReader(e)))
                }
                TxDecode(e) {
                    let r = t.TxDecodeRequest.encode(e).finish();
                    return this.rpc.request("cosmos.tx.v1beta1.Service", "TxDecode", r).then(e => t.TxDecodeResponse.decode(new p.BinaryReader(e)))
                }
                TxEncode(e) {
                    let r = t.TxEncodeRequest.encode(e).finish();
                    return this.rpc.request("cosmos.tx.v1beta1.Service", "TxEncode", r).then(e => t.TxEncodeResponse.decode(new p.BinaryReader(e)))
                }
                TxEncodeAmino(e) {
                    let r = t.TxEncodeAminoRequest.encode(e).finish();
                    return this.rpc.request("cosmos.tx.v1beta1.Service", "TxEncodeAmino", r).then(e => t.TxEncodeAminoResponse.decode(new p.BinaryReader(e)))
                }
                TxDecodeAmino(e) {
                    let r = t.TxDecodeAminoRequest.encode(e).finish();
                    return this.rpc.request("cosmos.tx.v1beta1.Service", "TxDecodeAmino", r).then(e => t.TxDecodeAminoResponse.decode(new p.BinaryReader(e)))
                }
            }
            t.ServiceClientImpl = D
        },
        93739: function(e, t, r) {
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: !0
            }), t.AuxSignerData = t.Tip = t.Fee = t.ModeInfo_Multi = t.ModeInfo_Single = t.ModeInfo = t.SignerInfo = t.AuthInfo = t.TxBody = t.SignDocDirectAux = t.SignDoc = t.TxRaw = t.Tx = t.protobufPackage = void 0;
            let n = r(65676),
                o = r(43062),
                i = r(96947),
                a = r(62809),
                s = r(28486),
                d = r(6476);

            function c() {
                return {
                    body: void 0,
                    authInfo: void 0,
                    signatures: []
                }
            }

            function l() {
                return {
                    bodyBytes: new Uint8Array,
                    authInfoBytes: new Uint8Array,
                    signatures: []
                }
            }

            function u() {
                return {
                    bodyBytes: new Uint8Array,
                    authInfoBytes: new Uint8Array,
                    chainId: "",
                    accountNumber: BigInt(0)
                }
            }

            function p() {
                return {
                    bodyBytes: new Uint8Array,
                    publicKey: void 0,
                    chainId: "",
                    accountNumber: BigInt(0),
                    sequence: BigInt(0),
                    tip: void 0
                }
            }

            function m() {
                return {
                    messages: [],
                    memo: "",
                    timeoutHeight: BigInt(0),
                    extensionOptions: [],
                    nonCriticalExtensionOptions: []
                }
            }

            function g() {
                return {
                    signerInfos: [],
                    fee: void 0,
                    tip: void 0
                }
            }

            function f() {
                return {
                    publicKey: void 0,
                    modeInfo: void 0,
                    sequence: BigInt(0)
                }
            }

            function y() {
                return {
                    single: void 0,
                    multi: void 0
                }
            }

            function h() {
                return {
                    mode: 0
                }
            }

            function v() {
                return {
                    bitarray: void 0,
                    modeInfos: []
                }
            }

            function b() {
                return {
                    amount: [],
                    gasLimit: BigInt(0),
                    payer: "",
                    granter: ""
                }
            }

            function S() {
                return {
                    amount: [],
                    tipper: ""
                }
            }

            function k() {
                return {
                    address: "",
                    signDoc: void 0,
                    mode: 0,
                    sig: new Uint8Array
                }
            }
            t.protobufPackage = "cosmos.tx.v1beta1", t.Tx = {
                typeUrl: "/cosmos.tx.v1beta1.Tx",
                encode(e, r = s.BinaryWriter.create()) {
                    for (let n of (void 0 !== e.body && t.TxBody.encode(e.body, r.uint32(10).fork()).ldelim(), void 0 !== e.authInfo && t.AuthInfo.encode(e.authInfo, r.uint32(18).fork()).ldelim(), e.signatures)) r.uint32(26).bytes(n);
                    return r
                },
                decode(e, r) {
                    let n = e instanceof s.BinaryReader ? e : new s.BinaryReader(e),
                        o = void 0 === r ? n.len : n.pos + r,
                        i = c();
                    for (; n.pos < o;) {
                        let e = n.uint32();
                        switch (e >>> 3) {
                            case 1:
                                i.body = t.TxBody.decode(n, n.uint32());
                                break;
                            case 2:
                                i.authInfo = t.AuthInfo.decode(n, n.uint32());
                                break;
                            case 3:
                                i.signatures.push(n.bytes());
                                break;
                            default:
                                n.skipType(7 & e)
                        }
                    }
                    return i
                },
                fromJSON(e) {
                    let r = c();
                    return (0, d.isSet)(e.body) && (r.body = t.TxBody.fromJSON(e.body)), (0, d.isSet)(e.authInfo) && (r.authInfo = t.AuthInfo.fromJSON(e.authInfo)), Array.isArray(e ? .signatures) && (r.signatures = e.signatures.map(e => (0, d.bytesFromBase64)(e))), r
                },
                toJSON(e) {
                    let r = {};
                    return void 0 !== e.body && (r.body = e.body ? t.TxBody.toJSON(e.body) : void 0), void 0 !== e.authInfo && (r.authInfo = e.authInfo ? t.AuthInfo.toJSON(e.authInfo) : void 0), e.signatures ? r.signatures = e.signatures.map(e => (0, d.base64FromBytes)(void 0 !== e ? e : new Uint8Array)) : r.signatures = [], r
                },
                fromPartial(e) {
                    let r = c();
                    return void 0 !== e.body && null !== e.body && (r.body = t.TxBody.fromPartial(e.body)), void 0 !== e.authInfo && null !== e.authInfo && (r.authInfo = t.AuthInfo.fromPartial(e.authInfo)), r.signatures = e.signatures ? .map(e => e) || [], r
                }
            }, t.TxRaw = {
                typeUrl: "/cosmos.tx.v1beta1.TxRaw",
                encode(e, t = s.BinaryWriter.create()) {
                    for (let r of (0 !== e.bodyBytes.length && t.uint32(10).bytes(e.bodyBytes), 0 !== e.authInfoBytes.length && t.uint32(18).bytes(e.authInfoBytes), e.signatures)) t.uint32(26).bytes(r);
                    return t
                },
                decode(e, t) {
                    let r = e instanceof s.BinaryReader ? e : new s.BinaryReader(e),
                        n = void 0 === t ? r.len : r.pos + t,
                        o = l();
                    for (; r.pos < n;) {
                        let e = r.uint32();
                        switch (e >>> 3) {
                            case 1:
                                o.bodyBytes = r.bytes();
                                break;
                            case 2:
                                o.authInfoBytes = r.bytes();
                                break;
                            case 3:
                                o.signatures.push(r.bytes());
                                break;
                            default:
                                r.skipType(7 & e)
                        }
                    }
                    return o
                },
                fromJSON(e) {
                    let t = l();
                    return (0, d.isSet)(e.bodyBytes) && (t.bodyBytes = (0, d.bytesFromBase64)(e.bodyBytes)), (0, d.isSet)(e.authInfoBytes) && (t.authInfoBytes = (0, d.bytesFromBase64)(e.authInfoBytes)), Array.isArray(e ? .signatures) && (t.signatures = e.signatures.map(e => (0, d.bytesFromBase64)(e))), t
                },
                toJSON(e) {
                    let t = {};
                    return void 0 !== e.bodyBytes && (t.bodyBytes = (0, d.base64FromBytes)(void 0 !== e.bodyBytes ? e.bodyBytes : new Uint8Array)), void 0 !== e.authInfoBytes && (t.authInfoBytes = (0, d.base64FromBytes)(void 0 !== e.authInfoBytes ? e.authInfoBytes : new Uint8Array)), e.signatures ? t.signatures = e.signatures.map(e => (0, d.base64FromBytes)(void 0 !== e ? e : new Uint8Array)) : t.signatures = [], t
                },
                fromPartial(e) {
                    let t = l();
                    return t.bodyBytes = e.bodyBytes ? ? new Uint8Array, t.authInfoBytes = e.authInfoBytes ? ? new Uint8Array, t.signatures = e.signatures ? .map(e => e) || [], t
                }
            }, t.SignDoc = {
                typeUrl: "/cosmos.tx.v1beta1.SignDoc",
                encode: (e, t = s.BinaryWriter.create()) => (0 !== e.bodyBytes.length && t.uint32(10).bytes(e.bodyBytes), 0 !== e.authInfoBytes.length && t.uint32(18).bytes(e.authInfoBytes), "" !== e.chainId && t.uint32(26).string(e.chainId), e.accountNumber !== BigInt(0) && t.uint32(32).uint64(e.accountNumber), t),
                decode(e, t) {
                    let r = e instanceof s.BinaryReader ? e : new s.BinaryReader(e),
                        n = void 0 === t ? r.len : r.pos + t,
                        o = u();
                    for (; r.pos < n;) {
                        let e = r.uint32();
                        switch (e >>> 3) {
                            case 1:
                                o.bodyBytes = r.bytes();
                                break;
                            case 2:
                                o.authInfoBytes = r.bytes();
                                break;
                            case 3:
                                o.chainId = r.string();
                                break;
                            case 4:
                                o.accountNumber = r.uint64();
                                break;
                            default:
                                r.skipType(7 & e)
                        }
                    }
                    return o
                },
                fromJSON(e) {
                    let t = u();
                    return (0, d.isSet)(e.bodyBytes) && (t.bodyBytes = (0, d.bytesFromBase64)(e.bodyBytes)), (0, d.isSet)(e.authInfoBytes) && (t.authInfoBytes = (0, d.bytesFromBase64)(e.authInfoBytes)), (0, d.isSet)(e.chainId) && (t.chainId = String(e.chainId)), (0, d.isSet)(e.accountNumber) && (t.accountNumber = BigInt(e.accountNumber.toString())), t
                },
                toJSON(e) {
                    let t = {};
                    return void 0 !== e.bodyBytes && (t.bodyBytes = (0, d.base64FromBytes)(void 0 !== e.bodyBytes ? e.bodyBytes : new Uint8Array)), void 0 !== e.authInfoBytes && (t.authInfoBytes = (0, d.base64FromBytes)(void 0 !== e.authInfoBytes ? e.authInfoBytes : new Uint8Array)), void 0 !== e.chainId && (t.chainId = e.chainId), void 0 !== e.accountNumber && (t.accountNumber = (e.accountNumber || BigInt(0)).toString()), t
                },
                fromPartial(e) {
                    let t = u();
                    return t.bodyBytes = e.bodyBytes ? ? new Uint8Array, t.authInfoBytes = e.authInfoBytes ? ? new Uint8Array, t.chainId = e.chainId ? ? "", void 0 !== e.accountNumber && null !== e.accountNumber && (t.accountNumber = BigInt(e.accountNumber.toString())), t
                }
            }, t.SignDocDirectAux = {
                typeUrl: "/cosmos.tx.v1beta1.SignDocDirectAux",
                encode: (e, r = s.BinaryWriter.create()) => (0 !== e.bodyBytes.length && r.uint32(10).bytes(e.bodyBytes), void 0 !== e.publicKey && n.Any.encode(e.publicKey, r.uint32(18).fork()).ldelim(), "" !== e.chainId && r.uint32(26).string(e.chainId), e.accountNumber !== BigInt(0) && r.uint32(32).uint64(e.accountNumber), e.sequence !== BigInt(0) && r.uint32(40).uint64(e.sequence), void 0 !== e.tip && t.Tip.encode(e.tip, r.uint32(50).fork()).ldelim(), r),
                decode(e, r) {
                    let o = e instanceof s.BinaryReader ? e : new s.BinaryReader(e),
                        i = void 0 === r ? o.len : o.pos + r,
                        a = p();
                    for (; o.pos < i;) {
                        let e = o.uint32();
                        switch (e >>> 3) {
                            case 1:
                                a.bodyBytes = o.bytes();
                                break;
                            case 2:
                                a.publicKey = n.Any.decode(o, o.uint32());
                                break;
                            case 3:
                                a.chainId = o.string();
                                break;
                            case 4:
                                a.accountNumber = o.uint64();
                                break;
                            case 5:
                                a.sequence = o.uint64();
                                break;
                            case 6:
                                a.tip = t.Tip.decode(o, o.uint32());
                                break;
                            default:
                                o.skipType(7 & e)
                        }
                    }
                    return a
                },
                fromJSON(e) {
                    let r = p();
                    return (0, d.isSet)(e.bodyBytes) && (r.bodyBytes = (0, d.bytesFromBase64)(e.bodyBytes)), (0, d.isSet)(e.publicKey) && (r.publicKey = n.Any.fromJSON(e.publicKey)), (0, d.isSet)(e.chainId) && (r.chainId = String(e.chainId)), (0, d.isSet)(e.accountNumber) && (r.accountNumber = BigInt(e.accountNumber.toString())), (0, d.isSet)(e.sequence) && (r.sequence = BigInt(e.sequence.toString())), (0, d.isSet)(e.tip) && (r.tip = t.Tip.fromJSON(e.tip)), r
                },
                toJSON(e) {
                    let r = {};
                    return void 0 !== e.bodyBytes && (r.bodyBytes = (0, d.base64FromBytes)(void 0 !== e.bodyBytes ? e.bodyBytes : new Uint8Array)), void 0 !== e.publicKey && (r.publicKey = e.publicKey ? n.Any.toJSON(e.publicKey) : void 0), void 0 !== e.chainId && (r.chainId = e.chainId), void 0 !== e.accountNumber && (r.accountNumber = (e.accountNumber || BigInt(0)).toString()), void 0 !== e.sequence && (r.sequence = (e.sequence || BigInt(0)).toString()), void 0 !== e.tip && (r.tip = e.tip ? t.Tip.toJSON(e.tip) : void 0), r
                },
                fromPartial(e) {
                    let r = p();
                    return r.bodyBytes = e.bodyBytes ? ? new Uint8Array, void 0 !== e.publicKey && null !== e.publicKey && (r.publicKey = n.Any.fromPartial(e.publicKey)), r.chainId = e.chainId ? ? "", void 0 !== e.accountNumber && null !== e.accountNumber && (r.accountNumber = BigInt(e.accountNumber.toString())), void 0 !== e.sequence && null !== e.sequence && (r.sequence = BigInt(e.sequence.toString())), void 0 !== e.tip && null !== e.tip && (r.tip = t.Tip.fromPartial(e.tip)), r
                }
            }, t.TxBody = {
                typeUrl: "/cosmos.tx.v1beta1.TxBody",
                encode(e, t = s.BinaryWriter.create()) {
                    for (let r of e.messages) n.Any.encode(r, t.uint32(10).fork()).ldelim();
                    for (let r of ("" !== e.memo && t.uint32(18).string(e.memo), e.timeoutHeight !== BigInt(0) && t.uint32(24).uint64(e.timeoutHeight), e.extensionOptions)) n.Any.encode(r, t.uint32(8186).fork()).ldelim();
                    for (let r of e.nonCriticalExtensionOptions) n.Any.encode(r, t.uint32(16378).fork()).ldelim();
                    return t
                },
                decode(e, t) {
                    let r = e instanceof s.BinaryReader ? e : new s.BinaryReader(e),
                        o = void 0 === t ? r.len : r.pos + t,
                        i = m();
                    for (; r.pos < o;) {
                        let e = r.uint32();
                        switch (e >>> 3) {
                            case 1:
                                i.messages.push(n.Any.decode(r, r.uint32()));
                                break;
                            case 2:
                                i.memo = r.string();
                                break;
                            case 3:
                                i.timeoutHeight = r.uint64();
                                break;
                            case 1023:
                                i.extensionOptions.push(n.Any.decode(r, r.uint32()));
                                break;
                            case 2047:
                                i.nonCriticalExtensionOptions.push(n.Any.decode(r, r.uint32()));
                                break;
                            default:
                                r.skipType(7 & e)
                        }
                    }
                    return i
                },
                fromJSON(e) {
                    let t = m();
                    return Array.isArray(e ? .messages) && (t.messages = e.messages.map(e => n.Any.fromJSON(e))), (0, d.isSet)(e.memo) && (t.memo = String(e.memo)), (0, d.isSet)(e.timeoutHeight) && (t.timeoutHeight = BigInt(e.timeoutHeight.toString())), Array.isArray(e ? .extensionOptions) && (t.extensionOptions = e.extensionOptions.map(e => n.Any.fromJSON(e))), Array.isArray(e ? .nonCriticalExtensionOptions) && (t.nonCriticalExtensionOptions = e.nonCriticalExtensionOptions.map(e => n.Any.fromJSON(e))), t
                },
                toJSON(e) {
                    let t = {};
                    return e.messages ? t.messages = e.messages.map(e => e ? n.Any.toJSON(e) : void 0) : t.messages = [], void 0 !== e.memo && (t.memo = e.memo), void 0 !== e.timeoutHeight && (t.timeoutHeight = (e.timeoutHeight || BigInt(0)).toString()), e.extensionOptions ? t.extensionOptions = e.extensionOptions.map(e => e ? n.Any.toJSON(e) : void 0) : t.extensionOptions = [], e.nonCriticalExtensionOptions ? t.nonCriticalExtensionOptions = e.nonCriticalExtensionOptions.map(e => e ? n.Any.toJSON(e) : void 0) : t.nonCriticalExtensionOptions = [], t
                },
                fromPartial(e) {
                    let t = m();
                    return t.messages = e.messages ? .map(e => n.Any.fromPartial(e)) || [], t.memo = e.memo ? ? "", void 0 !== e.timeoutHeight && null !== e.timeoutHeight && (t.timeoutHeight = BigInt(e.timeoutHeight.toString())), t.extensionOptions = e.extensionOptions ? .map(e => n.Any.fromPartial(e)) || [], t.nonCriticalExtensionOptions = e.nonCriticalExtensionOptions ? .map(e => n.Any.fromPartial(e)) || [], t
                }
            }, t.AuthInfo = {
                typeUrl: "/cosmos.tx.v1beta1.AuthInfo",
                encode(e, r = s.BinaryWriter.create()) {
                    for (let n of e.signerInfos) t.SignerInfo.encode(n, r.uint32(10).fork()).ldelim();
                    return void 0 !== e.fee && t.Fee.encode(e.fee, r.uint32(18).fork()).ldelim(), void 0 !== e.tip && t.Tip.encode(e.tip, r.uint32(26).fork()).ldelim(), r
                },
                decode(e, r) {
                    let n = e instanceof s.BinaryReader ? e : new s.BinaryReader(e),
                        o = void 0 === r ? n.len : n.pos + r,
                        i = g();
                    for (; n.pos < o;) {
                        let e = n.uint32();
                        switch (e >>> 3) {
                            case 1:
                                i.signerInfos.push(t.SignerInfo.decode(n, n.uint32()));
                                break;
                            case 2:
                                i.fee = t.Fee.decode(n, n.uint32());
                                break;
                            case 3:
                                i.tip = t.Tip.decode(n, n.uint32());
                                break;
                            default:
                                n.skipType(7 & e)
                        }
                    }
                    return i
                },
                fromJSON(e) {
                    let r = g();
                    return Array.isArray(e ? .signerInfos) && (r.signerInfos = e.signerInfos.map(e => t.SignerInfo.fromJSON(e))), (0, d.isSet)(e.fee) && (r.fee = t.Fee.fromJSON(e.fee)), (0, d.isSet)(e.tip) && (r.tip = t.Tip.fromJSON(e.tip)), r
                },
                toJSON(e) {
                    let r = {};
                    return e.signerInfos ? r.signerInfos = e.signerInfos.map(e => e ? t.SignerInfo.toJSON(e) : void 0) : r.signerInfos = [], void 0 !== e.fee && (r.fee = e.fee ? t.Fee.toJSON(e.fee) : void 0), void 0 !== e.tip && (r.tip = e.tip ? t.Tip.toJSON(e.tip) : void 0), r
                },
                fromPartial(e) {
                    let r = g();
                    return r.signerInfos = e.signerInfos ? .map(e => t.SignerInfo.fromPartial(e)) || [], void 0 !== e.fee && null !== e.fee && (r.fee = t.Fee.fromPartial(e.fee)), void 0 !== e.tip && null !== e.tip && (r.tip = t.Tip.fromPartial(e.tip)), r
                }
            }, t.SignerInfo = {
                typeUrl: "/cosmos.tx.v1beta1.SignerInfo",
                encode: (e, r = s.BinaryWriter.create()) => (void 0 !== e.publicKey && n.Any.encode(e.publicKey, r.uint32(10).fork()).ldelim(), void 0 !== e.modeInfo && t.ModeInfo.encode(e.modeInfo, r.uint32(18).fork()).ldelim(), e.sequence !== BigInt(0) && r.uint32(24).uint64(e.sequence), r),
                decode(e, r) {
                    let o = e instanceof s.BinaryReader ? e : new s.BinaryReader(e),
                        i = void 0 === r ? o.len : o.pos + r,
                        a = f();
                    for (; o.pos < i;) {
                        let e = o.uint32();
                        switch (e >>> 3) {
                            case 1:
                                a.publicKey = n.Any.decode(o, o.uint32());
                                break;
                            case 2:
                                a.modeInfo = t.ModeInfo.decode(o, o.uint32());
                                break;
                            case 3:
                                a.sequence = o.uint64();
                                break;
                            default:
                                o.skipType(7 & e)
                        }
                    }
                    return a
                },
                fromJSON(e) {
                    let r = f();
                    return (0, d.isSet)(e.publicKey) && (r.publicKey = n.Any.fromJSON(e.publicKey)), (0, d.isSet)(e.modeInfo) && (r.modeInfo = t.ModeInfo.fromJSON(e.modeInfo)), (0, d.isSet)(e.sequence) && (r.sequence = BigInt(e.sequence.toString())), r
                },
                toJSON(e) {
                    let r = {};
                    return void 0 !== e.publicKey && (r.publicKey = e.publicKey ? n.Any.toJSON(e.publicKey) : void 0), void 0 !== e.modeInfo && (r.modeInfo = e.modeInfo ? t.ModeInfo.toJSON(e.modeInfo) : void 0), void 0 !== e.sequence && (r.sequence = (e.sequence || BigInt(0)).toString()), r
                },
                fromPartial(e) {
                    let r = f();
                    return void 0 !== e.publicKey && null !== e.publicKey && (r.publicKey = n.Any.fromPartial(e.publicKey)), void 0 !== e.modeInfo && null !== e.modeInfo && (r.modeInfo = t.ModeInfo.fromPartial(e.modeInfo)), void 0 !== e.sequence && null !== e.sequence && (r.sequence = BigInt(e.sequence.toString())), r
                }
            }, t.ModeInfo = {
                typeUrl: "/cosmos.tx.v1beta1.ModeInfo",
                encode: (e, r = s.BinaryWriter.create()) => (void 0 !== e.single && t.ModeInfo_Single.encode(e.single, r.uint32(10).fork()).ldelim(), void 0 !== e.multi && t.ModeInfo_Multi.encode(e.multi, r.uint32(18).fork()).ldelim(), r),
                decode(e, r) {
                    let n = e instanceof s.BinaryReader ? e : new s.BinaryReader(e),
                        o = void 0 === r ? n.len : n.pos + r,
                        i = y();
                    for (; n.pos < o;) {
                        let e = n.uint32();
                        switch (e >>> 3) {
                            case 1:
                                i.single = t.ModeInfo_Single.decode(n, n.uint32());
                                break;
                            case 2:
                                i.multi = t.ModeInfo_Multi.decode(n, n.uint32());
                                break;
                            default:
                                n.skipType(7 & e)
                        }
                    }
                    return i
                },
                fromJSON(e) {
                    let r = y();
                    return (0, d.isSet)(e.single) && (r.single = t.ModeInfo_Single.fromJSON(e.single)), (0, d.isSet)(e.multi) && (r.multi = t.ModeInfo_Multi.fromJSON(e.multi)), r
                },
                toJSON(e) {
                    let r = {};
                    return void 0 !== e.single && (r.single = e.single ? t.ModeInfo_Single.toJSON(e.single) : void 0), void 0 !== e.multi && (r.multi = e.multi ? t.ModeInfo_Multi.toJSON(e.multi) : void 0), r
                },
                fromPartial(e) {
                    let r = y();
                    return void 0 !== e.single && null !== e.single && (r.single = t.ModeInfo_Single.fromPartial(e.single)), void 0 !== e.multi && null !== e.multi && (r.multi = t.ModeInfo_Multi.fromPartial(e.multi)), r
                }
            }, t.ModeInfo_Single = {
                typeUrl: "/cosmos.tx.v1beta1.Single",
                encode: (e, t = s.BinaryWriter.create()) => (0 !== e.mode && t.uint32(8).int32(e.mode), t),
                decode(e, t) {
                    let r = e instanceof s.BinaryReader ? e : new s.BinaryReader(e),
                        n = void 0 === t ? r.len : r.pos + t,
                        o = h();
                    for (; r.pos < n;) {
                        let e = r.uint32();
                        e >>> 3 == 1 ? o.mode = r.int32() : r.skipType(7 & e)
                    }
                    return o
                },
                fromJSON(e) {
                    let t = h();
                    return (0, d.isSet)(e.mode) && (t.mode = (0, o.signModeFromJSON)(e.mode)), t
                },
                toJSON(e) {
                    let t = {};
                    return void 0 !== e.mode && (t.mode = (0, o.signModeToJSON)(e.mode)), t
                },
                fromPartial(e) {
                    let t = h();
                    return t.mode = e.mode ? ? 0, t
                }
            }, t.ModeInfo_Multi = {
                typeUrl: "/cosmos.tx.v1beta1.Multi",
                encode(e, r = s.BinaryWriter.create()) {
                    for (let n of (void 0 !== e.bitarray && i.CompactBitArray.encode(e.bitarray, r.uint32(10).fork()).ldelim(), e.modeInfos)) t.ModeInfo.encode(n, r.uint32(18).fork()).ldelim();
                    return r
                },
                decode(e, r) {
                    let n = e instanceof s.BinaryReader ? e : new s.BinaryReader(e),
                        o = void 0 === r ? n.len : n.pos + r,
                        a = v();
                    for (; n.pos < o;) {
                        let e = n.uint32();
                        switch (e >>> 3) {
                            case 1:
                                a.bitarray = i.CompactBitArray.decode(n, n.uint32());
                                break;
                            case 2:
                                a.modeInfos.push(t.ModeInfo.decode(n, n.uint32()));
                                break;
                            default:
                                n.skipType(7 & e)
                        }
                    }
                    return a
                },
                fromJSON(e) {
                    let r = v();
                    return (0, d.isSet)(e.bitarray) && (r.bitarray = i.CompactBitArray.fromJSON(e.bitarray)), Array.isArray(e ? .modeInfos) && (r.modeInfos = e.modeInfos.map(e => t.ModeInfo.fromJSON(e))), r
                },
                toJSON(e) {
                    let r = {};
                    return void 0 !== e.bitarray && (r.bitarray = e.bitarray ? i.CompactBitArray.toJSON(e.bitarray) : void 0), e.modeInfos ? r.modeInfos = e.modeInfos.map(e => e ? t.ModeInfo.toJSON(e) : void 0) : r.modeInfos = [], r
                },
                fromPartial(e) {
                    let r = v();
                    return void 0 !== e.bitarray && null !== e.bitarray && (r.bitarray = i.CompactBitArray.fromPartial(e.bitarray)), r.modeInfos = e.modeInfos ? .map(e => t.ModeInfo.fromPartial(e)) || [], r
                }
            }, t.Fee = {
                typeUrl: "/cosmos.tx.v1beta1.Fee",
                encode(e, t = s.BinaryWriter.create()) {
                    for (let r of e.amount) a.Coin.encode(r, t.uint32(10).fork()).ldelim();
                    return e.gasLimit !== BigInt(0) && t.uint32(16).uint64(e.gasLimit), "" !== e.payer && t.uint32(26).string(e.payer), "" !== e.granter && t.uint32(34).string(e.granter), t
                },
                decode(e, t) {
                    let r = e instanceof s.BinaryReader ? e : new s.BinaryReader(e),
                        n = void 0 === t ? r.len : r.pos + t,
                        o = b();
                    for (; r.pos < n;) {
                        let e = r.uint32();
                        switch (e >>> 3) {
                            case 1:
                                o.amount.push(a.Coin.decode(r, r.uint32()));
                                break;
                            case 2:
                                o.gasLimit = r.uint64();
                                break;
                            case 3:
                                o.payer = r.string();
                                break;
                            case 4:
                                o.granter = r.string();
                                break;
                            default:
                                r.skipType(7 & e)
                        }
                    }
                    return o
                },
                fromJSON(e) {
                    let t = b();
                    return Array.isArray(e ? .amount) && (t.amount = e.amount.map(e => a.Coin.fromJSON(e))), (0, d.isSet)(e.gasLimit) && (t.gasLimit = BigInt(e.gasLimit.toString())), (0, d.isSet)(e.payer) && (t.payer = String(e.payer)), (0, d.isSet)(e.granter) && (t.granter = String(e.granter)), t
                },
                toJSON(e) {
                    let t = {};
                    return e.amount ? t.amount = e.amount.map(e => e ? a.Coin.toJSON(e) : void 0) : t.amount = [], void 0 !== e.gasLimit && (t.gasLimit = (e.gasLimit || BigInt(0)).toString()), void 0 !== e.payer && (t.payer = e.payer), void 0 !== e.granter && (t.granter = e.granter), t
                },
                fromPartial(e) {
                    let t = b();
                    return t.amount = e.amount ? .map(e => a.Coin.fromPartial(e)) || [], void 0 !== e.gasLimit && null !== e.gasLimit && (t.gasLimit = BigInt(e.gasLimit.toString())), t.payer = e.payer ? ? "", t.granter = e.granter ? ? "", t
                }
            }, t.Tip = {
                typeUrl: "/cosmos.tx.v1beta1.Tip",
                encode(e, t = s.BinaryWriter.create()) {
                    for (let r of e.amount) a.Coin.encode(r, t.uint32(10).fork()).ldelim();
                    return "" !== e.tipper && t.uint32(18).string(e.tipper), t
                },
                decode(e, t) {
                    let r = e instanceof s.BinaryReader ? e : new s.BinaryReader(e),
                        n = void 0 === t ? r.len : r.pos + t,
                        o = S();
                    for (; r.pos < n;) {
                        let e = r.uint32();
                        switch (e >>> 3) {
                            case 1:
                                o.amount.push(a.Coin.decode(r, r.uint32()));
                                break;
                            case 2:
                                o.tipper = r.string();
                                break;
                            default:
                                r.skipType(7 & e)
                        }
                    }
                    return o
                },
                fromJSON(e) {
                    let t = S();
                    return Array.isArray(e ? .amount) && (t.amount = e.amount.map(e => a.Coin.fromJSON(e))), (0, d.isSet)(e.tipper) && (t.tipper = String(e.tipper)), t
                },
                toJSON(e) {
                    let t = {};
                    return e.amount ? t.amount = e.amount.map(e => e ? a.Coin.toJSON(e) : void 0) : t.amount = [], void 0 !== e.tipper && (t.tipper = e.tipper), t
                },
                fromPartial(e) {
                    let t = S();
                    return t.amount = e.amount ? .map(e => a.Coin.fromPartial(e)) || [], t.tipper = e.tipper ? ? "", t
                }
            }, t.AuxSignerData = {
                typeUrl: "/cosmos.tx.v1beta1.AuxSignerData",
                encode: (e, r = s.BinaryWriter.create()) => ("" !== e.address && r.uint32(10).string(e.address), void 0 !== e.signDoc && t.SignDocDirectAux.encode(e.signDoc, r.uint32(18).fork()).ldelim(), 0 !== e.mode && r.uint32(24).int32(e.mode), 0 !== e.sig.length && r.uint32(34).bytes(e.sig), r),
                decode(e, r) {
                    let n = e instanceof s.BinaryReader ? e : new s.BinaryReader(e),
                        o = void 0 === r ? n.len : n.pos + r,
                        i = k();
                    for (; n.pos < o;) {
                        let e = n.uint32();
                        switch (e >>> 3) {
                            case 1:
                                i.address = n.string();
                                break;
                            case 2:
                                i.signDoc = t.SignDocDirectAux.decode(n, n.uint32());
                                break;
                            case 3:
                                i.mode = n.int32();
                                break;
                            case 4:
                                i.sig = n.bytes();
                                break;
                            default:
                                n.skipType(7 & e)
                        }
                    }
                    return i
                },
                fromJSON(e) {
                    let r = k();
                    return (0, d.isSet)(e.address) && (r.address = String(e.address)), (0, d.isSet)(e.signDoc) && (r.signDoc = t.SignDocDirectAux.fromJSON(e.signDoc)), (0, d.isSet)(e.mode) && (r.mode = (0, o.signModeFromJSON)(e.mode)), (0, d.isSet)(e.sig) && (r.sig = (0, d.bytesFromBase64)(e.sig)), r
                },
                toJSON(e) {
                    let r = {};
                    return void 0 !== e.address && (r.address = e.address), void 0 !== e.signDoc && (r.signDoc = e.signDoc ? t.SignDocDirectAux.toJSON(e.signDoc) : void 0), void 0 !== e.mode && (r.mode = (0, o.signModeToJSON)(e.mode)), void 0 !== e.sig && (r.sig = (0, d.base64FromBytes)(void 0 !== e.sig ? e.sig : new Uint8Array)), r
                },
                fromPartial(e) {
                    let r = k();
                    return r.address = e.address ? ? "", void 0 !== e.signDoc && null !== e.signDoc && (r.signDoc = t.SignDocDirectAux.fromPartial(e.signDoc)), r.mode = e.mode ? ? 0, r.sig = e.sig ? ? new Uint8Array, r
                }
            }
        },
        47256: function(e, t, r) {
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: !0
            }), t.ModuleVersion = t.CancelSoftwareUpgradeProposal = t.SoftwareUpgradeProposal = t.Plan = t.protobufPackage = void 0;
            let n = r(90614),
                o = r(65676),
                i = r(28486),
                a = r(6476);

            function s() {
                return {
                    name: "",
                    time: n.Timestamp.fromPartial({}),
                    height: BigInt(0),
                    info: "",
                    upgradedClientState: void 0
                }
            }

            function d() {
                return {
                    title: "",
                    description: "",
                    plan: t.Plan.fromPartial({})
                }
            }

            function c() {
                return {
                    title: "",
                    description: ""
                }
            }

            function l() {
                return {
                    name: "",
                    version: BigInt(0)
                }
            }
            t.protobufPackage = "cosmos.upgrade.v1beta1", t.Plan = {
                typeUrl: "/cosmos.upgrade.v1beta1.Plan",
                encode: (e, t = i.BinaryWriter.create()) => ("" !== e.name && t.uint32(10).string(e.name), void 0 !== e.time && n.Timestamp.encode(e.time, t.uint32(18).fork()).ldelim(), e.height !== BigInt(0) && t.uint32(24).int64(e.height), "" !== e.info && t.uint32(34).string(e.info), void 0 !== e.upgradedClientState && o.Any.encode(e.upgradedClientState, t.uint32(42).fork()).ldelim(), t),
                decode(e, t) {
                    let r = e instanceof i.BinaryReader ? e : new i.BinaryReader(e),
                        a = void 0 === t ? r.len : r.pos + t,
                        d = s();
                    for (; r.pos < a;) {
                        let e = r.uint32();
                        switch (e >>> 3) {
                            case 1:
                                d.name = r.string();
                                break;
                            case 2:
                                d.time = n.Timestamp.decode(r, r.uint32());
                                break;
                            case 3:
                                d.height = r.int64();
                                break;
                            case 4:
                                d.info = r.string();
                                break;
                            case 5:
                                d.upgradedClientState = o.Any.decode(r, r.uint32());
                                break;
                            default:
                                r.skipType(7 & e)
                        }
                    }
                    return d
                },
                fromJSON(e) {
                    let t = s();
                    return (0, a.isSet)(e.name) && (t.name = String(e.name)), (0, a.isSet)(e.time) && (t.time = (0, a.fromJsonTimestamp)(e.time)), (0, a.isSet)(e.height) && (t.height = BigInt(e.height.toString())), (0, a.isSet)(e.info) && (t.info = String(e.info)), (0, a.isSet)(e.upgradedClientState) && (t.upgradedClientState = o.Any.fromJSON(e.upgradedClientState)), t
                },
                toJSON(e) {
                    let t = {};
                    return void 0 !== e.name && (t.name = e.name), void 0 !== e.time && (t.time = (0, a.fromTimestamp)(e.time).toISOString()), void 0 !== e.height && (t.height = (e.height || BigInt(0)).toString()), void 0 !== e.info && (t.info = e.info), void 0 !== e.upgradedClientState && (t.upgradedClientState = e.upgradedClientState ? o.Any.toJSON(e.upgradedClientState) : void 0), t
                },
                fromPartial(e) {
                    let t = s();
                    return t.name = e.name ? ? "", void 0 !== e.time && null !== e.time && (t.time = n.Timestamp.fromPartial(e.time)), void 0 !== e.height && null !== e.height && (t.height = BigInt(e.height.toString())), t.info = e.info ? ? "", void 0 !== e.upgradedClientState && null !== e.upgradedClientState && (t.upgradedClientState = o.Any.fromPartial(e.upgradedClientState)), t
                }
            }, t.SoftwareUpgradeProposal = {
                typeUrl: "/cosmos.upgrade.v1beta1.SoftwareUpgradeProposal",
                encode: (e, r = i.BinaryWriter.create()) => ("" !== e.title && r.uint32(10).string(e.title), "" !== e.description && r.uint32(18).string(e.description), void 0 !== e.plan && t.Plan.encode(e.plan, r.uint32(26).fork()).ldelim(), r),
                decode(e, r) {
                    let n = e instanceof i.BinaryReader ? e : new i.BinaryReader(e),
                        o = void 0 === r ? n.len : n.pos + r,
                        a = d();
                    for (; n.pos < o;) {
                        let e = n.uint32();
                        switch (e >>> 3) {
                            case 1:
                                a.title = n.string();
                                break;
                            case 2:
                                a.description = n.string();
                                break;
                            case 3:
                                a.plan = t.Plan.decode(n, n.uint32());
                                break;
                            default:
                                n.skipType(7 & e)
                        }
                    }
                    return a
                },
                fromJSON(e) {
                    let r = d();
                    return (0, a.isSet)(e.title) && (r.title = String(e.title)), (0, a.isSet)(e.description) && (r.description = String(e.description)), (0, a.isSet)(e.plan) && (r.plan = t.Plan.fromJSON(e.plan)), r
                },
                toJSON(e) {
                    let r = {};
                    return void 0 !== e.title && (r.title = e.title), void 0 !== e.description && (r.description = e.description), void 0 !== e.plan && (r.plan = e.plan ? t.Plan.toJSON(e.plan) : void 0), r
                },
                fromPartial(e) {
                    let r = d();
                    return r.title = e.title ? ? "", r.description = e.description ? ? "", void 0 !== e.plan && null !== e.plan && (r.plan = t.Plan.fromPartial(e.plan)), r
                }
            }, t.CancelSoftwareUpgradeProposal = {
                typeUrl: "/cosmos.upgrade.v1beta1.CancelSoftwareUpgradeProposal",
                encode: (e, t = i.BinaryWriter.create()) => ("" !== e.title && t.uint32(10).string(e.title), "" !== e.description && t.uint32(18).string(e.description), t),
                decode(e, t) {
                    let r = e instanceof i.BinaryReader ? e : new i.BinaryReader(e),
                        n = void 0 === t ? r.len : r.pos + t,
                        o = c();
                    for (; r.pos < n;) {
                        let e = r.uint32();
                        switch (e >>> 3) {
                            case 1:
                                o.title = r.string();
                                break;
                            case 2:
                                o.description = r.string();
                                break;
                            default:
                                r.skipType(7 & e)
                        }
                    }
                    return o
                },
                fromJSON(e) {
                    let t = c();
                    return (0, a.isSet)(e.title) && (t.title = String(e.title)), (0, a.isSet)(e.description) && (t.description = String(e.description)), t
                },
                toJSON(e) {
                    let t = {};
                    return void 0 !== e.title && (t.title = e.title), void 0 !== e.description && (t.description = e.description), t
                },
                fromPartial(e) {
                    let t = c();
                    return t.title = e.title ? ? "", t.description = e.description ? ? "", t
                }
            }, t.ModuleVersion = {
                typeUrl: "/cosmos.upgrade.v1beta1.ModuleVersion",
                encode: (e, t = i.BinaryWriter.create()) => ("" !== e.name && t.uint32(10).string(e.name), e.version !== BigInt(0) && t.uint32(16).uint64(e.version), t),
                decode(e, t) {
                    let r = e instanceof i.BinaryReader ? e : new i.BinaryReader(e),
                        n = void 0 === t ? r.len : r.pos + t,
                        o = l();
                    for (; r.pos < n;) {
                        let e = r.uint32();
                        switch (e >>> 3) {
                            case 1:
                                o.name = r.string();
                                break;
                            case 2:
                                o.version = r.uint64();
                                break;
                            default:
                                r.skipType(7 & e)
                        }
                    }
                    return o
                },
                fromJSON(e) {
                    let t = l();
                    return (0, a.isSet)(e.name) && (t.name = String(e.name)), (0, a.isSet)(e.version) && (t.version = BigInt(e.version.toString())), t
                },
                toJSON(e) {
                    let t = {};
                    return void 0 !== e.name && (t.name = e.name), void 0 !== e.version && (t.version = (e.version || BigInt(0)).toString()), t
                },
                fromPartial(e) {
                    let t = l();
                    return t.name = e.name ? ? "", void 0 !== e.version && null !== e.version && (t.version = BigInt(e.version.toString())), t
                }
            }
        },
        51402: function(e, t, r) {
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: !0
            }), t.MsgClientImpl = t.MsgCreatePeriodicVestingAccountResponse = t.MsgCreatePeriodicVestingAccount = t.MsgCreatePermanentLockedAccountResponse = t.MsgCreatePermanentLockedAccount = t.MsgCreateVestingAccountResponse = t.MsgCreateVestingAccount = t.protobufPackage = void 0;
            let n = r(62809),
                o = r(71667),
                i = r(28486),
                a = r(6476);

            function s() {
                return {
                    fromAddress: "",
                    toAddress: "",
                    amount: [],
                    endTime: BigInt(0),
                    delayed: !1
                }
            }

            function d() {
                return {
                    fromAddress: "",
                    toAddress: "",
                    amount: []
                }
            }

            function c() {
                return {
                    fromAddress: "",
                    toAddress: "",
                    startTime: BigInt(0),
                    vestingPeriods: []
                }
            }
            t.protobufPackage = "cosmos.vesting.v1beta1", t.MsgCreateVestingAccount = {
                typeUrl: "/cosmos.vesting.v1beta1.MsgCreateVestingAccount",
                encode(e, t = i.BinaryWriter.create()) {
                    for (let r of ("" !== e.fromAddress && t.uint32(10).string(e.fromAddress), "" !== e.toAddress && t.uint32(18).string(e.toAddress), e.amount)) n.Coin.encode(r, t.uint32(26).fork()).ldelim();
                    return e.endTime !== BigInt(0) && t.uint32(32).int64(e.endTime), !0 === e.delayed && t.uint32(40).bool(e.delayed), t
                },
                decode(e, t) {
                    let r = e instanceof i.BinaryReader ? e : new i.BinaryReader(e),
                        o = void 0 === t ? r.len : r.pos + t,
                        a = s();
                    for (; r.pos < o;) {
                        let e = r.uint32();
                        switch (e >>> 3) {
                            case 1:
                                a.fromAddress = r.string();
                                break;
                            case 2:
                                a.toAddress = r.string();
                                break;
                            case 3:
                                a.amount.push(n.Coin.decode(r, r.uint32()));
                                break;
                            case 4:
                                a.endTime = r.int64();
                                break;
                            case 5:
                                a.delayed = r.bool();
                                break;
                            default:
                                r.skipType(7 & e)
                        }
                    }
                    return a
                },
                fromJSON(e) {
                    let t = s();
                    return (0, a.isSet)(e.fromAddress) && (t.fromAddress = String(e.fromAddress)), (0, a.isSet)(e.toAddress) && (t.toAddress = String(e.toAddress)), Array.isArray(e ? .amount) && (t.amount = e.amount.map(e => n.Coin.fromJSON(e))), (0, a.isSet)(e.endTime) && (t.endTime = BigInt(e.endTime.toString())), (0, a.isSet)(e.delayed) && (t.delayed = !!e.delayed), t
                },
                toJSON(e) {
                    let t = {};
                    return void 0 !== e.fromAddress && (t.fromAddress = e.fromAddress), void 0 !== e.toAddress && (t.toAddress = e.toAddress), e.amount ? t.amount = e.amount.map(e => e ? n.Coin.toJSON(e) : void 0) : t.amount = [], void 0 !== e.endTime && (t.endTime = (e.endTime || BigInt(0)).toString()), void 0 !== e.delayed && (t.delayed = e.delayed), t
                },
                fromPartial(e) {
                    let t = s();
                    return t.fromAddress = e.fromAddress ? ? "", t.toAddress = e.toAddress ? ? "", t.amount = e.amount ? .map(e => n.Coin.fromPartial(e)) || [], void 0 !== e.endTime && null !== e.endTime && (t.endTime = BigInt(e.endTime.toString())), t.delayed = e.delayed ? ? !1, t
                }
            }, t.MsgCreateVestingAccountResponse = {
                typeUrl: "/cosmos.vesting.v1beta1.MsgCreateVestingAccountResponse",
                encode: (e, t = i.BinaryWriter.create()) => t,
                decode(e, t) {
                    let r = e instanceof i.BinaryReader ? e : new i.BinaryReader(e),
                        n = void 0 === t ? r.len : r.pos + t;
                    for (; r.pos < n;) {
                        let e = r.uint32();
                        r.skipType(7 & e)
                    }
                    return {}
                },
                fromJSON: e => ({}),
                toJSON: e => ({}),
                fromPartial: e => ({})
            }, t.MsgCreatePermanentLockedAccount = {
                typeUrl: "/cosmos.vesting.v1beta1.MsgCreatePermanentLockedAccount",
                encode(e, t = i.BinaryWriter.create()) {
                    for (let r of ("" !== e.fromAddress && t.uint32(10).string(e.fromAddress), "" !== e.toAddress && t.uint32(18).string(e.toAddress), e.amount)) n.Coin.encode(r, t.uint32(26).fork()).ldelim();
                    return t
                },
                decode(e, t) {
                    let r = e instanceof i.BinaryReader ? e : new i.BinaryReader(e),
                        o = void 0 === t ? r.len : r.pos + t,
                        a = d();
                    for (; r.pos < o;) {
                        let e = r.uint32();
                        switch (e >>> 3) {
                            case 1:
                                a.fromAddress = r.string();
                                break;
                            case 2:
                                a.toAddress = r.string();
                                break;
                            case 3:
                                a.amount.push(n.Coin.decode(r, r.uint32()));
                                break;
                            default:
                                r.skipType(7 & e)
                        }
                    }
                    return a
                },
                fromJSON(e) {
                    let t = d();
                    return (0, a.isSet)(e.fromAddress) && (t.fromAddress = String(e.fromAddress)), (0, a.isSet)(e.toAddress) && (t.toAddress = String(e.toAddress)), Array.isArray(e ? .amount) && (t.amount = e.amount.map(e => n.Coin.fromJSON(e))), t
                },
                toJSON(e) {
                    let t = {};
                    return void 0 !== e.fromAddress && (t.fromAddress = e.fromAddress), void 0 !== e.toAddress && (t.toAddress = e.toAddress), e.amount ? t.amount = e.amount.map(e => e ? n.Coin.toJSON(e) : void 0) : t.amount = [], t
                },
                fromPartial(e) {
                    let t = d();
                    return t.fromAddress = e.fromAddress ? ? "", t.toAddress = e.toAddress ? ? "", t.amount = e.amount ? .map(e => n.Coin.fromPartial(e)) || [], t
                }
            }, t.MsgCreatePermanentLockedAccountResponse = {
                typeUrl: "/cosmos.vesting.v1beta1.MsgCreatePermanentLockedAccountResponse",
                encode: (e, t = i.BinaryWriter.create()) => t,
                decode(e, t) {
                    let r = e instanceof i.BinaryReader ? e : new i.BinaryReader(e),
                        n = void 0 === t ? r.len : r.pos + t;
                    for (; r.pos < n;) {
                        let e = r.uint32();
                        r.skipType(7 & e)
                    }
                    return {}
                },
                fromJSON: e => ({}),
                toJSON: e => ({}),
                fromPartial: e => ({})
            }, t.MsgCreatePeriodicVestingAccount = {
                typeUrl: "/cosmos.vesting.v1beta1.MsgCreatePeriodicVestingAccount",
                encode(e, t = i.BinaryWriter.create()) {
                    for (let r of ("" !== e.fromAddress && t.uint32(10).string(e.fromAddress), "" !== e.toAddress && t.uint32(18).string(e.toAddress), e.startTime !== BigInt(0) && t.uint32(24).int64(e.startTime), e.vestingPeriods)) o.Period.encode(r, t.uint32(34).fork()).ldelim();
                    return t
                },
                decode(e, t) {
                    let r = e instanceof i.BinaryReader ? e : new i.BinaryReader(e),
                        n = void 0 === t ? r.len : r.pos + t,
                        a = c();
                    for (; r.pos < n;) {
                        let e = r.uint32();
                        switch (e >>> 3) {
                            case 1:
                                a.fromAddress = r.string();
                                break;
                            case 2:
                                a.toAddress = r.string();
                                break;
                            case 3:
                                a.startTime = r.int64();
                                break;
                            case 4:
                                a.vestingPeriods.push(o.Period.decode(r, r.uint32()));
                                break;
                            default:
                                r.skipType(7 & e)
                        }
                    }
                    return a
                },
                fromJSON(e) {
                    let t = c();
                    return (0, a.isSet)(e.fromAddress) && (t.fromAddress = String(e.fromAddress)), (0, a.isSet)(e.toAddress) && (t.toAddress = String(e.toAddress)), (0, a.isSet)(e.startTime) && (t.startTime = BigInt(e.startTime.toString())), Array.isArray(e ? .vestingPeriods) && (t.vestingPeriods = e.vestingPeriods.map(e => o.Period.fromJSON(e))), t
                },
                toJSON(e) {
                    let t = {};
                    return void 0 !== e.fromAddress && (t.fromAddress = e.fromAddress), void 0 !== e.toAddress && (t.toAddress = e.toAddress), void 0 !== e.startTime && (t.startTime = (e.startTime || BigInt(0)).toString()), e.vestingPeriods ? t.vestingPeriods = e.vestingPeriods.map(e => e ? o.Period.toJSON(e) : void 0) : t.vestingPeriods = [], t
                },
                fromPartial(e) {
                    let t = c();
                    return t.fromAddress = e.fromAddress ? ? "", t.toAddress = e.toAddress ? ? "", void 0 !== e.startTime && null !== e.startTime && (t.startTime = BigInt(e.startTime.toString())), t.vestingPeriods = e.vestingPeriods ? .map(e => o.Period.fromPartial(e)) || [], t
                }
            }, t.MsgCreatePeriodicVestingAccountResponse = {
                typeUrl: "/cosmos.vesting.v1beta1.MsgCreatePeriodicVestingAccountResponse",
                encode: (e, t = i.BinaryWriter.create()) => t,
                decode(e, t) {
                    let r = e instanceof i.BinaryReader ? e : new i.BinaryReader(e),
                        n = void 0 === t ? r.len : r.pos + t;
                    for (; r.pos < n;) {
                        let e = r.uint32();
                        r.skipType(7 & e)
                    }
                    return {}
                },
                fromJSON: e => ({}),
                toJSON: e => ({}),
                fromPartial: e => ({})
            };
            class l {
                constructor(e) {
                    this.rpc = e, this.CreateVestingAccount = this.CreateVestingAccount.bind(this), this.CreatePermanentLockedAccount = this.CreatePermanentLockedAccount.bind(this), this.CreatePeriodicVestingAccount = this.CreatePeriodicVestingAccount.bind(this)
                }
                CreateVestingAccount(e) {
                    let r = t.MsgCreateVestingAccount.encode(e).finish();
                    return this.rpc.request("cosmos.vesting.v1beta1.Msg", "CreateVestingAccount", r).then(e => t.MsgCreateVestingAccountResponse.decode(new i.BinaryReader(e)))
                }
                CreatePermanentLockedAccount(e) {
                    let r = t.MsgCreatePermanentLockedAccount.encode(e).finish();
                    return this.rpc.request("cosmos.vesting.v1beta1.Msg", "CreatePermanentLockedAccount", r).then(e => t.MsgCreatePermanentLockedAccountResponse.decode(new i.BinaryReader(e)))
                }
                CreatePeriodicVestingAccount(e) {
                    let r = t.MsgCreatePeriodicVestingAccount.encode(e).finish();
                    return this.rpc.request("cosmos.vesting.v1beta1.Msg", "CreatePeriodicVestingAccount", r).then(e => t.MsgCreatePeriodicVestingAccountResponse.decode(new i.BinaryReader(e)))
                }
            }
            t.MsgClientImpl = l
        },
        71667: function(e, t, r) {
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: !0
            }), t.PermanentLockedAccount = t.PeriodicVestingAccount = t.Period = t.DelayedVestingAccount = t.ContinuousVestingAccount = t.BaseVestingAccount = t.protobufPackage = void 0;
            let n = r(50166),
                o = r(62809),
                i = r(28486),
                a = r(6476);

            function s() {
                return {
                    baseAccount: void 0,
                    originalVesting: [],
                    delegatedFree: [],
                    delegatedVesting: [],
                    endTime: BigInt(0)
                }
            }

            function d() {
                return {
                    baseVestingAccount: void 0,
                    startTime: BigInt(0)
                }
            }

            function c() {
                return {
                    baseVestingAccount: void 0
                }
            }

            function l() {
                return {
                    length: BigInt(0),
                    amount: []
                }
            }

            function u() {
                return {
                    baseVestingAccount: void 0,
                    startTime: BigInt(0),
                    vestingPeriods: []
                }
            }

            function p() {
                return {
                    baseVestingAccount: void 0
                }
            }
            t.protobufPackage = "cosmos.vesting.v1beta1", t.BaseVestingAccount = {
                typeUrl: "/cosmos.vesting.v1beta1.BaseVestingAccount",
                encode(e, t = i.BinaryWriter.create()) {
                    for (let r of (void 0 !== e.baseAccount && n.BaseAccount.encode(e.baseAccount, t.uint32(10).fork()).ldelim(), e.originalVesting)) o.Coin.encode(r, t.uint32(18).fork()).ldelim();
                    for (let r of e.delegatedFree) o.Coin.encode(r, t.uint32(26).fork()).ldelim();
                    for (let r of e.delegatedVesting) o.Coin.encode(r, t.uint32(34).fork()).ldelim();
                    return e.endTime !== BigInt(0) && t.uint32(40).int64(e.endTime), t
                },
                decode(e, t) {
                    let r = e instanceof i.BinaryReader ? e : new i.BinaryReader(e),
                        a = void 0 === t ? r.len : r.pos + t,
                        d = s();
                    for (; r.pos < a;) {
                        let e = r.uint32();
                        switch (e >>> 3) {
                            case 1:
                                d.baseAccount = n.BaseAccount.decode(r, r.uint32());
                                break;
                            case 2:
                                d.originalVesting.push(o.Coin.decode(r, r.uint32()));
                                break;
                            case 3:
                                d.delegatedFree.push(o.Coin.decode(r, r.uint32()));
                                break;
                            case 4:
                                d.delegatedVesting.push(o.Coin.decode(r, r.uint32()));
                                break;
                            case 5:
                                d.endTime = r.int64();
                                break;
                            default:
                                r.skipType(7 & e)
                        }
                    }
                    return d
                },
                fromJSON(e) {
                    let t = s();
                    return (0, a.isSet)(e.baseAccount) && (t.baseAccount = n.BaseAccount.fromJSON(e.baseAccount)), Array.isArray(e ? .originalVesting) && (t.originalVesting = e.originalVesting.map(e => o.Coin.fromJSON(e))), Array.isArray(e ? .delegatedFree) && (t.delegatedFree = e.delegatedFree.map(e => o.Coin.fromJSON(e))), Array.isArray(e ? .delegatedVesting) && (t.delegatedVesting = e.delegatedVesting.map(e => o.Coin.fromJSON(e))), (0, a.isSet)(e.endTime) && (t.endTime = BigInt(e.endTime.toString())), t
                },
                toJSON(e) {
                    let t = {};
                    return void 0 !== e.baseAccount && (t.baseAccount = e.baseAccount ? n.BaseAccount.toJSON(e.baseAccount) : void 0), e.originalVesting ? t.originalVesting = e.originalVesting.map(e => e ? o.Coin.toJSON(e) : void 0) : t.originalVesting = [], e.delegatedFree ? t.delegatedFree = e.delegatedFree.map(e => e ? o.Coin.toJSON(e) : void 0) : t.delegatedFree = [], e.delegatedVesting ? t.delegatedVesting = e.delegatedVesting.map(e => e ? o.Coin.toJSON(e) : void 0) : t.delegatedVesting = [], void 0 !== e.endTime && (t.endTime = (e.endTime || BigInt(0)).toString()), t
                },
                fromPartial(e) {
                    let t = s();
                    return void 0 !== e.baseAccount && null !== e.baseAccount && (t.baseAccount = n.BaseAccount.fromPartial(e.baseAccount)), t.originalVesting = e.originalVesting ? .map(e => o.Coin.fromPartial(e)) || [], t.delegatedFree = e.delegatedFree ? .map(e => o.Coin.fromPartial(e)) || [], t.delegatedVesting = e.delegatedVesting ? .map(e => o.Coin.fromPartial(e)) || [], void 0 !== e.endTime && null !== e.endTime && (t.endTime = BigInt(e.endTime.toString())), t
                }
            }, t.ContinuousVestingAccount = {
                typeUrl: "/cosmos.vesting.v1beta1.ContinuousVestingAccount",
                encode: (e, r = i.BinaryWriter.create()) => (void 0 !== e.baseVestingAccount && t.BaseVestingAccount.encode(e.baseVestingAccount, r.uint32(10).fork()).ldelim(), e.startTime !== BigInt(0) && r.uint32(16).int64(e.startTime), r),
                decode(e, r) {
                    let n = e instanceof i.BinaryReader ? e : new i.BinaryReader(e),
                        o = void 0 === r ? n.len : n.pos + r,
                        a = d();
                    for (; n.pos < o;) {
                        let e = n.uint32();
                        switch (e >>> 3) {
                            case 1:
                                a.baseVestingAccount = t.BaseVestingAccount.decode(n, n.uint32());
                                break;
                            case 2:
                                a.startTime = n.int64();
                                break;
                            default:
                                n.skipType(7 & e)
                        }
                    }
                    return a
                },
                fromJSON(e) {
                    let r = d();
                    return (0, a.isSet)(e.baseVestingAccount) && (r.baseVestingAccount = t.BaseVestingAccount.fromJSON(e.baseVestingAccount)), (0, a.isSet)(e.startTime) && (r.startTime = BigInt(e.startTime.toString())), r
                },
                toJSON(e) {
                    let r = {};
                    return void 0 !== e.baseVestingAccount && (r.baseVestingAccount = e.baseVestingAccount ? t.BaseVestingAccount.toJSON(e.baseVestingAccount) : void 0), void 0 !== e.startTime && (r.startTime = (e.startTime || BigInt(0)).toString()), r
                },
                fromPartial(e) {
                    let r = d();
                    return void 0 !== e.baseVestingAccount && null !== e.baseVestingAccount && (r.baseVestingAccount = t.BaseVestingAccount.fromPartial(e.baseVestingAccount)), void 0 !== e.startTime && null !== e.startTime && (r.startTime = BigInt(e.startTime.toString())), r
                }
            }, t.DelayedVestingAccount = {
                typeUrl: "/cosmos.vesting.v1beta1.DelayedVestingAccount",
                encode: (e, r = i.BinaryWriter.create()) => (void 0 !== e.baseVestingAccount && t.BaseVestingAccount.encode(e.baseVestingAccount, r.uint32(10).fork()).ldelim(), r),
                decode(e, r) {
                    let n = e instanceof i.BinaryReader ? e : new i.BinaryReader(e),
                        o = void 0 === r ? n.len : n.pos + r,
                        a = c();
                    for (; n.pos < o;) {
                        let e = n.uint32();
                        e >>> 3 == 1 ? a.baseVestingAccount = t.BaseVestingAccount.decode(n, n.uint32()) : n.skipType(7 & e)
                    }
                    return a
                },
                fromJSON(e) {
                    let r = c();
                    return (0, a.isSet)(e.baseVestingAccount) && (r.baseVestingAccount = t.BaseVestingAccount.fromJSON(e.baseVestingAccount)), r
                },
                toJSON(e) {
                    let r = {};
                    return void 0 !== e.baseVestingAccount && (r.baseVestingAccount = e.baseVestingAccount ? t.BaseVestingAccount.toJSON(e.baseVestingAccount) : void 0), r
                },
                fromPartial(e) {
                    let r = c();
                    return void 0 !== e.baseVestingAccount && null !== e.baseVestingAccount && (r.baseVestingAccount = t.BaseVestingAccount.fromPartial(e.baseVestingAccount)), r
                }
            }, t.Period = {
                typeUrl: "/cosmos.vesting.v1beta1.Period",
                encode(e, t = i.BinaryWriter.create()) {
                    for (let r of (e.length !== BigInt(0) && t.uint32(8).int64(e.length), e.amount)) o.Coin.encode(r, t.uint32(18).fork()).ldelim();
                    return t
                },
                decode(e, t) {
                    let r = e instanceof i.BinaryReader ? e : new i.BinaryReader(e),
                        n = void 0 === t ? r.len : r.pos + t,
                        a = l();
                    for (; r.pos < n;) {
                        let e = r.uint32();
                        switch (e >>> 3) {
                            case 1:
                                a.length = r.int64();
                                break;
                            case 2:
                                a.amount.push(o.Coin.decode(r, r.uint32()));
                                break;
                            default:
                                r.skipType(7 & e)
                        }
                    }
                    return a
                },
                fromJSON(e) {
                    let t = l();
                    return (0, a.isSet)(e.length) && (t.length = BigInt(e.length.toString())), Array.isArray(e ? .amount) && (t.amount = e.amount.map(e => o.Coin.fromJSON(e))), t
                },
                toJSON(e) {
                    let t = {};
                    return void 0 !== e.length && (t.length = (e.length || BigInt(0)).toString()), e.amount ? t.amount = e.amount.map(e => e ? o.Coin.toJSON(e) : void 0) : t.amount = [], t
                },
                fromPartial(e) {
                    let t = l();
                    return void 0 !== e.length && null !== e.length && (t.length = BigInt(e.length.toString())), t.amount = e.amount ? .map(e => o.Coin.fromPartial(e)) || [], t
                }
            }, t.PeriodicVestingAccount = {
                typeUrl: "/cosmos.vesting.v1beta1.PeriodicVestingAccount",
                encode(e, r = i.BinaryWriter.create()) {
                    for (let n of (void 0 !== e.baseVestingAccount && t.BaseVestingAccount.encode(e.baseVestingAccount, r.uint32(10).fork()).ldelim(), e.startTime !== BigInt(0) && r.uint32(16).int64(e.startTime), e.vestingPeriods)) t.Period.encode(n, r.uint32(26).fork()).ldelim();
                    return r
                },
                decode(e, r) {
                    let n = e instanceof i.BinaryReader ? e : new i.BinaryReader(e),
                        o = void 0 === r ? n.len : n.pos + r,
                        a = u();
                    for (; n.pos < o;) {
                        let e = n.uint32();
                        switch (e >>> 3) {
                            case 1:
                                a.baseVestingAccount = t.BaseVestingAccount.decode(n, n.uint32());
                                break;
                            case 2:
                                a.startTime = n.int64();
                                break;
                            case 3:
                                a.vestingPeriods.push(t.Period.decode(n, n.uint32()));
                                break;
                            default:
                                n.skipType(7 & e)
                        }
                    }
                    return a
                },
                fromJSON(e) {
                    let r = u();
                    return (0, a.isSet)(e.baseVestingAccount) && (r.baseVestingAccount = t.BaseVestingAccount.fromJSON(e.baseVestingAccount)), (0, a.isSet)(e.startTime) && (r.startTime = BigInt(e.startTime.toString())), Array.isArray(e ? .vestingPeriods) && (r.vestingPeriods = e.vestingPeriods.map(e => t.Period.fromJSON(e))), r
                },
                toJSON(e) {
                    let r = {};
                    return void 0 !== e.baseVestingAccount && (r.baseVestingAccount = e.baseVestingAccount ? t.BaseVestingAccount.toJSON(e.baseVestingAccount) : void 0), void 0 !== e.startTime && (r.startTime = (e.startTime || BigInt(0)).toString()), e.vestingPeriods ? r.vestingPeriods = e.vestingPeriods.map(e => e ? t.Period.toJSON(e) : void 0) : r.vestingPeriods = [], r
                },
                fromPartial(e) {
                    let r = u();
                    return void 0 !== e.baseVestingAccount && null !== e.baseVestingAccount && (r.baseVestingAccount = t.BaseVestingAccount.fromPartial(e.baseVestingAccount)), void 0 !== e.startTime && null !== e.startTime && (r.startTime = BigInt(e.startTime.toString())), r.vestingPeriods = e.vestingPeriods ? .map(e => t.Period.fromPartial(e)) || [], r
                }
            }, t.PermanentLockedAccount = {
                typeUrl: "/cosmos.vesting.v1beta1.PermanentLockedAccount",
                encode: (e, r = i.BinaryWriter.create()) => (void 0 !== e.baseVestingAccount && t.BaseVestingAccount.encode(e.baseVestingAccount, r.uint32(10).fork()).ldelim(), r),
                decode(e, r) {
                    let n = e instanceof i.BinaryReader ? e : new i.BinaryReader(e),
                        o = void 0 === r ? n.len : n.pos + r,
                        a = p();
                    for (; n.pos < o;) {
                        let e = n.uint32();
                        e >>> 3 == 1 ? a.baseVestingAccount = t.BaseVestingAccount.decode(n, n.uint32()) : n.skipType(7 & e)
                    }
                    return a
                },
                fromJSON(e) {
                    let r = p();
                    return (0, a.isSet)(e.baseVestingAccount) && (r.baseVestingAccount = t.BaseVestingAccount.fromJSON(e.baseVestingAccount)), r
                },
                toJSON(e) {
                    let r = {};
                    return void 0 !== e.baseVestingAccount && (r.baseVestingAccount = e.baseVestingAccount ? t.BaseVestingAccount.toJSON(e.baseVestingAccount) : void 0), r
                },
                fromPartial(e) {
                    let r = p();
                    return void 0 !== e.baseVestingAccount && null !== e.baseVestingAccount && (r.baseVestingAccount = t.BaseVestingAccount.fromPartial(e.baseVestingAccount)), r
                }
            }
        },
        65676: function(e, t, r) {
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: !0
            }), t.Any = t.protobufPackage = void 0;
            let n = r(28486),
                o = r(6476);

            function i() {
                return {
                    typeUrl: "",
                    value: new Uint8Array
                }
            }
            t.protobufPackage = "google.protobuf", t.Any = {
                typeUrl: "/google.protobuf.Any",
                encode: (e, t = n.BinaryWriter.create()) => ("" !== e.typeUrl && t.uint32(10).string(e.typeUrl), 0 !== e.value.length && t.uint32(18).bytes(e.value), t),
                decode(e, t) {
                    let r = e instanceof n.BinaryReader ? e : new n.BinaryReader(e),
                        o = void 0 === t ? r.len : r.pos + t,
                        a = i();
                    for (; r.pos < o;) {
                        let e = r.uint32();
                        switch (e >>> 3) {
                            case 1:
                                a.typeUrl = r.string();
                                break;
                            case 2:
                                a.value = r.bytes();
                                break;
                            default:
                                r.skipType(7 & e)
                        }
                    }
                    return a
                },
                fromJSON(e) {
                    let t = i();
                    return (0, o.isSet)(e.typeUrl) && (t.typeUrl = String(e.typeUrl)), (0, o.isSet)(e.value) && (t.value = (0, o.bytesFromBase64)(e.value)), t
                },
                toJSON(e) {
                    let t = {};
                    return void 0 !== e.typeUrl && (t.typeUrl = e.typeUrl), void 0 !== e.value && (t.value = (0, o.base64FromBytes)(void 0 !== e.value ? e.value : new Uint8Array)), t
                },
                fromPartial(e) {
                    let t = i();
                    return t.typeUrl = e.typeUrl ? ? "", t.value = e.value ? ? new Uint8Array, t
                }
            }
        },
        69441: function(e, t, r) {
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: !0
            }), t.Duration = t.protobufPackage = void 0;
            let n = r(28486),
                o = r(6476);

            function i() {
                return {
                    seconds: BigInt(0),
                    nanos: 0
                }
            }
            t.protobufPackage = "google.protobuf", t.Duration = {
                typeUrl: "/google.protobuf.Duration",
                encode: (e, t = n.BinaryWriter.create()) => (e.seconds !== BigInt(0) && t.uint32(8).int64(e.seconds), 0 !== e.nanos && t.uint32(16).int32(e.nanos), t),
                decode(e, t) {
                    let r = e instanceof n.BinaryReader ? e : new n.BinaryReader(e),
                        o = void 0 === t ? r.len : r.pos + t,
                        a = i();
                    for (; r.pos < o;) {
                        let e = r.uint32();
                        switch (e >>> 3) {
                            case 1:
                                a.seconds = r.int64();
                                break;
                            case 2:
                                a.nanos = r.int32();
                                break;
                            default:
                                r.skipType(7 & e)
                        }
                    }
                    return a
                },
                fromJSON(e) {
                    let t = i();
                    return (0, o.isSet)(e.seconds) && (t.seconds = BigInt(e.seconds.toString())), (0, o.isSet)(e.nanos) && (t.nanos = Number(e.nanos)), t
                },
                toJSON(e) {
                    let t = {};
                    return void 0 !== e.seconds && (t.seconds = (e.seconds || BigInt(0)).toString()), void 0 !== e.nanos && (t.nanos = Math.round(e.nanos)), t
                },
                fromPartial(e) {
                    let t = i();
                    return void 0 !== e.seconds && null !== e.seconds && (t.seconds = BigInt(e.seconds.toString())), t.nanos = e.nanos ? ? 0, t
                }
            }
        },
        90614: function(e, t, r) {
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: !0
            }), t.Timestamp = t.protobufPackage = void 0;
            let n = r(28486),
                o = r(6476);

            function i() {
                return {
                    seconds: BigInt(0),
                    nanos: 0
                }
            }
            t.protobufPackage = "google.protobuf", t.Timestamp = {
                typeUrl: "/google.protobuf.Timestamp",
                encode: (e, t = n.BinaryWriter.create()) => (e.seconds !== BigInt(0) && t.uint32(8).int64(e.seconds), 0 !== e.nanos && t.uint32(16).int32(e.nanos), t),
                decode(e, t) {
                    let r = e instanceof n.BinaryReader ? e : new n.BinaryReader(e),
                        o = void 0 === t ? r.len : r.pos + t,
                        a = i();
                    for (; r.pos < o;) {
                        let e = r.uint32();
                        switch (e >>> 3) {
                            case 1:
                                a.seconds = r.int64();
                                break;
                            case 2:
                                a.nanos = r.int32();
                                break;
                            default:
                                r.skipType(7 & e)
                        }
                    }
                    return a
                },
                fromJSON(e) {
                    let t = i();
                    return (0, o.isSet)(e.seconds) && (t.seconds = BigInt(e.seconds.toString())), (0, o.isSet)(e.nanos) && (t.nanos = Number(e.nanos)), t
                },
                toJSON(e) {
                    let t = {};
                    return void 0 !== e.seconds && (t.seconds = (e.seconds || BigInt(0)).toString()), void 0 !== e.nanos && (t.nanos = Math.round(e.nanos)), t
                },
                fromPartial(e) {
                    let t = i();
                    return void 0 !== e.seconds && null !== e.seconds && (t.seconds = BigInt(e.seconds.toString())), t.nanos = e.nanos ? ? 0, t
                }
            }
        },
        6476: function(e, t, r) {
            "use strict";
            var n = r(48764).Buffer;
            Object.defineProperty(t, "__esModule", {
                value: !0
            }), t.fromJsonTimestamp = t.fromTimestamp = t.toTimestamp = t.setPaginationParams = t.isObject = t.isSet = t.fromDuration = t.toDuration = t.omitDefault = t.base64FromBytes = t.bytesFromBase64 = void 0;
            var o = (() => {
                if (void 0 !== o) return o;
                if ("undefined" != typeof self) return self;
                if ("undefined" != typeof window) return window;
                if (void 0 !== r.g) return r.g;
                throw "Unable to locate global object"
            })();
            let i = o.atob || (e => o.Buffer.from(e, "base64").toString("binary"));
            t.bytesFromBase64 = function(e) {
                let t = i(e),
                    r = new Uint8Array(t.length);
                for (let e = 0; e < t.length; ++e) r[e] = t.charCodeAt(e);
                return r
            };
            let a = o.btoa || (e => o.Buffer.from(e, "binary").toString("base64"));

            function s(e) {
                return null != e
            }

            function d(e) {
                return {
                    seconds: BigInt(Math.trunc(e.getTime() / 1e3)),
                    nanos: e.getTime() % 1e3 * 1e6
                }
            }
            t.base64FromBytes = function(e) {
                let t = [];
                return e.forEach(e => {
                    t.push(String.fromCharCode(e))
                }), a(t.join(""))
            }, t.omitDefault = function(e) {
                if ("string" == typeof e) return "" === e ? void 0 : e;
                if ("number" == typeof e) return 0 === e ? void 0 : e;
                if ("bigint" == typeof e) return e === BigInt(0) ? void 0 : e;
                throw Error(`Got unsupported type ${typeof e}`)
            }, t.toDuration = function(e) {
                return {
                    seconds: BigInt(Math.floor(parseInt(e) / 1e9)),
                    nanos: parseInt(e) % 1e9
                }
            }, t.fromDuration = function(e) {
                return (1e9 * parseInt(e.seconds.toString()) + e.nanos).toString()
            }, t.isSet = s, t.isObject = function(e) {
                return "object" == typeof e && null !== e
            }, t.setPaginationParams = (e, t) => (t && (void 0 !== t ? .countTotal && (e.params["pagination.count_total"] = t.countTotal), void 0 !== t ? .key && (e.params["pagination.key"] = n.from(t.key).toString("base64")), void 0 !== t ? .limit && (e.params["pagination.limit"] = t.limit.toString()), void 0 !== t ? .offset && (e.params["pagination.offset"] = t.offset.toString()), void 0 !== t ? .reverse && (e.params["pagination.reverse"] = t.reverse)), e), t.toTimestamp = d, t.fromTimestamp = function(e) {
                let t = 1e3 * Number(e.seconds);
                return new Date(t += e.nanos / 1e6)
            };
            let c = e => ({
                seconds: s(e.seconds) ? BigInt(e.seconds.toString()) : BigInt(0),
                nanos: s(e.nanos) ? Number(e.nanos) : 0
            });
            t.fromJsonTimestamp = function(e) {
                return e instanceof Date ? d(e) : "string" == typeof e ? d(new Date(e)) : c(e)
            }
        },
        54480: function(e, t, r) {
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: !0
            }), t.QueryClientImpl = t.QueryEscrowAddressResponse = t.QueryEscrowAddressRequest = t.QueryDenomHashResponse = t.QueryDenomHashRequest = t.QueryParamsResponse = t.QueryParamsRequest = t.QueryDenomTracesResponse = t.QueryDenomTracesRequest = t.QueryDenomTraceResponse = t.QueryDenomTraceRequest = t.protobufPackage = void 0;
            let n = r(38792),
                o = r(34982),
                i = r(28486),
                a = r(6476);

            function s() {
                return {
                    hash: ""
                }
            }

            function d() {
                return {
                    denomTrace: void 0
                }
            }

            function c() {
                return {
                    pagination: void 0
                }
            }

            function l() {
                return {
                    denomTraces: [],
                    pagination: void 0
                }
            }

            function u() {
                return {
                    params: void 0
                }
            }

            function p() {
                return {
                    trace: ""
                }
            }

            function m() {
                return {
                    hash: ""
                }
            }

            function g() {
                return {
                    portId: "",
                    channelId: ""
                }
            }

            function f() {
                return {
                    escrowAddress: ""
                }
            }
            t.protobufPackage = "ibc.applications.transfer.v1", t.QueryDenomTraceRequest = {
                typeUrl: "/ibc.applications.transfer.v1.QueryDenomTraceRequest",
                encode: (e, t = i.BinaryWriter.create()) => ("" !== e.hash && t.uint32(10).string(e.hash), t),
                decode(e, t) {
                    let r = e instanceof i.BinaryReader ? e : new i.BinaryReader(e),
                        n = void 0 === t ? r.len : r.pos + t,
                        o = s();
                    for (; r.pos < n;) {
                        let e = r.uint32();
                        e >>> 3 == 1 ? o.hash = r.string() : r.skipType(7 & e)
                    }
                    return o
                },
                fromJSON(e) {
                    let t = s();
                    return (0, a.isSet)(e.hash) && (t.hash = String(e.hash)), t
                },
                toJSON(e) {
                    let t = {};
                    return void 0 !== e.hash && (t.hash = e.hash), t
                },
                fromPartial(e) {
                    let t = s();
                    return t.hash = e.hash ? ? "", t
                }
            }, t.QueryDenomTraceResponse = {
                typeUrl: "/ibc.applications.transfer.v1.QueryDenomTraceResponse",
                encode: (e, t = i.BinaryWriter.create()) => (void 0 !== e.denomTrace && o.DenomTrace.encode(e.denomTrace, t.uint32(10).fork()).ldelim(), t),
                decode(e, t) {
                    let r = e instanceof i.BinaryReader ? e : new i.BinaryReader(e),
                        n = void 0 === t ? r.len : r.pos + t,
                        a = d();
                    for (; r.pos < n;) {
                        let e = r.uint32();
                        e >>> 3 == 1 ? a.denomTrace = o.DenomTrace.decode(r, r.uint32()) : r.skipType(7 & e)
                    }
                    return a
                },
                fromJSON(e) {
                    let t = d();
                    return (0, a.isSet)(e.denomTrace) && (t.denomTrace = o.DenomTrace.fromJSON(e.denomTrace)), t
                },
                toJSON(e) {
                    let t = {};
                    return void 0 !== e.denomTrace && (t.denomTrace = e.denomTrace ? o.DenomTrace.toJSON(e.denomTrace) : void 0), t
                },
                fromPartial(e) {
                    let t = d();
                    return void 0 !== e.denomTrace && null !== e.denomTrace && (t.denomTrace = o.DenomTrace.fromPartial(e.denomTrace)), t
                }
            }, t.QueryDenomTracesRequest = {
                typeUrl: "/ibc.applications.transfer.v1.QueryDenomTracesRequest",
                encode: (e, t = i.BinaryWriter.create()) => (void 0 !== e.pagination && n.PageRequest.encode(e.pagination, t.uint32(10).fork()).ldelim(), t),
                decode(e, t) {
                    let r = e instanceof i.BinaryReader ? e : new i.BinaryReader(e),
                        o = void 0 === t ? r.len : r.pos + t,
                        a = c();
                    for (; r.pos < o;) {
                        let e = r.uint32();
                        e >>> 3 == 1 ? a.pagination = n.PageRequest.decode(r, r.uint32()) : r.skipType(7 & e)
                    }
                    return a
                },
                fromJSON(e) {
                    let t = c();
                    return (0, a.isSet)(e.pagination) && (t.pagination = n.PageRequest.fromJSON(e.pagination)), t
                },
                toJSON(e) {
                    let t = {};
                    return void 0 !== e.pagination && (t.pagination = e.pagination ? n.PageRequest.toJSON(e.pagination) : void 0), t
                },
                fromPartial(e) {
                    let t = c();
                    return void 0 !== e.pagination && null !== e.pagination && (t.pagination = n.PageRequest.fromPartial(e.pagination)), t
                }
            }, t.QueryDenomTracesResponse = {
                typeUrl: "/ibc.applications.transfer.v1.QueryDenomTracesResponse",
                encode(e, t = i.BinaryWriter.create()) {
                    for (let r of e.denomTraces) o.DenomTrace.encode(r, t.uint32(10).fork()).ldelim();
                    return void 0 !== e.pagination && n.PageResponse.encode(e.pagination, t.uint32(18).fork()).ldelim(), t
                },
                decode(e, t) {
                    let r = e instanceof i.BinaryReader ? e : new i.BinaryReader(e),
                        a = void 0 === t ? r.len : r.pos + t,
                        s = l();
                    for (; r.pos < a;) {
                        let e = r.uint32();
                        switch (e >>> 3) {
                            case 1:
                                s.denomTraces.push(o.DenomTrace.decode(r, r.uint32()));
                                break;
                            case 2:
                                s.pagination = n.PageResponse.decode(r, r.uint32());
                                break;
                            default:
                                r.skipType(7 & e)
                        }
                    }
                    return s
                },
                fromJSON(e) {
                    let t = l();
                    return Array.isArray(e ? .denomTraces) && (t.denomTraces = e.denomTraces.map(e => o.DenomTrace.fromJSON(e))), (0, a.isSet)(e.pagination) && (t.pagination = n.PageResponse.fromJSON(e.pagination)), t
                },
                toJSON(e) {
                    let t = {};
                    return e.denomTraces ? t.denomTraces = e.denomTraces.map(e => e ? o.DenomTrace.toJSON(e) : void 0) : t.denomTraces = [], void 0 !== e.pagination && (t.pagination = e.pagination ? n.PageResponse.toJSON(e.pagination) : void 0), t
                },
                fromPartial(e) {
                    let t = l();
                    return t.denomTraces = e.denomTraces ? .map(e => o.DenomTrace.fromPartial(e)) || [], void 0 !== e.pagination && null !== e.pagination && (t.pagination = n.PageResponse.fromPartial(e.pagination)), t
                }
            }, t.QueryParamsRequest = {
                typeUrl: "/ibc.applications.transfer.v1.QueryParamsRequest",
                encode: (e, t = i.BinaryWriter.create()) => t,
                decode(e, t) {
                    let r = e instanceof i.BinaryReader ? e : new i.BinaryReader(e),
                        n = void 0 === t ? r.len : r.pos + t;
                    for (; r.pos < n;) {
                        let e = r.uint32();
                        r.skipType(7 & e)
                    }
                    return {}
                },
                fromJSON: e => ({}),
                toJSON: e => ({}),
                fromPartial: e => ({})
            }, t.QueryParamsResponse = {
                typeUrl: "/ibc.applications.transfer.v1.QueryParamsResponse",
                encode: (e, t = i.BinaryWriter.create()) => (void 0 !== e.params && o.Params.encode(e.params, t.uint32(10).fork()).ldelim(), t),
                decode(e, t) {
                    let r = e instanceof i.BinaryReader ? e : new i.BinaryReader(e),
                        n = void 0 === t ? r.len : r.pos + t,
                        a = u();
                    for (; r.pos < n;) {
                        let e = r.uint32();
                        e >>> 3 == 1 ? a.params = o.Params.decode(r, r.uint32()) : r.skipType(7 & e)
                    }
                    return a
                },
                fromJSON(e) {
                    let t = u();
                    return (0, a.isSet)(e.params) && (t.params = o.Params.fromJSON(e.params)), t
                },
                toJSON(e) {
                    let t = {};
                    return void 0 !== e.params && (t.params = e.params ? o.Params.toJSON(e.params) : void 0), t
                },
                fromPartial(e) {
                    let t = u();
                    return void 0 !== e.params && null !== e.params && (t.params = o.Params.fromPartial(e.params)), t
                }
            }, t.QueryDenomHashRequest = {
                typeUrl: "/ibc.applications.transfer.v1.QueryDenomHashRequest",
                encode: (e, t = i.BinaryWriter.create()) => ("" !== e.trace && t.uint32(10).string(e.trace), t),
                decode(e, t) {
                    let r = e instanceof i.BinaryReader ? e : new i.BinaryReader(e),
                        n = void 0 === t ? r.len : r.pos + t,
                        o = p();
                    for (; r.pos < n;) {
                        let e = r.uint32();
                        e >>> 3 == 1 ? o.trace = r.string() : r.skipType(7 & e)
                    }
                    return o
                },
                fromJSON(e) {
                    let t = p();
                    return (0, a.isSet)(e.trace) && (t.trace = String(e.trace)), t
                },
                toJSON(e) {
                    let t = {};
                    return void 0 !== e.trace && (t.trace = e.trace), t
                },
                fromPartial(e) {
                    let t = p();
                    return t.trace = e.trace ? ? "", t
                }
            }, t.QueryDenomHashResponse = {
                typeUrl: "/ibc.applications.transfer.v1.QueryDenomHashResponse",
                encode: (e, t = i.BinaryWriter.create()) => ("" !== e.hash && t.uint32(10).string(e.hash), t),
                decode(e, t) {
                    let r = e instanceof i.BinaryReader ? e : new i.BinaryReader(e),
                        n = void 0 === t ? r.len : r.pos + t,
                        o = m();
                    for (; r.pos < n;) {
                        let e = r.uint32();
                        e >>> 3 == 1 ? o.hash = r.string() : r.skipType(7 & e)
                    }
                    return o
                },
                fromJSON(e) {
                    let t = m();
                    return (0, a.isSet)(e.hash) && (t.hash = String(e.hash)), t
                },
                toJSON(e) {
                    let t = {};
                    return void 0 !== e.hash && (t.hash = e.hash), t
                },
                fromPartial(e) {
                    let t = m();
                    return t.hash = e.hash ? ? "", t
                }
            }, t.QueryEscrowAddressRequest = {
                typeUrl: "/ibc.applications.transfer.v1.QueryEscrowAddressRequest",
                encode: (e, t = i.BinaryWriter.create()) => ("" !== e.portId && t.uint32(10).string(e.portId), "" !== e.channelId && t.uint32(18).string(e.channelId), t),
                decode(e, t) {
                    let r = e instanceof i.BinaryReader ? e : new i.BinaryReader(e),
                        n = void 0 === t ? r.len : r.pos + t,
                        o = g();
                    for (; r.pos < n;) {
                        let e = r.uint32();
                        switch (e >>> 3) {
                            case 1:
                                o.portId = r.string();
                                break;
                            case 2:
                                o.channelId = r.string();
                                break;
                            default:
                                r.skipType(7 & e)
                        }
                    }
                    return o
                },
                fromJSON(e) {
                    let t = g();
                    return (0, a.isSet)(e.portId) && (t.portId = String(e.portId)), (0, a.isSet)(e.channelId) && (t.channelId = String(e.channelId)), t
                },
                toJSON(e) {
                    let t = {};
                    return void 0 !== e.portId && (t.portId = e.portId), void 0 !== e.channelId && (t.channelId = e.channelId), t
                },
                fromPartial(e) {
                    let t = g();
                    return t.portId = e.portId ? ? "", t.channelId = e.channelId ? ? "", t
                }
            }, t.QueryEscrowAddressResponse = {
                typeUrl: "/ibc.applications.transfer.v1.QueryEscrowAddressResponse",
                encode: (e, t = i.BinaryWriter.create()) => ("" !== e.escrowAddress && t.uint32(10).string(e.escrowAddress), t),
                decode(e, t) {
                    let r = e instanceof i.BinaryReader ? e : new i.BinaryReader(e),
                        n = void 0 === t ? r.len : r.pos + t,
                        o = f();
                    for (; r.pos < n;) {
                        let e = r.uint32();
                        e >>> 3 == 1 ? o.escrowAddress = r.string() : r.skipType(7 & e)
                    }
                    return o
                },
                fromJSON(e) {
                    let t = f();
                    return (0, a.isSet)(e.escrowAddress) && (t.escrowAddress = String(e.escrowAddress)), t
                },
                toJSON(e) {
                    let t = {};
                    return void 0 !== e.escrowAddress && (t.escrowAddress = e.escrowAddress), t
                },
                fromPartial(e) {
                    let t = f();
                    return t.escrowAddress = e.escrowAddress ? ? "", t
                }
            };
            class y {
                constructor(e) {
                    this.rpc = e, this.DenomTrace = this.DenomTrace.bind(this), this.DenomTraces = this.DenomTraces.bind(this), this.Params = this.Params.bind(this), this.DenomHash = this.DenomHash.bind(this), this.EscrowAddress = this.EscrowAddress.bind(this)
                }
                DenomTrace(e) {
                    let r = t.QueryDenomTraceRequest.encode(e).finish();
                    return this.rpc.request("ibc.applications.transfer.v1.Query", "DenomTrace", r).then(e => t.QueryDenomTraceResponse.decode(new i.BinaryReader(e)))
                }
                DenomTraces(e = {
                    pagination: n.PageRequest.fromPartial({})
                }) {
                    let r = t.QueryDenomTracesRequest.encode(e).finish();
                    return this.rpc.request("ibc.applications.transfer.v1.Query", "DenomTraces", r).then(e => t.QueryDenomTracesResponse.decode(new i.BinaryReader(e)))
                }
                Params(e = {}) {
                    let r = t.QueryParamsRequest.encode(e).finish();
                    return this.rpc.request("ibc.applications.transfer.v1.Query", "Params", r).then(e => t.QueryParamsResponse.decode(new i.BinaryReader(e)))
                }
                DenomHash(e) {
                    let r = t.QueryDenomHashRequest.encode(e).finish();
                    return this.rpc.request("ibc.applications.transfer.v1.Query", "DenomHash", r).then(e => t.QueryDenomHashResponse.decode(new i.BinaryReader(e)))
                }
                EscrowAddress(e) {
                    let r = t.QueryEscrowAddressRequest.encode(e).finish();
                    return this.rpc.request("ibc.applications.transfer.v1.Query", "EscrowAddress", r).then(e => t.QueryEscrowAddressResponse.decode(new i.BinaryReader(e)))
                }
            }
            t.QueryClientImpl = y
        },
        34982: function(e, t, r) {
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: !0
            }), t.Params = t.DenomTrace = t.protobufPackage = void 0;
            let n = r(28486),
                o = r(6476);

            function i() {
                return {
                    path: "",
                    baseDenom: ""
                }
            }

            function a() {
                return {
                    sendEnabled: !1,
                    receiveEnabled: !1
                }
            }
            t.protobufPackage = "ibc.applications.transfer.v1", t.DenomTrace = {
                typeUrl: "/ibc.applications.transfer.v1.DenomTrace",
                encode: (e, t = n.BinaryWriter.create()) => ("" !== e.path && t.uint32(10).string(e.path), "" !== e.baseDenom && t.uint32(18).string(e.baseDenom), t),
                decode(e, t) {
                    let r = e instanceof n.BinaryReader ? e : new n.BinaryReader(e),
                        o = void 0 === t ? r.len : r.pos + t,
                        a = i();
                    for (; r.pos < o;) {
                        let e = r.uint32();
                        switch (e >>> 3) {
                            case 1:
                                a.path = r.string();
                                break;
                            case 2:
                                a.baseDenom = r.string();
                                break;
                            default:
                                r.skipType(7 & e)
                        }
                    }
                    return a
                },
                fromJSON(e) {
                    let t = i();
                    return (0, o.isSet)(e.path) && (t.path = String(e.path)), (0, o.isSet)(e.baseDenom) && (t.baseDenom = String(e.baseDenom)), t
                },
                toJSON(e) {
                    let t = {};
                    return void 0 !== e.path && (t.path = e.path), void 0 !== e.baseDenom && (t.baseDenom = e.baseDenom), t
                },
                fromPartial(e) {
                    let t = i();
                    return t.path = e.path ? ? "", t.baseDenom = e.baseDenom ? ? "", t
                }
            }, t.Params = {
                typeUrl: "/ibc.applications.transfer.v1.Params",
                encode: (e, t = n.BinaryWriter.create()) => (!0 === e.sendEnabled && t.uint32(8).bool(e.sendEnabled), !0 === e.receiveEnabled && t.uint32(16).bool(e.receiveEnabled), t),
                decode(e, t) {
                    let r = e instanceof n.BinaryReader ? e : new n.BinaryReader(e),
                        o = void 0 === t ? r.len : r.pos + t,
                        i = a();
                    for (; r.pos < o;) {
                        let e = r.uint32();
                        switch (e >>> 3) {
                            case 1:
                                i.sendEnabled = r.bool();
                                break;
                            case 2:
                                i.receiveEnabled = r.bool();
                                break;
                            default:
                                r.skipType(7 & e)
                        }
                    }
                    return i
                },
                fromJSON(e) {
                    let t = a();
                    return (0, o.isSet)(e.sendEnabled) && (t.sendEnabled = !!e.sendEnabled), (0, o.isSet)(e.receiveEnabled) && (t.receiveEnabled = !!e.receiveEnabled), t
                },
                toJSON(e) {
                    let t = {};
                    return void 0 !== e.sendEnabled && (t.sendEnabled = e.sendEnabled), void 0 !== e.receiveEnabled && (t.receiveEnabled = e.receiveEnabled), t
                },
                fromPartial(e) {
                    let t = a();
                    return t.sendEnabled = e.sendEnabled ? ? !1, t.receiveEnabled = e.receiveEnabled ? ? !1, t
                }
            }
        },
        37762: function(e, t, r) {
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: !0
            }), t.MsgClientImpl = t.MsgTransferResponse = t.MsgTransfer = t.protobufPackage = void 0;
            let n = r(62809),
                o = r(24648),
                i = r(28486),
                a = r(6476);

            function s() {
                return {
                    sourcePort: "",
                    sourceChannel: "",
                    token: n.Coin.fromPartial({}),
                    sender: "",
                    receiver: "",
                    timeoutHeight: o.Height.fromPartial({}),
                    timeoutTimestamp: BigInt(0),
                    memo: ""
                }
            }

            function d() {
                return {
                    sequence: BigInt(0)
                }
            }
            t.protobufPackage = "ibc.applications.transfer.v1", t.MsgTransfer = {
                typeUrl: "/ibc.applications.transfer.v1.MsgTransfer",
                encode: (e, t = i.BinaryWriter.create()) => ("" !== e.sourcePort && t.uint32(10).string(e.sourcePort), "" !== e.sourceChannel && t.uint32(18).string(e.sourceChannel), void 0 !== e.token && n.Coin.encode(e.token, t.uint32(26).fork()).ldelim(), "" !== e.sender && t.uint32(34).string(e.sender), "" !== e.receiver && t.uint32(42).string(e.receiver), void 0 !== e.timeoutHeight && o.Height.encode(e.timeoutHeight, t.uint32(50).fork()).ldelim(), e.timeoutTimestamp !== BigInt(0) && t.uint32(56).uint64(e.timeoutTimestamp), "" !== e.memo && t.uint32(66).string(e.memo), t),
                decode(e, t) {
                    let r = e instanceof i.BinaryReader ? e : new i.BinaryReader(e),
                        a = void 0 === t ? r.len : r.pos + t,
                        d = s();
                    for (; r.pos < a;) {
                        let e = r.uint32();
                        switch (e >>> 3) {
                            case 1:
                                d.sourcePort = r.string();
                                break;
                            case 2:
                                d.sourceChannel = r.string();
                                break;
                            case 3:
                                d.token = n.Coin.decode(r, r.uint32());
                                break;
                            case 4:
                                d.sender = r.string();
                                break;
                            case 5:
                                d.receiver = r.string();
                                break;
                            case 6:
                                d.timeoutHeight = o.Height.decode(r, r.uint32());
                                break;
                            case 7:
                                d.timeoutTimestamp = r.uint64();
                                break;
                            case 8:
                                d.memo = r.string();
                                break;
                            default:
                                r.skipType(7 & e)
                        }
                    }
                    return d
                },
                fromJSON(e) {
                    let t = s();
                    return (0, a.isSet)(e.sourcePort) && (t.sourcePort = String(e.sourcePort)), (0, a.isSet)(e.sourceChannel) && (t.sourceChannel = String(e.sourceChannel)), (0, a.isSet)(e.token) && (t.token = n.Coin.fromJSON(e.token)), (0, a.isSet)(e.sender) && (t.sender = String(e.sender)), (0, a.isSet)(e.receiver) && (t.receiver = String(e.receiver)), (0, a.isSet)(e.timeoutHeight) && (t.timeoutHeight = o.Height.fromJSON(e.timeoutHeight)), (0, a.isSet)(e.timeoutTimestamp) && (t.timeoutTimestamp = BigInt(e.timeoutTimestamp.toString())), (0, a.isSet)(e.memo) && (t.memo = String(e.memo)), t
                },
                toJSON(e) {
                    let t = {};
                    return void 0 !== e.sourcePort && (t.sourcePort = e.sourcePort), void 0 !== e.sourceChannel && (t.sourceChannel = e.sourceChannel), void 0 !== e.token && (t.token = e.token ? n.Coin.toJSON(e.token) : void 0), void 0 !== e.sender && (t.sender = e.sender), void 0 !== e.receiver && (t.receiver = e.receiver), void 0 !== e.timeoutHeight && (t.timeoutHeight = e.timeoutHeight ? o.Height.toJSON(e.timeoutHeight) : void 0), void 0 !== e.timeoutTimestamp && (t.timeoutTimestamp = (e.timeoutTimestamp || BigInt(0)).toString()), void 0 !== e.memo && (t.memo = e.memo), t
                },
                fromPartial(e) {
                    let t = s();
                    return t.sourcePort = e.sourcePort ? ? "", t.sourceChannel = e.sourceChannel ? ? "", void 0 !== e.token && null !== e.token && (t.token = n.Coin.fromPartial(e.token)), t.sender = e.sender ? ? "", t.receiver = e.receiver ? ? "", void 0 !== e.timeoutHeight && null !== e.timeoutHeight && (t.timeoutHeight = o.Height.fromPartial(e.timeoutHeight)), void 0 !== e.timeoutTimestamp && null !== e.timeoutTimestamp && (t.timeoutTimestamp = BigInt(e.timeoutTimestamp.toString())), t.memo = e.memo ? ? "", t
                }
            }, t.MsgTransferResponse = {
                typeUrl: "/ibc.applications.transfer.v1.MsgTransferResponse",
                encode: (e, t = i.BinaryWriter.create()) => (e.sequence !== BigInt(0) && t.uint32(8).uint64(e.sequence), t),
                decode(e, t) {
                    let r = e instanceof i.BinaryReader ? e : new i.BinaryReader(e),
                        n = void 0 === t ? r.len : r.pos + t,
                        o = d();
                    for (; r.pos < n;) {
                        let e = r.uint32();
                        e >>> 3 == 1 ? o.sequence = r.uint64() : r.skipType(7 & e)
                    }
                    return o
                },
                fromJSON(e) {
                    let t = d();
                    return (0, a.isSet)(e.sequence) && (t.sequence = BigInt(e.sequence.toString())), t
                },
                toJSON(e) {
                    let t = {};
                    return void 0 !== e.sequence && (t.sequence = (e.sequence || BigInt(0)).toString()), t
                },
                fromPartial(e) {
                    let t = d();
                    return void 0 !== e.sequence && null !== e.sequence && (t.sequence = BigInt(e.sequence.toString())), t
                }
            };
            class c {
                constructor(e) {
                    this.rpc = e, this.Transfer = this.Transfer.bind(this)
                }
                Transfer(e) {
                    let r = t.MsgTransfer.encode(e).finish();
                    return this.rpc.request("ibc.applications.transfer.v1.Msg", "Transfer", r).then(e => t.MsgTransferResponse.decode(new i.BinaryReader(e)))
                }
            }
            t.MsgClientImpl = c
        },
        98287: function(e, t, r) {
            "use strict";
            var n, o, i, a;
            Object.defineProperty(t, "__esModule", {
                value: !0
            }), t.Acknowledgement = t.PacketId = t.PacketState = t.Packet = t.Counterparty = t.IdentifiedChannel = t.Channel = t.orderToJSON = t.orderFromJSON = t.Order = t.stateToJSON = t.stateFromJSON = t.State = t.protobufPackage = void 0;
            let s = r(24648),
                d = r(28486),
                c = r(6476);

            function l(e) {
                switch (e) {
                    case 0:
                    case "STATE_UNINITIALIZED_UNSPECIFIED":
                        return n.STATE_UNINITIALIZED_UNSPECIFIED;
                    case 1:
                    case "STATE_INIT":
                        return n.STATE_INIT;
                    case 2:
                    case "STATE_TRYOPEN":
                        return n.STATE_TRYOPEN;
                    case 3:
                    case "STATE_OPEN":
                        return n.STATE_OPEN;
                    case 4:
                    case "STATE_CLOSED":
                        return n.STATE_CLOSED;
                    default:
                        return n.UNRECOGNIZED
                }
            }

            function u(e) {
                switch (e) {
                    case n.STATE_UNINITIALIZED_UNSPECIFIED:
                        return "STATE_UNINITIALIZED_UNSPECIFIED";
                    case n.STATE_INIT:
                        return "STATE_INIT";
                    case n.STATE_TRYOPEN:
                        return "STATE_TRYOPEN";
                    case n.STATE_OPEN:
                        return "STATE_OPEN";
                    case n.STATE_CLOSED:
                        return "STATE_CLOSED";
                    case n.UNRECOGNIZED:
                    default:
                        return "UNRECOGNIZED"
                }
            }

            function p(e) {
                switch (e) {
                    case 0:
                    case "ORDER_NONE_UNSPECIFIED":
                        return o.ORDER_NONE_UNSPECIFIED;
                    case 1:
                    case "ORDER_UNORDERED":
                        return o.ORDER_UNORDERED;
                    case 2:
                    case "ORDER_ORDERED":
                        return o.ORDER_ORDERED;
                    default:
                        return o.UNRECOGNIZED
                }
            }

            function m(e) {
                switch (e) {
                    case o.ORDER_NONE_UNSPECIFIED:
                        return "ORDER_NONE_UNSPECIFIED";
                    case o.ORDER_UNORDERED:
                        return "ORDER_UNORDERED";
                    case o.ORDER_ORDERED:
                        return "ORDER_ORDERED";
                    case o.UNRECOGNIZED:
                    default:
                        return "UNRECOGNIZED"
                }
            }

            function g() {
                return {
                    state: 0,
                    ordering: 0,
                    counterparty: t.Counterparty.fromPartial({}),
                    connectionHops: [],
                    version: ""
                }
            }

            function f() {
                return {
                    state: 0,
                    ordering: 0,
                    counterparty: t.Counterparty.fromPartial({}),
                    connectionHops: [],
                    version: "",
                    portId: "",
                    channelId: ""
                }
            }

            function y() {
                return {
                    portId: "",
                    channelId: ""
                }
            }

            function h() {
                return {
                    sequence: BigInt(0),
                    sourcePort: "",
                    sourceChannel: "",
                    destinationPort: "",
                    destinationChannel: "",
                    data: new Uint8Array,
                    timeoutHeight: s.Height.fromPartial({}),
                    timeoutTimestamp: BigInt(0)
                }
            }

            function v() {
                return {
                    portId: "",
                    channelId: "",
                    sequence: BigInt(0),
                    data: new Uint8Array
                }
            }

            function b() {
                return {
                    portId: "",
                    channelId: "",
                    sequence: BigInt(0)
                }
            }

            function S() {
                return {
                    result: void 0,
                    error: void 0
                }
            }
            t.protobufPackage = "ibc.core.channel.v1", (i = n || (t.State = n = {}))[i.STATE_UNINITIALIZED_UNSPECIFIED = 0] = "STATE_UNINITIALIZED_UNSPECIFIED", i[i.STATE_INIT = 1] = "STATE_INIT", i[i.STATE_TRYOPEN = 2] = "STATE_TRYOPEN", i[i.STATE_OPEN = 3] = "STATE_OPEN", i[i.STATE_CLOSED = 4] = "STATE_CLOSED", i[i.UNRECOGNIZED = -1] = "UNRECOGNIZED", t.stateFromJSON = l, t.stateToJSON = u, (a = o || (t.Order = o = {}))[a.ORDER_NONE_UNSPECIFIED = 0] = "ORDER_NONE_UNSPECIFIED", a[a.ORDER_UNORDERED = 1] = "ORDER_UNORDERED", a[a.ORDER_ORDERED = 2] = "ORDER_ORDERED", a[a.UNRECOGNIZED = -1] = "UNRECOGNIZED", t.orderFromJSON = p, t.orderToJSON = m, t.Channel = {
                typeUrl: "/ibc.core.channel.v1.Channel",
                encode(e, r = d.BinaryWriter.create()) {
                    for (let n of (0 !== e.state && r.uint32(8).int32(e.state), 0 !== e.ordering && r.uint32(16).int32(e.ordering), void 0 !== e.counterparty && t.Counterparty.encode(e.counterparty, r.uint32(26).fork()).ldelim(), e.connectionHops)) r.uint32(34).string(n);
                    return "" !== e.version && r.uint32(42).string(e.version), r
                },
                decode(e, r) {
                    let n = e instanceof d.BinaryReader ? e : new d.BinaryReader(e),
                        o = void 0 === r ? n.len : n.pos + r,
                        i = g();
                    for (; n.pos < o;) {
                        let e = n.uint32();
                        switch (e >>> 3) {
                            case 1:
                                i.state = n.int32();
                                break;
                            case 2:
                                i.ordering = n.int32();
                                break;
                            case 3:
                                i.counterparty = t.Counterparty.decode(n, n.uint32());
                                break;
                            case 4:
                                i.connectionHops.push(n.string());
                                break;
                            case 5:
                                i.version = n.string();
                                break;
                            default:
                                n.skipType(7 & e)
                        }
                    }
                    return i
                },
                fromJSON(e) {
                    let r = g();
                    return (0, c.isSet)(e.state) && (r.state = l(e.state)), (0, c.isSet)(e.ordering) && (r.ordering = p(e.ordering)), (0, c.isSet)(e.counterparty) && (r.counterparty = t.Counterparty.fromJSON(e.counterparty)), Array.isArray(e ? .connectionHops) && (r.connectionHops = e.connectionHops.map(e => String(e))), (0, c.isSet)(e.version) && (r.version = String(e.version)), r
                },
                toJSON(e) {
                    let r = {};
                    return void 0 !== e.state && (r.state = u(e.state)), void 0 !== e.ordering && (r.ordering = m(e.ordering)), void 0 !== e.counterparty && (r.counterparty = e.counterparty ? t.Counterparty.toJSON(e.counterparty) : void 0), e.connectionHops ? r.connectionHops = e.connectionHops.map(e => e) : r.connectionHops = [], void 0 !== e.version && (r.version = e.version), r
                },
                fromPartial(e) {
                    let r = g();
                    return r.state = e.state ? ? 0, r.ordering = e.ordering ? ? 0, void 0 !== e.counterparty && null !== e.counterparty && (r.counterparty = t.Counterparty.fromPartial(e.counterparty)), r.connectionHops = e.connectionHops ? .map(e => e) || [], r.version = e.version ? ? "", r
                }
            }, t.IdentifiedChannel = {
                typeUrl: "/ibc.core.channel.v1.IdentifiedChannel",
                encode(e, r = d.BinaryWriter.create()) {
                    for (let n of (0 !== e.state && r.uint32(8).int32(e.state), 0 !== e.ordering && r.uint32(16).int32(e.ordering), void 0 !== e.counterparty && t.Counterparty.encode(e.counterparty, r.uint32(26).fork()).ldelim(), e.connectionHops)) r.uint32(34).string(n);
                    return "" !== e.version && r.uint32(42).string(e.version), "" !== e.portId && r.uint32(50).string(e.portId), "" !== e.channelId && r.uint32(58).string(e.channelId), r
                },
                decode(e, r) {
                    let n = e instanceof d.BinaryReader ? e : new d.BinaryReader(e),
                        o = void 0 === r ? n.len : n.pos + r,
                        i = f();
                    for (; n.pos < o;) {
                        let e = n.uint32();
                        switch (e >>> 3) {
                            case 1:
                                i.state = n.int32();
                                break;
                            case 2:
                                i.ordering = n.int32();
                                break;
                            case 3:
                                i.counterparty = t.Counterparty.decode(n, n.uint32());
                                break;
                            case 4:
                                i.connectionHops.push(n.string());
                                break;
                            case 5:
                                i.version = n.string();
                                break;
                            case 6:
                                i.portId = n.string();
                                break;
                            case 7:
                                i.channelId = n.string();
                                break;
                            default:
                                n.skipType(7 & e)
                        }
                    }
                    return i
                },
                fromJSON(e) {
                    let r = f();
                    return (0, c.isSet)(e.state) && (r.state = l(e.state)), (0, c.isSet)(e.ordering) && (r.ordering = p(e.ordering)), (0, c.isSet)(e.counterparty) && (r.counterparty = t.Counterparty.fromJSON(e.counterparty)), Array.isArray(e ? .connectionHops) && (r.connectionHops = e.connectionHops.map(e => String(e))), (0, c.isSet)(e.version) && (r.version = String(e.version)), (0, c.isSet)(e.portId) && (r.portId = String(e.portId)), (0, c.isSet)(e.channelId) && (r.channelId = String(e.channelId)), r
                },
                toJSON(e) {
                    let r = {};
                    return void 0 !== e.state && (r.state = u(e.state)), void 0 !== e.ordering && (r.ordering = m(e.ordering)), void 0 !== e.counterparty && (r.counterparty = e.counterparty ? t.Counterparty.toJSON(e.counterparty) : void 0), e.connectionHops ? r.connectionHops = e.connectionHops.map(e => e) : r.connectionHops = [], void 0 !== e.version && (r.version = e.version), void 0 !== e.portId && (r.portId = e.portId), void 0 !== e.channelId && (r.channelId = e.channelId), r
                },
                fromPartial(e) {
                    let r = f();
                    return r.state = e.state ? ? 0, r.ordering = e.ordering ? ? 0, void 0 !== e.counterparty && null !== e.counterparty && (r.counterparty = t.Counterparty.fromPartial(e.counterparty)), r.connectionHops = e.connectionHops ? .map(e => e) || [], r.version = e.version ? ? "", r.portId = e.portId ? ? "", r.channelId = e.channelId ? ? "", r
                }
            }, t.Counterparty = {
                typeUrl: "/ibc.core.channel.v1.Counterparty",
                encode: (e, t = d.BinaryWriter.create()) => ("" !== e.portId && t.uint32(10).string(e.portId), "" !== e.channelId && t.uint32(18).string(e.channelId), t),
                decode(e, t) {
                    let r = e instanceof d.BinaryReader ? e : new d.BinaryReader(e),
                        n = void 0 === t ? r.len : r.pos + t,
                        o = y();
                    for (; r.pos < n;) {
                        let e = r.uint32();
                        switch (e >>> 3) {
                            case 1:
                                o.portId = r.string();
                                break;
                            case 2:
                                o.channelId = r.string();
                                break;
                            default:
                                r.skipType(7 & e)
                        }
                    }
                    return o
                },
                fromJSON(e) {
                    let t = y();
                    return (0, c.isSet)(e.portId) && (t.portId = String(e.portId)), (0, c.isSet)(e.channelId) && (t.channelId = String(e.channelId)), t
                },
                toJSON(e) {
                    let t = {};
                    return void 0 !== e.portId && (t.portId = e.portId), void 0 !== e.channelId && (t.channelId = e.channelId), t
                },
                fromPartial(e) {
                    let t = y();
                    return t.portId = e.portId ? ? "", t.channelId = e.channelId ? ? "", t
                }
            }, t.Packet = {
                typeUrl: "/ibc.core.channel.v1.Packet",
                encode: (e, t = d.BinaryWriter.create()) => (e.sequence !== BigInt(0) && t.uint32(8).uint64(e.sequence), "" !== e.sourcePort && t.uint32(18).string(e.sourcePort), "" !== e.sourceChannel && t.uint32(26).string(e.sourceChannel), "" !== e.destinationPort && t.uint32(34).string(e.destinationPort), "" !== e.destinationChannel && t.uint32(42).string(e.destinationChannel), 0 !== e.data.length && t.uint32(50).bytes(e.data), void 0 !== e.timeoutHeight && s.Height.encode(e.timeoutHeight, t.uint32(58).fork()).ldelim(), e.timeoutTimestamp !== BigInt(0) && t.uint32(64).uint64(e.timeoutTimestamp), t),
                decode(e, t) {
                    let r = e instanceof d.BinaryReader ? e : new d.BinaryReader(e),
                        n = void 0 === t ? r.len : r.pos + t,
                        o = h();
                    for (; r.pos < n;) {
                        let e = r.uint32();
                        switch (e >>> 3) {
                            case 1:
                                o.sequence = r.uint64();
                                break;
                            case 2:
                                o.sourcePort = r.string();
                                break;
                            case 3:
                                o.sourceChannel = r.string();
                                break;
                            case 4:
                                o.destinationPort = r.string();
                                break;
                            case 5:
                                o.destinationChannel = r.string();
                                break;
                            case 6:
                                o.data = r.bytes();
                                break;
                            case 7:
                                o.timeoutHeight = s.Height.decode(r, r.uint32());
                                break;
                            case 8:
                                o.timeoutTimestamp = r.uint64();
                                break;
                            default:
                                r.skipType(7 & e)
                        }
                    }
                    return o
                },
                fromJSON(e) {
                    let t = h();
                    return (0, c.isSet)(e.sequence) && (t.sequence = BigInt(e.sequence.toString())), (0, c.isSet)(e.sourcePort) && (t.sourcePort = String(e.sourcePort)), (0, c.isSet)(e.sourceChannel) && (t.sourceChannel = String(e.sourceChannel)), (0, c.isSet)(e.destinationPort) && (t.destinationPort = String(e.destinationPort)), (0, c.isSet)(e.destinationChannel) && (t.destinationChannel = String(e.destinationChannel)), (0, c.isSet)(e.data) && (t.data = (0, c.bytesFromBase64)(e.data)), (0, c.isSet)(e.timeoutHeight) && (t.timeoutHeight = s.Height.fromJSON(e.timeoutHeight)), (0, c.isSet)(e.timeoutTimestamp) && (t.timeoutTimestamp = BigInt(e.timeoutTimestamp.toString())), t
                },
                toJSON(e) {
                    let t = {};
                    return void 0 !== e.sequence && (t.sequence = (e.sequence || BigInt(0)).toString()), void 0 !== e.sourcePort && (t.sourcePort = e.sourcePort), void 0 !== e.sourceChannel && (t.sourceChannel = e.sourceChannel), void 0 !== e.destinationPort && (t.destinationPort = e.destinationPort), void 0 !== e.destinationChannel && (t.destinationChannel = e.destinationChannel), void 0 !== e.data && (t.data = (0, c.base64FromBytes)(void 0 !== e.data ? e.data : new Uint8Array)), void 0 !== e.timeoutHeight && (t.timeoutHeight = e.timeoutHeight ? s.Height.toJSON(e.timeoutHeight) : void 0), void 0 !== e.timeoutTimestamp && (t.timeoutTimestamp = (e.timeoutTimestamp || BigInt(0)).toString()), t
                },
                fromPartial(e) {
                    let t = h();
                    return void 0 !== e.sequence && null !== e.sequence && (t.sequence = BigInt(e.sequence.toString())), t.sourcePort = e.sourcePort ? ? "", t.sourceChannel = e.sourceChannel ? ? "", t.destinationPort = e.destinationPort ? ? "", t.destinationChannel = e.destinationChannel ? ? "", t.data = e.data ? ? new Uint8Array, void 0 !== e.timeoutHeight && null !== e.timeoutHeight && (t.timeoutHeight = s.Height.fromPartial(e.timeoutHeight)), void 0 !== e.timeoutTimestamp && null !== e.timeoutTimestamp && (t.timeoutTimestamp = BigInt(e.timeoutTimestamp.toString())), t
                }
            }, t.PacketState = {
                typeUrl: "/ibc.core.channel.v1.PacketState",
                encode: (e, t = d.BinaryWriter.create()) => ("" !== e.portId && t.uint32(10).string(e.portId), "" !== e.channelId && t.uint32(18).string(e.channelId), e.sequence !== BigInt(0) && t.uint32(24).uint64(e.sequence), 0 !== e.data.length && t.uint32(34).bytes(e.data), t),
                decode(e, t) {
                    let r = e instanceof d.BinaryReader ? e : new d.BinaryReader(e),
                        n = void 0 === t ? r.len : r.pos + t,
                        o = v();
                    for (; r.pos < n;) {
                        let e = r.uint32();
                        switch (e >>> 3) {
                            case 1:
                                o.portId = r.string();
                                break;
                            case 2:
                                o.channelId = r.string();
                                break;
                            case 3:
                                o.sequence = r.uint64();
                                break;
                            case 4:
                                o.data = r.bytes();
                                break;
                            default:
                                r.skipType(7 & e)
                        }
                    }
                    return o
                },
                fromJSON(e) {
                    let t = v();
                    return (0, c.isSet)(e.portId) && (t.portId = String(e.portId)), (0, c.isSet)(e.channelId) && (t.channelId = String(e.channelId)), (0, c.isSet)(e.sequence) && (t.sequence = BigInt(e.sequence.toString())), (0, c.isSet)(e.data) && (t.data = (0, c.bytesFromBase64)(e.data)), t
                },
                toJSON(e) {
                    let t = {};
                    return void 0 !== e.portId && (t.portId = e.portId), void 0 !== e.channelId && (t.channelId = e.channelId), void 0 !== e.sequence && (t.sequence = (e.sequence || BigInt(0)).toString()), void 0 !== e.data && (t.data = (0, c.base64FromBytes)(void 0 !== e.data ? e.data : new Uint8Array)), t
                },
                fromPartial(e) {
                    let t = v();
                    return t.portId = e.portId ? ? "", t.channelId = e.channelId ? ? "", void 0 !== e.sequence && null !== e.sequence && (t.sequence = BigInt(e.sequence.toString())), t.data = e.data ? ? new Uint8Array, t
                }
            }, t.PacketId = {
                typeUrl: "/ibc.core.channel.v1.PacketId",
                encode: (e, t = d.BinaryWriter.create()) => ("" !== e.portId && t.uint32(10).string(e.portId), "" !== e.channelId && t.uint32(18).string(e.channelId), e.sequence !== BigInt(0) && t.uint32(24).uint64(e.sequence), t),
                decode(e, t) {
                    let r = e instanceof d.BinaryReader ? e : new d.BinaryReader(e),
                        n = void 0 === t ? r.len : r.pos + t,
                        o = b();
                    for (; r.pos < n;) {
                        let e = r.uint32();
                        switch (e >>> 3) {
                            case 1:
                                o.portId = r.string();
                                break;
                            case 2:
                                o.channelId = r.string();
                                break;
                            case 3:
                                o.sequence = r.uint64();
                                break;
                            default:
                                r.skipType(7 & e)
                        }
                    }
                    return o
                },
                fromJSON(e) {
                    let t = b();
                    return (0, c.isSet)(e.portId) && (t.portId = String(e.portId)), (0, c.isSet)(e.channelId) && (t.channelId = String(e.channelId)), (0, c.isSet)(e.sequence) && (t.sequence = BigInt(e.sequence.toString())), t
                },
                toJSON(e) {
                    let t = {};
                    return void 0 !== e.portId && (t.portId = e.portId), void 0 !== e.channelId && (t.channelId = e.channelId), void 0 !== e.sequence && (t.sequence = (e.sequence || BigInt(0)).toString()), t
                },
                fromPartial(e) {
                    let t = b();
                    return t.portId = e.portId ? ? "", t.channelId = e.channelId ? ? "", void 0 !== e.sequence && null !== e.sequence && (t.sequence = BigInt(e.sequence.toString())), t
                }
            }, t.Acknowledgement = {
                typeUrl: "/ibc.core.channel.v1.Acknowledgement",
                encode: (e, t = d.BinaryWriter.create()) => (void 0 !== e.result && t.uint32(170).bytes(e.result), void 0 !== e.error && t.uint32(178).string(e.error), t),
                decode(e, t) {
                    let r = e instanceof d.BinaryReader ? e : new d.BinaryReader(e),
                        n = void 0 === t ? r.len : r.pos + t,
                        o = S();
                    for (; r.pos < n;) {
                        let e = r.uint32();
                        switch (e >>> 3) {
                            case 21:
                                o.result = r.bytes();
                                break;
                            case 22:
                                o.error = r.string();
                                break;
                            default:
                                r.skipType(7 & e)
                        }
                    }
                    return o
                },
                fromJSON(e) {
                    let t = S();
                    return (0, c.isSet)(e.result) && (t.result = (0, c.bytesFromBase64)(e.result)), (0, c.isSet)(e.error) && (t.error = String(e.error)), t
                },
                toJSON(e) {
                    let t = {};
                    return void 0 !== e.result && (t.result = void 0 !== e.result ? (0, c.base64FromBytes)(e.result) : void 0), void 0 !== e.error && (t.error = e.error), t
                },
                fromPartial(e) {
                    let t = S();
                    return t.result = e.result ? ? void 0, t.error = e.error ? ? void 0, t
                }
            }
        },
        50549: function(e, t, r) {
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: !0
            }), t.QueryClientImpl = t.QueryNextSequenceReceiveResponse = t.QueryNextSequenceReceiveRequest = t.QueryUnreceivedAcksResponse = t.QueryUnreceivedAcksRequest = t.QueryUnreceivedPacketsResponse = t.QueryUnreceivedPacketsRequest = t.QueryPacketAcknowledgementsResponse = t.QueryPacketAcknowledgementsRequest = t.QueryPacketAcknowledgementResponse = t.QueryPacketAcknowledgementRequest = t.QueryPacketReceiptResponse = t.QueryPacketReceiptRequest = t.QueryPacketCommitmentsResponse = t.QueryPacketCommitmentsRequest = t.QueryPacketCommitmentResponse = t.QueryPacketCommitmentRequest = t.QueryChannelConsensusStateResponse = t.QueryChannelConsensusStateRequest = t.QueryChannelClientStateResponse = t.QueryChannelClientStateRequest = t.QueryConnectionChannelsResponse = t.QueryConnectionChannelsRequest = t.QueryChannelsResponse = t.QueryChannelsRequest = t.QueryChannelResponse = t.QueryChannelRequest = t.protobufPackage = void 0;
            let n = r(38792),
                o = r(98287),
                i = r(24648),
                a = r(65676),
                s = r(28486),
                d = r(6476);

            function c() {
                return {
                    portId: "",
                    channelId: ""
                }
            }

            function l() {
                return {
                    channel: void 0,
                    proof: new Uint8Array,
                    proofHeight: i.Height.fromPartial({})
                }
            }

            function u() {
                return {
                    pagination: void 0
                }
            }

            function p() {
                return {
                    channels: [],
                    pagination: void 0,
                    height: i.Height.fromPartial({})
                }
            }

            function m() {
                return {
                    connection: "",
                    pagination: void 0
                }
            }

            function g() {
                return {
                    channels: [],
                    pagination: void 0,
                    height: i.Height.fromPartial({})
                }
            }

            function f() {
                return {
                    portId: "",
                    channelId: ""
                }
            }

            function y() {
                return {
                    identifiedClientState: void 0,
                    proof: new Uint8Array,
                    proofHeight: i.Height.fromPartial({})
                }
            }

            function h() {
                return {
                    portId: "",
                    channelId: "",
                    revisionNumber: BigInt(0),
                    revisionHeight: BigInt(0)
                }
            }

            function v() {
                return {
                    consensusState: void 0,
                    clientId: "",
                    proof: new Uint8Array,
                    proofHeight: i.Height.fromPartial({})
                }
            }

            function b() {
                return {
                    portId: "",
                    channelId: "",
                    sequence: BigInt(0)
                }
            }

            function S() {
                return {
                    commitment: new Uint8Array,
                    proof: new Uint8Array,
                    proofHeight: i.Height.fromPartial({})
                }
            }

            function k() {
                return {
                    portId: "",
                    channelId: "",
                    pagination: void 0
                }
            }

            function P() {
                return {
                    commitments: [],
                    pagination: void 0,
                    height: i.Height.fromPartial({})
                }
            }

            function _() {
                return {
                    portId: "",
                    channelId: "",
                    sequence: BigInt(0)
                }
            }

            function B() {
                return {
                    received: !1,
                    proof: new Uint8Array,
                    proofHeight: i.Height.fromPartial({})
                }
            }

            function O() {
                return {
                    portId: "",
                    channelId: "",
                    sequence: BigInt(0)
                }
            }

            function R() {
                return {
                    acknowledgement: new Uint8Array,
                    proof: new Uint8Array,
                    proofHeight: i.Height.fromPartial({})
                }
            }

            function A() {
                return {
                    portId: "",
                    channelId: "",
                    pagination: void 0,
                    packetCommitmentSequences: []
                }
            }

            function I() {
                return {
                    acknowledgements: [],
                    pagination: void 0,
                    height: i.Height.fromPartial({})
                }
            }

            function w() {
                return {
                    portId: "",
                    channelId: "",
                    packetCommitmentSequences: []
                }
            }

            function T() {
                return {
                    sequences: [],
                    height: i.Height.fromPartial({})
                }
            }

            function N() {
                return {
                    portId: "",
                    channelId: "",
                    packetAckSequences: []
                }
            }

            function C() {
                return {
                    sequences: [],
                    height: i.Height.fromPartial({})
                }
            }

            function E() {
                return {
                    portId: "",
                    channelId: ""
                }
            }

            function x() {
                return {
                    nextSequenceReceive: BigInt(0),
                    proof: new Uint8Array,
                    proofHeight: i.Height.fromPartial({})
                }
            }
            t.protobufPackage = "ibc.core.channel.v1", t.QueryChannelRequest = {
                typeUrl: "/ibc.core.channel.v1.QueryChannelRequest",
                encode: (e, t = s.BinaryWriter.create()) => ("" !== e.portId && t.uint32(10).string(e.portId), "" !== e.channelId && t.uint32(18).string(e.channelId), t),
                decode(e, t) {
                    let r = e instanceof s.BinaryReader ? e : new s.BinaryReader(e),
                        n = void 0 === t ? r.len : r.pos + t,
                        o = c();
                    for (; r.pos < n;) {
                        let e = r.uint32();
                        switch (e >>> 3) {
                            case 1:
                                o.portId = r.string();
                                break;
                            case 2:
                                o.channelId = r.string();
                                break;
                            default:
                                r.skipType(7 & e)
                        }
                    }
                    return o
                },
                fromJSON(e) {
                    let t = c();
                    return (0, d.isSet)(e.portId) && (t.portId = String(e.portId)), (0, d.isSet)(e.channelId) && (t.channelId = String(e.channelId)), t
                },
                toJSON(e) {
                    let t = {};
                    return void 0 !== e.portId && (t.portId = e.portId), void 0 !== e.channelId && (t.channelId = e.channelId), t
                },
                fromPartial(e) {
                    let t = c();
                    return t.portId = e.portId ? ? "", t.channelId = e.channelId ? ? "", t
                }
            }, t.QueryChannelResponse = {
                typeUrl: "/ibc.core.channel.v1.QueryChannelResponse",
                encode: (e, t = s.BinaryWriter.create()) => (void 0 !== e.channel && o.Channel.encode(e.channel, t.uint32(10).fork()).ldelim(), 0 !== e.proof.length && t.uint32(18).bytes(e.proof), void 0 !== e.proofHeight && i.Height.encode(e.proofHeight, t.uint32(26).fork()).ldelim(), t),
                decode(e, t) {
                    let r = e instanceof s.BinaryReader ? e : new s.BinaryReader(e),
                        n = void 0 === t ? r.len : r.pos + t,
                        a = l();
                    for (; r.pos < n;) {
                        let e = r.uint32();
                        switch (e >>> 3) {
                            case 1:
                                a.channel = o.Channel.decode(r, r.uint32());
                                break;
                            case 2:
                                a.proof = r.bytes();
                                break;
                            case 3:
                                a.proofHeight = i.Height.decode(r, r.uint32());
                                break;
                            default:
                                r.skipType(7 & e)
                        }
                    }
                    return a
                },
                fromJSON(e) {
                    let t = l();
                    return (0, d.isSet)(e.channel) && (t.channel = o.Channel.fromJSON(e.channel)), (0, d.isSet)(e.proof) && (t.proof = (0, d.bytesFromBase64)(e.proof)), (0, d.isSet)(e.proofHeight) && (t.proofHeight = i.Height.fromJSON(e.proofHeight)), t
                },
                toJSON(e) {
                    let t = {};
                    return void 0 !== e.channel && (t.channel = e.channel ? o.Channel.toJSON(e.channel) : void 0), void 0 !== e.proof && (t.proof = (0, d.base64FromBytes)(void 0 !== e.proof ? e.proof : new Uint8Array)), void 0 !== e.proofHeight && (t.proofHeight = e.proofHeight ? i.Height.toJSON(e.proofHeight) : void 0), t
                },
                fromPartial(e) {
                    let t = l();
                    return void 0 !== e.channel && null !== e.channel && (t.channel = o.Channel.fromPartial(e.channel)), t.proof = e.proof ? ? new Uint8Array, void 0 !== e.proofHeight && null !== e.proofHeight && (t.proofHeight = i.Height.fromPartial(e.proofHeight)), t
                }
            }, t.QueryChannelsRequest = {
                typeUrl: "/ibc.core.channel.v1.QueryChannelsRequest",
                encode: (e, t = s.BinaryWriter.create()) => (void 0 !== e.pagination && n.PageRequest.encode(e.pagination, t.uint32(10).fork()).ldelim(), t),
                decode(e, t) {
                    let r = e instanceof s.BinaryReader ? e : new s.BinaryReader(e),
                        o = void 0 === t ? r.len : r.pos + t,
                        i = u();
                    for (; r.pos < o;) {
                        let e = r.uint32();
                        e >>> 3 == 1 ? i.pagination = n.PageRequest.decode(r, r.uint32()) : r.skipType(7 & e)
                    }
                    return i
                },
                fromJSON(e) {
                    let t = u();
                    return (0, d.isSet)(e.pagination) && (t.pagination = n.PageRequest.fromJSON(e.pagination)), t
                },
                toJSON(e) {
                    let t = {};
                    return void 0 !== e.pagination && (t.pagination = e.pagination ? n.PageRequest.toJSON(e.pagination) : void 0), t
                },
                fromPartial(e) {
                    let t = u();
                    return void 0 !== e.pagination && null !== e.pagination && (t.pagination = n.PageRequest.fromPartial(e.pagination)), t
                }
            }, t.QueryChannelsResponse = {
                typeUrl: "/ibc.core.channel.v1.QueryChannelsResponse",
                encode(e, t = s.BinaryWriter.create()) {
                    for (let r of e.channels) o.IdentifiedChannel.encode(r, t.uint32(10).fork()).ldelim();
                    return void 0 !== e.pagination && n.PageResponse.encode(e.pagination, t.uint32(18).fork()).ldelim(), void 0 !== e.height && i.Height.encode(e.height, t.uint32(26).fork()).ldelim(), t
                },
                decode(e, t) {
                    let r = e instanceof s.BinaryReader ? e : new s.BinaryReader(e),
                        a = void 0 === t ? r.len : r.pos + t,
                        d = p();
                    for (; r.pos < a;) {
                        let e = r.uint32();
                        switch (e >>> 3) {
                            case 1:
                                d.channels.push(o.IdentifiedChannel.decode(r, r.uint32()));
                                break;
                            case 2:
                                d.pagination = n.PageResponse.decode(r, r.uint32());
                                break;
                            case 3:
                                d.height = i.Height.decode(r, r.uint32());
                                break;
                            default:
                                r.skipType(7 & e)
                        }
                    }
                    return d
                },
                fromJSON(e) {
                    let t = p();
                    return Array.isArray(e ? .channels) && (t.channels = e.channels.map(e => o.IdentifiedChannel.fromJSON(e))), (0, d.isSet)(e.pagination) && (t.pagination = n.PageResponse.fromJSON(e.pagination)), (0, d.isSet)(e.height) && (t.height = i.Height.fromJSON(e.height)), t
                },
                toJSON(e) {
                    let t = {};
                    return e.channels ? t.channels = e.channels.map(e => e ? o.IdentifiedChannel.toJSON(e) : void 0) : t.channels = [], void 0 !== e.pagination && (t.pagination = e.pagination ? n.PageResponse.toJSON(e.pagination) : void 0), void 0 !== e.height && (t.height = e.height ? i.Height.toJSON(e.height) : void 0), t
                },
                fromPartial(e) {
                    let t = p();
                    return t.channels = e.channels ? .map(e => o.IdentifiedChannel.fromPartial(e)) || [], void 0 !== e.pagination && null !== e.pagination && (t.pagination = n.PageResponse.fromPartial(e.pagination)), void 0 !== e.height && null !== e.height && (t.height = i.Height.fromPartial(e.height)), t
                }
            }, t.QueryConnectionChannelsRequest = {
                typeUrl: "/ibc.core.channel.v1.QueryConnectionChannelsRequest",
                encode: (e, t = s.BinaryWriter.create()) => ("" !== e.connection && t.uint32(10).string(e.connection), void 0 !== e.pagination && n.PageRequest.encode(e.pagination, t.uint32(18).fork()).ldelim(), t),
                decode(e, t) {
                    let r = e instanceof s.BinaryReader ? e : new s.BinaryReader(e),
                        o = void 0 === t ? r.len : r.pos + t,
                        i = m();
                    for (; r.pos < o;) {
                        let e = r.uint32();
                        switch (e >>> 3) {
                            case 1:
                                i.connection = r.string();
                                break;
                            case 2:
                                i.pagination = n.PageRequest.decode(r, r.uint32());
                                break;
                            default:
                                r.skipType(7 & e)
                        }
                    }
                    return i
                },
                fromJSON(e) {
                    let t = m();
                    return (0, d.isSet)(e.connection) && (t.connection = String(e.connection)), (0, d.isSet)(e.pagination) && (t.pagination = n.PageRequest.fromJSON(e.pagination)), t
                },
                toJSON(e) {
                    let t = {};
                    return void 0 !== e.connection && (t.connection = e.connection), void 0 !== e.pagination && (t.pagination = e.pagination ? n.PageRequest.toJSON(e.pagination) : void 0), t
                },
                fromPartial(e) {
                    let t = m();
                    return t.connection = e.connection ? ? "", void 0 !== e.pagination && null !== e.pagination && (t.pagination = n.PageRequest.fromPartial(e.pagination)), t
                }
            }, t.QueryConnectionChannelsResponse = {
                typeUrl: "/ibc.core.channel.v1.QueryConnectionChannelsResponse",
                encode(e, t = s.BinaryWriter.create()) {
                    for (let r of e.channels) o.IdentifiedChannel.encode(r, t.uint32(10).fork()).ldelim();
                    return void 0 !== e.pagination && n.PageResponse.encode(e.pagination, t.uint32(18).fork()).ldelim(), void 0 !== e.height && i.Height.encode(e.height, t.uint32(26).fork()).ldelim(), t
                },
                decode(e, t) {
                    let r = e instanceof s.BinaryReader ? e : new s.BinaryReader(e),
                        a = void 0 === t ? r.len : r.pos + t,
                        d = g();
                    for (; r.pos < a;) {
                        let e = r.uint32();
                        switch (e >>> 3) {
                            case 1:
                                d.channels.push(o.IdentifiedChannel.decode(r, r.uint32()));
                                break;
                            case 2:
                                d.pagination = n.PageResponse.decode(r, r.uint32());
                                break;
                            case 3:
                                d.height = i.Height.decode(r, r.uint32());
                                break;
                            default:
                                r.skipType(7 & e)
                        }
                    }
                    return d
                },
                fromJSON(e) {
                    let t = g();
                    return Array.isArray(e ? .channels) && (t.channels = e.channels.map(e => o.IdentifiedChannel.fromJSON(e))), (0, d.isSet)(e.pagination) && (t.pagination = n.PageResponse.fromJSON(e.pagination)), (0, d.isSet)(e.height) && (t.height = i.Height.fromJSON(e.height)), t
                },
                toJSON(e) {
                    let t = {};
                    return e.channels ? t.channels = e.channels.map(e => e ? o.IdentifiedChannel.toJSON(e) : void 0) : t.channels = [], void 0 !== e.pagination && (t.pagination = e.pagination ? n.PageResponse.toJSON(e.pagination) : void 0), void 0 !== e.height && (t.height = e.height ? i.Height.toJSON(e.height) : void 0), t
                },
                fromPartial(e) {
                    let t = g();
                    return t.channels = e.channels ? .map(e => o.IdentifiedChannel.fromPartial(e)) || [], void 0 !== e.pagination && null !== e.pagination && (t.pagination = n.PageResponse.fromPartial(e.pagination)), void 0 !== e.height && null !== e.height && (t.height = i.Height.fromPartial(e.height)), t
                }
            }, t.QueryChannelClientStateRequest = {
                typeUrl: "/ibc.core.channel.v1.QueryChannelClientStateRequest",
                encode: (e, t = s.BinaryWriter.create()) => ("" !== e.portId && t.uint32(10).string(e.portId), "" !== e.channelId && t.uint32(18).string(e.channelId), t),
                decode(e, t) {
                    let r = e instanceof s.BinaryReader ? e : new s.BinaryReader(e),
                        n = void 0 === t ? r.len : r.pos + t,
                        o = f();
                    for (; r.pos < n;) {
                        let e = r.uint32();
                        switch (e >>> 3) {
                            case 1:
                                o.portId = r.string();
                                break;
                            case 2:
                                o.channelId = r.string();
                                break;
                            default:
                                r.skipType(7 & e)
                        }
                    }
                    return o
                },
                fromJSON(e) {
                    let t = f();
                    return (0, d.isSet)(e.portId) && (t.portId = String(e.portId)), (0, d.isSet)(e.channelId) && (t.channelId = String(e.channelId)), t
                },
                toJSON(e) {
                    let t = {};
                    return void 0 !== e.portId && (t.portId = e.portId), void 0 !== e.channelId && (t.channelId = e.channelId), t
                },
                fromPartial(e) {
                    let t = f();
                    return t.portId = e.portId ? ? "", t.channelId = e.channelId ? ? "", t
                }
            }, t.QueryChannelClientStateResponse = {
                typeUrl: "/ibc.core.channel.v1.QueryChannelClientStateResponse",
                encode: (e, t = s.BinaryWriter.create()) => (void 0 !== e.identifiedClientState && i.IdentifiedClientState.encode(e.identifiedClientState, t.uint32(10).fork()).ldelim(), 0 !== e.proof.length && t.uint32(18).bytes(e.proof), void 0 !== e.proofHeight && i.Height.encode(e.proofHeight, t.uint32(26).fork()).ldelim(), t),
                decode(e, t) {
                    let r = e instanceof s.BinaryReader ? e : new s.BinaryReader(e),
                        n = void 0 === t ? r.len : r.pos + t,
                        o = y();
                    for (; r.pos < n;) {
                        let e = r.uint32();
                        switch (e >>> 3) {
                            case 1:
                                o.identifiedClientState = i.IdentifiedClientState.decode(r, r.uint32());
                                break;
                            case 2:
                                o.proof = r.bytes();
                                break;
                            case 3:
                                o.proofHeight = i.Height.decode(r, r.uint32());
                                break;
                            default:
                                r.skipType(7 & e)
                        }
                    }
                    return o
                },
                fromJSON(e) {
                    let t = y();
                    return (0, d.isSet)(e.identifiedClientState) && (t.identifiedClientState = i.IdentifiedClientState.fromJSON(e.identifiedClientState)), (0, d.isSet)(e.proof) && (t.proof = (0, d.bytesFromBase64)(e.proof)), (0, d.isSet)(e.proofHeight) && (t.proofHeight = i.Height.fromJSON(e.proofHeight)), t
                },
                toJSON(e) {
                    let t = {};
                    return void 0 !== e.identifiedClientState && (t.identifiedClientState = e.identifiedClientState ? i.IdentifiedClientState.toJSON(e.identifiedClientState) : void 0), void 0 !== e.proof && (t.proof = (0, d.base64FromBytes)(void 0 !== e.proof ? e.proof : new Uint8Array)), void 0 !== e.proofHeight && (t.proofHeight = e.proofHeight ? i.Height.toJSON(e.proofHeight) : void 0), t
                },
                fromPartial(e) {
                    let t = y();
                    return void 0 !== e.identifiedClientState && null !== e.identifiedClientState && (t.identifiedClientState = i.IdentifiedClientState.fromPartial(e.identifiedClientState)), t.proof = e.proof ? ? new Uint8Array, void 0 !== e.proofHeight && null !== e.proofHeight && (t.proofHeight = i.Height.fromPartial(e.proofHeight)), t
                }
            }, t.QueryChannelConsensusStateRequest = {
                typeUrl: "/ibc.core.channel.v1.QueryChannelConsensusStateRequest",
                encode: (e, t = s.BinaryWriter.create()) => ("" !== e.portId && t.uint32(10).string(e.portId), "" !== e.channelId && t.uint32(18).string(e.channelId), e.revisionNumber !== BigInt(0) && t.uint32(24).uint64(e.revisionNumber), e.revisionHeight !== BigInt(0) && t.uint32(32).uint64(e.revisionHeight), t),
                decode(e, t) {
                    let r = e instanceof s.BinaryReader ? e : new s.BinaryReader(e),
                        n = void 0 === t ? r.len : r.pos + t,
                        o = h();
                    for (; r.pos < n;) {
                        let e = r.uint32();
                        switch (e >>> 3) {
                            case 1:
                                o.portId = r.string();
                                break;
                            case 2:
                                o.channelId = r.string();
                                break;
                            case 3:
                                o.revisionNumber = r.uint64();
                                break;
                            case 4:
                                o.revisionHeight = r.uint64();
                                break;
                            default:
                                r.skipType(7 & e)
                        }
                    }
                    return o
                },
                fromJSON(e) {
                    let t = h();
                    return (0, d.isSet)(e.portId) && (t.portId = String(e.portId)), (0, d.isSet)(e.channelId) && (t.channelId = String(e.channelId)), (0, d.isSet)(e.revisionNumber) && (t.revisionNumber = BigInt(e.revisionNumber.toString())), (0, d.isSet)(e.revisionHeight) && (t.revisionHeight = BigInt(e.revisionHeight.toString())), t
                },
                toJSON(e) {
                    let t = {};
                    return void 0 !== e.portId && (t.portId = e.portId), void 0 !== e.channelId && (t.channelId = e.channelId), void 0 !== e.revisionNumber && (t.revisionNumber = (e.revisionNumber || BigInt(0)).toString()), void 0 !== e.revisionHeight && (t.revisionHeight = (e.revisionHeight || BigInt(0)).toString()), t
                },
                fromPartial(e) {
                    let t = h();
                    return t.portId = e.portId ? ? "", t.channelId = e.channelId ? ? "", void 0 !== e.revisionNumber && null !== e.revisionNumber && (t.revisionNumber = BigInt(e.revisionNumber.toString())), void 0 !== e.revisionHeight && null !== e.revisionHeight && (t.revisionHeight = BigInt(e.revisionHeight.toString())), t
                }
            }, t.QueryChannelConsensusStateResponse = {
                typeUrl: "/ibc.core.channel.v1.QueryChannelConsensusStateResponse",
                encode: (e, t = s.BinaryWriter.create()) => (void 0 !== e.consensusState && a.Any.encode(e.consensusState, t.uint32(10).fork()).ldelim(), "" !== e.clientId && t.uint32(18).string(e.clientId), 0 !== e.proof.length && t.uint32(26).bytes(e.proof), void 0 !== e.proofHeight && i.Height.encode(e.proofHeight, t.uint32(34).fork()).ldelim(), t),
                decode(e, t) {
                    let r = e instanceof s.BinaryReader ? e : new s.BinaryReader(e),
                        n = void 0 === t ? r.len : r.pos + t,
                        o = v();
                    for (; r.pos < n;) {
                        let e = r.uint32();
                        switch (e >>> 3) {
                            case 1:
                                o.consensusState = a.Any.decode(r, r.uint32());
                                break;
                            case 2:
                                o.clientId = r.string();
                                break;
                            case 3:
                                o.proof = r.bytes();
                                break;
                            case 4:
                                o.proofHeight = i.Height.decode(r, r.uint32());
                                break;
                            default:
                                r.skipType(7 & e)
                        }
                    }
                    return o
                },
                fromJSON(e) {
                    let t = v();
                    return (0, d.isSet)(e.consensusState) && (t.consensusState = a.Any.fromJSON(e.consensusState)), (0, d.isSet)(e.clientId) && (t.clientId = String(e.clientId)), (0, d.isSet)(e.proof) && (t.proof = (0, d.bytesFromBase64)(e.proof)), (0, d.isSet)(e.proofHeight) && (t.proofHeight = i.Height.fromJSON(e.proofHeight)), t
                },
                toJSON(e) {
                    let t = {};
                    return void 0 !== e.consensusState && (t.consensusState = e.consensusState ? a.Any.toJSON(e.consensusState) : void 0), void 0 !== e.clientId && (t.clientId = e.clientId), void 0 !== e.proof && (t.proof = (0, d.base64FromBytes)(void 0 !== e.proof ? e.proof : new Uint8Array)), void 0 !== e.proofHeight && (t.proofHeight = e.proofHeight ? i.Height.toJSON(e.proofHeight) : void 0), t
                },
                fromPartial(e) {
                    let t = v();
                    return void 0 !== e.consensusState && null !== e.consensusState && (t.consensusState = a.Any.fromPartial(e.consensusState)), t.clientId = e.clientId ? ? "", t.proof = e.proof ? ? new Uint8Array, void 0 !== e.proofHeight && null !== e.proofHeight && (t.proofHeight = i.Height.fromPartial(e.proofHeight)), t
                }
            }, t.QueryPacketCommitmentRequest = {
                typeUrl: "/ibc.core.channel.v1.QueryPacketCommitmentRequest",
                encode: (e, t = s.BinaryWriter.create()) => ("" !== e.portId && t.uint32(10).string(e.portId), "" !== e.channelId && t.uint32(18).string(e.channelId), e.sequence !== BigInt(0) && t.uint32(24).uint64(e.sequence), t),
                decode(e, t) {
                    let r = e instanceof s.BinaryReader ? e : new s.BinaryReader(e),
                        n = void 0 === t ? r.len : r.pos + t,
                        o = b();
                    for (; r.pos < n;) {
                        let e = r.uint32();
                        switch (e >>> 3) {
                            case 1:
                                o.portId = r.string();
                                break;
                            case 2:
                                o.channelId = r.string();
                                break;
                            case 3:
                                o.sequence = r.uint64();
                                break;
                            default:
                                r.skipType(7 & e)
                        }
                    }
                    return o
                },
                fromJSON(e) {
                    let t = b();
                    return (0, d.isSet)(e.portId) && (t.portId = String(e.portId)), (0, d.isSet)(e.channelId) && (t.channelId = String(e.channelId)), (0, d.isSet)(e.sequence) && (t.sequence = BigInt(e.sequence.toString())), t
                },
                toJSON(e) {
                    let t = {};
                    return void 0 !== e.portId && (t.portId = e.portId), void 0 !== e.channelId && (t.channelId = e.channelId), void 0 !== e.sequence && (t.sequence = (e.sequence || BigInt(0)).toString()), t
                },
                fromPartial(e) {
                    let t = b();
                    return t.portId = e.portId ? ? "", t.channelId = e.channelId ? ? "", void 0 !== e.sequence && null !== e.sequence && (t.sequence = BigInt(e.sequence.toString())), t
                }
            }, t.QueryPacketCommitmentResponse = {
                typeUrl: "/ibc.core.channel.v1.QueryPacketCommitmentResponse",
                encode: (e, t = s.BinaryWriter.create()) => (0 !== e.commitment.length && t.uint32(10).bytes(e.commitment), 0 !== e.proof.length && t.uint32(18).bytes(e.proof), void 0 !== e.proofHeight && i.Height.encode(e.proofHeight, t.uint32(26).fork()).ldelim(), t),
                decode(e, t) {
                    let r = e instanceof s.BinaryReader ? e : new s.BinaryReader(e),
                        n = void 0 === t ? r.len : r.pos + t,
                        o = S();
                    for (; r.pos < n;) {
                        let e = r.uint32();
                        switch (e >>> 3) {
                            case 1:
                                o.commitment = r.bytes();
                                break;
                            case 2:
                                o.proof = r.bytes();
                                break;
                            case 3:
                                o.proofHeight = i.Height.decode(r, r.uint32());
                                break;
                            default:
                                r.skipType(7 & e)
                        }
                    }
                    return o
                },
                fromJSON(e) {
                    let t = S();
                    return (0, d.isSet)(e.commitment) && (t.commitment = (0, d.bytesFromBase64)(e.commitment)), (0, d.isSet)(e.proof) && (t.proof = (0, d.bytesFromBase64)(e.proof)), (0, d.isSet)(e.proofHeight) && (t.proofHeight = i.Height.fromJSON(e.proofHeight)), t
                },
                toJSON(e) {
                    let t = {};
                    return void 0 !== e.commitment && (t.commitment = (0, d.base64FromBytes)(void 0 !== e.commitment ? e.commitment : new Uint8Array)), void 0 !== e.proof && (t.proof = (0, d.base64FromBytes)(void 0 !== e.proof ? e.proof : new Uint8Array)), void 0 !== e.proofHeight && (t.proofHeight = e.proofHeight ? i.Height.toJSON(e.proofHeight) : void 0), t
                },
                fromPartial(e) {
                    let t = S();
                    return t.commitment = e.commitment ? ? new Uint8Array, t.proof = e.proof ? ? new Uint8Array, void 0 !== e.proofHeight && null !== e.proofHeight && (t.proofHeight = i.Height.fromPartial(e.proofHeight)), t
                }
            }, t.QueryPacketCommitmentsRequest = {
                typeUrl: "/ibc.core.channel.v1.QueryPacketCommitmentsRequest",
                encode: (e, t = s.BinaryWriter.create()) => ("" !== e.portId && t.uint32(10).string(e.portId), "" !== e.channelId && t.uint32(18).string(e.channelId), void 0 !== e.pagination && n.PageRequest.encode(e.pagination, t.uint32(26).fork()).ldelim(), t),
                decode(e, t) {
                    let r = e instanceof s.BinaryReader ? e : new s.BinaryReader(e),
                        o = void 0 === t ? r.len : r.pos + t,
                        i = k();
                    for (; r.pos < o;) {
                        let e = r.uint32();
                        switch (e >>> 3) {
                            case 1:
                                i.portId = r.string();
                                break;
                            case 2:
                                i.channelId = r.string();
                                break;
                            case 3:
                                i.pagination = n.PageRequest.decode(r, r.uint32());
                                break;
                            default:
                                r.skipType(7 & e)
                        }
                    }
                    return i
                },
                fromJSON(e) {
                    let t = k();
                    return (0, d.isSet)(e.portId) && (t.portId = String(e.portId)), (0, d.isSet)(e.channelId) && (t.channelId = String(e.channelId)), (0, d.isSet)(e.pagination) && (t.pagination = n.PageRequest.fromJSON(e.pagination)), t
                },
                toJSON(e) {
                    let t = {};
                    return void 0 !== e.portId && (t.portId = e.portId), void 0 !== e.channelId && (t.channelId = e.channelId), void 0 !== e.pagination && (t.pagination = e.pagination ? n.PageRequest.toJSON(e.pagination) : void 0), t
                },
                fromPartial(e) {
                    let t = k();
                    return t.portId = e.portId ? ? "", t.channelId = e.channelId ? ? "", void 0 !== e.pagination && null !== e.pagination && (t.pagination = n.PageRequest.fromPartial(e.pagination)), t
                }
            }, t.QueryPacketCommitmentsResponse = {
                typeUrl: "/ibc.core.channel.v1.QueryPacketCommitmentsResponse",
                encode(e, t = s.BinaryWriter.create()) {
                    for (let r of e.commitments) o.PacketState.encode(r, t.uint32(10).fork()).ldelim();
                    return void 0 !== e.pagination && n.PageResponse.encode(e.pagination, t.uint32(18).fork()).ldelim(), void 0 !== e.height && i.Height.encode(e.height, t.uint32(26).fork()).ldelim(), t
                },
                decode(e, t) {
                    let r = e instanceof s.BinaryReader ? e : new s.BinaryReader(e),
                        a = void 0 === t ? r.len : r.pos + t,
                        d = P();
                    for (; r.pos < a;) {
                        let e = r.uint32();
                        switch (e >>> 3) {
                            case 1:
                                d.commitments.push(o.PacketState.decode(r, r.uint32()));
                                break;
                            case 2:
                                d.pagination = n.PageResponse.decode(r, r.uint32());
                                break;
                            case 3:
                                d.height = i.Height.decode(r, r.uint32());
                                break;
                            default:
                                r.skipType(7 & e)
                        }
                    }
                    return d
                },
                fromJSON(e) {
                    let t = P();
                    return Array.isArray(e ? .commitments) && (t.commitments = e.commitments.map(e => o.PacketState.fromJSON(e))), (0, d.isSet)(e.pagination) && (t.pagination = n.PageResponse.fromJSON(e.pagination)), (0, d.isSet)(e.height) && (t.height = i.Height.fromJSON(e.height)), t
                },
                toJSON(e) {
                    let t = {};
                    return e.commitments ? t.commitments = e.commitments.map(e => e ? o.PacketState.toJSON(e) : void 0) : t.commitments = [], void 0 !== e.pagination && (t.pagination = e.pagination ? n.PageResponse.toJSON(e.pagination) : void 0), void 0 !== e.height && (t.height = e.height ? i.Height.toJSON(e.height) : void 0), t
                },
                fromPartial(e) {
                    let t = P();
                    return t.commitments = e.commitments ? .map(e => o.PacketState.fromPartial(e)) || [], void 0 !== e.pagination && null !== e.pagination && (t.pagination = n.PageResponse.fromPartial(e.pagination)), void 0 !== e.height && null !== e.height && (t.height = i.Height.fromPartial(e.height)), t
                }
            }, t.QueryPacketReceiptRequest = {
                typeUrl: "/ibc.core.channel.v1.QueryPacketReceiptRequest",
                encode: (e, t = s.BinaryWriter.create()) => ("" !== e.portId && t.uint32(10).string(e.portId), "" !== e.channelId && t.uint32(18).string(e.channelId), e.sequence !== BigInt(0) && t.uint32(24).uint64(e.sequence), t),
                decode(e, t) {
                    let r = e instanceof s.BinaryReader ? e : new s.BinaryReader(e),
                        n = void 0 === t ? r.len : r.pos + t,
                        o = _();
                    for (; r.pos < n;) {
                        let e = r.uint32();
                        switch (e >>> 3) {
                            case 1:
                                o.portId = r.string();
                                break;
                            case 2:
                                o.channelId = r.string();
                                break;
                            case 3:
                                o.sequence = r.uint64();
                                break;
                            default:
                                r.skipType(7 & e)
                        }
                    }
                    return o
                },
                fromJSON(e) {
                    let t = _();
                    return (0, d.isSet)(e.portId) && (t.portId = String(e.portId)), (0, d.isSet)(e.channelId) && (t.channelId = String(e.channelId)), (0, d.isSet)(e.sequence) && (t.sequence = BigInt(e.sequence.toString())), t
                },
                toJSON(e) {
                    let t = {};
                    return void 0 !== e.portId && (t.portId = e.portId), void 0 !== e.channelId && (t.channelId = e.channelId), void 0 !== e.sequence && (t.sequence = (e.sequence || BigInt(0)).toString()), t
                },
                fromPartial(e) {
                    let t = _();
                    return t.portId = e.portId ? ? "", t.channelId = e.channelId ? ? "", void 0 !== e.sequence && null !== e.sequence && (t.sequence = BigInt(e.sequence.toString())), t
                }
            }, t.QueryPacketReceiptResponse = {
                typeUrl: "/ibc.core.channel.v1.QueryPacketReceiptResponse",
                encode: (e, t = s.BinaryWriter.create()) => (!0 === e.received && t.uint32(16).bool(e.received), 0 !== e.proof.length && t.uint32(26).bytes(e.proof), void 0 !== e.proofHeight && i.Height.encode(e.proofHeight, t.uint32(34).fork()).ldelim(), t),
                decode(e, t) {
                    let r = e instanceof s.BinaryReader ? e : new s.BinaryReader(e),
                        n = void 0 === t ? r.len : r.pos + t,
                        o = B();
                    for (; r.pos < n;) {
                        let e = r.uint32();
                        switch (e >>> 3) {
                            case 2:
                                o.received = r.bool();
                                break;
                            case 3:
                                o.proof = r.bytes();
                                break;
                            case 4:
                                o.proofHeight = i.Height.decode(r, r.uint32());
                                break;
                            default:
                                r.skipType(7 & e)
                        }
                    }
                    return o
                },
                fromJSON(e) {
                    let t = B();
                    return (0, d.isSet)(e.received) && (t.received = !!e.received), (0, d.isSet)(e.proof) && (t.proof = (0, d.bytesFromBase64)(e.proof)), (0, d.isSet)(e.proofHeight) && (t.proofHeight = i.Height.fromJSON(e.proofHeight)), t
                },
                toJSON(e) {
                    let t = {};
                    return void 0 !== e.received && (t.received = e.received), void 0 !== e.proof && (t.proof = (0, d.base64FromBytes)(void 0 !== e.proof ? e.proof : new Uint8Array)), void 0 !== e.proofHeight && (t.proofHeight = e.proofHeight ? i.Height.toJSON(e.proofHeight) : void 0), t
                },
                fromPartial(e) {
                    let t = B();
                    return t.received = e.received ? ? !1, t.proof = e.proof ? ? new Uint8Array, void 0 !== e.proofHeight && null !== e.proofHeight && (t.proofHeight = i.Height.fromPartial(e.proofHeight)), t
                }
            }, t.QueryPacketAcknowledgementRequest = {
                typeUrl: "/ibc.core.channel.v1.QueryPacketAcknowledgementRequest",
                encode: (e, t = s.BinaryWriter.create()) => ("" !== e.portId && t.uint32(10).string(e.portId), "" !== e.channelId && t.uint32(18).string(e.channelId), e.sequence !== BigInt(0) && t.uint32(24).uint64(e.sequence), t),
                decode(e, t) {
                    let r = e instanceof s.BinaryReader ? e : new s.BinaryReader(e),
                        n = void 0 === t ? r.len : r.pos + t,
                        o = O();
                    for (; r.pos < n;) {
                        let e = r.uint32();
                        switch (e >>> 3) {
                            case 1:
                                o.portId = r.string();
                                break;
                            case 2:
                                o.channelId = r.string();
                                break;
                            case 3:
                                o.sequence = r.uint64();
                                break;
                            default:
                                r.skipType(7 & e)
                        }
                    }
                    return o
                },
                fromJSON(e) {
                    let t = O();
                    return (0, d.isSet)(e.portId) && (t.portId = String(e.portId)), (0, d.isSet)(e.channelId) && (t.channelId = String(e.channelId)), (0, d.isSet)(e.sequence) && (t.sequence = BigInt(e.sequence.toString())), t
                },
                toJSON(e) {
                    let t = {};
                    return void 0 !== e.portId && (t.portId = e.portId), void 0 !== e.channelId && (t.channelId = e.channelId), void 0 !== e.sequence && (t.sequence = (e.sequence || BigInt(0)).toString()), t
                },
                fromPartial(e) {
                    let t = O();
                    return t.portId = e.portId ? ? "", t.channelId = e.channelId ? ? "", void 0 !== e.sequence && null !== e.sequence && (t.sequence = BigInt(e.sequence.toString())), t
                }
            }, t.QueryPacketAcknowledgementResponse = {
                typeUrl: "/ibc.core.channel.v1.QueryPacketAcknowledgementResponse",
                encode: (e, t = s.BinaryWriter.create()) => (0 !== e.acknowledgement.length && t.uint32(10).bytes(e.acknowledgement), 0 !== e.proof.length && t.uint32(18).bytes(e.proof), void 0 !== e.proofHeight && i.Height.encode(e.proofHeight, t.uint32(26).fork()).ldelim(), t),
                decode(e, t) {
                    let r = e instanceof s.BinaryReader ? e : new s.BinaryReader(e),
                        n = void 0 === t ? r.len : r.pos + t,
                        o = R();
                    for (; r.pos < n;) {
                        let e = r.uint32();
                        switch (e >>> 3) {
                            case 1:
                                o.acknowledgement = r.bytes();
                                break;
                            case 2:
                                o.proof = r.bytes();
                                break;
                            case 3:
                                o.proofHeight = i.Height.decode(r, r.uint32());
                                break;
                            default:
                                r.skipType(7 & e)
                        }
                    }
                    return o
                },
                fromJSON(e) {
                    let t = R();
                    return (0, d.isSet)(e.acknowledgement) && (t.acknowledgement = (0, d.bytesFromBase64)(e.acknowledgement)), (0, d.isSet)(e.proof) && (t.proof = (0, d.bytesFromBase64)(e.proof)), (0, d.isSet)(e.proofHeight) && (t.proofHeight = i.Height.fromJSON(e.proofHeight)), t
                },
                toJSON(e) {
                    let t = {};
                    return void 0 !== e.acknowledgement && (t.acknowledgement = (0, d.base64FromBytes)(void 0 !== e.acknowledgement ? e.acknowledgement : new Uint8Array)), void 0 !== e.proof && (t.proof = (0, d.base64FromBytes)(void 0 !== e.proof ? e.proof : new Uint8Array)), void 0 !== e.proofHeight && (t.proofHeight = e.proofHeight ? i.Height.toJSON(e.proofHeight) : void 0), t
                },
                fromPartial(e) {
                    let t = R();
                    return t.acknowledgement = e.acknowledgement ? ? new Uint8Array, t.proof = e.proof ? ? new Uint8Array, void 0 !== e.proofHeight && null !== e.proofHeight && (t.proofHeight = i.Height.fromPartial(e.proofHeight)), t
                }
            }, t.QueryPacketAcknowledgementsRequest = {
                typeUrl: "/ibc.core.channel.v1.QueryPacketAcknowledgementsRequest",
                encode(e, t = s.BinaryWriter.create()) {
                    for (let r of ("" !== e.portId && t.uint32(10).string(e.portId), "" !== e.channelId && t.uint32(18).string(e.channelId), void 0 !== e.pagination && n.PageRequest.encode(e.pagination, t.uint32(26).fork()).ldelim(), t.uint32(34).fork(), e.packetCommitmentSequences)) t.uint64(r);
                    return t.ldelim(), t
                },
                decode(e, t) {
                    let r = e instanceof s.BinaryReader ? e : new s.BinaryReader(e),
                        o = void 0 === t ? r.len : r.pos + t,
                        i = A();
                    for (; r.pos < o;) {
                        let e = r.uint32();
                        switch (e >>> 3) {
                            case 1:
                                i.portId = r.string();
                                break;
                            case 2:
                                i.channelId = r.string();
                                break;
                            case 3:
                                i.pagination = n.PageRequest.decode(r, r.uint32());
                                break;
                            case 4:
                                if ((7 & e) == 2) {
                                    let e = r.uint32() + r.pos;
                                    for (; r.pos < e;) i.packetCommitmentSequences.push(r.uint64())
                                } else i.packetCommitmentSequences.push(r.uint64());
                                break;
                            default:
                                r.skipType(7 & e)
                        }
                    }
                    return i
                },
                fromJSON(e) {
                    let t = A();
                    return (0, d.isSet)(e.portId) && (t.portId = String(e.portId)), (0, d.isSet)(e.channelId) && (t.channelId = String(e.channelId)), (0, d.isSet)(e.pagination) && (t.pagination = n.PageRequest.fromJSON(e.pagination)), Array.isArray(e ? .packetCommitmentSequences) && (t.packetCommitmentSequences = e.packetCommitmentSequences.map(e => BigInt(e.toString()))), t
                },
                toJSON(e) {
                    let t = {};
                    return void 0 !== e.portId && (t.portId = e.portId), void 0 !== e.channelId && (t.channelId = e.channelId), void 0 !== e.pagination && (t.pagination = e.pagination ? n.PageRequest.toJSON(e.pagination) : void 0), e.packetCommitmentSequences ? t.packetCommitmentSequences = e.packetCommitmentSequences.map(e => (e || BigInt(0)).toString()) : t.packetCommitmentSequences = [], t
                },
                fromPartial(e) {
                    let t = A();
                    return t.portId = e.portId ? ? "", t.channelId = e.channelId ? ? "", void 0 !== e.pagination && null !== e.pagination && (t.pagination = n.PageRequest.fromPartial(e.pagination)), t.packetCommitmentSequences = e.packetCommitmentSequences ? .map(e => BigInt(e.toString())) || [], t
                }
            }, t.QueryPacketAcknowledgementsResponse = {
                typeUrl: "/ibc.core.channel.v1.QueryPacketAcknowledgementsResponse",
                encode(e, t = s.BinaryWriter.create()) {
                    for (let r of e.acknowledgements) o.PacketState.encode(r, t.uint32(10).fork()).ldelim();
                    return void 0 !== e.pagination && n.PageResponse.encode(e.pagination, t.uint32(18).fork()).ldelim(), void 0 !== e.height && i.Height.encode(e.height, t.uint32(26).fork()).ldelim(), t
                },
                decode(e, t) {
                    let r = e instanceof s.BinaryReader ? e : new s.BinaryReader(e),
                        a = void 0 === t ? r.len : r.pos + t,
                        d = I();
                    for (; r.pos < a;) {
                        let e = r.uint32();
                        switch (e >>> 3) {
                            case 1:
                                d.acknowledgements.push(o.PacketState.decode(r, r.uint32()));
                                break;
                            case 2:
                                d.pagination = n.PageResponse.decode(r, r.uint32());
                                break;
                            case 3:
                                d.height = i.Height.decode(r, r.uint32());
                                break;
                            default:
                                r.skipType(7 & e)
                        }
                    }
                    return d
                },
                fromJSON(e) {
                    let t = I();
                    return Array.isArray(e ? .acknowledgements) && (t.acknowledgements = e.acknowledgements.map(e => o.PacketState.fromJSON(e))), (0, d.isSet)(e.pagination) && (t.pagination = n.PageResponse.fromJSON(e.pagination)), (0, d.isSet)(e.height) && (t.height = i.Height.fromJSON(e.height)), t
                },
                toJSON(e) {
                    let t = {};
                    return e.acknowledgements ? t.acknowledgements = e.acknowledgements.map(e => e ? o.PacketState.toJSON(e) : void 0) : t.acknowledgements = [], void 0 !== e.pagination && (t.pagination = e.pagination ? n.PageResponse.toJSON(e.pagination) : void 0), void 0 !== e.height && (t.height = e.height ? i.Height.toJSON(e.height) : void 0), t
                },
                fromPartial(e) {
                    let t = I();
                    return t.acknowledgements = e.acknowledgements ? .map(e => o.PacketState.fromPartial(e)) || [], void 0 !== e.pagination && null !== e.pagination && (t.pagination = n.PageResponse.fromPartial(e.pagination)), void 0 !== e.height && null !== e.height && (t.height = i.Height.fromPartial(e.height)), t
                }
            }, t.QueryUnreceivedPacketsRequest = {
                typeUrl: "/ibc.core.channel.v1.QueryUnreceivedPacketsRequest",
                encode(e, t = s.BinaryWriter.create()) {
                    for (let r of ("" !== e.portId && t.uint32(10).string(e.portId), "" !== e.channelId && t.uint32(18).string(e.channelId), t.uint32(26).fork(), e.packetCommitmentSequences)) t.uint64(r);
                    return t.ldelim(), t
                },
                decode(e, t) {
                    let r = e instanceof s.BinaryReader ? e : new s.BinaryReader(e),
                        n = void 0 === t ? r.len : r.pos + t,
                        o = w();
                    for (; r.pos < n;) {
                        let e = r.uint32();
                        switch (e >>> 3) {
                            case 1:
                                o.portId = r.string();
                                break;
                            case 2:
                                o.channelId = r.string();
                                break;
                            case 3:
                                if ((7 & e) == 2) {
                                    let e = r.uint32() + r.pos;
                                    for (; r.pos < e;) o.packetCommitmentSequences.push(r.uint64())
                                } else o.packetCommitmentSequences.push(r.uint64());
                                break;
                            default:
                                r.skipType(7 & e)
                        }
                    }
                    return o
                },
                fromJSON(e) {
                    let t = w();
                    return (0, d.isSet)(e.portId) && (t.portId = String(e.portId)), (0, d.isSet)(e.channelId) && (t.channelId = String(e.channelId)), Array.isArray(e ? .packetCommitmentSequences) && (t.packetCommitmentSequences = e.packetCommitmentSequences.map(e => BigInt(e.toString()))), t
                },
                toJSON(e) {
                    let t = {};
                    return void 0 !== e.portId && (t.portId = e.portId), void 0 !== e.channelId && (t.channelId = e.channelId), e.packetCommitmentSequences ? t.packetCommitmentSequences = e.packetCommitmentSequences.map(e => (e || BigInt(0)).toString()) : t.packetCommitmentSequences = [], t
                },
                fromPartial(e) {
                    let t = w();
                    return t.portId = e.portId ? ? "", t.channelId = e.channelId ? ? "", t.packetCommitmentSequences = e.packetCommitmentSequences ? .map(e => BigInt(e.toString())) || [], t
                }
            }, t.QueryUnreceivedPacketsResponse = {
                typeUrl: "/ibc.core.channel.v1.QueryUnreceivedPacketsResponse",
                encode(e, t = s.BinaryWriter.create()) {
                    for (let r of (t.uint32(10).fork(), e.sequences)) t.uint64(r);
                    return t.ldelim(), void 0 !== e.height && i.Height.encode(e.height, t.uint32(18).fork()).ldelim(), t
                },
                decode(e, t) {
                    let r = e instanceof s.BinaryReader ? e : new s.BinaryReader(e),
                        n = void 0 === t ? r.len : r.pos + t,
                        o = T();
                    for (; r.pos < n;) {
                        let e = r.uint32();
                        switch (e >>> 3) {
                            case 1:
                                if ((7 & e) == 2) {
                                    let e = r.uint32() + r.pos;
                                    for (; r.pos < e;) o.sequences.push(r.uint64())
                                } else o.sequences.push(r.uint64());
                                break;
                            case 2:
                                o.height = i.Height.decode(r, r.uint32());
                                break;
                            default:
                                r.skipType(7 & e)
                        }
                    }
                    return o
                },
                fromJSON(e) {
                    let t = T();
                    return Array.isArray(e ? .sequences) && (t.sequences = e.sequences.map(e => BigInt(e.toString()))), (0, d.isSet)(e.height) && (t.height = i.Height.fromJSON(e.height)), t
                },
                toJSON(e) {
                    let t = {};
                    return e.sequences ? t.sequences = e.sequences.map(e => (e || BigInt(0)).toString()) : t.sequences = [], void 0 !== e.height && (t.height = e.height ? i.Height.toJSON(e.height) : void 0), t
                },
                fromPartial(e) {
                    let t = T();
                    return t.sequences = e.sequences ? .map(e => BigInt(e.toString())) || [], void 0 !== e.height && null !== e.height && (t.height = i.Height.fromPartial(e.height)), t
                }
            }, t.QueryUnreceivedAcksRequest = {
                typeUrl: "/ibc.core.channel.v1.QueryUnreceivedAcksRequest",
                encode(e, t = s.BinaryWriter.create()) {
                    for (let r of ("" !== e.portId && t.uint32(10).string(e.portId), "" !== e.channelId && t.uint32(18).string(e.channelId), t.uint32(26).fork(), e.packetAckSequences)) t.uint64(r);
                    return t.ldelim(), t
                },
                decode(e, t) {
                    let r = e instanceof s.BinaryReader ? e : new s.BinaryReader(e),
                        n = void 0 === t ? r.len : r.pos + t,
                        o = N();
                    for (; r.pos < n;) {
                        let e = r.uint32();
                        switch (e >>> 3) {
                            case 1:
                                o.portId = r.string();
                                break;
                            case 2:
                                o.channelId = r.string();
                                break;
                            case 3:
                                if ((7 & e) == 2) {
                                    let e = r.uint32() + r.pos;
                                    for (; r.pos < e;) o.packetAckSequences.push(r.uint64())
                                } else o.packetAckSequences.push(r.uint64());
                                break;
                            default:
                                r.skipType(7 & e)
                        }
                    }
                    return o
                },
                fromJSON(e) {
                    let t = N();
                    return (0, d.isSet)(e.portId) && (t.portId = String(e.portId)), (0, d.isSet)(e.channelId) && (t.channelId = String(e.channelId)), Array.isArray(e ? .packetAckSequences) && (t.packetAckSequences = e.packetAckSequences.map(e => BigInt(e.toString()))), t
                },
                toJSON(e) {
                    let t = {};
                    return void 0 !== e.portId && (t.portId = e.portId), void 0 !== e.channelId && (t.channelId = e.channelId), e.packetAckSequences ? t.packetAckSequences = e.packetAckSequences.map(e => (e || BigInt(0)).toString()) : t.packetAckSequences = [], t
                },
                fromPartial(e) {
                    let t = N();
                    return t.portId = e.portId ? ? "", t.channelId = e.channelId ? ? "", t.packetAckSequences = e.packetAckSequences ? .map(e => BigInt(e.toString())) || [], t
                }
            }, t.QueryUnreceivedAcksResponse = {
                typeUrl: "/ibc.core.channel.v1.QueryUnreceivedAcksResponse",
                encode(e, t = s.BinaryWriter.create()) {
                    for (let r of (t.uint32(10).fork(), e.sequences)) t.uint64(r);
                    return t.ldelim(), void 0 !== e.height && i.Height.encode(e.height, t.uint32(18).fork()).ldelim(), t
                },
                decode(e, t) {
                    let r = e instanceof s.BinaryReader ? e : new s.BinaryReader(e),
                        n = void 0 === t ? r.len : r.pos + t,
                        o = C();
                    for (; r.pos < n;) {
                        let e = r.uint32();
                        switch (e >>> 3) {
                            case 1:
                                if ((7 & e) == 2) {
                                    let e = r.uint32() + r.pos;
                                    for (; r.pos < e;) o.sequences.push(r.uint64())
                                } else o.sequences.push(r.uint64());
                                break;
                            case 2:
                                o.height = i.Height.decode(r, r.uint32());
                                break;
                            default:
                                r.skipType(7 & e)
                        }
                    }
                    return o
                },
                fromJSON(e) {
                    let t = C();
                    return Array.isArray(e ? .sequences) && (t.sequences = e.sequences.map(e => BigInt(e.toString()))), (0, d.isSet)(e.height) && (t.height = i.Height.fromJSON(e.height)), t
                },
                toJSON(e) {
                    let t = {};
                    return e.sequences ? t.sequences = e.sequences.map(e => (e || BigInt(0)).toString()) : t.sequences = [], void 0 !== e.height && (t.height = e.height ? i.Height.toJSON(e.height) : void 0), t
                },
                fromPartial(e) {
                    let t = C();
                    return t.sequences = e.sequences ? .map(e => BigInt(e.toString())) || [], void 0 !== e.height && null !== e.height && (t.height = i.Height.fromPartial(e.height)), t
                }
            }, t.QueryNextSequenceReceiveRequest = {
                typeUrl: "/ibc.core.channel.v1.QueryNextSequenceReceiveRequest",
                encode: (e, t = s.BinaryWriter.create()) => ("" !== e.portId && t.uint32(10).string(e.portId), "" !== e.channelId && t.uint32(18).string(e.channelId), t),
                decode(e, t) {
                    let r = e instanceof s.BinaryReader ? e : new s.BinaryReader(e),
                        n = void 0 === t ? r.len : r.pos + t,
                        o = E();
                    for (; r.pos < n;) {
                        let e = r.uint32();
                        switch (e >>> 3) {
                            case 1:
                                o.portId = r.string();
                                break;
                            case 2:
                                o.channelId = r.string();
                                break;
                            default:
                                r.skipType(7 & e)
                        }
                    }
                    return o
                },
                fromJSON(e) {
                    let t = E();
                    return (0, d.isSet)(e.portId) && (t.portId = String(e.portId)), (0, d.isSet)(e.channelId) && (t.channelId = String(e.channelId)), t
                },
                toJSON(e) {
                    let t = {};
                    return void 0 !== e.portId && (t.portId = e.portId), void 0 !== e.channelId && (t.channelId = e.channelId), t
                },
                fromPartial(e) {
                    let t = E();
                    return t.portId = e.portId ? ? "", t.channelId = e.channelId ? ? "", t
                }
            }, t.QueryNextSequenceReceiveResponse = {
                typeUrl: "/ibc.core.channel.v1.QueryNextSequenceReceiveResponse",
                encode: (e, t = s.BinaryWriter.create()) => (e.nextSequenceReceive !== BigInt(0) && t.uint32(8).uint64(e.nextSequenceReceive), 0 !== e.proof.length && t.uint32(18).bytes(e.proof), void 0 !== e.proofHeight && i.Height.encode(e.proofHeight, t.uint32(26).fork()).ldelim(), t),
                decode(e, t) {
                    let r = e instanceof s.BinaryReader ? e : new s.BinaryReader(e),
                        n = void 0 === t ? r.len : r.pos + t,
                        o = x();
                    for (; r.pos < n;) {
                        let e = r.uint32();
                        switch (e >>> 3) {
                            case 1:
                                o.nextSequenceReceive = r.uint64();
                                break;
                            case 2:
                                o.proof = r.bytes();
                                break;
                            case 3:
                                o.proofHeight = i.Height.decode(r, r.uint32());
                                break;
                            default:
                                r.skipType(7 & e)
                        }
                    }
                    return o
                },
                fromJSON(e) {
                    let t = x();
                    return (0, d.isSet)(e.nextSequenceReceive) && (t.nextSequenceReceive = BigInt(e.nextSequenceReceive.toString())), (0, d.isSet)(e.proof) && (t.proof = (0, d.bytesFromBase64)(e.proof)), (0, d.isSet)(e.proofHeight) && (t.proofHeight = i.Height.fromJSON(e.proofHeight)), t
                },
                toJSON(e) {
                    let t = {};
                    return void 0 !== e.nextSequenceReceive && (t.nextSequenceReceive = (e.nextSequenceReceive || BigInt(0)).toString()), void 0 !== e.proof && (t.proof = (0, d.base64FromBytes)(void 0 !== e.proof ? e.proof : new Uint8Array)), void 0 !== e.proofHeight && (t.proofHeight = e.proofHeight ? i.Height.toJSON(e.proofHeight) : void 0), t
                },
                fromPartial(e) {
                    let t = x();
                    return void 0 !== e.nextSequenceReceive && null !== e.nextSequenceReceive && (t.nextSequenceReceive = BigInt(e.nextSequenceReceive.toString())), t.proof = e.proof ? ? new Uint8Array, void 0 !== e.proofHeight && null !== e.proofHeight && (t.proofHeight = i.Height.fromPartial(e.proofHeight)), t
                }
            };
            class U {
                constructor(e) {
                    this.rpc = e, this.Channel = this.Channel.bind(this), this.Channels = this.Channels.bind(this), this.ConnectionChannels = this.ConnectionChannels.bind(this), this.ChannelClientState = this.ChannelClientState.bind(this), this.ChannelConsensusState = this.ChannelConsensusState.bind(this), this.PacketCommitment = this.PacketCommitment.bind(this), this.PacketCommitments = this.PacketCommitments.bind(this), this.PacketReceipt = this.PacketReceipt.bind(this), this.PacketAcknowledgement = this.PacketAcknowledgement.bind(this), this.PacketAcknowledgements = this.PacketAcknowledgements.bind(this), this.UnreceivedPackets = this.UnreceivedPackets.bind(this), this.UnreceivedAcks = this.UnreceivedAcks.bind(this), this.NextSequenceReceive = this.NextSequenceReceive.bind(this)
                }
                Channel(e) {
                    let r = t.QueryChannelRequest.encode(e).finish();
                    return this.rpc.request("ibc.core.channel.v1.Query", "Channel", r).then(e => t.QueryChannelResponse.decode(new s.BinaryReader(e)))
                }
                Channels(e = {
                    pagination: n.PageRequest.fromPartial({})
                }) {
                    let r = t.QueryChannelsRequest.encode(e).finish();
                    return this.rpc.request("ibc.core.channel.v1.Query", "Channels", r).then(e => t.QueryChannelsResponse.decode(new s.BinaryReader(e)))
                }
                ConnectionChannels(e) {
                    let r = t.QueryConnectionChannelsRequest.encode(e).finish();
                    return this.rpc.request("ibc.core.channel.v1.Query", "ConnectionChannels", r).then(e => t.QueryConnectionChannelsResponse.decode(new s.BinaryReader(e)))
                }
                ChannelClientState(e) {
                    let r = t.QueryChannelClientStateRequest.encode(e).finish();
                    return this.rpc.request("ibc.core.channel.v1.Query", "ChannelClientState", r).then(e => t.QueryChannelClientStateResponse.decode(new s.BinaryReader(e)))
                }
                ChannelConsensusState(e) {
                    let r = t.QueryChannelConsensusStateRequest.encode(e).finish();
                    return this.rpc.request("ibc.core.channel.v1.Query", "ChannelConsensusState", r).then(e => t.QueryChannelConsensusStateResponse.decode(new s.BinaryReader(e)))
                }
                PacketCommitment(e) {
                    let r = t.QueryPacketCommitmentRequest.encode(e).finish();
                    return this.rpc.request("ibc.core.channel.v1.Query", "PacketCommitment", r).then(e => t.QueryPacketCommitmentResponse.decode(new s.BinaryReader(e)))
                }
                PacketCommitments(e) {
                    let r = t.QueryPacketCommitmentsRequest.encode(e).finish();
                    return this.rpc.request("ibc.core.channel.v1.Query", "PacketCommitments", r).then(e => t.QueryPacketCommitmentsResponse.decode(new s.BinaryReader(e)))
                }
                PacketReceipt(e) {
                    let r = t.QueryPacketReceiptRequest.encode(e).finish();
                    return this.rpc.request("ibc.core.channel.v1.Query", "PacketReceipt", r).then(e => t.QueryPacketReceiptResponse.decode(new s.BinaryReader(e)))
                }
                PacketAcknowledgement(e) {
                    let r = t.QueryPacketAcknowledgementRequest.encode(e).finish();
                    return this.rpc.request("ibc.core.channel.v1.Query", "PacketAcknowledgement", r).then(e => t.QueryPacketAcknowledgementResponse.decode(new s.BinaryReader(e)))
                }
                PacketAcknowledgements(e) {
                    let r = t.QueryPacketAcknowledgementsRequest.encode(e).finish();
                    return this.rpc.request("ibc.core.channel.v1.Query", "PacketAcknowledgements", r).then(e => t.QueryPacketAcknowledgementsResponse.decode(new s.BinaryReader(e)))
                }
                UnreceivedPackets(e) {
                    let r = t.QueryUnreceivedPacketsRequest.encode(e).finish();
                    return this.rpc.request("ibc.core.channel.v1.Query", "UnreceivedPackets", r).then(e => t.QueryUnreceivedPacketsResponse.decode(new s.BinaryReader(e)))
                }
                UnreceivedAcks(e) {
                    let r = t.QueryUnreceivedAcksRequest.encode(e).finish();
                    return this.rpc.request("ibc.core.channel.v1.Query", "UnreceivedAcks", r).then(e => t.QueryUnreceivedAcksResponse.decode(new s.BinaryReader(e)))
                }
                NextSequenceReceive(e) {
                    let r = t.QueryNextSequenceReceiveRequest.encode(e).finish();
                    return this.rpc.request("ibc.core.channel.v1.Query", "NextSequenceReceive", r).then(e => t.QueryNextSequenceReceiveResponse.decode(new s.BinaryReader(e)))
                }
            }
            t.QueryClientImpl = U
        },
        90268: function(e, t, r) {
            "use strict";
            var n, o;
            Object.defineProperty(t, "__esModule", {
                value: !0
            }), t.MsgClientImpl = t.MsgAcknowledgementResponse = t.MsgAcknowledgement = t.MsgTimeoutOnCloseResponse = t.MsgTimeoutOnClose = t.MsgTimeoutResponse = t.MsgTimeout = t.MsgRecvPacketResponse = t.MsgRecvPacket = t.MsgChannelCloseConfirmResponse = t.MsgChannelCloseConfirm = t.MsgChannelCloseInitResponse = t.MsgChannelCloseInit = t.MsgChannelOpenConfirmResponse = t.MsgChannelOpenConfirm = t.MsgChannelOpenAckResponse = t.MsgChannelOpenAck = t.MsgChannelOpenTryResponse = t.MsgChannelOpenTry = t.MsgChannelOpenInitResponse = t.MsgChannelOpenInit = t.responseResultTypeToJSON = t.responseResultTypeFromJSON = t.ResponseResultType = t.protobufPackage = void 0;
            let i = r(98287),
                a = r(24648),
                s = r(28486),
                d = r(6476);

            function c(e) {
                switch (e) {
                    case 0:
                    case "RESPONSE_RESULT_TYPE_UNSPECIFIED":
                        return n.RESPONSE_RESULT_TYPE_UNSPECIFIED;
                    case 1:
                    case "RESPONSE_RESULT_TYPE_NOOP":
                        return n.RESPONSE_RESULT_TYPE_NOOP;
                    case 2:
                    case "RESPONSE_RESULT_TYPE_SUCCESS":
                        return n.RESPONSE_RESULT_TYPE_SUCCESS;
                    default:
                        return n.UNRECOGNIZED
                }
            }

            function l(e) {
                switch (e) {
                    case n.RESPONSE_RESULT_TYPE_UNSPECIFIED:
                        return "RESPONSE_RESULT_TYPE_UNSPECIFIED";
                    case n.RESPONSE_RESULT_TYPE_NOOP:
                        return "RESPONSE_RESULT_TYPE_NOOP";
                    case n.RESPONSE_RESULT_TYPE_SUCCESS:
                        return "RESPONSE_RESULT_TYPE_SUCCESS";
                    case n.UNRECOGNIZED:
                    default:
                        return "UNRECOGNIZED"
                }
            }

            function u() {
                return {
                    portId: "",
                    channel: i.Channel.fromPartial({}),
                    signer: ""
                }
            }

            function p() {
                return {
                    channelId: "",
                    version: ""
                }
            }

            function m() {
                return {
                    portId: "",
                    previousChannelId: "",
                    channel: i.Channel.fromPartial({}),
                    counterpartyVersion: "",
                    proofInit: new Uint8Array,
                    proofHeight: a.Height.fromPartial({}),
                    signer: ""
                }
            }

            function g() {
                return {
                    version: ""
                }
            }

            function f() {
                return {
                    portId: "",
                    channelId: "",
                    counterpartyChannelId: "",
                    counterpartyVersion: "",
                    proofTry: new Uint8Array,
                    proofHeight: a.Height.fromPartial({}),
                    signer: ""
                }
            }

            function y() {
                return {
                    portId: "",
                    channelId: "",
                    proofAck: new Uint8Array,
                    proofHeight: a.Height.fromPartial({}),
                    signer: ""
                }
            }

            function h() {
                return {
                    portId: "",
                    channelId: "",
                    signer: ""
                }
            }

            function v() {
                return {
                    portId: "",
                    channelId: "",
                    proofInit: new Uint8Array,
                    proofHeight: a.Height.fromPartial({}),
                    signer: ""
                }
            }

            function b() {
                return {
                    packet: i.Packet.fromPartial({}),
                    proofCommitment: new Uint8Array,
                    proofHeight: a.Height.fromPartial({}),
                    signer: ""
                }
            }

            function S() {
                return {
                    result: 0
                }
            }

            function k() {
                return {
                    packet: i.Packet.fromPartial({}),
                    proofUnreceived: new Uint8Array,
                    proofHeight: a.Height.fromPartial({}),
                    nextSequenceRecv: BigInt(0),
                    signer: ""
                }
            }

            function P() {
                return {
                    result: 0
                }
            }

            function _() {
                return {
                    packet: i.Packet.fromPartial({}),
                    proofUnreceived: new Uint8Array,
                    proofClose: new Uint8Array,
                    proofHeight: a.Height.fromPartial({}),
                    nextSequenceRecv: BigInt(0),
                    signer: ""
                }
            }

            function B() {
                return {
                    result: 0
                }
            }

            function O() {
                return {
                    packet: i.Packet.fromPartial({}),
                    acknowledgement: new Uint8Array,
                    proofAcked: new Uint8Array,
                    proofHeight: a.Height.fromPartial({}),
                    signer: ""
                }
            }

            function R() {
                return {
                    result: 0
                }
            }
            t.protobufPackage = "ibc.core.channel.v1", (o = n || (t.ResponseResultType = n = {}))[o.RESPONSE_RESULT_TYPE_UNSPECIFIED = 0] = "RESPONSE_RESULT_TYPE_UNSPECIFIED", o[o.RESPONSE_RESULT_TYPE_NOOP = 1] = "RESPONSE_RESULT_TYPE_NOOP", o[o.RESPONSE_RESULT_TYPE_SUCCESS = 2] = "RESPONSE_RESULT_TYPE_SUCCESS", o[o.UNRECOGNIZED = -1] = "UNRECOGNIZED", t.responseResultTypeFromJSON = c, t.responseResultTypeToJSON = l, t.MsgChannelOpenInit = {
                typeUrl: "/ibc.core.channel.v1.MsgChannelOpenInit",
                encode: (e, t = s.BinaryWriter.create()) => ("" !== e.portId && t.uint32(10).string(e.portId), void 0 !== e.channel && i.Channel.encode(e.channel, t.uint32(18).fork()).ldelim(), "" !== e.signer && t.uint32(26).string(e.signer), t),
                decode(e, t) {
                    let r = e instanceof s.BinaryReader ? e : new s.BinaryReader(e),
                        n = void 0 === t ? r.len : r.pos + t,
                        o = u();
                    for (; r.pos < n;) {
                        let e = r.uint32();
                        switch (e >>> 3) {
                            case 1:
                                o.portId = r.string();
                                break;
                            case 2:
                                o.channel = i.Channel.decode(r, r.uint32());
                                break;
                            case 3:
                                o.signer = r.string();
                                break;
                            default:
                                r.skipType(7 & e)
                        }
                    }
                    return o
                },
                fromJSON(e) {
                    let t = u();
                    return (0, d.isSet)(e.portId) && (t.portId = String(e.portId)), (0, d.isSet)(e.channel) && (t.channel = i.Channel.fromJSON(e.channel)), (0, d.isSet)(e.signer) && (t.signer = String(e.signer)), t
                },
                toJSON(e) {
                    let t = {};
                    return void 0 !== e.portId && (t.portId = e.portId), void 0 !== e.channel && (t.channel = e.channel ? i.Channel.toJSON(e.channel) : void 0), void 0 !== e.signer && (t.signer = e.signer), t
                },
                fromPartial(e) {
                    let t = u();
                    return t.portId = e.portId ? ? "", void 0 !== e.channel && null !== e.channel && (t.channel = i.Channel.fromPartial(e.channel)), t.signer = e.signer ? ? "", t
                }
            }, t.MsgChannelOpenInitResponse = {
                typeUrl: "/ibc.core.channel.v1.MsgChannelOpenInitResponse",
                encode: (e, t = s.BinaryWriter.create()) => ("" !== e.channelId && t.uint32(10).string(e.channelId), "" !== e.version && t.uint32(18).string(e.version), t),
                decode(e, t) {
                    let r = e instanceof s.BinaryReader ? e : new s.BinaryReader(e),
                        n = void 0 === t ? r.len : r.pos + t,
                        o = p();
                    for (; r.pos < n;) {
                        let e = r.uint32();
                        switch (e >>> 3) {
                            case 1:
                                o.channelId = r.string();
                                break;
                            case 2:
                                o.version = r.string();
                                break;
                            default:
                                r.skipType(7 & e)
                        }
                    }
                    return o
                },
                fromJSON(e) {
                    let t = p();
                    return (0, d.isSet)(e.channelId) && (t.channelId = String(e.channelId)), (0, d.isSet)(e.version) && (t.version = String(e.version)), t
                },
                toJSON(e) {
                    let t = {};
                    return void 0 !== e.channelId && (t.channelId = e.channelId), void 0 !== e.version && (t.version = e.version), t
                },
                fromPartial(e) {
                    let t = p();
                    return t.channelId = e.channelId ? ? "", t.version = e.version ? ? "", t
                }
            }, t.MsgChannelOpenTry = {
                typeUrl: "/ibc.core.channel.v1.MsgChannelOpenTry",
                encode: (e, t = s.BinaryWriter.create()) => ("" !== e.portId && t.uint32(10).string(e.portId), "" !== e.previousChannelId && t.uint32(18).string(e.previousChannelId), void 0 !== e.channel && i.Channel.encode(e.channel, t.uint32(26).fork()).ldelim(), "" !== e.counterpartyVersion && t.uint32(34).string(e.counterpartyVersion), 0 !== e.proofInit.length && t.uint32(42).bytes(e.proofInit), void 0 !== e.proofHeight && a.Height.encode(e.proofHeight, t.uint32(50).fork()).ldelim(), "" !== e.signer && t.uint32(58).string(e.signer), t),
                decode(e, t) {
                    let r = e instanceof s.BinaryReader ? e : new s.BinaryReader(e),
                        n = void 0 === t ? r.len : r.pos + t,
                        o = m();
                    for (; r.pos < n;) {
                        let e = r.uint32();
                        switch (e >>> 3) {
                            case 1:
                                o.portId = r.string();
                                break;
                            case 2:
                                o.previousChannelId = r.string();
                                break;
                            case 3:
                                o.channel = i.Channel.decode(r, r.uint32());
                                break;
                            case 4:
                                o.counterpartyVersion = r.string();
                                break;
                            case 5:
                                o.proofInit = r.bytes();
                                break;
                            case 6:
                                o.proofHeight = a.Height.decode(r, r.uint32());
                                break;
                            case 7:
                                o.signer = r.string();
                                break;
                            default:
                                r.skipType(7 & e)
                        }
                    }
                    return o
                },
                fromJSON(e) {
                    let t = m();
                    return (0, d.isSet)(e.portId) && (t.portId = String(e.portId)), (0, d.isSet)(e.previousChannelId) && (t.previousChannelId = String(e.previousChannelId)), (0, d.isSet)(e.channel) && (t.channel = i.Channel.fromJSON(e.channel)), (0, d.isSet)(e.counterpartyVersion) && (t.counterpartyVersion = String(e.counterpartyVersion)), (0, d.isSet)(e.proofInit) && (t.proofInit = (0, d.bytesFromBase64)(e.proofInit)), (0, d.isSet)(e.proofHeight) && (t.proofHeight = a.Height.fromJSON(e.proofHeight)), (0, d.isSet)(e.signer) && (t.signer = String(e.signer)), t
                },
                toJSON(e) {
                    let t = {};
                    return void 0 !== e.portId && (t.portId = e.portId), void 0 !== e.previousChannelId && (t.previousChannelId = e.previousChannelId), void 0 !== e.channel && (t.channel = e.channel ? i.Channel.toJSON(e.channel) : void 0), void 0 !== e.counterpartyVersion && (t.counterpartyVersion = e.counterpartyVersion), void 0 !== e.proofInit && (t.proofInit = (0, d.base64FromBytes)(void 0 !== e.proofInit ? e.proofInit : new Uint8Array)), void 0 !== e.proofHeight && (t.proofHeight = e.proofHeight ? a.Height.toJSON(e.proofHeight) : void 0), void 0 !== e.signer && (t.signer = e.signer), t
                },
                fromPartial(e) {
                    let t = m();
                    return t.portId = e.portId ? ? "", t.previousChannelId = e.previousChannelId ? ? "", void 0 !== e.channel && null !== e.channel && (t.channel = i.Channel.fromPartial(e.channel)), t.counterpartyVersion = e.counterpartyVersion ? ? "", t.proofInit = e.proofInit ? ? new Uint8Array, void 0 !== e.proofHeight && null !== e.proofHeight && (t.proofHeight = a.Height.fromPartial(e.proofHeight)), t.signer = e.signer ? ? "", t
                }
            }, t.MsgChannelOpenTryResponse = {
                typeUrl: "/ibc.core.channel.v1.MsgChannelOpenTryResponse",
                encode: (e, t = s.BinaryWriter.create()) => ("" !== e.version && t.uint32(10).string(e.version), t),
                decode(e, t) {
                    let r = e instanceof s.BinaryReader ? e : new s.BinaryReader(e),
                        n = void 0 === t ? r.len : r.pos + t,
                        o = g();
                    for (; r.pos < n;) {
                        let e = r.uint32();
                        e >>> 3 == 1 ? o.version = r.string() : r.skipType(7 & e)
                    }
                    return o
                },
                fromJSON(e) {
                    let t = g();
                    return (0, d.isSet)(e.version) && (t.version = String(e.version)), t
                },
                toJSON(e) {
                    let t = {};
                    return void 0 !== e.version && (t.version = e.version), t
                },
                fromPartial(e) {
                    let t = g();
                    return t.version = e.version ? ? "", t
                }
            }, t.MsgChannelOpenAck = {
                typeUrl: "/ibc.core.channel.v1.MsgChannelOpenAck",
                encode: (e, t = s.BinaryWriter.create()) => ("" !== e.portId && t.uint32(10).string(e.portId), "" !== e.channelId && t.uint32(18).string(e.channelId), "" !== e.counterpartyChannelId && t.uint32(26).string(e.counterpartyChannelId), "" !== e.counterpartyVersion && t.uint32(34).string(e.counterpartyVersion), 0 !== e.proofTry.length && t.uint32(42).bytes(e.proofTry), void 0 !== e.proofHeight && a.Height.encode(e.proofHeight, t.uint32(50).fork()).ldelim(), "" !== e.signer && t.uint32(58).string(e.signer), t),
                decode(e, t) {
                    let r = e instanceof s.BinaryReader ? e : new s.BinaryReader(e),
                        n = void 0 === t ? r.len : r.pos + t,
                        o = f();
                    for (; r.pos < n;) {
                        let e = r.uint32();
                        switch (e >>> 3) {
                            case 1:
                                o.portId = r.string();
                                break;
                            case 2:
                                o.channelId = r.string();
                                break;
                            case 3:
                                o.counterpartyChannelId = r.string();
                                break;
                            case 4:
                                o.counterpartyVersion = r.string();
                                break;
                            case 5:
                                o.proofTry = r.bytes();
                                break;
                            case 6:
                                o.proofHeight = a.Height.decode(r, r.uint32());
                                break;
                            case 7:
                                o.signer = r.string();
                                break;
                            default:
                                r.skipType(7 & e)
                        }
                    }
                    return o
                },
                fromJSON(e) {
                    let t = f();
                    return (0, d.isSet)(e.portId) && (t.portId = String(e.portId)), (0, d.isSet)(e.channelId) && (t.channelId = String(e.channelId)), (0, d.isSet)(e.counterpartyChannelId) && (t.counterpartyChannelId = String(e.counterpartyChannelId)), (0, d.isSet)(e.counterpartyVersion) && (t.counterpartyVersion = String(e.counterpartyVersion)), (0, d.isSet)(e.proofTry) && (t.proofTry = (0, d.bytesFromBase64)(e.proofTry)), (0, d.isSet)(e.proofHeight) && (t.proofHeight = a.Height.fromJSON(e.proofHeight)), (0, d.isSet)(e.signer) && (t.signer = String(e.signer)), t
                },
                toJSON(e) {
                    let t = {};
                    return void 0 !== e.portId && (t.portId = e.portId), void 0 !== e.channelId && (t.channelId = e.channelId), void 0 !== e.counterpartyChannelId && (t.counterpartyChannelId = e.counterpartyChannelId), void 0 !== e.counterpartyVersion && (t.counterpartyVersion = e.counterpartyVersion), void 0 !== e.proofTry && (t.proofTry = (0, d.base64FromBytes)(void 0 !== e.proofTry ? e.proofTry : new Uint8Array)), void 0 !== e.proofHeight && (t.proofHeight = e.proofHeight ? a.Height.toJSON(e.proofHeight) : void 0), void 0 !== e.signer && (t.signer = e.signer), t
                },
                fromPartial(e) {
                    let t = f();
                    return t.portId = e.portId ? ? "", t.channelId = e.channelId ? ? "", t.counterpartyChannelId = e.counterpartyChannelId ? ? "", t.counterpartyVersion = e.counterpartyVersion ? ? "", t.proofTry = e.proofTry ? ? new Uint8Array, void 0 !== e.proofHeight && null !== e.proofHeight && (t.proofHeight = a.Height.fromPartial(e.proofHeight)), t.signer = e.signer ? ? "", t
                }
            }, t.MsgChannelOpenAckResponse = {
                typeUrl: "/ibc.core.channel.v1.MsgChannelOpenAckResponse",
                encode: (e, t = s.BinaryWriter.create()) => t,
                decode(e, t) {
                    let r = e instanceof s.BinaryReader ? e : new s.BinaryReader(e),
                        n = void 0 === t ? r.len : r.pos + t;
                    for (; r.pos < n;) {
                        let e = r.uint32();
                        r.skipType(7 & e)
                    }
                    return {}
                },
                fromJSON: e => ({}),
                toJSON: e => ({}),
                fromPartial: e => ({})
            }, t.MsgChannelOpenConfirm = {
                typeUrl: "/ibc.core.channel.v1.MsgChannelOpenConfirm",
                encode: (e, t = s.BinaryWriter.create()) => ("" !== e.portId && t.uint32(10).string(e.portId), "" !== e.channelId && t.uint32(18).string(e.channelId), 0 !== e.proofAck.length && t.uint32(26).bytes(e.proofAck), void 0 !== e.proofHeight && a.Height.encode(e.proofHeight, t.uint32(34).fork()).ldelim(), "" !== e.signer && t.uint32(42).string(e.signer), t),
                decode(e, t) {
                    let r = e instanceof s.BinaryReader ? e : new s.BinaryReader(e),
                        n = void 0 === t ? r.len : r.pos + t,
                        o = y();
                    for (; r.pos < n;) {
                        let e = r.uint32();
                        switch (e >>> 3) {
                            case 1:
                                o.portId = r.string();
                                break;
                            case 2:
                                o.channelId = r.string();
                                break;
                            case 3:
                                o.proofAck = r.bytes();
                                break;
                            case 4:
                                o.proofHeight = a.Height.decode(r, r.uint32());
                                break;
                            case 5:
                                o.signer = r.string();
                                break;
                            default:
                                r.skipType(7 & e)
                        }
                    }
                    return o
                },
                fromJSON(e) {
                    let t = y();
                    return (0, d.isSet)(e.portId) && (t.portId = String(e.portId)), (0, d.isSet)(e.channelId) && (t.channelId = String(e.channelId)), (0, d.isSet)(e.proofAck) && (t.proofAck = (0, d.bytesFromBase64)(e.proofAck)), (0, d.isSet)(e.proofHeight) && (t.proofHeight = a.Height.fromJSON(e.proofHeight)), (0, d.isSet)(e.signer) && (t.signer = String(e.signer)), t
                },
                toJSON(e) {
                    let t = {};
                    return void 0 !== e.portId && (t.portId = e.portId), void 0 !== e.channelId && (t.channelId = e.channelId), void 0 !== e.proofAck && (t.proofAck = (0, d.base64FromBytes)(void 0 !== e.proofAck ? e.proofAck : new Uint8Array)), void 0 !== e.proofHeight && (t.proofHeight = e.proofHeight ? a.Height.toJSON(e.proofHeight) : void 0), void 0 !== e.signer && (t.signer = e.signer), t
                },
                fromPartial(e) {
                    let t = y();
                    return t.portId = e.portId ? ? "", t.channelId = e.channelId ? ? "", t.proofAck = e.proofAck ? ? new Uint8Array, void 0 !== e.proofHeight && null !== e.proofHeight && (t.proofHeight = a.Height.fromPartial(e.proofHeight)), t.signer = e.signer ? ? "", t
                }
            }, t.MsgChannelOpenConfirmResponse = {
                typeUrl: "/ibc.core.channel.v1.MsgChannelOpenConfirmResponse",
                encode: (e, t = s.BinaryWriter.create()) => t,
                decode(e, t) {
                    let r = e instanceof s.BinaryReader ? e : new s.BinaryReader(e),
                        n = void 0 === t ? r.len : r.pos + t;
                    for (; r.pos < n;) {
                        let e = r.uint32();
                        r.skipType(7 & e)
                    }
                    return {}
                },
                fromJSON: e => ({}),
                toJSON: e => ({}),
                fromPartial: e => ({})
            }, t.MsgChannelCloseInit = {
                typeUrl: "/ibc.core.channel.v1.MsgChannelCloseInit",
                encode: (e, t = s.BinaryWriter.create()) => ("" !== e.portId && t.uint32(10).string(e.portId), "" !== e.channelId && t.uint32(18).string(e.channelId), "" !== e.signer && t.uint32(26).string(e.signer), t),
                decode(e, t) {
                    let r = e instanceof s.BinaryReader ? e : new s.BinaryReader(e),
                        n = void 0 === t ? r.len : r.pos + t,
                        o = h();
                    for (; r.pos < n;) {
                        let e = r.uint32();
                        switch (e >>> 3) {
                            case 1:
                                o.portId = r.string();
                                break;
                            case 2:
                                o.channelId = r.string();
                                break;
                            case 3:
                                o.signer = r.string();
                                break;
                            default:
                                r.skipType(7 & e)
                        }
                    }
                    return o
                },
                fromJSON(e) {
                    let t = h();
                    return (0, d.isSet)(e.portId) && (t.portId = String(e.portId)), (0, d.isSet)(e.channelId) && (t.channelId = String(e.channelId)), (0, d.isSet)(e.signer) && (t.signer = String(e.signer)), t
                },
                toJSON(e) {
                    let t = {};
                    return void 0 !== e.portId && (t.portId = e.portId), void 0 !== e.channelId && (t.channelId = e.channelId), void 0 !== e.signer && (t.signer = e.signer), t
                },
                fromPartial(e) {
                    let t = h();
                    return t.portId = e.portId ? ? "", t.channelId = e.channelId ? ? "", t.signer = e.signer ? ? "", t
                }
            }, t.MsgChannelCloseInitResponse = {
                typeUrl: "/ibc.core.channel.v1.MsgChannelCloseInitResponse",
                encode: (e, t = s.BinaryWriter.create()) => t,
                decode(e, t) {
                    let r = e instanceof s.BinaryReader ? e : new s.BinaryReader(e),
                        n = void 0 === t ? r.len : r.pos + t;
                    for (; r.pos < n;) {
                        let e = r.uint32();
                        r.skipType(7 & e)
                    }
                    return {}
                },
                fromJSON: e => ({}),
                toJSON: e => ({}),
                fromPartial: e => ({})
            }, t.MsgChannelCloseConfirm = {
                typeUrl: "/ibc.core.channel.v1.MsgChannelCloseConfirm",
                encode: (e, t = s.BinaryWriter.create()) => ("" !== e.portId && t.uint32(10).string(e.portId), "" !== e.channelId && t.uint32(18).string(e.channelId), 0 !== e.proofInit.length && t.uint32(26).bytes(e.proofInit), void 0 !== e.proofHeight && a.Height.encode(e.proofHeight, t.uint32(34).fork()).ldelim(), "" !== e.signer && t.uint32(42).string(e.signer), t),
                decode(e, t) {
                    let r = e instanceof s.BinaryReader ? e : new s.BinaryReader(e),
                        n = void 0 === t ? r.len : r.pos + t,
                        o = v();
                    for (; r.pos < n;) {
                        let e = r.uint32();
                        switch (e >>> 3) {
                            case 1:
                                o.portId = r.string();
                                break;
                            case 2:
                                o.channelId = r.string();
                                break;
                            case 3:
                                o.proofInit = r.bytes();
                                break;
                            case 4:
                                o.proofHeight = a.Height.decode(r, r.uint32());
                                break;
                            case 5:
                                o.signer = r.string();
                                break;
                            default:
                                r.skipType(7 & e)
                        }
                    }
                    return o
                },
                fromJSON(e) {
                    let t = v();
                    return (0, d.isSet)(e.portId) && (t.portId = String(e.portId)), (0, d.isSet)(e.channelId) && (t.channelId = String(e.channelId)), (0, d.isSet)(e.proofInit) && (t.proofInit = (0, d.bytesFromBase64)(e.proofInit)), (0, d.isSet)(e.proofHeight) && (t.proofHeight = a.Height.fromJSON(e.proofHeight)), (0, d.isSet)(e.signer) && (t.signer = String(e.signer)), t
                },
                toJSON(e) {
                    let t = {};
                    return void 0 !== e.portId && (t.portId = e.portId), void 0 !== e.channelId && (t.channelId = e.channelId), void 0 !== e.proofInit && (t.proofInit = (0, d.base64FromBytes)(void 0 !== e.proofInit ? e.proofInit : new Uint8Array)), void 0 !== e.proofHeight && (t.proofHeight = e.proofHeight ? a.Height.toJSON(e.proofHeight) : void 0), void 0 !== e.signer && (t.signer = e.signer), t
                },
                fromPartial(e) {
                    let t = v();
                    return t.portId = e.portId ? ? "", t.channelId = e.channelId ? ? "", t.proofInit = e.proofInit ? ? new Uint8Array, void 0 !== e.proofHeight && null !== e.proofHeight && (t.proofHeight = a.Height.fromPartial(e.proofHeight)), t.signer = e.signer ? ? "", t
                }
            }, t.MsgChannelCloseConfirmResponse = {
                typeUrl: "/ibc.core.channel.v1.MsgChannelCloseConfirmResponse",
                encode: (e, t = s.BinaryWriter.create()) => t,
                decode(e, t) {
                    let r = e instanceof s.BinaryReader ? e : new s.BinaryReader(e),
                        n = void 0 === t ? r.len : r.pos + t;
                    for (; r.pos < n;) {
                        let e = r.uint32();
                        r.skipType(7 & e)
                    }
                    return {}
                },
                fromJSON: e => ({}),
                toJSON: e => ({}),
                fromPartial: e => ({})
            }, t.MsgRecvPacket = {
                typeUrl: "/ibc.core.channel.v1.MsgRecvPacket",
                encode: (e, t = s.BinaryWriter.create()) => (void 0 !== e.packet && i.Packet.encode(e.packet, t.uint32(10).fork()).ldelim(), 0 !== e.proofCommitment.length && t.uint32(18).bytes(e.proofCommitment), void 0 !== e.proofHeight && a.Height.encode(e.proofHeight, t.uint32(26).fork()).ldelim(), "" !== e.signer && t.uint32(34).string(e.signer), t),
                decode(e, t) {
                    let r = e instanceof s.BinaryReader ? e : new s.BinaryReader(e),
                        n = void 0 === t ? r.len : r.pos + t,
                        o = b();
                    for (; r.pos < n;) {
                        let e = r.uint32();
                        switch (e >>> 3) {
                            case 1:
                                o.packet = i.Packet.decode(r, r.uint32());
                                break;
                            case 2:
                                o.proofCommitment = r.bytes();
                                break;
                            case 3:
                                o.proofHeight = a.Height.decode(r, r.uint32());
                                break;
                            case 4:
                                o.signer = r.string();
                                break;
                            default:
                                r.skipType(7 & e)
                        }
                    }
                    return o
                },
                fromJSON(e) {
                    let t = b();
                    return (0, d.isSet)(e.packet) && (t.packet = i.Packet.fromJSON(e.packet)), (0, d.isSet)(e.proofCommitment) && (t.proofCommitment = (0, d.bytesFromBase64)(e.proofCommitment)), (0, d.isSet)(e.proofHeight) && (t.proofHeight = a.Height.fromJSON(e.proofHeight)), (0, d.isSet)(e.signer) && (t.signer = String(e.signer)), t
                },
                toJSON(e) {
                    let t = {};
                    return void 0 !== e.packet && (t.packet = e.packet ? i.Packet.toJSON(e.packet) : void 0), void 0 !== e.proofCommitment && (t.proofCommitment = (0, d.base64FromBytes)(void 0 !== e.proofCommitment ? e.proofCommitment : new Uint8Array)), void 0 !== e.proofHeight && (t.proofHeight = e.proofHeight ? a.Height.toJSON(e.proofHeight) : void 0), void 0 !== e.signer && (t.signer = e.signer), t
                },
                fromPartial(e) {
                    let t = b();
                    return void 0 !== e.packet && null !== e.packet && (t.packet = i.Packet.fromPartial(e.packet)), t.proofCommitment = e.proofCommitment ? ? new Uint8Array, void 0 !== e.proofHeight && null !== e.proofHeight && (t.proofHeight = a.Height.fromPartial(e.proofHeight)), t.signer = e.signer ? ? "", t
                }
            }, t.MsgRecvPacketResponse = {
                typeUrl: "/ibc.core.channel.v1.MsgRecvPacketResponse",
                encode: (e, t = s.BinaryWriter.create()) => (0 !== e.result && t.uint32(8).int32(e.result), t),
                decode(e, t) {
                    let r = e instanceof s.BinaryReader ? e : new s.BinaryReader(e),
                        n = void 0 === t ? r.len : r.pos + t,
                        o = S();
                    for (; r.pos < n;) {
                        let e = r.uint32();
                        e >>> 3 == 1 ? o.result = r.int32() : r.skipType(7 & e)
                    }
                    return o
                },
                fromJSON(e) {
                    let t = S();
                    return (0, d.isSet)(e.result) && (t.result = c(e.result)), t
                },
                toJSON(e) {
                    let t = {};
                    return void 0 !== e.result && (t.result = l(e.result)), t
                },
                fromPartial(e) {
                    let t = S();
                    return t.result = e.result ? ? 0, t
                }
            }, t.MsgTimeout = {
                typeUrl: "/ibc.core.channel.v1.MsgTimeout",
                encode: (e, t = s.BinaryWriter.create()) => (void 0 !== e.packet && i.Packet.encode(e.packet, t.uint32(10).fork()).ldelim(), 0 !== e.proofUnreceived.length && t.uint32(18).bytes(e.proofUnreceived), void 0 !== e.proofHeight && a.Height.encode(e.proofHeight, t.uint32(26).fork()).ldelim(), e.nextSequenceRecv !== BigInt(0) && t.uint32(32).uint64(e.nextSequenceRecv), "" !== e.signer && t.uint32(42).string(e.signer), t),
                decode(e, t) {
                    let r = e instanceof s.BinaryReader ? e : new s.BinaryReader(e),
                        n = void 0 === t ? r.len : r.pos + t,
                        o = k();
                    for (; r.pos < n;) {
                        let e = r.uint32();
                        switch (e >>> 3) {
                            case 1:
                                o.packet = i.Packet.decode(r, r.uint32());
                                break;
                            case 2:
                                o.proofUnreceived = r.bytes();
                                break;
                            case 3:
                                o.proofHeight = a.Height.decode(r, r.uint32());
                                break;
                            case 4:
                                o.nextSequenceRecv = r.uint64();
                                break;
                            case 5:
                                o.signer = r.string();
                                break;
                            default:
                                r.skipType(7 & e)
                        }
                    }
                    return o
                },
                fromJSON(e) {
                    let t = k();
                    return (0, d.isSet)(e.packet) && (t.packet = i.Packet.fromJSON(e.packet)), (0, d.isSet)(e.proofUnreceived) && (t.proofUnreceived = (0, d.bytesFromBase64)(e.proofUnreceived)), (0, d.isSet)(e.proofHeight) && (t.proofHeight = a.Height.fromJSON(e.proofHeight)), (0, d.isSet)(e.nextSequenceRecv) && (t.nextSequenceRecv = BigInt(e.nextSequenceRecv.toString())), (0, d.isSet)(e.signer) && (t.signer = String(e.signer)), t
                },
                toJSON(e) {
                    let t = {};
                    return void 0 !== e.packet && (t.packet = e.packet ? i.Packet.toJSON(e.packet) : void 0), void 0 !== e.proofUnreceived && (t.proofUnreceived = (0, d.base64FromBytes)(void 0 !== e.proofUnreceived ? e.proofUnreceived : new Uint8Array)), void 0 !== e.proofHeight && (t.proofHeight = e.proofHeight ? a.Height.toJSON(e.proofHeight) : void 0), void 0 !== e.nextSequenceRecv && (t.nextSequenceRecv = (e.nextSequenceRecv || BigInt(0)).toString()), void 0 !== e.signer && (t.signer = e.signer), t
                },
                fromPartial(e) {
                    let t = k();
                    return void 0 !== e.packet && null !== e.packet && (t.packet = i.Packet.fromPartial(e.packet)), t.proofUnreceived = e.proofUnreceived ? ? new Uint8Array, void 0 !== e.proofHeight && null !== e.proofHeight && (t.proofHeight = a.Height.fromPartial(e.proofHeight)), void 0 !== e.nextSequenceRecv && null !== e.nextSequenceRecv && (t.nextSequenceRecv = BigInt(e.nextSequenceRecv.toString())), t.signer = e.signer ? ? "", t
                }
            }, t.MsgTimeoutResponse = {
                typeUrl: "/ibc.core.channel.v1.MsgTimeoutResponse",
                encode: (e, t = s.BinaryWriter.create()) => (0 !== e.result && t.uint32(8).int32(e.result), t),
                decode(e, t) {
                    let r = e instanceof s.BinaryReader ? e : new s.BinaryReader(e),
                        n = void 0 === t ? r.len : r.pos + t,
                        o = P();
                    for (; r.pos < n;) {
                        let e = r.uint32();
                        e >>> 3 == 1 ? o.result = r.int32() : r.skipType(7 & e)
                    }
                    return o
                },
                fromJSON(e) {
                    let t = P();
                    return (0, d.isSet)(e.result) && (t.result = c(e.result)), t
                },
                toJSON(e) {
                    let t = {};
                    return void 0 !== e.result && (t.result = l(e.result)), t
                },
                fromPartial(e) {
                    let t = P();
                    return t.result = e.result ? ? 0, t
                }
            }, t.MsgTimeoutOnClose = {
                typeUrl: "/ibc.core.channel.v1.MsgTimeoutOnClose",
                encode: (e, t = s.BinaryWriter.create()) => (void 0 !== e.packet && i.Packet.encode(e.packet, t.uint32(10).fork()).ldelim(), 0 !== e.proofUnreceived.length && t.uint32(18).bytes(e.proofUnreceived), 0 !== e.proofClose.length && t.uint32(26).bytes(e.proofClose), void 0 !== e.proofHeight && a.Height.encode(e.proofHeight, t.uint32(34).fork()).ldelim(), e.nextSequenceRecv !== BigInt(0) && t.uint32(40).uint64(e.nextSequenceRecv), "" !== e.signer && t.uint32(50).string(e.signer), t),
                decode(e, t) {
                    let r = e instanceof s.BinaryReader ? e : new s.BinaryReader(e),
                        n = void 0 === t ? r.len : r.pos + t,
                        o = _();
                    for (; r.pos < n;) {
                        let e = r.uint32();
                        switch (e >>> 3) {
                            case 1:
                                o.packet = i.Packet.decode(r, r.uint32());
                                break;
                            case 2:
                                o.proofUnreceived = r.bytes();
                                break;
                            case 3:
                                o.proofClose = r.bytes();
                                break;
                            case 4:
                                o.proofHeight = a.Height.decode(r, r.uint32());
                                break;
                            case 5:
                                o.nextSequenceRecv = r.uint64();
                                break;
                            case 6:
                                o.signer = r.string();
                                break;
                            default:
                                r.skipType(7 & e)
                        }
                    }
                    return o
                },
                fromJSON(e) {
                    let t = _();
                    return (0, d.isSet)(e.packet) && (t.packet = i.Packet.fromJSON(e.packet)), (0, d.isSet)(e.proofUnreceived) && (t.proofUnreceived = (0, d.bytesFromBase64)(e.proofUnreceived)), (0, d.isSet)(e.proofClose) && (t.proofClose = (0, d.bytesFromBase64)(e.proofClose)), (0, d.isSet)(e.proofHeight) && (t.proofHeight = a.Height.fromJSON(e.proofHeight)), (0, d.isSet)(e.nextSequenceRecv) && (t.nextSequenceRecv = BigInt(e.nextSequenceRecv.toString())), (0, d.isSet)(e.signer) && (t.signer = String(e.signer)), t
                },
                toJSON(e) {
                    let t = {};
                    return void 0 !== e.packet && (t.packet = e.packet ? i.Packet.toJSON(e.packet) : void 0), void 0 !== e.proofUnreceived && (t.proofUnreceived = (0, d.base64FromBytes)(void 0 !== e.proofUnreceived ? e.proofUnreceived : new Uint8Array)), void 0 !== e.proofClose && (t.proofClose = (0, d.base64FromBytes)(void 0 !== e.proofClose ? e.proofClose : new Uint8Array)), void 0 !== e.proofHeight && (t.proofHeight = e.proofHeight ? a.Height.toJSON(e.proofHeight) : void 0), void 0 !== e.nextSequenceRecv && (t.nextSequenceRecv = (e.nextSequenceRecv || BigInt(0)).toString()), void 0 !== e.signer && (t.signer = e.signer), t
                },
                fromPartial(e) {
                    let t = _();
                    return void 0 !== e.packet && null !== e.packet && (t.packet = i.Packet.fromPartial(e.packet)), t.proofUnreceived = e.proofUnreceived ? ? new Uint8Array, t.proofClose = e.proofClose ? ? new Uint8Array, void 0 !== e.proofHeight && null !== e.proofHeight && (t.proofHeight = a.Height.fromPartial(e.proofHeight)), void 0 !== e.nextSequenceRecv && null !== e.nextSequenceRecv && (t.nextSequenceRecv = BigInt(e.nextSequenceRecv.toString())), t.signer = e.signer ? ? "", t
                }
            }, t.MsgTimeoutOnCloseResponse = {
                typeUrl: "/ibc.core.channel.v1.MsgTimeoutOnCloseResponse",
                encode: (e, t = s.BinaryWriter.create()) => (0 !== e.result && t.uint32(8).int32(e.result), t),
                decode(e, t) {
                    let r = e instanceof s.BinaryReader ? e : new s.BinaryReader(e),
                        n = void 0 === t ? r.len : r.pos + t,
                        o = B();
                    for (; r.pos < n;) {
                        let e = r.uint32();
                        e >>> 3 == 1 ? o.result = r.int32() : r.skipType(7 & e)
                    }
                    return o
                },
                fromJSON(e) {
                    let t = B();
                    return (0, d.isSet)(e.result) && (t.result = c(e.result)), t
                },
                toJSON(e) {
                    let t = {};
                    return void 0 !== e.result && (t.result = l(e.result)), t
                },
                fromPartial(e) {
                    let t = B();
                    return t.result = e.result ? ? 0, t
                }
            }, t.MsgAcknowledgement = {
                typeUrl: "/ibc.core.channel.v1.MsgAcknowledgement",
                encode: (e, t = s.BinaryWriter.create()) => (void 0 !== e.packet && i.Packet.encode(e.packet, t.uint32(10).fork()).ldelim(), 0 !== e.acknowledgement.length && t.uint32(18).bytes(e.acknowledgement), 0 !== e.proofAcked.length && t.uint32(26).bytes(e.proofAcked), void 0 !== e.proofHeight && a.Height.encode(e.proofHeight, t.uint32(34).fork()).ldelim(), "" !== e.signer && t.uint32(42).string(e.signer), t),
                decode(e, t) {
                    let r = e instanceof s.BinaryReader ? e : new s.BinaryReader(e),
                        n = void 0 === t ? r.len : r.pos + t,
                        o = O();
                    for (; r.pos < n;) {
                        let e = r.uint32();
                        switch (e >>> 3) {
                            case 1:
                                o.packet = i.Packet.decode(r, r.uint32());
                                break;
                            case 2:
                                o.acknowledgement = r.bytes();
                                break;
                            case 3:
                                o.proofAcked = r.bytes();
                                break;
                            case 4:
                                o.proofHeight = a.Height.decode(r, r.uint32());
                                break;
                            case 5:
                                o.signer = r.string();
                                break;
                            default:
                                r.skipType(7 & e)
                        }
                    }
                    return o
                },
                fromJSON(e) {
                    let t = O();
                    return (0, d.isSet)(e.packet) && (t.packet = i.Packet.fromJSON(e.packet)), (0, d.isSet)(e.acknowledgement) && (t.acknowledgement = (0, d.bytesFromBase64)(e.acknowledgement)), (0, d.isSet)(e.proofAcked) && (t.proofAcked = (0, d.bytesFromBase64)(e.proofAcked)), (0, d.isSet)(e.proofHeight) && (t.proofHeight = a.Height.fromJSON(e.proofHeight)), (0, d.isSet)(e.signer) && (t.signer = String(e.signer)), t
                },
                toJSON(e) {
                    let t = {};
                    return void 0 !== e.packet && (t.packet = e.packet ? i.Packet.toJSON(e.packet) : void 0), void 0 !== e.acknowledgement && (t.acknowledgement = (0, d.base64FromBytes)(void 0 !== e.acknowledgement ? e.acknowledgement : new Uint8Array)), void 0 !== e.proofAcked && (t.proofAcked = (0, d.base64FromBytes)(void 0 !== e.proofAcked ? e.proofAcked : new Uint8Array)), void 0 !== e.proofHeight && (t.proofHeight = e.proofHeight ? a.Height.toJSON(e.proofHeight) : void 0), void 0 !== e.signer && (t.signer = e.signer), t
                },
                fromPartial(e) {
                    let t = O();
                    return void 0 !== e.packet && null !== e.packet && (t.packet = i.Packet.fromPartial(e.packet)), t.acknowledgement = e.acknowledgement ? ? new Uint8Array, t.proofAcked = e.proofAcked ? ? new Uint8Array, void 0 !== e.proofHeight && null !== e.proofHeight && (t.proofHeight = a.Height.fromPartial(e.proofHeight)), t.signer = e.signer ? ? "", t
                }
            }, t.MsgAcknowledgementResponse = {
                typeUrl: "/ibc.core.channel.v1.MsgAcknowledgementResponse",
                encode: (e, t = s.BinaryWriter.create()) => (0 !== e.result && t.uint32(8).int32(e.result), t),
                decode(e, t) {
                    let r = e instanceof s.BinaryReader ? e : new s.BinaryReader(e),
                        n = void 0 === t ? r.len : r.pos + t,
                        o = R();
                    for (; r.pos < n;) {
                        let e = r.uint32();
                        e >>> 3 == 1 ? o.result = r.int32() : r.skipType(7 & e)
                    }
                    return o
                },
                fromJSON(e) {
                    let t = R();
                    return (0, d.isSet)(e.result) && (t.result = c(e.result)), t
                },
                toJSON(e) {
                    let t = {};
                    return void 0 !== e.result && (t.result = l(e.result)), t
                },
                fromPartial(e) {
                    let t = R();
                    return t.result = e.result ? ? 0, t
                }
            };
            class A {
                constructor(e) {
                    this.rpc = e, this.ChannelOpenInit = this.ChannelOpenInit.bind(this), this.ChannelOpenTry = this.ChannelOpenTry.bind(this), this.ChannelOpenAck = this.ChannelOpenAck.bind(this), this.ChannelOpenConfirm = this.ChannelOpenConfirm.bind(this), this.ChannelCloseInit = this.ChannelCloseInit.bind(this), this.ChannelCloseConfirm = this.ChannelCloseConfirm.bind(this), this.RecvPacket = this.RecvPacket.bind(this), this.Timeout = this.Timeout.bind(this), this.TimeoutOnClose = this.TimeoutOnClose.bind(this), this.Acknowledgement = this.Acknowledgement.bind(this)
                }
                ChannelOpenInit(e) {
                    let r = t.MsgChannelOpenInit.encode(e).finish();
                    return this.rpc.request("ibc.core.channel.v1.Msg", "ChannelOpenInit", r).then(e => t.MsgChannelOpenInitResponse.decode(new s.BinaryReader(e)))
                }
                ChannelOpenTry(e) {
                    let r = t.MsgChannelOpenTry.encode(e).finish();
                    return this.rpc.request("ibc.core.channel.v1.Msg", "ChannelOpenTry", r).then(e => t.MsgChannelOpenTryResponse.decode(new s.BinaryReader(e)))
                }
                ChannelOpenAck(e) {
                    let r = t.MsgChannelOpenAck.encode(e).finish();
                    return this.rpc.request("ibc.core.channel.v1.Msg", "ChannelOpenAck", r).then(e => t.MsgChannelOpenAckResponse.decode(new s.BinaryReader(e)))
                }
                ChannelOpenConfirm(e) {
                    let r = t.MsgChannelOpenConfirm.encode(e).finish();
                    return this.rpc.request("ibc.core.channel.v1.Msg", "ChannelOpenConfirm", r).then(e => t.MsgChannelOpenConfirmResponse.decode(new s.BinaryReader(e)))
                }
                ChannelCloseInit(e) {
                    let r = t.MsgChannelCloseInit.encode(e).finish();
                    return this.rpc.request("ibc.core.channel.v1.Msg", "ChannelCloseInit", r).then(e => t.MsgChannelCloseInitResponse.decode(new s.BinaryReader(e)))
                }
                ChannelCloseConfirm(e) {
                    let r = t.MsgChannelCloseConfirm.encode(e).finish();
                    return this.rpc.request("ibc.core.channel.v1.Msg", "ChannelCloseConfirm", r).then(e => t.MsgChannelCloseConfirmResponse.decode(new s.BinaryReader(e)))
                }
                RecvPacket(e) {
                    let r = t.MsgRecvPacket.encode(e).finish();
                    return this.rpc.request("ibc.core.channel.v1.Msg", "RecvPacket", r).then(e => t.MsgRecvPacketResponse.decode(new s.BinaryReader(e)))
                }
                Timeout(e) {
                    let r = t.MsgTimeout.encode(e).finish();
                    return this.rpc.request("ibc.core.channel.v1.Msg", "Timeout", r).then(e => t.MsgTimeoutResponse.decode(new s.BinaryReader(e)))
                }
                TimeoutOnClose(e) {
                    let r = t.MsgTimeoutOnClose.encode(e).finish();
                    return this.rpc.request("ibc.core.channel.v1.Msg", "TimeoutOnClose", r).then(e => t.MsgTimeoutOnCloseResponse.decode(new s.BinaryReader(e)))
                }
                Acknowledgement(e) {
                    let r = t.MsgAcknowledgement.encode(e).finish();
                    return this.rpc.request("ibc.core.channel.v1.Msg", "Acknowledgement", r).then(e => t.MsgAcknowledgementResponse.decode(new s.BinaryReader(e)))
                }
            }
            t.MsgClientImpl = A
        },
        24648: function(e, t, r) {
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: !0
            }), t.Params = t.Height = t.UpgradeProposal = t.ClientUpdateProposal = t.ClientConsensusStates = t.ConsensusStateWithHeight = t.IdentifiedClientState = t.protobufPackage = void 0;
            let n = r(65676),
                o = r(47256),
                i = r(28486),
                a = r(6476);

            function s() {
                return {
                    clientId: "",
                    clientState: void 0
                }
            }

            function d() {
                return {
                    height: t.Height.fromPartial({}),
                    consensusState: void 0
                }
            }

            function c() {
                return {
                    clientId: "",
                    consensusStates: []
                }
            }

            function l() {
                return {
                    title: "",
                    description: "",
                    subjectClientId: "",
                    substituteClientId: ""
                }
            }

            function u() {
                return {
                    title: "",
                    description: "",
                    plan: o.Plan.fromPartial({}),
                    upgradedClientState: void 0
                }
            }

            function p() {
                return {
                    revisionNumber: BigInt(0),
                    revisionHeight: BigInt(0)
                }
            }

            function m() {
                return {
                    allowedClients: []
                }
            }
            t.protobufPackage = "ibc.core.client.v1", t.IdentifiedClientState = {
                typeUrl: "/ibc.core.client.v1.IdentifiedClientState",
                encode: (e, t = i.BinaryWriter.create()) => ("" !== e.clientId && t.uint32(10).string(e.clientId), void 0 !== e.clientState && n.Any.encode(e.clientState, t.uint32(18).fork()).ldelim(), t),
                decode(e, t) {
                    let r = e instanceof i.BinaryReader ? e : new i.BinaryReader(e),
                        o = void 0 === t ? r.len : r.pos + t,
                        a = s();
                    for (; r.pos < o;) {
                        let e = r.uint32();
                        switch (e >>> 3) {
                            case 1:
                                a.clientId = r.string();
                                break;
                            case 2:
                                a.clientState = n.Any.decode(r, r.uint32());
                                break;
                            default:
                                r.skipType(7 & e)
                        }
                    }
                    return a
                },
                fromJSON(e) {
                    let t = s();
                    return (0, a.isSet)(e.clientId) && (t.clientId = String(e.clientId)), (0, a.isSet)(e.clientState) && (t.clientState = n.Any.fromJSON(e.clientState)), t
                },
                toJSON(e) {
                    let t = {};
                    return void 0 !== e.clientId && (t.clientId = e.clientId), void 0 !== e.clientState && (t.clientState = e.clientState ? n.Any.toJSON(e.clientState) : void 0), t
                },
                fromPartial(e) {
                    let t = s();
                    return t.clientId = e.clientId ? ? "", void 0 !== e.clientState && null !== e.clientState && (t.clientState = n.Any.fromPartial(e.clientState)), t
                }
            }, t.ConsensusStateWithHeight = {
                typeUrl: "/ibc.core.client.v1.ConsensusStateWithHeight",
                encode: (e, r = i.BinaryWriter.create()) => (void 0 !== e.height && t.Height.encode(e.height, r.uint32(10).fork()).ldelim(), void 0 !== e.consensusState && n.Any.encode(e.consensusState, r.uint32(18).fork()).ldelim(), r),
                decode(e, r) {
                    let o = e instanceof i.BinaryReader ? e : new i.BinaryReader(e),
                        a = void 0 === r ? o.len : o.pos + r,
                        s = d();
                    for (; o.pos < a;) {
                        let e = o.uint32();
                        switch (e >>> 3) {
                            case 1:
                                s.height = t.Height.decode(o, o.uint32());
                                break;
                            case 2:
                                s.consensusState = n.Any.decode(o, o.uint32());
                                break;
                            default:
                                o.skipType(7 & e)
                        }
                    }
                    return s
                },
                fromJSON(e) {
                    let r = d();
                    return (0, a.isSet)(e.height) && (r.height = t.Height.fromJSON(e.height)), (0, a.isSet)(e.consensusState) && (r.consensusState = n.Any.fromJSON(e.consensusState)), r
                },
                toJSON(e) {
                    let r = {};
                    return void 0 !== e.height && (r.height = e.height ? t.Height.toJSON(e.height) : void 0), void 0 !== e.consensusState && (r.consensusState = e.consensusState ? n.Any.toJSON(e.consensusState) : void 0), r
                },
                fromPartial(e) {
                    let r = d();
                    return void 0 !== e.height && null !== e.height && (r.height = t.Height.fromPartial(e.height)), void 0 !== e.consensusState && null !== e.consensusState && (r.consensusState = n.Any.fromPartial(e.consensusState)), r
                }
            }, t.ClientConsensusStates = {
                typeUrl: "/ibc.core.client.v1.ClientConsensusStates",
                encode(e, r = i.BinaryWriter.create()) {
                    for (let n of ("" !== e.clientId && r.uint32(10).string(e.clientId), e.consensusStates)) t.ConsensusStateWithHeight.encode(n, r.uint32(18).fork()).ldelim();
                    return r
                },
                decode(e, r) {
                    let n = e instanceof i.BinaryReader ? e : new i.BinaryReader(e),
                        o = void 0 === r ? n.len : n.pos + r,
                        a = c();
                    for (; n.pos < o;) {
                        let e = n.uint32();
                        switch (e >>> 3) {
                            case 1:
                                a.clientId = n.string();
                                break;
                            case 2:
                                a.consensusStates.push(t.ConsensusStateWithHeight.decode(n, n.uint32()));
                                break;
                            default:
                                n.skipType(7 & e)
                        }
                    }
                    return a
                },
                fromJSON(e) {
                    let r = c();
                    return (0, a.isSet)(e.clientId) && (r.clientId = String(e.clientId)), Array.isArray(e ? .consensusStates) && (r.consensusStates = e.consensusStates.map(e => t.ConsensusStateWithHeight.fromJSON(e))), r
                },
                toJSON(e) {
                    let r = {};
                    return void 0 !== e.clientId && (r.clientId = e.clientId), e.consensusStates ? r.consensusStates = e.consensusStates.map(e => e ? t.ConsensusStateWithHeight.toJSON(e) : void 0) : r.consensusStates = [], r
                },
                fromPartial(e) {
                    let r = c();
                    return r.clientId = e.clientId ? ? "", r.consensusStates = e.consensusStates ? .map(e => t.ConsensusStateWithHeight.fromPartial(e)) || [], r
                }
            }, t.ClientUpdateProposal = {
                typeUrl: "/ibc.core.client.v1.ClientUpdateProposal",
                encode: (e, t = i.BinaryWriter.create()) => ("" !== e.title && t.uint32(10).string(e.title), "" !== e.description && t.uint32(18).string(e.description), "" !== e.subjectClientId && t.uint32(26).string(e.subjectClientId), "" !== e.substituteClientId && t.uint32(34).string(e.substituteClientId), t),
                decode(e, t) {
                    let r = e instanceof i.BinaryReader ? e : new i.BinaryReader(e),
                        n = void 0 === t ? r.len : r.pos + t,
                        o = l();
                    for (; r.pos < n;) {
                        let e = r.uint32();
                        switch (e >>> 3) {
                            case 1:
                                o.title = r.string();
                                break;
                            case 2:
                                o.description = r.string();
                                break;
                            case 3:
                                o.subjectClientId = r.string();
                                break;
                            case 4:
                                o.substituteClientId = r.string();
                                break;
                            default:
                                r.skipType(7 & e)
                        }
                    }
                    return o
                },
                fromJSON(e) {
                    let t = l();
                    return (0, a.isSet)(e.title) && (t.title = String(e.title)), (0, a.isSet)(e.description) && (t.description = String(e.description)), (0, a.isSet)(e.subjectClientId) && (t.subjectClientId = String(e.subjectClientId)), (0, a.isSet)(e.substituteClientId) && (t.substituteClientId = String(e.substituteClientId)), t
                },
                toJSON(e) {
                    let t = {};
                    return void 0 !== e.title && (t.title = e.title), void 0 !== e.description && (t.description = e.description), void 0 !== e.subjectClientId && (t.subjectClientId = e.subjectClientId), void 0 !== e.substituteClientId && (t.substituteClientId = e.substituteClientId), t
                },
                fromPartial(e) {
                    let t = l();
                    return t.title = e.title ? ? "", t.description = e.description ? ? "", t.subjectClientId = e.subjectClientId ? ? "", t.substituteClientId = e.substituteClientId ? ? "", t
                }
            }, t.UpgradeProposal = {
                typeUrl: "/ibc.core.client.v1.UpgradeProposal",
                encode: (e, t = i.BinaryWriter.create()) => ("" !== e.title && t.uint32(10).string(e.title), "" !== e.description && t.uint32(18).string(e.description), void 0 !== e.plan && o.Plan.encode(e.plan, t.uint32(26).fork()).ldelim(), void 0 !== e.upgradedClientState && n.Any.encode(e.upgradedClientState, t.uint32(34).fork()).ldelim(), t),
                decode(e, t) {
                    let r = e instanceof i.BinaryReader ? e : new i.BinaryReader(e),
                        a = void 0 === t ? r.len : r.pos + t,
                        s = u();
                    for (; r.pos < a;) {
                        let e = r.uint32();
                        switch (e >>> 3) {
                            case 1:
                                s.title = r.string();
                                break;
                            case 2:
                                s.description = r.string();
                                break;
                            case 3:
                                s.plan = o.Plan.decode(r, r.uint32());
                                break;
                            case 4:
                                s.upgradedClientState = n.Any.decode(r, r.uint32());
                                break;
                            default:
                                r.skipType(7 & e)
                        }
                    }
                    return s
                },
                fromJSON(e) {
                    let t = u();
                    return (0, a.isSet)(e.title) && (t.title = String(e.title)), (0, a.isSet)(e.description) && (t.description = String(e.description)), (0, a.isSet)(e.plan) && (t.plan = o.Plan.fromJSON(e.plan)), (0, a.isSet)(e.upgradedClientState) && (t.upgradedClientState = n.Any.fromJSON(e.upgradedClientState)), t
                },
                toJSON(e) {
                    let t = {};
                    return void 0 !== e.title && (t.title = e.title), void 0 !== e.description && (t.description = e.description), void 0 !== e.plan && (t.plan = e.plan ? o.Plan.toJSON(e.plan) : void 0), void 0 !== e.upgradedClientState && (t.upgradedClientState = e.upgradedClientState ? n.Any.toJSON(e.upgradedClientState) : void 0), t
                },
                fromPartial(e) {
                    let t = u();
                    return t.title = e.title ? ? "", t.description = e.description ? ? "", void 0 !== e.plan && null !== e.plan && (t.plan = o.Plan.fromPartial(e.plan)), void 0 !== e.upgradedClientState && null !== e.upgradedClientState && (t.upgradedClientState = n.Any.fromPartial(e.upgradedClientState)), t
                }
            }, t.Height = {
                typeUrl: "/ibc.core.client.v1.Height",
                encode: (e, t = i.BinaryWriter.create()) => (e.revisionNumber !== BigInt(0) && t.uint32(8).uint64(e.revisionNumber), e.revisionHeight !== BigInt(0) && t.uint32(16).uint64(e.revisionHeight), t),
                decode(e, t) {
                    let r = e instanceof i.BinaryReader ? e : new i.BinaryReader(e),
                        n = void 0 === t ? r.len : r.pos + t,
                        o = p();
                    for (; r.pos < n;) {
                        let e = r.uint32();
                        switch (e >>> 3) {
                            case 1:
                                o.revisionNumber = r.uint64();
                                break;
                            case 2:
                                o.revisionHeight = r.uint64();
                                break;
                            default:
                                r.skipType(7 & e)
                        }
                    }
                    return o
                },
                fromJSON(e) {
                    let t = p();
                    return (0, a.isSet)(e.revisionNumber) && (t.revisionNumber = BigInt(e.revisionNumber.toString())), (0, a.isSet)(e.revisionHeight) && (t.revisionHeight = BigInt(e.revisionHeight.toString())), t
                },
                toJSON(e) {
                    let t = {};
                    return void 0 !== e.revisionNumber && (t.revisionNumber = (e.revisionNumber || BigInt(0)).toString()), void 0 !== e.revisionHeight && (t.revisionHeight = (e.revisionHeight || BigInt(0)).toString()), t
                },
                fromPartial(e) {
                    let t = p();
                    return void 0 !== e.revisionNumber && null !== e.revisionNumber && (t.revisionNumber = BigInt(e.revisionNumber.toString())), void 0 !== e.revisionHeight && null !== e.revisionHeight && (t.revisionHeight = BigInt(e.revisionHeight.toString())), t
                }
            }, t.Params = {
                typeUrl: "/ibc.core.client.v1.Params",
                encode(e, t = i.BinaryWriter.create()) {
                    for (let r of e.allowedClients) t.uint32(10).string(r);
                    return t
                },
                decode(e, t) {
                    let r = e instanceof i.BinaryReader ? e : new i.BinaryReader(e),
                        n = void 0 === t ? r.len : r.pos + t,
                        o = m();
                    for (; r.pos < n;) {
                        let e = r.uint32();
                        e >>> 3 == 1 ? o.allowedClients.push(r.string()) : r.skipType(7 & e)
                    }
                    return o
                },
                fromJSON(e) {
                    let t = m();
                    return Array.isArray(e ? .allowedClients) && (t.allowedClients = e.allowedClients.map(e => String(e))), t
                },
                toJSON(e) {
                    let t = {};
                    return e.allowedClients ? t.allowedClients = e.allowedClients.map(e => e) : t.allowedClients = [], t
                },
                fromPartial(e) {
                    let t = m();
                    return t.allowedClients = e.allowedClients ? .map(e => e) || [], t
                }
            }
        },
        59046: function(e, t, r) {
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: !0
            }), t.QueryClientImpl = t.QueryUpgradedConsensusStateResponse = t.QueryUpgradedConsensusStateRequest = t.QueryUpgradedClientStateResponse = t.QueryUpgradedClientStateRequest = t.QueryClientParamsResponse = t.QueryClientParamsRequest = t.QueryClientStatusResponse = t.QueryClientStatusRequest = t.QueryConsensusStateHeightsResponse = t.QueryConsensusStateHeightsRequest = t.QueryConsensusStatesResponse = t.QueryConsensusStatesRequest = t.QueryConsensusStateResponse = t.QueryConsensusStateRequest = t.QueryClientStatesResponse = t.QueryClientStatesRequest = t.QueryClientStateResponse = t.QueryClientStateRequest = t.protobufPackage = void 0;
            let n = r(38792),
                o = r(65676),
                i = r(24648),
                a = r(28486),
                s = r(6476);

            function d() {
                return {
                    clientId: ""
                }
            }

            function c() {
                return {
                    clientState: void 0,
                    proof: new Uint8Array,
                    proofHeight: i.Height.fromPartial({})
                }
            }

            function l() {
                return {
                    pagination: void 0
                }
            }

            function u() {
                return {
                    clientStates: [],
                    pagination: void 0
                }
            }

            function p() {
                return {
                    clientId: "",
                    revisionNumber: BigInt(0),
                    revisionHeight: BigInt(0),
                    latestHeight: !1
                }
            }

            function m() {
                return {
                    consensusState: void 0,
                    proof: new Uint8Array,
                    proofHeight: i.Height.fromPartial({})
                }
            }

            function g() {
                return {
                    clientId: "",
                    pagination: void 0
                }
            }

            function f() {
                return {
                    consensusStates: [],
                    pagination: void 0
                }
            }

            function y() {
                return {
                    clientId: "",
                    pagination: void 0
                }
            }

            function h() {
                return {
                    consensusStateHeights: [],
                    pagination: void 0
                }
            }

            function v() {
                return {
                    clientId: ""
                }
            }

            function b() {
                return {
                    status: ""
                }
            }

            function S() {
                return {
                    params: void 0
                }
            }

            function k() {
                return {
                    upgradedClientState: void 0
                }
            }

            function P() {
                return {
                    upgradedConsensusState: void 0
                }
            }
            t.protobufPackage = "ibc.core.client.v1", t.QueryClientStateRequest = {
                typeUrl: "/ibc.core.client.v1.QueryClientStateRequest",
                encode: (e, t = a.BinaryWriter.create()) => ("" !== e.clientId && t.uint32(10).string(e.clientId), t),
                decode(e, t) {
                    let r = e instanceof a.BinaryReader ? e : new a.BinaryReader(e),
                        n = void 0 === t ? r.len : r.pos + t,
                        o = d();
                    for (; r.pos < n;) {
                        let e = r.uint32();
                        e >>> 3 == 1 ? o.clientId = r.string() : r.skipType(7 & e)
                    }
                    return o
                },
                fromJSON(e) {
                    let t = d();
                    return (0, s.isSet)(e.clientId) && (t.clientId = String(e.clientId)), t
                },
                toJSON(e) {
                    let t = {};
                    return void 0 !== e.clientId && (t.clientId = e.clientId), t
                },
                fromPartial(e) {
                    let t = d();
                    return t.clientId = e.clientId ? ? "", t
                }
            }, t.QueryClientStateResponse = {
                typeUrl: "/ibc.core.client.v1.QueryClientStateResponse",
                encode: (e, t = a.BinaryWriter.create()) => (void 0 !== e.clientState && o.Any.encode(e.clientState, t.uint32(10).fork()).ldelim(), 0 !== e.proof.length && t.uint32(18).bytes(e.proof), void 0 !== e.proofHeight && i.Height.encode(e.proofHeight, t.uint32(26).fork()).ldelim(), t),
                decode(e, t) {
                    let r = e instanceof a.BinaryReader ? e : new a.BinaryReader(e),
                        n = void 0 === t ? r.len : r.pos + t,
                        s = c();
                    for (; r.pos < n;) {
                        let e = r.uint32();
                        switch (e >>> 3) {
                            case 1:
                                s.clientState = o.Any.decode(r, r.uint32());
                                break;
                            case 2:
                                s.proof = r.bytes();
                                break;
                            case 3:
                                s.proofHeight = i.Height.decode(r, r.uint32());
                                break;
                            default:
                                r.skipType(7 & e)
                        }
                    }
                    return s
                },
                fromJSON(e) {
                    let t = c();
                    return (0, s.isSet)(e.clientState) && (t.clientState = o.Any.fromJSON(e.clientState)), (0, s.isSet)(e.proof) && (t.proof = (0, s.bytesFromBase64)(e.proof)), (0, s.isSet)(e.proofHeight) && (t.proofHeight = i.Height.fromJSON(e.proofHeight)), t
                },
                toJSON(e) {
                    let t = {};
                    return void 0 !== e.clientState && (t.clientState = e.clientState ? o.Any.toJSON(e.clientState) : void 0), void 0 !== e.proof && (t.proof = (0, s.base64FromBytes)(void 0 !== e.proof ? e.proof : new Uint8Array)), void 0 !== e.proofHeight && (t.proofHeight = e.proofHeight ? i.Height.toJSON(e.proofHeight) : void 0), t
                },
                fromPartial(e) {
                    let t = c();
                    return void 0 !== e.clientState && null !== e.clientState && (t.clientState = o.Any.fromPartial(e.clientState)), t.proof = e.proof ? ? new Uint8Array, void 0 !== e.proofHeight && null !== e.proofHeight && (t.proofHeight = i.Height.fromPartial(e.proofHeight)), t
                }
            }, t.QueryClientStatesRequest = {
                typeUrl: "/ibc.core.client.v1.QueryClientStatesRequest",
                encode: (e, t = a.BinaryWriter.create()) => (void 0 !== e.pagination && n.PageRequest.encode(e.pagination, t.uint32(10).fork()).ldelim(), t),
                decode(e, t) {
                    let r = e instanceof a.BinaryReader ? e : new a.BinaryReader(e),
                        o = void 0 === t ? r.len : r.pos + t,
                        i = l();
                    for (; r.pos < o;) {
                        let e = r.uint32();
                        e >>> 3 == 1 ? i.pagination = n.PageRequest.decode(r, r.uint32()) : r.skipType(7 & e)
                    }
                    return i
                },
                fromJSON(e) {
                    let t = l();
                    return (0, s.isSet)(e.pagination) && (t.pagination = n.PageRequest.fromJSON(e.pagination)), t
                },
                toJSON(e) {
                    let t = {};
                    return void 0 !== e.pagination && (t.pagination = e.pagination ? n.PageRequest.toJSON(e.pagination) : void 0), t
                },
                fromPartial(e) {
                    let t = l();
                    return void 0 !== e.pagination && null !== e.pagination && (t.pagination = n.PageRequest.fromPartial(e.pagination)), t
                }
            }, t.QueryClientStatesResponse = {
                typeUrl: "/ibc.core.client.v1.QueryClientStatesResponse",
                encode(e, t = a.BinaryWriter.create()) {
                    for (let r of e.clientStates) i.IdentifiedClientState.encode(r, t.uint32(10).fork()).ldelim();
                    return void 0 !== e.pagination && n.PageResponse.encode(e.pagination, t.uint32(18).fork()).ldelim(), t
                },
                decode(e, t) {
                    let r = e instanceof a.BinaryReader ? e : new a.BinaryReader(e),
                        o = void 0 === t ? r.len : r.pos + t,
                        s = u();
                    for (; r.pos < o;) {
                        let e = r.uint32();
                        switch (e >>> 3) {
                            case 1:
                                s.clientStates.push(i.IdentifiedClientState.decode(r, r.uint32()));
                                break;
                            case 2:
                                s.pagination = n.PageResponse.decode(r, r.uint32());
                                break;
                            default:
                                r.skipType(7 & e)
                        }
                    }
                    return s
                },
                fromJSON(e) {
                    let t = u();
                    return Array.isArray(e ? .clientStates) && (t.clientStates = e.clientStates.map(e => i.IdentifiedClientState.fromJSON(e))), (0, s.isSet)(e.pagination) && (t.pagination = n.PageResponse.fromJSON(e.pagination)), t
                },
                toJSON(e) {
                    let t = {};
                    return e.clientStates ? t.clientStates = e.clientStates.map(e => e ? i.IdentifiedClientState.toJSON(e) : void 0) : t.clientStates = [], void 0 !== e.pagination && (t.pagination = e.pagination ? n.PageResponse.toJSON(e.pagination) : void 0), t
                },
                fromPartial(e) {
                    let t = u();
                    return t.clientStates = e.clientStates ? .map(e => i.IdentifiedClientState.fromPartial(e)) || [], void 0 !== e.pagination && null !== e.pagination && (t.pagination = n.PageResponse.fromPartial(e.pagination)), t
                }
            }, t.QueryConsensusStateRequest = {
                typeUrl: "/ibc.core.client.v1.QueryConsensusStateRequest",
                encode: (e, t = a.BinaryWriter.create()) => ("" !== e.clientId && t.uint32(10).string(e.clientId), e.revisionNumber !== BigInt(0) && t.uint32(16).uint64(e.revisionNumber), e.revisionHeight !== BigInt(0) && t.uint32(24).uint64(e.revisionHeight), !0 === e.latestHeight && t.uint32(32).bool(e.latestHeight), t),
                decode(e, t) {
                    let r = e instanceof a.BinaryReader ? e : new a.BinaryReader(e),
                        n = void 0 === t ? r.len : r.pos + t,
                        o = p();
                    for (; r.pos < n;) {
                        let e = r.uint32();
                        switch (e >>> 3) {
                            case 1:
                                o.clientId = r.string();
                                break;
                            case 2:
                                o.revisionNumber = r.uint64();
                                break;
                            case 3:
                                o.revisionHeight = r.uint64();
                                break;
                            case 4:
                                o.latestHeight = r.bool();
                                break;
                            default:
                                r.skipType(7 & e)
                        }
                    }
                    return o
                },
                fromJSON(e) {
                    let t = p();
                    return (0, s.isSet)(e.clientId) && (t.clientId = String(e.clientId)), (0, s.isSet)(e.revisionNumber) && (t.revisionNumber = BigInt(e.revisionNumber.toString())), (0, s.isSet)(e.revisionHeight) && (t.revisionHeight = BigInt(e.revisionHeight.toString())), (0, s.isSet)(e.latestHeight) && (t.latestHeight = !!e.latestHeight), t
                },
                toJSON(e) {
                    let t = {};
                    return void 0 !== e.clientId && (t.clientId = e.clientId), void 0 !== e.revisionNumber && (t.revisionNumber = (e.revisionNumber || BigInt(0)).toString()), void 0 !== e.revisionHeight && (t.revisionHeight = (e.revisionHeight || BigInt(0)).toString()), void 0 !== e.latestHeight && (t.latestHeight = e.latestHeight), t
                },
                fromPartial(e) {
                    let t = p();
                    return t.clientId = e.clientId ? ? "", void 0 !== e.revisionNumber && null !== e.revisionNumber && (t.revisionNumber = BigInt(e.revisionNumber.toString())), void 0 !== e.revisionHeight && null !== e.revisionHeight && (t.revisionHeight = BigInt(e.revisionHeight.toString())), t.latestHeight = e.latestHeight ? ? !1, t
                }
            }, t.QueryConsensusStateResponse = {
                typeUrl: "/ibc.core.client.v1.QueryConsensusStateResponse",
                encode: (e, t = a.BinaryWriter.create()) => (void 0 !== e.consensusState && o.Any.encode(e.consensusState, t.uint32(10).fork()).ldelim(), 0 !== e.proof.length && t.uint32(18).bytes(e.proof), void 0 !== e.proofHeight && i.Height.encode(e.proofHeight, t.uint32(26).fork()).ldelim(), t),
                decode(e, t) {
                    let r = e instanceof a.BinaryReader ? e : new a.BinaryReader(e),
                        n = void 0 === t ? r.len : r.pos + t,
                        s = m();
                    for (; r.pos < n;) {
                        let e = r.uint32();
                        switch (e >>> 3) {
                            case 1:
                                s.consensusState = o.Any.decode(r, r.uint32());
                                break;
                            case 2:
                                s.proof = r.bytes();
                                break;
                            case 3:
                                s.proofHeight = i.Height.decode(r, r.uint32());
                                break;
                            default:
                                r.skipType(7 & e)
                        }
                    }
                    return s
                },
                fromJSON(e) {
                    let t = m();
                    return (0, s.isSet)(e.consensusState) && (t.consensusState = o.Any.fromJSON(e.consensusState)), (0, s.isSet)(e.proof) && (t.proof = (0, s.bytesFromBase64)(e.proof)), (0, s.isSet)(e.proofHeight) && (t.proofHeight = i.Height.fromJSON(e.proofHeight)), t
                },
                toJSON(e) {
                    let t = {};
                    return void 0 !== e.consensusState && (t.consensusState = e.consensusState ? o.Any.toJSON(e.consensusState) : void 0), void 0 !== e.proof && (t.proof = (0, s.base64FromBytes)(void 0 !== e.proof ? e.proof : new Uint8Array)), void 0 !== e.proofHeight && (t.proofHeight = e.proofHeight ? i.Height.toJSON(e.proofHeight) : void 0), t
                },
                fromPartial(e) {
                    let t = m();
                    return void 0 !== e.consensusState && null !== e.consensusState && (t.consensusState = o.Any.fromPartial(e.consensusState)), t.proof = e.proof ? ? new Uint8Array, void 0 !== e.proofHeight && null !== e.proofHeight && (t.proofHeight = i.Height.fromPartial(e.proofHeight)), t
                }
            }, t.QueryConsensusStatesRequest = {
                typeUrl: "/ibc.core.client.v1.QueryConsensusStatesRequest",
                encode: (e, t = a.BinaryWriter.create()) => ("" !== e.clientId && t.uint32(10).string(e.clientId), void 0 !== e.pagination && n.PageRequest.encode(e.pagination, t.uint32(18).fork()).ldelim(), t),
                decode(e, t) {
                    let r = e instanceof a.BinaryReader ? e : new a.BinaryReader(e),
                        o = void 0 === t ? r.len : r.pos + t,
                        i = g();
                    for (; r.pos < o;) {
                        let e = r.uint32();
                        switch (e >>> 3) {
                            case 1:
                                i.clientId = r.string();
                                break;
                            case 2:
                                i.pagination = n.PageRequest.decode(r, r.uint32());
                                break;
                            default:
                                r.skipType(7 & e)
                        }
                    }
                    return i
                },
                fromJSON(e) {
                    let t = g();
                    return (0, s.isSet)(e.clientId) && (t.clientId = String(e.clientId)), (0, s.isSet)(e.pagination) && (t.pagination = n.PageRequest.fromJSON(e.pagination)), t
                },
                toJSON(e) {
                    let t = {};
                    return void 0 !== e.clientId && (t.clientId = e.clientId), void 0 !== e.pagination && (t.pagination = e.pagination ? n.PageRequest.toJSON(e.pagination) : void 0), t
                },
                fromPartial(e) {
                    let t = g();
                    return t.clientId = e.clientId ? ? "", void 0 !== e.pagination && null !== e.pagination && (t.pagination = n.PageRequest.fromPartial(e.pagination)), t
                }
            }, t.QueryConsensusStatesResponse = {
                typeUrl: "/ibc.core.client.v1.QueryConsensusStatesResponse",
                encode(e, t = a.BinaryWriter.create()) {
                    for (let r of e.consensusStates) i.ConsensusStateWithHeight.encode(r, t.uint32(10).fork()).ldelim();
                    return void 0 !== e.pagination && n.PageResponse.encode(e.pagination, t.uint32(18).fork()).ldelim(), t
                },
                decode(e, t) {
                    let r = e instanceof a.BinaryReader ? e : new a.BinaryReader(e),
                        o = void 0 === t ? r.len : r.pos + t,
                        s = f();
                    for (; r.pos < o;) {
                        let e = r.uint32();
                        switch (e >>> 3) {
                            case 1:
                                s.consensusStates.push(i.ConsensusStateWithHeight.decode(r, r.uint32()));
                                break;
                            case 2:
                                s.pagination = n.PageResponse.decode(r, r.uint32());
                                break;
                            default:
                                r.skipType(7 & e)
                        }
                    }
                    return s
                },
                fromJSON(e) {
                    let t = f();
                    return Array.isArray(e ? .consensusStates) && (t.consensusStates = e.consensusStates.map(e => i.ConsensusStateWithHeight.fromJSON(e))), (0, s.isSet)(e.pagination) && (t.pagination = n.PageResponse.fromJSON(e.pagination)), t
                },
                toJSON(e) {
                    let t = {};
                    return e.consensusStates ? t.consensusStates = e.consensusStates.map(e => e ? i.ConsensusStateWithHeight.toJSON(e) : void 0) : t.consensusStates = [], void 0 !== e.pagination && (t.pagination = e.pagination ? n.PageResponse.toJSON(e.pagination) : void 0), t
                },
                fromPartial(e) {
                    let t = f();
                    return t.consensusStates = e.consensusStates ? .map(e => i.ConsensusStateWithHeight.fromPartial(e)) || [], void 0 !== e.pagination && null !== e.pagination && (t.pagination = n.PageResponse.fromPartial(e.pagination)), t
                }
            }, t.QueryConsensusStateHeightsRequest = {
                typeUrl: "/ibc.core.client.v1.QueryConsensusStateHeightsRequest",
                encode: (e, t = a.BinaryWriter.create()) => ("" !== e.clientId && t.uint32(10).string(e.clientId), void 0 !== e.pagination && n.PageRequest.encode(e.pagination, t.uint32(18).fork()).ldelim(), t),
                decode(e, t) {
                    let r = e instanceof a.BinaryReader ? e : new a.BinaryReader(e),
                        o = void 0 === t ? r.len : r.pos + t,
                        i = y();
                    for (; r.pos < o;) {
                        let e = r.uint32();
                        switch (e >>> 3) {
                            case 1:
                                i.clientId = r.string();
                                break;
                            case 2:
                                i.pagination = n.PageRequest.decode(r, r.uint32());
                                break;
                            default:
                                r.skipType(7 & e)
                        }
                    }
                    return i
                },
                fromJSON(e) {
                    let t = y();
                    return (0, s.isSet)(e.clientId) && (t.clientId = String(e.clientId)), (0, s.isSet)(e.pagination) && (t.pagination = n.PageRequest.fromJSON(e.pagination)), t
                },
                toJSON(e) {
                    let t = {};
                    return void 0 !== e.clientId && (t.clientId = e.clientId), void 0 !== e.pagination && (t.pagination = e.pagination ? n.PageRequest.toJSON(e.pagination) : void 0), t
                },
                fromPartial(e) {
                    let t = y();
                    return t.clientId = e.clientId ? ? "", void 0 !== e.pagination && null !== e.pagination && (t.pagination = n.PageRequest.fromPartial(e.pagination)), t
                }
            }, t.QueryConsensusStateHeightsResponse = {
                typeUrl: "/ibc.core.client.v1.QueryConsensusStateHeightsResponse",
                encode(e, t = a.BinaryWriter.create()) {
                    for (let r of e.consensusStateHeights) i.Height.encode(r, t.uint32(10).fork()).ldelim();
                    return void 0 !== e.pagination && n.PageResponse.encode(e.pagination, t.uint32(18).fork()).ldelim(), t
                },
                decode(e, t) {
                    let r = e instanceof a.BinaryReader ? e : new a.BinaryReader(e),
                        o = void 0 === t ? r.len : r.pos + t,
                        s = h();
                    for (; r.pos < o;) {
                        let e = r.uint32();
                        switch (e >>> 3) {
                            case 1:
                                s.consensusStateHeights.push(i.Height.decode(r, r.uint32()));
                                break;
                            case 2:
                                s.pagination = n.PageResponse.decode(r, r.uint32());
                                break;
                            default:
                                r.skipType(7 & e)
                        }
                    }
                    return s
                },
                fromJSON(e) {
                    let t = h();
                    return Array.isArray(e ? .consensusStateHeights) && (t.consensusStateHeights = e.consensusStateHeights.map(e => i.Height.fromJSON(e))), (0, s.isSet)(e.pagination) && (t.pagination = n.PageResponse.fromJSON(e.pagination)), t
                },
                toJSON(e) {
                    let t = {};
                    return e.consensusStateHeights ? t.consensusStateHeights = e.consensusStateHeights.map(e => e ? i.Height.toJSON(e) : void 0) : t.consensusStateHeights = [], void 0 !== e.pagination && (t.pagination = e.pagination ? n.PageResponse.toJSON(e.pagination) : void 0), t
                },
                fromPartial(e) {
                    let t = h();
                    return t.consensusStateHeights = e.consensusStateHeights ? .map(e => i.Height.fromPartial(e)) || [], void 0 !== e.pagination && null !== e.pagination && (t.pagination = n.PageResponse.fromPartial(e.pagination)), t
                }
            }, t.QueryClientStatusRequest = {
                typeUrl: "/ibc.core.client.v1.QueryClientStatusRequest",
                encode: (e, t = a.BinaryWriter.create()) => ("" !== e.clientId && t.uint32(10).string(e.clientId), t),
                decode(e, t) {
                    let r = e instanceof a.BinaryReader ? e : new a.BinaryReader(e),
                        n = void 0 === t ? r.len : r.pos + t,
                        o = v();
                    for (; r.pos < n;) {
                        let e = r.uint32();
                        e >>> 3 == 1 ? o.clientId = r.string() : r.skipType(7 & e)
                    }
                    return o
                },
                fromJSON(e) {
                    let t = v();
                    return (0, s.isSet)(e.clientId) && (t.clientId = String(e.clientId)), t
                },
                toJSON(e) {
                    let t = {};
                    return void 0 !== e.clientId && (t.clientId = e.clientId), t
                },
                fromPartial(e) {
                    let t = v();
                    return t.clientId = e.clientId ? ? "", t
                }
            }, t.QueryClientStatusResponse = {
                typeUrl: "/ibc.core.client.v1.QueryClientStatusResponse",
                encode: (e, t = a.BinaryWriter.create()) => ("" !== e.status && t.uint32(10).string(e.status), t),
                decode(e, t) {
                    let r = e instanceof a.BinaryReader ? e : new a.BinaryReader(e),
                        n = void 0 === t ? r.len : r.pos + t,
                        o = b();
                    for (; r.pos < n;) {
                        let e = r.uint32();
                        e >>> 3 == 1 ? o.status = r.string() : r.skipType(7 & e)
                    }
                    return o
                },
                fromJSON(e) {
                    let t = b();
                    return (0, s.isSet)(e.status) && (t.status = String(e.status)), t
                },
                toJSON(e) {
                    let t = {};
                    return void 0 !== e.status && (t.status = e.status), t
                },
                fromPartial(e) {
                    let t = b();
                    return t.status = e.status ? ? "", t
                }
            }, t.QueryClientParamsRequest = {
                typeUrl: "/ibc.core.client.v1.QueryClientParamsRequest",
                encode: (e, t = a.BinaryWriter.create()) => t,
                decode(e, t) {
                    let r = e instanceof a.BinaryReader ? e : new a.BinaryReader(e),
                        n = void 0 === t ? r.len : r.pos + t;
                    for (; r.pos < n;) {
                        let e = r.uint32();
                        r.skipType(7 & e)
                    }
                    return {}
                },
                fromJSON: e => ({}),
                toJSON: e => ({}),
                fromPartial: e => ({})
            }, t.QueryClientParamsResponse = {
                typeUrl: "/ibc.core.client.v1.QueryClientParamsResponse",
                encode: (e, t = a.BinaryWriter.create()) => (void 0 !== e.params && i.Params.encode(e.params, t.uint32(10).fork()).ldelim(), t),
                decode(e, t) {
                    let r = e instanceof a.BinaryReader ? e : new a.BinaryReader(e),
                        n = void 0 === t ? r.len : r.pos + t,
                        o = S();
                    for (; r.pos < n;) {
                        let e = r.uint32();
                        e >>> 3 == 1 ? o.params = i.Params.decode(r, r.uint32()) : r.skipType(7 & e)
                    }
                    return o
                },
                fromJSON(e) {
                    let t = S();
                    return (0, s.isSet)(e.params) && (t.params = i.Params.fromJSON(e.params)), t
                },
                toJSON(e) {
                    let t = {};
                    return void 0 !== e.params && (t.params = e.params ? i.Params.toJSON(e.params) : void 0), t
                },
                fromPartial(e) {
                    let t = S();
                    return void 0 !== e.params && null !== e.params && (t.params = i.Params.fromPartial(e.params)), t
                }
            }, t.QueryUpgradedClientStateRequest = {
                typeUrl: "/ibc.core.client.v1.QueryUpgradedClientStateRequest",
                encode: (e, t = a.BinaryWriter.create()) => t,
                decode(e, t) {
                    let r = e instanceof a.BinaryReader ? e : new a.BinaryReader(e),
                        n = void 0 === t ? r.len : r.pos + t;
                    for (; r.pos < n;) {
                        let e = r.uint32();
                        r.skipType(7 & e)
                    }
                    return {}
                },
                fromJSON: e => ({}),
                toJSON: e => ({}),
                fromPartial: e => ({})
            }, t.QueryUpgradedClientStateResponse = {
                typeUrl: "/ibc.core.client.v1.QueryUpgradedClientStateResponse",
                encode: (e, t = a.BinaryWriter.create()) => (void 0 !== e.upgradedClientState && o.Any.encode(e.upgradedClientState, t.uint32(10).fork()).ldelim(), t),
                decode(e, t) {
                    let r = e instanceof a.BinaryReader ? e : new a.BinaryReader(e),
                        n = void 0 === t ? r.len : r.pos + t,
                        i = k();
                    for (; r.pos < n;) {
                        let e = r.uint32();
                        e >>> 3 == 1 ? i.upgradedClientState = o.Any.decode(r, r.uint32()) : r.skipType(7 & e)
                    }
                    return i
                },
                fromJSON(e) {
                    let t = k();
                    return (0, s.isSet)(e.upgradedClientState) && (t.upgradedClientState = o.Any.fromJSON(e.upgradedClientState)), t
                },
                toJSON(e) {
                    let t = {};
                    return void 0 !== e.upgradedClientState && (t.upgradedClientState = e.upgradedClientState ? o.Any.toJSON(e.upgradedClientState) : void 0), t
                },
                fromPartial(e) {
                    let t = k();
                    return void 0 !== e.upgradedClientState && null !== e.upgradedClientState && (t.upgradedClientState = o.Any.fromPartial(e.upgradedClientState)), t
                }
            }, t.QueryUpgradedConsensusStateRequest = {
                typeUrl: "/ibc.core.client.v1.QueryUpgradedConsensusStateRequest",
                encode: (e, t = a.BinaryWriter.create()) => t,
                decode(e, t) {
                    let r = e instanceof a.BinaryReader ? e : new a.BinaryReader(e),
                        n = void 0 === t ? r.len : r.pos + t;
                    for (; r.pos < n;) {
                        let e = r.uint32();
                        r.skipType(7 & e)
                    }
                    return {}
                },
                fromJSON: e => ({}),
                toJSON: e => ({}),
                fromPartial: e => ({})
            }, t.QueryUpgradedConsensusStateResponse = {
                typeUrl: "/ibc.core.client.v1.QueryUpgradedConsensusStateResponse",
                encode: (e, t = a.BinaryWriter.create()) => (void 0 !== e.upgradedConsensusState && o.Any.encode(e.upgradedConsensusState, t.uint32(10).fork()).ldelim(), t),
                decode(e, t) {
                    let r = e instanceof a.BinaryReader ? e : new a.BinaryReader(e),
                        n = void 0 === t ? r.len : r.pos + t,
                        i = P();
                    for (; r.pos < n;) {
                        let e = r.uint32();
                        e >>> 3 == 1 ? i.upgradedConsensusState = o.Any.decode(r, r.uint32()) : r.skipType(7 & e)
                    }
                    return i
                },
                fromJSON(e) {
                    let t = P();
                    return (0, s.isSet)(e.upgradedConsensusState) && (t.upgradedConsensusState = o.Any.fromJSON(e.upgradedConsensusState)), t
                },
                toJSON(e) {
                    let t = {};
                    return void 0 !== e.upgradedConsensusState && (t.upgradedConsensusState = e.upgradedConsensusState ? o.Any.toJSON(e.upgradedConsensusState) : void 0), t
                },
                fromPartial(e) {
                    let t = P();
                    return void 0 !== e.upgradedConsensusState && null !== e.upgradedConsensusState && (t.upgradedConsensusState = o.Any.fromPartial(e.upgradedConsensusState)), t
                }
            };
            class _ {
                constructor(e) {
                    this.rpc = e, this.ClientState = this.ClientState.bind(this), this.ClientStates = this.ClientStates.bind(this), this.ConsensusState = this.ConsensusState.bind(this), this.ConsensusStates = this.ConsensusStates.bind(this), this.ConsensusStateHeights = this.ConsensusStateHeights.bind(this), this.ClientStatus = this.ClientStatus.bind(this), this.ClientParams = this.ClientParams.bind(this), this.UpgradedClientState = this.UpgradedClientState.bind(this), this.UpgradedConsensusState = this.UpgradedConsensusState.bind(this)
                }
                ClientState(e) {
                    let r = t.QueryClientStateRequest.encode(e).finish();
                    return this.rpc.request("ibc.core.client.v1.Query", "ClientState", r).then(e => t.QueryClientStateResponse.decode(new a.BinaryReader(e)))
                }
                ClientStates(e = {
                    pagination: n.PageRequest.fromPartial({})
                }) {
                    let r = t.QueryClientStatesRequest.encode(e).finish();
                    return this.rpc.request("ibc.core.client.v1.Query", "ClientStates", r).then(e => t.QueryClientStatesResponse.decode(new a.BinaryReader(e)))
                }
                ConsensusState(e) {
                    let r = t.QueryConsensusStateRequest.encode(e).finish();
                    return this.rpc.request("ibc.core.client.v1.Query", "ConsensusState", r).then(e => t.QueryConsensusStateResponse.decode(new a.BinaryReader(e)))
                }
                ConsensusStates(e) {
                    let r = t.QueryConsensusStatesRequest.encode(e).finish();
                    return this.rpc.request("ibc.core.client.v1.Query", "ConsensusStates", r).then(e => t.QueryConsensusStatesResponse.decode(new a.BinaryReader(e)))
                }
                ConsensusStateHeights(e) {
                    let r = t.QueryConsensusStateHeightsRequest.encode(e).finish();
                    return this.rpc.request("ibc.core.client.v1.Query", "ConsensusStateHeights", r).then(e => t.QueryConsensusStateHeightsResponse.decode(new a.BinaryReader(e)))
                }
                ClientStatus(e) {
                    let r = t.QueryClientStatusRequest.encode(e).finish();
                    return this.rpc.request("ibc.core.client.v1.Query", "ClientStatus", r).then(e => t.QueryClientStatusResponse.decode(new a.BinaryReader(e)))
                }
                ClientParams(e = {}) {
                    let r = t.QueryClientParamsRequest.encode(e).finish();
                    return this.rpc.request("ibc.core.client.v1.Query", "ClientParams", r).then(e => t.QueryClientParamsResponse.decode(new a.BinaryReader(e)))
                }
                UpgradedClientState(e = {}) {
                    let r = t.QueryUpgradedClientStateRequest.encode(e).finish();
                    return this.rpc.request("ibc.core.client.v1.Query", "UpgradedClientState", r).then(e => t.QueryUpgradedClientStateResponse.decode(new a.BinaryReader(e)))
                }
                UpgradedConsensusState(e = {}) {
                    let r = t.QueryUpgradedConsensusStateRequest.encode(e).finish();
                    return this.rpc.request("ibc.core.client.v1.Query", "UpgradedConsensusState", r).then(e => t.QueryUpgradedConsensusStateResponse.decode(new a.BinaryReader(e)))
                }
            }
            t.QueryClientImpl = _
        },
        29040: function(e, t, r) {
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: !0
            }), t.MsgClientImpl = t.MsgSubmitMisbehaviourResponse = t.MsgSubmitMisbehaviour = t.MsgUpgradeClientResponse = t.MsgUpgradeClient = t.MsgUpdateClientResponse = t.MsgUpdateClient = t.MsgCreateClientResponse = t.MsgCreateClient = t.protobufPackage = void 0;
            let n = r(65676),
                o = r(28486),
                i = r(6476);

            function a() {
                return {
                    clientState: void 0,
                    consensusState: void 0,
                    signer: ""
                }
            }

            function s() {
                return {
                    clientId: "",
                    clientMessage: void 0,
                    signer: ""
                }
            }

            function d() {
                return {
                    clientId: "",
                    clientState: void 0,
                    consensusState: void 0,
                    proofUpgradeClient: new Uint8Array,
                    proofUpgradeConsensusState: new Uint8Array,
                    signer: ""
                }
            }

            function c() {
                return {
                    clientId: "",
                    misbehaviour: void 0,
                    signer: ""
                }
            }
            t.protobufPackage = "ibc.core.client.v1", t.MsgCreateClient = {
                typeUrl: "/ibc.core.client.v1.MsgCreateClient",
                encode: (e, t = o.BinaryWriter.create()) => (void 0 !== e.clientState && n.Any.encode(e.clientState, t.uint32(10).fork()).ldelim(), void 0 !== e.consensusState && n.Any.encode(e.consensusState, t.uint32(18).fork()).ldelim(), "" !== e.signer && t.uint32(26).string(e.signer), t),
                decode(e, t) {
                    let r = e instanceof o.BinaryReader ? e : new o.BinaryReader(e),
                        i = void 0 === t ? r.len : r.pos + t,
                        s = a();
                    for (; r.pos < i;) {
                        let e = r.uint32();
                        switch (e >>> 3) {
                            case 1:
                                s.clientState = n.Any.decode(r, r.uint32());
                                break;
                            case 2:
                                s.consensusState = n.Any.decode(r, r.uint32());
                                break;
                            case 3:
                                s.signer = r.string();
                                break;
                            default:
                                r.skipType(7 & e)
                        }
                    }
                    return s
                },
                fromJSON(e) {
                    let t = a();
                    return (0, i.isSet)(e.clientState) && (t.clientState = n.Any.fromJSON(e.clientState)), (0, i.isSet)(e.consensusState) && (t.consensusState = n.Any.fromJSON(e.consensusState)), (0, i.isSet)(e.signer) && (t.signer = String(e.signer)), t
                },
                toJSON(e) {
                    let t = {};
                    return void 0 !== e.clientState && (t.clientState = e.clientState ? n.Any.toJSON(e.clientState) : void 0), void 0 !== e.consensusState && (t.consensusState = e.consensusState ? n.Any.toJSON(e.consensusState) : void 0), void 0 !== e.signer && (t.signer = e.signer), t
                },
                fromPartial(e) {
                    let t = a();
                    return void 0 !== e.clientState && null !== e.clientState && (t.clientState = n.Any.fromPartial(e.clientState)), void 0 !== e.consensusState && null !== e.consensusState && (t.consensusState = n.Any.fromPartial(e.consensusState)), t.signer = e.signer ? ? "", t
                }
            }, t.MsgCreateClientResponse = {
                typeUrl: "/ibc.core.client.v1.MsgCreateClientResponse",
                encode: (e, t = o.BinaryWriter.create()) => t,
                decode(e, t) {
                    let r = e instanceof o.BinaryReader ? e : new o.BinaryReader(e),
                        n = void 0 === t ? r.len : r.pos + t;
                    for (; r.pos < n;) {
                        let e = r.uint32();
                        r.skipType(7 & e)
                    }
                    return {}
                },
                fromJSON: e => ({}),
                toJSON: e => ({}),
                fromPartial: e => ({})
            }, t.MsgUpdateClient = {
                typeUrl: "/ibc.core.client.v1.MsgUpdateClient",
                encode: (e, t = o.BinaryWriter.create()) => ("" !== e.clientId && t.uint32(10).string(e.clientId), void 0 !== e.clientMessage && n.Any.encode(e.clientMessage, t.uint32(18).fork()).ldelim(), "" !== e.signer && t.uint32(26).string(e.signer), t),
                decode(e, t) {
                    let r = e instanceof o.BinaryReader ? e : new o.BinaryReader(e),
                        i = void 0 === t ? r.len : r.pos + t,
                        a = s();
                    for (; r.pos < i;) {
                        let e = r.uint32();
                        switch (e >>> 3) {
                            case 1:
                                a.clientId = r.string();
                                break;
                            case 2:
                                a.clientMessage = n.Any.decode(r, r.uint32());
                                break;
                            case 3:
                                a.signer = r.string();
                                break;
                            default:
                                r.skipType(7 & e)
                        }
                    }
                    return a
                },
                fromJSON(e) {
                    let t = s();
                    return (0, i.isSet)(e.clientId) && (t.clientId = String(e.clientId)), (0, i.isSet)(e.clientMessage) && (t.clientMessage = n.Any.fromJSON(e.clientMessage)), (0, i.isSet)(e.signer) && (t.signer = String(e.signer)), t
                },
                toJSON(e) {
                    let t = {};
                    return void 0 !== e.clientId && (t.clientId = e.clientId), void 0 !== e.clientMessage && (t.clientMessage = e.clientMessage ? n.Any.toJSON(e.clientMessage) : void 0), void 0 !== e.signer && (t.signer = e.signer), t
                },
                fromPartial(e) {
                    let t = s();
                    return t.clientId = e.clientId ? ? "", void 0 !== e.clientMessage && null !== e.clientMessage && (t.clientMessage = n.Any.fromPartial(e.clientMessage)), t.signer = e.signer ? ? "", t
                }
            }, t.MsgUpdateClientResponse = {
                typeUrl: "/ibc.core.client.v1.MsgUpdateClientResponse",
                encode: (e, t = o.BinaryWriter.create()) => t,
                decode(e, t) {
                    let r = e instanceof o.BinaryReader ? e : new o.BinaryReader(e),
                        n = void 0 === t ? r.len : r.pos + t;
                    for (; r.pos < n;) {
                        let e = r.uint32();
                        r.skipType(7 & e)
                    }
                    return {}
                },
                fromJSON: e => ({}),
                toJSON: e => ({}),
                fromPartial: e => ({})
            }, t.MsgUpgradeClient = {
                typeUrl: "/ibc.core.client.v1.MsgUpgradeClient",
                encode: (e, t = o.BinaryWriter.create()) => ("" !== e.clientId && t.uint32(10).string(e.clientId), void 0 !== e.clientState && n.Any.encode(e.clientState, t.uint32(18).fork()).ldelim(), void 0 !== e.consensusState && n.Any.encode(e.consensusState, t.uint32(26).fork()).ldelim(), 0 !== e.proofUpgradeClient.length && t.uint32(34).bytes(e.proofUpgradeClient), 0 !== e.proofUpgradeConsensusState.length && t.uint32(42).bytes(e.proofUpgradeConsensusState), "" !== e.signer && t.uint32(50).string(e.signer), t),
                decode(e, t) {
                    let r = e instanceof o.BinaryReader ? e : new o.BinaryReader(e),
                        i = void 0 === t ? r.len : r.pos + t,
                        a = d();
                    for (; r.pos < i;) {
                        let e = r.uint32();
                        switch (e >>> 3) {
                            case 1:
                                a.clientId = r.string();
                                break;
                            case 2:
                                a.clientState = n.Any.decode(r, r.uint32());
                                break;
                            case 3:
                                a.consensusState = n.Any.decode(r, r.uint32());
                                break;
                            case 4:
                                a.proofUpgradeClient = r.bytes();
                                break;
                            case 5:
                                a.proofUpgradeConsensusState = r.bytes();
                                break;
                            case 6:
                                a.signer = r.string();
                                break;
                            default:
                                r.skipType(7 & e)
                        }
                    }
                    return a
                },
                fromJSON(e) {
                    let t = d();
                    return (0, i.isSet)(e.clientId) && (t.clientId = String(e.clientId)), (0, i.isSet)(e.clientState) && (t.clientState = n.Any.fromJSON(e.clientState)), (0, i.isSet)(e.consensusState) && (t.consensusState = n.Any.fromJSON(e.consensusState)), (0, i.isSet)(e.proofUpgradeClient) && (t.proofUpgradeClient = (0, i.bytesFromBase64)(e.proofUpgradeClient)), (0, i.isSet)(e.proofUpgradeConsensusState) && (t.proofUpgradeConsensusState = (0, i.bytesFromBase64)(e.proofUpgradeConsensusState)), (0, i.isSet)(e.signer) && (t.signer = String(e.signer)), t
                },
                toJSON(e) {
                    let t = {};
                    return void 0 !== e.clientId && (t.clientId = e.clientId), void 0 !== e.clientState && (t.clientState = e.clientState ? n.Any.toJSON(e.clientState) : void 0), void 0 !== e.consensusState && (t.consensusState = e.consensusState ? n.Any.toJSON(e.consensusState) : void 0), void 0 !== e.proofUpgradeClient && (t.proofUpgradeClient = (0, i.base64FromBytes)(void 0 !== e.proofUpgradeClient ? e.proofUpgradeClient : new Uint8Array)), void 0 !== e.proofUpgradeConsensusState && (t.proofUpgradeConsensusState = (0, i.base64FromBytes)(void 0 !== e.proofUpgradeConsensusState ? e.proofUpgradeConsensusState : new Uint8Array)), void 0 !== e.signer && (t.signer = e.signer), t
                },
                fromPartial(e) {
                    let t = d();
                    return t.clientId = e.clientId ? ? "", void 0 !== e.clientState && null !== e.clientState && (t.clientState = n.Any.fromPartial(e.clientState)), void 0 !== e.consensusState && null !== e.consensusState && (t.consensusState = n.Any.fromPartial(e.consensusState)), t.proofUpgradeClient = e.proofUpgradeClient ? ? new Uint8Array, t.proofUpgradeConsensusState = e.proofUpgradeConsensusState ? ? new Uint8Array, t.signer = e.signer ? ? "", t
                }
            }, t.MsgUpgradeClientResponse = {
                typeUrl: "/ibc.core.client.v1.MsgUpgradeClientResponse",
                encode: (e, t = o.BinaryWriter.create()) => t,
                decode(e, t) {
                    let r = e instanceof o.BinaryReader ? e : new o.BinaryReader(e),
                        n = void 0 === t ? r.len : r.pos + t;
                    for (; r.pos < n;) {
                        let e = r.uint32();
                        r.skipType(7 & e)
                    }
                    return {}
                },
                fromJSON: e => ({}),
                toJSON: e => ({}),
                fromPartial: e => ({})
            }, t.MsgSubmitMisbehaviour = {
                typeUrl: "/ibc.core.client.v1.MsgSubmitMisbehaviour",
                encode: (e, t = o.BinaryWriter.create()) => ("" !== e.clientId && t.uint32(10).string(e.clientId), void 0 !== e.misbehaviour && n.Any.encode(e.misbehaviour, t.uint32(18).fork()).ldelim(), "" !== e.signer && t.uint32(26).string(e.signer), t),
                decode(e, t) {
                    let r = e instanceof o.BinaryReader ? e : new o.BinaryReader(e),
                        i = void 0 === t ? r.len : r.pos + t,
                        a = c();
                    for (; r.pos < i;) {
                        let e = r.uint32();
                        switch (e >>> 3) {
                            case 1:
                                a.clientId = r.string();
                                break;
                            case 2:
                                a.misbehaviour = n.Any.decode(r, r.uint32());
                                break;
                            case 3:
                                a.signer = r.string();
                                break;
                            default:
                                r.skipType(7 & e)
                        }
                    }
                    return a
                },
                fromJSON(e) {
                    let t = c();
                    return (0, i.isSet)(e.clientId) && (t.clientId = String(e.clientId)), (0, i.isSet)(e.misbehaviour) && (t.misbehaviour = n.Any.fromJSON(e.misbehaviour)), (0, i.isSet)(e.signer) && (t.signer = String(e.signer)), t
                },
                toJSON(e) {
                    let t = {};
                    return void 0 !== e.clientId && (t.clientId = e.clientId), void 0 !== e.misbehaviour && (t.misbehaviour = e.misbehaviour ? n.Any.toJSON(e.misbehaviour) : void 0), void 0 !== e.signer && (t.signer = e.signer), t
                },
                fromPartial(e) {
                    let t = c();
                    return t.clientId = e.clientId ? ? "", void 0 !== e.misbehaviour && null !== e.misbehaviour && (t.misbehaviour = n.Any.fromPartial(e.misbehaviour)), t.signer = e.signer ? ? "", t
                }
            }, t.MsgSubmitMisbehaviourResponse = {
                typeUrl: "/ibc.core.client.v1.MsgSubmitMisbehaviourResponse",
                encode: (e, t = o.BinaryWriter.create()) => t,
                decode(e, t) {
                    let r = e instanceof o.BinaryReader ? e : new o.BinaryReader(e),
                        n = void 0 === t ? r.len : r.pos + t;
                    for (; r.pos < n;) {
                        let e = r.uint32();
                        r.skipType(7 & e)
                    }
                    return {}
                },
                fromJSON: e => ({}),
                toJSON: e => ({}),
                fromPartial: e => ({})
            };
            class l {
                constructor(e) {
                    this.rpc = e, this.CreateClient = this.CreateClient.bind(this), this.UpdateClient = this.UpdateClient.bind(this), this.UpgradeClient = this.UpgradeClient.bind(this), this.SubmitMisbehaviour = this.SubmitMisbehaviour.bind(this)
                }
                CreateClient(e) {
                    let r = t.MsgCreateClient.encode(e).finish();
                    return this.rpc.request("ibc.core.client.v1.Msg", "CreateClient", r).then(e => t.MsgCreateClientResponse.decode(new o.BinaryReader(e)))
                }
                UpdateClient(e) {
                    let r = t.MsgUpdateClient.encode(e).finish();
                    return this.rpc.request("ibc.core.client.v1.Msg", "UpdateClient", r).then(e => t.MsgUpdateClientResponse.decode(new o.BinaryReader(e)))
                }
                UpgradeClient(e) {
                    let r = t.MsgUpgradeClient.encode(e).finish();
                    return this.rpc.request("ibc.core.client.v1.Msg", "UpgradeClient", r).then(e => t.MsgUpgradeClientResponse.decode(new o.BinaryReader(e)))
                }
                SubmitMisbehaviour(e) {
                    let r = t.MsgSubmitMisbehaviour.encode(e).finish();
                    return this.rpc.request("ibc.core.client.v1.Msg", "SubmitMisbehaviour", r).then(e => t.MsgSubmitMisbehaviourResponse.decode(new o.BinaryReader(e)))
                }
            }
            t.MsgClientImpl = l
        },
        52673: function(e, t, r) {
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: !0
            }), t.MerkleProof = t.MerklePath = t.MerklePrefix = t.MerkleRoot = t.protobufPackage = void 0;
            let n = r(51570),
                o = r(28486),
                i = r(6476);

            function a() {
                return {
                    hash: new Uint8Array
                }
            }

            function s() {
                return {
                    keyPrefix: new Uint8Array
                }
            }

            function d() {
                return {
                    keyPath: []
                }
            }

            function c() {
                return {
                    proofs: []
                }
            }
            t.protobufPackage = "ibc.core.commitment.v1", t.MerkleRoot = {
                typeUrl: "/ibc.core.commitment.v1.MerkleRoot",
                encode: (e, t = o.BinaryWriter.create()) => (0 !== e.hash.length && t.uint32(10).bytes(e.hash), t),
                decode(e, t) {
                    let r = e instanceof o.BinaryReader ? e : new o.BinaryReader(e),
                        n = void 0 === t ? r.len : r.pos + t,
                        i = a();
                    for (; r.pos < n;) {
                        let e = r.uint32();
                        e >>> 3 == 1 ? i.hash = r.bytes() : r.skipType(7 & e)
                    }
                    return i
                },
                fromJSON(e) {
                    let t = a();
                    return (0, i.isSet)(e.hash) && (t.hash = (0, i.bytesFromBase64)(e.hash)), t
                },
                toJSON(e) {
                    let t = {};
                    return void 0 !== e.hash && (t.hash = (0, i.base64FromBytes)(void 0 !== e.hash ? e.hash : new Uint8Array)), t
                },
                fromPartial(e) {
                    let t = a();
                    return t.hash = e.hash ? ? new Uint8Array, t
                }
            }, t.MerklePrefix = {
                typeUrl: "/ibc.core.commitment.v1.MerklePrefix",
                encode: (e, t = o.BinaryWriter.create()) => (0 !== e.keyPrefix.length && t.uint32(10).bytes(e.keyPrefix), t),
                decode(e, t) {
                    let r = e instanceof o.BinaryReader ? e : new o.BinaryReader(e),
                        n = void 0 === t ? r.len : r.pos + t,
                        i = s();
                    for (; r.pos < n;) {
                        let e = r.uint32();
                        e >>> 3 == 1 ? i.keyPrefix = r.bytes() : r.skipType(7 & e)
                    }
                    return i
                },
                fromJSON(e) {
                    let t = s();
                    return (0, i.isSet)(e.keyPrefix) && (t.keyPrefix = (0, i.bytesFromBase64)(e.keyPrefix)), t
                },
                toJSON(e) {
                    let t = {};
                    return void 0 !== e.keyPrefix && (t.keyPrefix = (0, i.base64FromBytes)(void 0 !== e.keyPrefix ? e.keyPrefix : new Uint8Array)), t
                },
                fromPartial(e) {
                    let t = s();
                    return t.keyPrefix = e.keyPrefix ? ? new Uint8Array, t
                }
            }, t.MerklePath = {
                typeUrl: "/ibc.core.commitment.v1.MerklePath",
                encode(e, t = o.BinaryWriter.create()) {
                    for (let r of e.keyPath) t.uint32(10).string(r);
                    return t
                },
                decode(e, t) {
                    let r = e instanceof o.BinaryReader ? e : new o.BinaryReader(e),
                        n = void 0 === t ? r.len : r.pos + t,
                        i = d();
                    for (; r.pos < n;) {
                        let e = r.uint32();
                        e >>> 3 == 1 ? i.keyPath.push(r.string()) : r.skipType(7 & e)
                    }
                    return i
                },
                fromJSON(e) {
                    let t = d();
                    return Array.isArray(e ? .keyPath) && (t.keyPath = e.keyPath.map(e => String(e))), t
                },
                toJSON(e) {
                    let t = {};
                    return e.keyPath ? t.keyPath = e.keyPath.map(e => e) : t.keyPath = [], t
                },
                fromPartial(e) {
                    let t = d();
                    return t.keyPath = e.keyPath ? .map(e => e) || [], t
                }
            }, t.MerkleProof = {
                typeUrl: "/ibc.core.commitment.v1.MerkleProof",
                encode(e, t = o.BinaryWriter.create()) {
                    for (let r of e.proofs) n.CommitmentProof.encode(r, t.uint32(10).fork()).ldelim();
                    return t
                },
                decode(e, t) {
                    let r = e instanceof o.BinaryReader ? e : new o.BinaryReader(e),
                        i = void 0 === t ? r.len : r.pos + t,
                        a = c();
                    for (; r.pos < i;) {
                        let e = r.uint32();
                        e >>> 3 == 1 ? a.proofs.push(n.CommitmentProof.decode(r, r.uint32())) : r.skipType(7 & e)
                    }
                    return a
                },
                fromJSON(e) {
                    let t = c();
                    return Array.isArray(e ? .proofs) && (t.proofs = e.proofs.map(e => n.CommitmentProof.fromJSON(e))), t
                },
                toJSON(e) {
                    let t = {};
                    return e.proofs ? t.proofs = e.proofs.map(e => e ? n.CommitmentProof.toJSON(e) : void 0) : t.proofs = [], t
                },
                fromPartial(e) {
                    let t = c();
                    return t.proofs = e.proofs ? .map(e => n.CommitmentProof.fromPartial(e)) || [], t
                }
            }
        },
        30416: function(e, t, r) {
            "use strict";
            var n, o;
            Object.defineProperty(t, "__esModule", {
                value: !0
            }), t.Params = t.Version = t.ConnectionPaths = t.ClientPaths = t.Counterparty = t.IdentifiedConnection = t.ConnectionEnd = t.stateToJSON = t.stateFromJSON = t.State = t.protobufPackage = void 0;
            let i = r(52673),
                a = r(28486),
                s = r(6476);

            function d(e) {
                switch (e) {
                    case 0:
                    case "STATE_UNINITIALIZED_UNSPECIFIED":
                        return n.STATE_UNINITIALIZED_UNSPECIFIED;
                    case 1:
                    case "STATE_INIT":
                        return n.STATE_INIT;
                    case 2:
                    case "STATE_TRYOPEN":
                        return n.STATE_TRYOPEN;
                    case 3:
                    case "STATE_OPEN":
                        return n.STATE_OPEN;
                    default:
                        return n.UNRECOGNIZED
                }
            }

            function c(e) {
                switch (e) {
                    case n.STATE_UNINITIALIZED_UNSPECIFIED:
                        return "STATE_UNINITIALIZED_UNSPECIFIED";
                    case n.STATE_INIT:
                        return "STATE_INIT";
                    case n.STATE_TRYOPEN:
                        return "STATE_TRYOPEN";
                    case n.STATE_OPEN:
                        return "STATE_OPEN";
                    case n.UNRECOGNIZED:
                    default:
                        return "UNRECOGNIZED"
                }
            }

            function l() {
                return {
                    clientId: "",
                    versions: [],
                    state: 0,
                    counterparty: t.Counterparty.fromPartial({}),
                    delayPeriod: BigInt(0)
                }
            }

            function u() {
                return {
                    id: "",
                    clientId: "",
                    versions: [],
                    state: 0,
                    counterparty: t.Counterparty.fromPartial({}),
                    delayPeriod: BigInt(0)
                }
            }

            function p() {
                return {
                    clientId: "",
                    connectionId: "",
                    prefix: i.MerklePrefix.fromPartial({})
                }
            }

            function m() {
                return {
                    paths: []
                }
            }

            function g() {
                return {
                    clientId: "",
                    paths: []
                }
            }

            function f() {
                return {
                    identifier: "",
                    features: []
                }
            }

            function y() {
                return {
                    maxExpectedTimePerBlock: BigInt(0)
                }
            }
            t.protobufPackage = "ibc.core.connection.v1", (o = n || (t.State = n = {}))[o.STATE_UNINITIALIZED_UNSPECIFIED = 0] = "STATE_UNINITIALIZED_UNSPECIFIED", o[o.STATE_INIT = 1] = "STATE_INIT", o[o.STATE_TRYOPEN = 2] = "STATE_TRYOPEN", o[o.STATE_OPEN = 3] = "STATE_OPEN", o[o.UNRECOGNIZED = -1] = "UNRECOGNIZED", t.stateFromJSON = d, t.stateToJSON = c, t.ConnectionEnd = {
                typeUrl: "/ibc.core.connection.v1.ConnectionEnd",
                encode(e, r = a.BinaryWriter.create()) {
                    for (let n of ("" !== e.clientId && r.uint32(10).string(e.clientId), e.versions)) t.Version.encode(n, r.uint32(18).fork()).ldelim();
                    return 0 !== e.state && r.uint32(24).int32(e.state), void 0 !== e.counterparty && t.Counterparty.encode(e.counterparty, r.uint32(34).fork()).ldelim(), e.delayPeriod !== BigInt(0) && r.uint32(40).uint64(e.delayPeriod), r
                },
                decode(e, r) {
                    let n = e instanceof a.BinaryReader ? e : new a.BinaryReader(e),
                        o = void 0 === r ? n.len : n.pos + r,
                        i = l();
                    for (; n.pos < o;) {
                        let e = n.uint32();
                        switch (e >>> 3) {
                            case 1:
                                i.clientId = n.string();
                                break;
                            case 2:
                                i.versions.push(t.Version.decode(n, n.uint32()));
                                break;
                            case 3:
                                i.state = n.int32();
                                break;
                            case 4:
                                i.counterparty = t.Counterparty.decode(n, n.uint32());
                                break;
                            case 5:
                                i.delayPeriod = n.uint64();
                                break;
                            default:
                                n.skipType(7 & e)
                        }
                    }
                    return i
                },
                fromJSON(e) {
                    let r = l();
                    return (0, s.isSet)(e.clientId) && (r.clientId = String(e.clientId)), Array.isArray(e ? .versions) && (r.versions = e.versions.map(e => t.Version.fromJSON(e))), (0, s.isSet)(e.state) && (r.state = d(e.state)), (0, s.isSet)(e.counterparty) && (r.counterparty = t.Counterparty.fromJSON(e.counterparty)), (0, s.isSet)(e.delayPeriod) && (r.delayPeriod = BigInt(e.delayPeriod.toString())), r
                },
                toJSON(e) {
                    let r = {};
                    return void 0 !== e.clientId && (r.clientId = e.clientId), e.versions ? r.versions = e.versions.map(e => e ? t.Version.toJSON(e) : void 0) : r.versions = [], void 0 !== e.state && (r.state = c(e.state)), void 0 !== e.counterparty && (r.counterparty = e.counterparty ? t.Counterparty.toJSON(e.counterparty) : void 0), void 0 !== e.delayPeriod && (r.delayPeriod = (e.delayPeriod || BigInt(0)).toString()), r
                },
                fromPartial(e) {
                    let r = l();
                    return r.clientId = e.clientId ? ? "", r.versions = e.versions ? .map(e => t.Version.fromPartial(e)) || [], r.state = e.state ? ? 0, void 0 !== e.counterparty && null !== e.counterparty && (r.counterparty = t.Counterparty.fromPartial(e.counterparty)), void 0 !== e.delayPeriod && null !== e.delayPeriod && (r.delayPeriod = BigInt(e.delayPeriod.toString())), r
                }
            }, t.IdentifiedConnection = {
                typeUrl: "/ibc.core.connection.v1.IdentifiedConnection",
                encode(e, r = a.BinaryWriter.create()) {
                    for (let n of ("" !== e.id && r.uint32(10).string(e.id), "" !== e.clientId && r.uint32(18).string(e.clientId), e.versions)) t.Version.encode(n, r.uint32(26).fork()).ldelim();
                    return 0 !== e.state && r.uint32(32).int32(e.state), void 0 !== e.counterparty && t.Counterparty.encode(e.counterparty, r.uint32(42).fork()).ldelim(), e.delayPeriod !== BigInt(0) && r.uint32(48).uint64(e.delayPeriod), r
                },
                decode(e, r) {
                    let n = e instanceof a.BinaryReader ? e : new a.BinaryReader(e),
                        o = void 0 === r ? n.len : n.pos + r,
                        i = u();
                    for (; n.pos < o;) {
                        let e = n.uint32();
                        switch (e >>> 3) {
                            case 1:
                                i.id = n.string();
                                break;
                            case 2:
                                i.clientId = n.string();
                                break;
                            case 3:
                                i.versions.push(t.Version.decode(n, n.uint32()));
                                break;
                            case 4:
                                i.state = n.int32();
                                break;
                            case 5:
                                i.counterparty = t.Counterparty.decode(n, n.uint32());
                                break;
                            case 6:
                                i.delayPeriod = n.uint64();
                                break;
                            default:
                                n.skipType(7 & e)
                        }
                    }
                    return i
                },
                fromJSON(e) {
                    let r = u();
                    return (0, s.isSet)(e.id) && (r.id = String(e.id)), (0, s.isSet)(e.clientId) && (r.clientId = String(e.clientId)), Array.isArray(e ? .versions) && (r.versions = e.versions.map(e => t.Version.fromJSON(e))), (0, s.isSet)(e.state) && (r.state = d(e.state)), (0, s.isSet)(e.counterparty) && (r.counterparty = t.Counterparty.fromJSON(e.counterparty)), (0, s.isSet)(e.delayPeriod) && (r.delayPeriod = BigInt(e.delayPeriod.toString())), r
                },
                toJSON(e) {
                    let r = {};
                    return void 0 !== e.id && (r.id = e.id), void 0 !== e.clientId && (r.clientId = e.clientId), e.versions ? r.versions = e.versions.map(e => e ? t.Version.toJSON(e) : void 0) : r.versions = [], void 0 !== e.state && (r.state = c(e.state)), void 0 !== e.counterparty && (r.counterparty = e.counterparty ? t.Counterparty.toJSON(e.counterparty) : void 0), void 0 !== e.delayPeriod && (r.delayPeriod = (e.delayPeriod || BigInt(0)).toString()), r
                },
                fromPartial(e) {
                    let r = u();
                    return r.id = e.id ? ? "", r.clientId = e.clientId ? ? "", r.versions = e.versions ? .map(e => t.Version.fromPartial(e)) || [], r.state = e.state ? ? 0, void 0 !== e.counterparty && null !== e.counterparty && (r.counterparty = t.Counterparty.fromPartial(e.counterparty)), void 0 !== e.delayPeriod && null !== e.delayPeriod && (r.delayPeriod = BigInt(e.delayPeriod.toString())), r
                }
            }, t.Counterparty = {
                typeUrl: "/ibc.core.connection.v1.Counterparty",
                encode: (e, t = a.BinaryWriter.create()) => ("" !== e.clientId && t.uint32(10).string(e.clientId), "" !== e.connectionId && t.uint32(18).string(e.connectionId), void 0 !== e.prefix && i.MerklePrefix.encode(e.prefix, t.uint32(26).fork()).ldelim(), t),
                decode(e, t) {
                    let r = e instanceof a.BinaryReader ? e : new a.BinaryReader(e),
                        n = void 0 === t ? r.len : r.pos + t,
                        o = p();
                    for (; r.pos < n;) {
                        let e = r.uint32();
                        switch (e >>> 3) {
                            case 1:
                                o.clientId = r.string();
                                break;
                            case 2:
                                o.connectionId = r.string();
                                break;
                            case 3:
                                o.prefix = i.MerklePrefix.decode(r, r.uint32());
                                break;
                            default:
                                r.skipType(7 & e)
                        }
                    }
                    return o
                },
                fromJSON(e) {
                    let t = p();
                    return (0, s.isSet)(e.clientId) && (t.clientId = String(e.clientId)), (0, s.isSet)(e.connectionId) && (t.connectionId = String(e.connectionId)), (0, s.isSet)(e.prefix) && (t.prefix = i.MerklePrefix.fromJSON(e.prefix)), t
                },
                toJSON(e) {
                    let t = {};
                    return void 0 !== e.clientId && (t.clientId = e.clientId), void 0 !== e.connectionId && (t.connectionId = e.connectionId), void 0 !== e.prefix && (t.prefix = e.prefix ? i.MerklePrefix.toJSON(e.prefix) : void 0), t
                },
                fromPartial(e) {
                    let t = p();
                    return t.clientId = e.clientId ? ? "", t.connectionId = e.connectionId ? ? "", void 0 !== e.prefix && null !== e.prefix && (t.prefix = i.MerklePrefix.fromPartial(e.prefix)), t
                }
            }, t.ClientPaths = {
                typeUrl: "/ibc.core.connection.v1.ClientPaths",
                encode(e, t = a.BinaryWriter.create()) {
                    for (let r of e.paths) t.uint32(10).string(r);
                    return t
                },
                decode(e, t) {
                    let r = e instanceof a.BinaryReader ? e : new a.BinaryReader(e),
                        n = void 0 === t ? r.len : r.pos + t,
                        o = m();
                    for (; r.pos < n;) {
                        let e = r.uint32();
                        e >>> 3 == 1 ? o.paths.push(r.string()) : r.skipType(7 & e)
                    }
                    return o
                },
                fromJSON(e) {
                    let t = m();
                    return Array.isArray(e ? .paths) && (t.paths = e.paths.map(e => String(e))), t
                },
                toJSON(e) {
                    let t = {};
                    return e.paths ? t.paths = e.paths.map(e => e) : t.paths = [], t
                },
                fromPartial(e) {
                    let t = m();
                    return t.paths = e.paths ? .map(e => e) || [], t
                }
            }, t.ConnectionPaths = {
                typeUrl: "/ibc.core.connection.v1.ConnectionPaths",
                encode(e, t = a.BinaryWriter.create()) {
                    for (let r of ("" !== e.clientId && t.uint32(10).string(e.clientId), e.paths)) t.uint32(18).string(r);
                    return t
                },
                decode(e, t) {
                    let r = e instanceof a.BinaryReader ? e : new a.BinaryReader(e),
                        n = void 0 === t ? r.len : r.pos + t,
                        o = g();
                    for (; r.pos < n;) {
                        let e = r.uint32();
                        switch (e >>> 3) {
                            case 1:
                                o.clientId = r.string();
                                break;
                            case 2:
                                o.paths.push(r.string());
                                break;
                            default:
                                r.skipType(7 & e)
                        }
                    }
                    return o
                },
                fromJSON(e) {
                    let t = g();
                    return (0, s.isSet)(e.clientId) && (t.clientId = String(e.clientId)), Array.isArray(e ? .paths) && (t.paths = e.paths.map(e => String(e))), t
                },
                toJSON(e) {
                    let t = {};
                    return void 0 !== e.clientId && (t.clientId = e.clientId), e.paths ? t.paths = e.paths.map(e => e) : t.paths = [], t
                },
                fromPartial(e) {
                    let t = g();
                    return t.clientId = e.clientId ? ? "", t.paths = e.paths ? .map(e => e) || [], t
                }
            }, t.Version = {
                typeUrl: "/ibc.core.connection.v1.Version",
                encode(e, t = a.BinaryWriter.create()) {
                    for (let r of ("" !== e.identifier && t.uint32(10).string(e.identifier), e.features)) t.uint32(18).string(r);
                    return t
                },
                decode(e, t) {
                    let r = e instanceof a.BinaryReader ? e : new a.BinaryReader(e),
                        n = void 0 === t ? r.len : r.pos + t,
                        o = f();
                    for (; r.pos < n;) {
                        let e = r.uint32();
                        switch (e >>> 3) {
                            case 1:
                                o.identifier = r.string();
                                break;
                            case 2:
                                o.features.push(r.string());
                                break;
                            default:
                                r.skipType(7 & e)
                        }
                    }
                    return o
                },
                fromJSON(e) {
                    let t = f();
                    return (0, s.isSet)(e.identifier) && (t.identifier = String(e.identifier)), Array.isArray(e ? .features) && (t.features = e.features.map(e => String(e))), t
                },
                toJSON(e) {
                    let t = {};
                    return void 0 !== e.identifier && (t.identifier = e.identifier), e.features ? t.features = e.features.map(e => e) : t.features = [], t
                },
                fromPartial(e) {
                    let t = f();
                    return t.identifier = e.identifier ? ? "", t.features = e.features ? .map(e => e) || [], t
                }
            }, t.Params = {
                typeUrl: "/ibc.core.connection.v1.Params",
                encode: (e, t = a.BinaryWriter.create()) => (e.maxExpectedTimePerBlock !== BigInt(0) && t.uint32(8).uint64(e.maxExpectedTimePerBlock), t),
                decode(e, t) {
                    let r = e instanceof a.BinaryReader ? e : new a.BinaryReader(e),
                        n = void 0 === t ? r.len : r.pos + t,
                        o = y();
                    for (; r.pos < n;) {
                        let e = r.uint32();
                        e >>> 3 == 1 ? o.maxExpectedTimePerBlock = r.uint64() : r.skipType(7 & e)
                    }
                    return o
                },
                fromJSON(e) {
                    let t = y();
                    return (0, s.isSet)(e.maxExpectedTimePerBlock) && (t.maxExpectedTimePerBlock = BigInt(e.maxExpectedTimePerBlock.toString())), t
                },
                toJSON(e) {
                    let t = {};
                    return void 0 !== e.maxExpectedTimePerBlock && (t.maxExpectedTimePerBlock = (e.maxExpectedTimePerBlock || BigInt(0)).toString()), t
                },
                fromPartial(e) {
                    let t = y();
                    return void 0 !== e.maxExpectedTimePerBlock && null !== e.maxExpectedTimePerBlock && (t.maxExpectedTimePerBlock = BigInt(e.maxExpectedTimePerBlock.toString())), t
                }
            }
        },
        36754: function(e, t, r) {
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: !0
            }), t.QueryClientImpl = t.QueryConnectionParamsResponse = t.QueryConnectionParamsRequest = t.QueryConnectionConsensusStateResponse = t.QueryConnectionConsensusStateRequest = t.QueryConnectionClientStateResponse = t.QueryConnectionClientStateRequest = t.QueryClientConnectionsResponse = t.QueryClientConnectionsRequest = t.QueryConnectionsResponse = t.QueryConnectionsRequest = t.QueryConnectionResponse = t.QueryConnectionRequest = t.protobufPackage = void 0;
            let n = r(38792),
                o = r(30416),
                i = r(24648),
                a = r(65676),
                s = r(28486),
                d = r(6476);

            function c() {
                return {
                    connectionId: ""
                }
            }

            function l() {
                return {
                    connection: void 0,
                    proof: new Uint8Array,
                    proofHeight: i.Height.fromPartial({})
                }
            }

            function u() {
                return {
                    pagination: void 0
                }
            }

            function p() {
                return {
                    connections: [],
                    pagination: void 0,
                    height: i.Height.fromPartial({})
                }
            }

            function m() {
                return {
                    clientId: ""
                }
            }

            function g() {
                return {
                    connectionPaths: [],
                    proof: new Uint8Array,
                    proofHeight: i.Height.fromPartial({})
                }
            }

            function f() {
                return {
                    connectionId: ""
                }
            }

            function y() {
                return {
                    identifiedClientState: void 0,
                    proof: new Uint8Array,
                    proofHeight: i.Height.fromPartial({})
                }
            }

            function h() {
                return {
                    connectionId: "",
                    revisionNumber: BigInt(0),
                    revisionHeight: BigInt(0)
                }
            }

            function v() {
                return {
                    consensusState: void 0,
                    clientId: "",
                    proof: new Uint8Array,
                    proofHeight: i.Height.fromPartial({})
                }
            }

            function b() {
                return {
                    params: void 0
                }
            }
            t.protobufPackage = "ibc.core.connection.v1", t.QueryConnectionRequest = {
                typeUrl: "/ibc.core.connection.v1.QueryConnectionRequest",
                encode: (e, t = s.BinaryWriter.create()) => ("" !== e.connectionId && t.uint32(10).string(e.connectionId), t),
                decode(e, t) {
                    let r = e instanceof s.BinaryReader ? e : new s.BinaryReader(e),
                        n = void 0 === t ? r.len : r.pos + t,
                        o = c();
                    for (; r.pos < n;) {
                        let e = r.uint32();
                        e >>> 3 == 1 ? o.connectionId = r.string() : r.skipType(7 & e)
                    }
                    return o
                },
                fromJSON(e) {
                    let t = c();
                    return (0, d.isSet)(e.connectionId) && (t.connectionId = String(e.connectionId)), t
                },
                toJSON(e) {
                    let t = {};
                    return void 0 !== e.connectionId && (t.connectionId = e.connectionId), t
                },
                fromPartial(e) {
                    let t = c();
                    return t.connectionId = e.connectionId ? ? "", t
                }
            }, t.QueryConnectionResponse = {
                typeUrl: "/ibc.core.connection.v1.QueryConnectionResponse",
                encode: (e, t = s.BinaryWriter.create()) => (void 0 !== e.connection && o.ConnectionEnd.encode(e.connection, t.uint32(10).fork()).ldelim(), 0 !== e.proof.length && t.uint32(18).bytes(e.proof), void 0 !== e.proofHeight && i.Height.encode(e.proofHeight, t.uint32(26).fork()).ldelim(), t),
                decode(e, t) {
                    let r = e instanceof s.BinaryReader ? e : new s.BinaryReader(e),
                        n = void 0 === t ? r.len : r.pos + t,
                        a = l();
                    for (; r.pos < n;) {
                        let e = r.uint32();
                        switch (e >>> 3) {
                            case 1:
                                a.connection = o.ConnectionEnd.decode(r, r.uint32());
                                break;
                            case 2:
                                a.proof = r.bytes();
                                break;
                            case 3:
                                a.proofHeight = i.Height.decode(r, r.uint32());
                                break;
                            default:
                                r.skipType(7 & e)
                        }
                    }
                    return a
                },
                fromJSON(e) {
                    let t = l();
                    return (0, d.isSet)(e.connection) && (t.connection = o.ConnectionEnd.fromJSON(e.connection)), (0, d.isSet)(e.proof) && (t.proof = (0, d.bytesFromBase64)(e.proof)), (0, d.isSet)(e.proofHeight) && (t.proofHeight = i.Height.fromJSON(e.proofHeight)), t
                },
                toJSON(e) {
                    let t = {};
                    return void 0 !== e.connection && (t.connection = e.connection ? o.ConnectionEnd.toJSON(e.connection) : void 0), void 0 !== e.proof && (t.proof = (0, d.base64FromBytes)(void 0 !== e.proof ? e.proof : new Uint8Array)), void 0 !== e.proofHeight && (t.proofHeight = e.proofHeight ? i.Height.toJSON(e.proofHeight) : void 0), t
                },
                fromPartial(e) {
                    let t = l();
                    return void 0 !== e.connection && null !== e.connection && (t.connection = o.ConnectionEnd.fromPartial(e.connection)), t.proof = e.proof ? ? new Uint8Array, void 0 !== e.proofHeight && null !== e.proofHeight && (t.proofHeight = i.Height.fromPartial(e.proofHeight)), t
                }
            }, t.QueryConnectionsRequest = {
                typeUrl: "/ibc.core.connection.v1.QueryConnectionsRequest",
                encode: (e, t = s.BinaryWriter.create()) => (void 0 !== e.pagination && n.PageRequest.encode(e.pagination, t.uint32(10).fork()).ldelim(), t),
                decode(e, t) {
                    let r = e instanceof s.BinaryReader ? e : new s.BinaryReader(e),
                        o = void 0 === t ? r.len : r.pos + t,
                        i = u();
                    for (; r.pos < o;) {
                        let e = r.uint32();
                        e >>> 3 == 1 ? i.pagination = n.PageRequest.decode(r, r.uint32()) : r.skipType(7 & e)
                    }
                    return i
                },
                fromJSON(e) {
                    let t = u();
                    return (0, d.isSet)(e.pagination) && (t.pagination = n.PageRequest.fromJSON(e.pagination)), t
                },
                toJSON(e) {
                    let t = {};
                    return void 0 !== e.pagination && (t.pagination = e.pagination ? n.PageRequest.toJSON(e.pagination) : void 0), t
                },
                fromPartial(e) {
                    let t = u();
                    return void 0 !== e.pagination && null !== e.pagination && (t.pagination = n.PageRequest.fromPartial(e.pagination)), t
                }
            }, t.QueryConnectionsResponse = {
                typeUrl: "/ibc.core.connection.v1.QueryConnectionsResponse",
                encode(e, t = s.BinaryWriter.create()) {
                    for (let r of e.connections) o.IdentifiedConnection.encode(r, t.uint32(10).fork()).ldelim();
                    return void 0 !== e.pagination && n.PageResponse.encode(e.pagination, t.uint32(18).fork()).ldelim(), void 0 !== e.height && i.Height.encode(e.height, t.uint32(26).fork()).ldelim(), t
                },
                decode(e, t) {
                    let r = e instanceof s.BinaryReader ? e : new s.BinaryReader(e),
                        a = void 0 === t ? r.len : r.pos + t,
                        d = p();
                    for (; r.pos < a;) {
                        let e = r.uint32();
                        switch (e >>> 3) {
                            case 1:
                                d.connections.push(o.IdentifiedConnection.decode(r, r.uint32()));
                                break;
                            case 2:
                                d.pagination = n.PageResponse.decode(r, r.uint32());
                                break;
                            case 3:
                                d.height = i.Height.decode(r, r.uint32());
                                break;
                            default:
                                r.skipType(7 & e)
                        }
                    }
                    return d
                },
                fromJSON(e) {
                    let t = p();
                    return Array.isArray(e ? .connections) && (t.connections = e.connections.map(e => o.IdentifiedConnection.fromJSON(e))), (0, d.isSet)(e.pagination) && (t.pagination = n.PageResponse.fromJSON(e.pagination)), (0, d.isSet)(e.height) && (t.height = i.Height.fromJSON(e.height)), t
                },
                toJSON(e) {
                    let t = {};
                    return e.connections ? t.connections = e.connections.map(e => e ? o.IdentifiedConnection.toJSON(e) : void 0) : t.connections = [], void 0 !== e.pagination && (t.pagination = e.pagination ? n.PageResponse.toJSON(e.pagination) : void 0), void 0 !== e.height && (t.height = e.height ? i.Height.toJSON(e.height) : void 0), t
                },
                fromPartial(e) {
                    let t = p();
                    return t.connections = e.connections ? .map(e => o.IdentifiedConnection.fromPartial(e)) || [], void 0 !== e.pagination && null !== e.pagination && (t.pagination = n.PageResponse.fromPartial(e.pagination)), void 0 !== e.height && null !== e.height && (t.height = i.Height.fromPartial(e.height)), t
                }
            }, t.QueryClientConnectionsRequest = {
                typeUrl: "/ibc.core.connection.v1.QueryClientConnectionsRequest",
                encode: (e, t = s.BinaryWriter.create()) => ("" !== e.clientId && t.uint32(10).string(e.clientId), t),
                decode(e, t) {
                    let r = e instanceof s.BinaryReader ? e : new s.BinaryReader(e),
                        n = void 0 === t ? r.len : r.pos + t,
                        o = m();
                    for (; r.pos < n;) {
                        let e = r.uint32();
                        e >>> 3 == 1 ? o.clientId = r.string() : r.skipType(7 & e)
                    }
                    return o
                },
                fromJSON(e) {
                    let t = m();
                    return (0, d.isSet)(e.clientId) && (t.clientId = String(e.clientId)), t
                },
                toJSON(e) {
                    let t = {};
                    return void 0 !== e.clientId && (t.clientId = e.clientId), t
                },
                fromPartial(e) {
                    let t = m();
                    return t.clientId = e.clientId ? ? "", t
                }
            }, t.QueryClientConnectionsResponse = {
                typeUrl: "/ibc.core.connection.v1.QueryClientConnectionsResponse",
                encode(e, t = s.BinaryWriter.create()) {
                    for (let r of e.connectionPaths) t.uint32(10).string(r);
                    return 0 !== e.proof.length && t.uint32(18).bytes(e.proof), void 0 !== e.proofHeight && i.Height.encode(e.proofHeight, t.uint32(26).fork()).ldelim(), t
                },
                decode(e, t) {
                    let r = e instanceof s.BinaryReader ? e : new s.BinaryReader(e),
                        n = void 0 === t ? r.len : r.pos + t,
                        o = g();
                    for (; r.pos < n;) {
                        let e = r.uint32();
                        switch (e >>> 3) {
                            case 1:
                                o.connectionPaths.push(r.string());
                                break;
                            case 2:
                                o.proof = r.bytes();
                                break;
                            case 3:
                                o.proofHeight = i.Height.decode(r, r.uint32());
                                break;
                            default:
                                r.skipType(7 & e)
                        }
                    }
                    return o
                },
                fromJSON(e) {
                    let t = g();
                    return Array.isArray(e ? .connectionPaths) && (t.connectionPaths = e.connectionPaths.map(e => String(e))), (0, d.isSet)(e.proof) && (t.proof = (0, d.bytesFromBase64)(e.proof)), (0, d.isSet)(e.proofHeight) && (t.proofHeight = i.Height.fromJSON(e.proofHeight)), t
                },
                toJSON(e) {
                    let t = {};
                    return e.connectionPaths ? t.connectionPaths = e.connectionPaths.map(e => e) : t.connectionPaths = [], void 0 !== e.proof && (t.proof = (0, d.base64FromBytes)(void 0 !== e.proof ? e.proof : new Uint8Array)), void 0 !== e.proofHeight && (t.proofHeight = e.proofHeight ? i.Height.toJSON(e.proofHeight) : void 0), t
                },
                fromPartial(e) {
                    let t = g();
                    return t.connectionPaths = e.connectionPaths ? .map(e => e) || [], t.proof = e.proof ? ? new Uint8Array, void 0 !== e.proofHeight && null !== e.proofHeight && (t.proofHeight = i.Height.fromPartial(e.proofHeight)), t
                }
            }, t.QueryConnectionClientStateRequest = {
                typeUrl: "/ibc.core.connection.v1.QueryConnectionClientStateRequest",
                encode: (e, t = s.BinaryWriter.create()) => ("" !== e.connectionId && t.uint32(10).string(e.connectionId), t),
                decode(e, t) {
                    let r = e instanceof s.BinaryReader ? e : new s.BinaryReader(e),
                        n = void 0 === t ? r.len : r.pos + t,
                        o = f();
                    for (; r.pos < n;) {
                        let e = r.uint32();
                        e >>> 3 == 1 ? o.connectionId = r.string() : r.skipType(7 & e)
                    }
                    return o
                },
                fromJSON(e) {
                    let t = f();
                    return (0, d.isSet)(e.connectionId) && (t.connectionId = String(e.connectionId)), t
                },
                toJSON(e) {
                    let t = {};
                    return void 0 !== e.connectionId && (t.connectionId = e.connectionId), t
                },
                fromPartial(e) {
                    let t = f();
                    return t.connectionId = e.connectionId ? ? "", t
                }
            }, t.QueryConnectionClientStateResponse = {
                typeUrl: "/ibc.core.connection.v1.QueryConnectionClientStateResponse",
                encode: (e, t = s.BinaryWriter.create()) => (void 0 !== e.identifiedClientState && i.IdentifiedClientState.encode(e.identifiedClientState, t.uint32(10).fork()).ldelim(), 0 !== e.proof.length && t.uint32(18).bytes(e.proof), void 0 !== e.proofHeight && i.Height.encode(e.proofHeight, t.uint32(26).fork()).ldelim(), t),
                decode(e, t) {
                    let r = e instanceof s.BinaryReader ? e : new s.BinaryReader(e),
                        n = void 0 === t ? r.len : r.pos + t,
                        o = y();
                    for (; r.pos < n;) {
                        let e = r.uint32();
                        switch (e >>> 3) {
                            case 1:
                                o.identifiedClientState = i.IdentifiedClientState.decode(r, r.uint32());
                                break;
                            case 2:
                                o.proof = r.bytes();
                                break;
                            case 3:
                                o.proofHeight = i.Height.decode(r, r.uint32());
                                break;
                            default:
                                r.skipType(7 & e)
                        }
                    }
                    return o
                },
                fromJSON(e) {
                    let t = y();
                    return (0, d.isSet)(e.identifiedClientState) && (t.identifiedClientState = i.IdentifiedClientState.fromJSON(e.identifiedClientState)), (0, d.isSet)(e.proof) && (t.proof = (0, d.bytesFromBase64)(e.proof)), (0, d.isSet)(e.proofHeight) && (t.proofHeight = i.Height.fromJSON(e.proofHeight)), t
                },
                toJSON(e) {
                    let t = {};
                    return void 0 !== e.identifiedClientState && (t.identifiedClientState = e.identifiedClientState ? i.IdentifiedClientState.toJSON(e.identifiedClientState) : void 0), void 0 !== e.proof && (t.proof = (0, d.base64FromBytes)(void 0 !== e.proof ? e.proof : new Uint8Array)), void 0 !== e.proofHeight && (t.proofHeight = e.proofHeight ? i.Height.toJSON(e.proofHeight) : void 0), t
                },
                fromPartial(e) {
                    let t = y();
                    return void 0 !== e.identifiedClientState && null !== e.identifiedClientState && (t.identifiedClientState = i.IdentifiedClientState.fromPartial(e.identifiedClientState)), t.proof = e.proof ? ? new Uint8Array, void 0 !== e.proofHeight && null !== e.proofHeight && (t.proofHeight = i.Height.fromPartial(e.proofHeight)), t
                }
            }, t.QueryConnectionConsensusStateRequest = {
                typeUrl: "/ibc.core.connection.v1.QueryConnectionConsensusStateRequest",
                encode: (e, t = s.BinaryWriter.create()) => ("" !== e.connectionId && t.uint32(10).string(e.connectionId), e.revisionNumber !== BigInt(0) && t.uint32(16).uint64(e.revisionNumber), e.revisionHeight !== BigInt(0) && t.uint32(24).uint64(e.revisionHeight), t),
                decode(e, t) {
                    let r = e instanceof s.BinaryReader ? e : new s.BinaryReader(e),
                        n = void 0 === t ? r.len : r.pos + t,
                        o = h();
                    for (; r.pos < n;) {
                        let e = r.uint32();
                        switch (e >>> 3) {
                            case 1:
                                o.connectionId = r.string();
                                break;
                            case 2:
                                o.revisionNumber = r.uint64();
                                break;
                            case 3:
                                o.revisionHeight = r.uint64();
                                break;
                            default:
                                r.skipType(7 & e)
                        }
                    }
                    return o
                },
                fromJSON(e) {
                    let t = h();
                    return (0, d.isSet)(e.connectionId) && (t.connectionId = String(e.connectionId)), (0, d.isSet)(e.revisionNumber) && (t.revisionNumber = BigInt(e.revisionNumber.toString())), (0, d.isSet)(e.revisionHeight) && (t.revisionHeight = BigInt(e.revisionHeight.toString())), t
                },
                toJSON(e) {
                    let t = {};
                    return void 0 !== e.connectionId && (t.connectionId = e.connectionId), void 0 !== e.revisionNumber && (t.revisionNumber = (e.revisionNumber || BigInt(0)).toString()), void 0 !== e.revisionHeight && (t.revisionHeight = (e.revisionHeight || BigInt(0)).toString()), t
                },
                fromPartial(e) {
                    let t = h();
                    return t.connectionId = e.connectionId ? ? "", void 0 !== e.revisionNumber && null !== e.revisionNumber && (t.revisionNumber = BigInt(e.revisionNumber.toString())), void 0 !== e.revisionHeight && null !== e.revisionHeight && (t.revisionHeight = BigInt(e.revisionHeight.toString())), t
                }
            }, t.QueryConnectionConsensusStateResponse = {
                typeUrl: "/ibc.core.connection.v1.QueryConnectionConsensusStateResponse",
                encode: (e, t = s.BinaryWriter.create()) => (void 0 !== e.consensusState && a.Any.encode(e.consensusState, t.uint32(10).fork()).ldelim(), "" !== e.clientId && t.uint32(18).string(e.clientId), 0 !== e.proof.length && t.uint32(26).bytes(e.proof), void 0 !== e.proofHeight && i.Height.encode(e.proofHeight, t.uint32(34).fork()).ldelim(), t),
                decode(e, t) {
                    let r = e instanceof s.BinaryReader ? e : new s.BinaryReader(e),
                        n = void 0 === t ? r.len : r.pos + t,
                        o = v();
                    for (; r.pos < n;) {
                        let e = r.uint32();
                        switch (e >>> 3) {
                            case 1:
                                o.consensusState = a.Any.decode(r, r.uint32());
                                break;
                            case 2:
                                o.clientId = r.string();
                                break;
                            case 3:
                                o.proof = r.bytes();
                                break;
                            case 4:
                                o.proofHeight = i.Height.decode(r, r.uint32());
                                break;
                            default:
                                r.skipType(7 & e)
                        }
                    }
                    return o
                },
                fromJSON(e) {
                    let t = v();
                    return (0, d.isSet)(e.consensusState) && (t.consensusState = a.Any.fromJSON(e.consensusState)), (0, d.isSet)(e.clientId) && (t.clientId = String(e.clientId)), (0, d.isSet)(e.proof) && (t.proof = (0, d.bytesFromBase64)(e.proof)), (0, d.isSet)(e.proofHeight) && (t.proofHeight = i.Height.fromJSON(e.proofHeight)), t
                },
                toJSON(e) {
                    let t = {};
                    return void 0 !== e.consensusState && (t.consensusState = e.consensusState ? a.Any.toJSON(e.consensusState) : void 0), void 0 !== e.clientId && (t.clientId = e.clientId), void 0 !== e.proof && (t.proof = (0, d.base64FromBytes)(void 0 !== e.proof ? e.proof : new Uint8Array)), void 0 !== e.proofHeight && (t.proofHeight = e.proofHeight ? i.Height.toJSON(e.proofHeight) : void 0), t
                },
                fromPartial(e) {
                    let t = v();
                    return void 0 !== e.consensusState && null !== e.consensusState && (t.consensusState = a.Any.fromPartial(e.consensusState)), t.clientId = e.clientId ? ? "", t.proof = e.proof ? ? new Uint8Array, void 0 !== e.proofHeight && null !== e.proofHeight && (t.proofHeight = i.Height.fromPartial(e.proofHeight)), t
                }
            }, t.QueryConnectionParamsRequest = {
                typeUrl: "/ibc.core.connection.v1.QueryConnectionParamsRequest",
                encode: (e, t = s.BinaryWriter.create()) => t,
                decode(e, t) {
                    let r = e instanceof s.BinaryReader ? e : new s.BinaryReader(e),
                        n = void 0 === t ? r.len : r.pos + t;
                    for (; r.pos < n;) {
                        let e = r.uint32();
                        r.skipType(7 & e)
                    }
                    return {}
                },
                fromJSON: e => ({}),
                toJSON: e => ({}),
                fromPartial: e => ({})
            }, t.QueryConnectionParamsResponse = {
                typeUrl: "/ibc.core.connection.v1.QueryConnectionParamsResponse",
                encode: (e, t = s.BinaryWriter.create()) => (void 0 !== e.params && i.Params.encode(e.params, t.uint32(10).fork()).ldelim(), t),
                decode(e, t) {
                    let r = e instanceof s.BinaryReader ? e : new s.BinaryReader(e),
                        n = void 0 === t ? r.len : r.pos + t,
                        o = b();
                    for (; r.pos < n;) {
                        let e = r.uint32();
                        e >>> 3 == 1 ? o.params = i.Params.decode(r, r.uint32()) : r.skipType(7 & e)
                    }
                    return o
                },
                fromJSON(e) {
                    let t = b();
                    return (0, d.isSet)(e.params) && (t.params = i.Params.fromJSON(e.params)), t
                },
                toJSON(e) {
                    let t = {};
                    return void 0 !== e.params && (t.params = e.params ? i.Params.toJSON(e.params) : void 0), t
                },
                fromPartial(e) {
                    let t = b();
                    return void 0 !== e.params && null !== e.params && (t.params = i.Params.fromPartial(e.params)), t
                }
            };
            class S {
                constructor(e) {
                    this.rpc = e, this.Connection = this.Connection.bind(this), this.Connections = this.Connections.bind(this), this.ClientConnections = this.ClientConnections.bind(this), this.ConnectionClientState = this.ConnectionClientState.bind(this), this.ConnectionConsensusState = this.ConnectionConsensusState.bind(this), this.ConnectionParams = this.ConnectionParams.bind(this)
                }
                Connection(e) {
                    let r = t.QueryConnectionRequest.encode(e).finish();
                    return this.rpc.request("ibc.core.connection.v1.Query", "Connection", r).then(e => t.QueryConnectionResponse.decode(new s.BinaryReader(e)))
                }
                Connections(e = {
                    pagination: n.PageRequest.fromPartial({})
                }) {
                    let r = t.QueryConnectionsRequest.encode(e).finish();
                    return this.rpc.request("ibc.core.connection.v1.Query", "Connections", r).then(e => t.QueryConnectionsResponse.decode(new s.BinaryReader(e)))
                }
                ClientConnections(e) {
                    let r = t.QueryClientConnectionsRequest.encode(e).finish();
                    return this.rpc.request("ibc.core.connection.v1.Query", "ClientConnections", r).then(e => t.QueryClientConnectionsResponse.decode(new s.BinaryReader(e)))
                }
                ConnectionClientState(e) {
                    let r = t.QueryConnectionClientStateRequest.encode(e).finish();
                    return this.rpc.request("ibc.core.connection.v1.Query", "ConnectionClientState", r).then(e => t.QueryConnectionClientStateResponse.decode(new s.BinaryReader(e)))
                }
                ConnectionConsensusState(e) {
                    let r = t.QueryConnectionConsensusStateRequest.encode(e).finish();
                    return this.rpc.request("ibc.core.connection.v1.Query", "ConnectionConsensusState", r).then(e => t.QueryConnectionConsensusStateResponse.decode(new s.BinaryReader(e)))
                }
                ConnectionParams(e = {}) {
                    let r = t.QueryConnectionParamsRequest.encode(e).finish();
                    return this.rpc.request("ibc.core.connection.v1.Query", "ConnectionParams", r).then(e => t.QueryConnectionParamsResponse.decode(new s.BinaryReader(e)))
                }
            }
            t.QueryClientImpl = S
        },
        71031: function(e, t, r) {
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: !0
            }), t.MsgClientImpl = t.MsgConnectionOpenConfirmResponse = t.MsgConnectionOpenConfirm = t.MsgConnectionOpenAckResponse = t.MsgConnectionOpenAck = t.MsgConnectionOpenTryResponse = t.MsgConnectionOpenTry = t.MsgConnectionOpenInitResponse = t.MsgConnectionOpenInit = t.protobufPackage = void 0;
            let n = r(30416),
                o = r(65676),
                i = r(24648),
                a = r(28486),
                s = r(6476);

            function d() {
                return {
                    clientId: "",
                    counterparty: n.Counterparty.fromPartial({}),
                    version: void 0,
                    delayPeriod: BigInt(0),
                    signer: ""
                }
            }

            function c() {
                return {
                    clientId: "",
                    previousConnectionId: "",
                    clientState: void 0,
                    counterparty: n.Counterparty.fromPartial({}),
                    delayPeriod: BigInt(0),
                    counterpartyVersions: [],
                    proofHeight: i.Height.fromPartial({}),
                    proofInit: new Uint8Array,
                    proofClient: new Uint8Array,
                    proofConsensus: new Uint8Array,
                    consensusHeight: i.Height.fromPartial({}),
                    signer: "",
                    hostConsensusStateProof: new Uint8Array
                }
            }

            function l() {
                return {
                    connectionId: "",
                    counterpartyConnectionId: "",
                    version: void 0,
                    clientState: void 0,
                    proofHeight: i.Height.fromPartial({}),
                    proofTry: new Uint8Array,
                    proofClient: new Uint8Array,
                    proofConsensus: new Uint8Array,
                    consensusHeight: i.Height.fromPartial({}),
                    signer: "",
                    hostConsensusStateProof: new Uint8Array
                }
            }

            function u() {
                return {
                    connectionId: "",
                    proofAck: new Uint8Array,
                    proofHeight: i.Height.fromPartial({}),
                    signer: ""
                }
            }
            t.protobufPackage = "ibc.core.connection.v1", t.MsgConnectionOpenInit = {
                typeUrl: "/ibc.core.connection.v1.MsgConnectionOpenInit",
                encode: (e, t = a.BinaryWriter.create()) => ("" !== e.clientId && t.uint32(10).string(e.clientId), void 0 !== e.counterparty && n.Counterparty.encode(e.counterparty, t.uint32(18).fork()).ldelim(), void 0 !== e.version && n.Version.encode(e.version, t.uint32(26).fork()).ldelim(), e.delayPeriod !== BigInt(0) && t.uint32(32).uint64(e.delayPeriod), "" !== e.signer && t.uint32(42).string(e.signer), t),
                decode(e, t) {
                    let r = e instanceof a.BinaryReader ? e : new a.BinaryReader(e),
                        o = void 0 === t ? r.len : r.pos + t,
                        i = d();
                    for (; r.pos < o;) {
                        let e = r.uint32();
                        switch (e >>> 3) {
                            case 1:
                                i.clientId = r.string();
                                break;
                            case 2:
                                i.counterparty = n.Counterparty.decode(r, r.uint32());
                                break;
                            case 3:
                                i.version = n.Version.decode(r, r.uint32());
                                break;
                            case 4:
                                i.delayPeriod = r.uint64();
                                break;
                            case 5:
                                i.signer = r.string();
                                break;
                            default:
                                r.skipType(7 & e)
                        }
                    }
                    return i
                },
                fromJSON(e) {
                    let t = d();
                    return (0, s.isSet)(e.clientId) && (t.clientId = String(e.clientId)), (0, s.isSet)(e.counterparty) && (t.counterparty = n.Counterparty.fromJSON(e.counterparty)), (0, s.isSet)(e.version) && (t.version = n.Version.fromJSON(e.version)), (0, s.isSet)(e.delayPeriod) && (t.delayPeriod = BigInt(e.delayPeriod.toString())), (0, s.isSet)(e.signer) && (t.signer = String(e.signer)), t
                },
                toJSON(e) {
                    let t = {};
                    return void 0 !== e.clientId && (t.clientId = e.clientId), void 0 !== e.counterparty && (t.counterparty = e.counterparty ? n.Counterparty.toJSON(e.counterparty) : void 0), void 0 !== e.version && (t.version = e.version ? n.Version.toJSON(e.version) : void 0), void 0 !== e.delayPeriod && (t.delayPeriod = (e.delayPeriod || BigInt(0)).toString()), void 0 !== e.signer && (t.signer = e.signer), t
                },
                fromPartial(e) {
                    let t = d();
                    return t.clientId = e.clientId ? ? "", void 0 !== e.counterparty && null !== e.counterparty && (t.counterparty = n.Counterparty.fromPartial(e.counterparty)), void 0 !== e.version && null !== e.version && (t.version = n.Version.fromPartial(e.version)), void 0 !== e.delayPeriod && null !== e.delayPeriod && (t.delayPeriod = BigInt(e.delayPeriod.toString())), t.signer = e.signer ? ? "", t
                }
            }, t.MsgConnectionOpenInitResponse = {
                typeUrl: "/ibc.core.connection.v1.MsgConnectionOpenInitResponse",
                encode: (e, t = a.BinaryWriter.create()) => t,
                decode(e, t) {
                    let r = e instanceof a.BinaryReader ? e : new a.BinaryReader(e),
                        n = void 0 === t ? r.len : r.pos + t;
                    for (; r.pos < n;) {
                        let e = r.uint32();
                        r.skipType(7 & e)
                    }
                    return {}
                },
                fromJSON: e => ({}),
                toJSON: e => ({}),
                fromPartial: e => ({})
            }, t.MsgConnectionOpenTry = {
                typeUrl: "/ibc.core.connection.v1.MsgConnectionOpenTry",
                encode(e, t = a.BinaryWriter.create()) {
                    for (let r of ("" !== e.clientId && t.uint32(10).string(e.clientId), "" !== e.previousConnectionId && t.uint32(18).string(e.previousConnectionId), void 0 !== e.clientState && o.Any.encode(e.clientState, t.uint32(26).fork()).ldelim(), void 0 !== e.counterparty && n.Counterparty.encode(e.counterparty, t.uint32(34).fork()).ldelim(), e.delayPeriod !== BigInt(0) && t.uint32(40).uint64(e.delayPeriod), e.counterpartyVersions)) n.Version.encode(r, t.uint32(50).fork()).ldelim();
                    return void 0 !== e.proofHeight && i.Height.encode(e.proofHeight, t.uint32(58).fork()).ldelim(), 0 !== e.proofInit.length && t.uint32(66).bytes(e.proofInit), 0 !== e.proofClient.length && t.uint32(74).bytes(e.proofClient), 0 !== e.proofConsensus.length && t.uint32(82).bytes(e.proofConsensus), void 0 !== e.consensusHeight && i.Height.encode(e.consensusHeight, t.uint32(90).fork()).ldelim(), "" !== e.signer && t.uint32(98).string(e.signer), 0 !== e.hostConsensusStateProof.length && t.uint32(106).bytes(e.hostConsensusStateProof), t
                },
                decode(e, t) {
                    let r = e instanceof a.BinaryReader ? e : new a.BinaryReader(e),
                        s = void 0 === t ? r.len : r.pos + t,
                        d = c();
                    for (; r.pos < s;) {
                        let e = r.uint32();
                        switch (e >>> 3) {
                            case 1:
                                d.clientId = r.string();
                                break;
                            case 2:
                                d.previousConnectionId = r.string();
                                break;
                            case 3:
                                d.clientState = o.Any.decode(r, r.uint32());
                                break;
                            case 4:
                                d.counterparty = n.Counterparty.decode(r, r.uint32());
                                break;
                            case 5:
                                d.delayPeriod = r.uint64();
                                break;
                            case 6:
                                d.counterpartyVersions.push(n.Version.decode(r, r.uint32()));
                                break;
                            case 7:
                                d.proofHeight = i.Height.decode(r, r.uint32());
                                break;
                            case 8:
                                d.proofInit = r.bytes();
                                break;
                            case 9:
                                d.proofClient = r.bytes();
                                break;
                            case 10:
                                d.proofConsensus = r.bytes();
                                break;
                            case 11:
                                d.consensusHeight = i.Height.decode(r, r.uint32());
                                break;
                            case 12:
                                d.signer = r.string();
                                break;
                            case 13:
                                d.hostConsensusStateProof = r.bytes();
                                break;
                            default:
                                r.skipType(7 & e)
                        }
                    }
                    return d
                },
                fromJSON(e) {
                    let t = c();
                    return (0, s.isSet)(e.clientId) && (t.clientId = String(e.clientId)), (0, s.isSet)(e.previousConnectionId) && (t.previousConnectionId = String(e.previousConnectionId)), (0, s.isSet)(e.clientState) && (t.clientState = o.Any.fromJSON(e.clientState)), (0, s.isSet)(e.counterparty) && (t.counterparty = n.Counterparty.fromJSON(e.counterparty)), (0, s.isSet)(e.delayPeriod) && (t.delayPeriod = BigInt(e.delayPeriod.toString())), Array.isArray(e ? .counterpartyVersions) && (t.counterpartyVersions = e.counterpartyVersions.map(e => n.Version.fromJSON(e))), (0, s.isSet)(e.proofHeight) && (t.proofHeight = i.Height.fromJSON(e.proofHeight)), (0, s.isSet)(e.proofInit) && (t.proofInit = (0, s.bytesFromBase64)(e.proofInit)), (0, s.isSet)(e.proofClient) && (t.proofClient = (0, s.bytesFromBase64)(e.proofClient)), (0, s.isSet)(e.proofConsensus) && (t.proofConsensus = (0, s.bytesFromBase64)(e.proofConsensus)), (0, s.isSet)(e.consensusHeight) && (t.consensusHeight = i.Height.fromJSON(e.consensusHeight)), (0, s.isSet)(e.signer) && (t.signer = String(e.signer)), (0, s.isSet)(e.hostConsensusStateProof) && (t.hostConsensusStateProof = (0, s.bytesFromBase64)(e.hostConsensusStateProof)), t
                },
                toJSON(e) {
                    let t = {};
                    return void 0 !== e.clientId && (t.clientId = e.clientId), void 0 !== e.previousConnectionId && (t.previousConnectionId = e.previousConnectionId), void 0 !== e.clientState && (t.clientState = e.clientState ? o.Any.toJSON(e.clientState) : void 0), void 0 !== e.counterparty && (t.counterparty = e.counterparty ? n.Counterparty.toJSON(e.counterparty) : void 0), void 0 !== e.delayPeriod && (t.delayPeriod = (e.delayPeriod || BigInt(0)).toString()), e.counterpartyVersions ? t.counterpartyVersions = e.counterpartyVersions.map(e => e ? n.Version.toJSON(e) : void 0) : t.counterpartyVersions = [], void 0 !== e.proofHeight && (t.proofHeight = e.proofHeight ? i.Height.toJSON(e.proofHeight) : void 0), void 0 !== e.proofInit && (t.proofInit = (0, s.base64FromBytes)(void 0 !== e.proofInit ? e.proofInit : new Uint8Array)), void 0 !== e.proofClient && (t.proofClient = (0, s.base64FromBytes)(void 0 !== e.proofClient ? e.proofClient : new Uint8Array)), void 0 !== e.proofConsensus && (t.proofConsensus = (0, s.base64FromBytes)(void 0 !== e.proofConsensus ? e.proofConsensus : new Uint8Array)), void 0 !== e.consensusHeight && (t.consensusHeight = e.consensusHeight ? i.Height.toJSON(e.consensusHeight) : void 0), void 0 !== e.signer && (t.signer = e.signer), void 0 !== e.hostConsensusStateProof && (t.hostConsensusStateProof = (0, s.base64FromBytes)(void 0 !== e.hostConsensusStateProof ? e.hostConsensusStateProof : new Uint8Array)), t
                },
                fromPartial(e) {
                    let t = c();
                    return t.clientId = e.clientId ? ? "", t.previousConnectionId = e.previousConnectionId ? ? "", void 0 !== e.clientState && null !== e.clientState && (t.clientState = o.Any.fromPartial(e.clientState)), void 0 !== e.counterparty && null !== e.counterparty && (t.counterparty = n.Counterparty.fromPartial(e.counterparty)), void 0 !== e.delayPeriod && null !== e.delayPeriod && (t.delayPeriod = BigInt(e.delayPeriod.toString())), t.counterpartyVersions = e.counterpartyVersions ? .map(e => n.Version.fromPartial(e)) || [], void 0 !== e.proofHeight && null !== e.proofHeight && (t.proofHeight = i.Height.fromPartial(e.proofHeight)), t.proofInit = e.proofInit ? ? new Uint8Array, t.proofClient = e.proofClient ? ? new Uint8Array, t.proofConsensus = e.proofConsensus ? ? new Uint8Array, void 0 !== e.consensusHeight && null !== e.consensusHeight && (t.consensusHeight = i.Height.fromPartial(e.consensusHeight)), t.signer = e.signer ? ? "", t.hostConsensusStateProof = e.hostConsensusStateProof ? ? new Uint8Array, t
                }
            }, t.MsgConnectionOpenTryResponse = {
                typeUrl: "/ibc.core.connection.v1.MsgConnectionOpenTryResponse",
                encode: (e, t = a.BinaryWriter.create()) => t,
                decode(e, t) {
                    let r = e instanceof a.BinaryReader ? e : new a.BinaryReader(e),
                        n = void 0 === t ? r.len : r.pos + t;
                    for (; r.pos < n;) {
                        let e = r.uint32();
                        r.skipType(7 & e)
                    }
                    return {}
                },
                fromJSON: e => ({}),
                toJSON: e => ({}),
                fromPartial: e => ({})
            }, t.MsgConnectionOpenAck = {
                typeUrl: "/ibc.core.connection.v1.MsgConnectionOpenAck",
                encode: (e, t = a.BinaryWriter.create()) => ("" !== e.connectionId && t.uint32(10).string(e.connectionId), "" !== e.counterpartyConnectionId && t.uint32(18).string(e.counterpartyConnectionId), void 0 !== e.version && n.Version.encode(e.version, t.uint32(26).fork()).ldelim(), void 0 !== e.clientState && o.Any.encode(e.clientState, t.uint32(34).fork()).ldelim(), void 0 !== e.proofHeight && i.Height.encode(e.proofHeight, t.uint32(42).fork()).ldelim(), 0 !== e.proofTry.length && t.uint32(50).bytes(e.proofTry), 0 !== e.proofClient.length && t.uint32(58).bytes(e.proofClient), 0 !== e.proofConsensus.length && t.uint32(66).bytes(e.proofConsensus), void 0 !== e.consensusHeight && i.Height.encode(e.consensusHeight, t.uint32(74).fork()).ldelim(), "" !== e.signer && t.uint32(82).string(e.signer), 0 !== e.hostConsensusStateProof.length && t.uint32(90).bytes(e.hostConsensusStateProof), t),
                decode(e, t) {
                    let r = e instanceof a.BinaryReader ? e : new a.BinaryReader(e),
                        s = void 0 === t ? r.len : r.pos + t,
                        d = l();
                    for (; r.pos < s;) {
                        let e = r.uint32();
                        switch (e >>> 3) {
                            case 1:
                                d.connectionId = r.string();
                                break;
                            case 2:
                                d.counterpartyConnectionId = r.string();
                                break;
                            case 3:
                                d.version = n.Version.decode(r, r.uint32());
                                break;
                            case 4:
                                d.clientState = o.Any.decode(r, r.uint32());
                                break;
                            case 5:
                                d.proofHeight = i.Height.decode(r, r.uint32());
                                break;
                            case 6:
                                d.proofTry = r.bytes();
                                break;
                            case 7:
                                d.proofClient = r.bytes();
                                break;
                            case 8:
                                d.proofConsensus = r.bytes();
                                break;
                            case 9:
                                d.consensusHeight = i.Height.decode(r, r.uint32());
                                break;
                            case 10:
                                d.signer = r.string();
                                break;
                            case 11:
                                d.hostConsensusStateProof = r.bytes();
                                break;
                            default:
                                r.skipType(7 & e)
                        }
                    }
                    return d
                },
                fromJSON(e) {
                    let t = l();
                    return (0, s.isSet)(e.connectionId) && (t.connectionId = String(e.connectionId)), (0, s.isSet)(e.counterpartyConnectionId) && (t.counterpartyConnectionId = String(e.counterpartyConnectionId)), (0, s.isSet)(e.version) && (t.version = n.Version.fromJSON(e.version)), (0, s.isSet)(e.clientState) && (t.clientState = o.Any.fromJSON(e.clientState)), (0, s.isSet)(e.proofHeight) && (t.proofHeight = i.Height.fromJSON(e.proofHeight)), (0, s.isSet)(e.proofTry) && (t.proofTry = (0, s.bytesFromBase64)(e.proofTry)), (0, s.isSet)(e.proofClient) && (t.proofClient = (0, s.bytesFromBase64)(e.proofClient)), (0, s.isSet)(e.proofConsensus) && (t.proofConsensus = (0, s.bytesFromBase64)(e.proofConsensus)), (0, s.isSet)(e.consensusHeight) && (t.consensusHeight = i.Height.fromJSON(e.consensusHeight)), (0, s.isSet)(e.signer) && (t.signer = String(e.signer)), (0, s.isSet)(e.hostConsensusStateProof) && (t.hostConsensusStateProof = (0, s.bytesFromBase64)(e.hostConsensusStateProof)), t
                },
                toJSON(e) {
                    let t = {};
                    return void 0 !== e.connectionId && (t.connectionId = e.connectionId), void 0 !== e.counterpartyConnectionId && (t.counterpartyConnectionId = e.counterpartyConnectionId), void 0 !== e.version && (t.version = e.version ? n.Version.toJSON(e.version) : void 0), void 0 !== e.clientState && (t.clientState = e.clientState ? o.Any.toJSON(e.clientState) : void 0), void 0 !== e.proofHeight && (t.proofHeight = e.proofHeight ? i.Height.toJSON(e.proofHeight) : void 0), void 0 !== e.proofTry && (t.proofTry = (0, s.base64FromBytes)(void 0 !== e.proofTry ? e.proofTry : new Uint8Array)), void 0 !== e.proofClient && (t.proofClient = (0, s.base64FromBytes)(void 0 !== e.proofClient ? e.proofClient : new Uint8Array)), void 0 !== e.proofConsensus && (t.proofConsensus = (0, s.base64FromBytes)(void 0 !== e.proofConsensus ? e.proofConsensus : new Uint8Array)), void 0 !== e.consensusHeight && (t.consensusHeight = e.consensusHeight ? i.Height.toJSON(e.consensusHeight) : void 0), void 0 !== e.signer && (t.signer = e.signer), void 0 !== e.hostConsensusStateProof && (t.hostConsensusStateProof = (0, s.base64FromBytes)(void 0 !== e.hostConsensusStateProof ? e.hostConsensusStateProof : new Uint8Array)), t
                },
                fromPartial(e) {
                    let t = l();
                    return t.connectionId = e.connectionId ? ? "", t.counterpartyConnectionId = e.counterpartyConnectionId ? ? "", void 0 !== e.version && null !== e.version && (t.version = n.Version.fromPartial(e.version)), void 0 !== e.clientState && null !== e.clientState && (t.clientState = o.Any.fromPartial(e.clientState)), void 0 !== e.proofHeight && null !== e.proofHeight && (t.proofHeight = i.Height.fromPartial(e.proofHeight)), t.proofTry = e.proofTry ? ? new Uint8Array, t.proofClient = e.proofClient ? ? new Uint8Array, t.proofConsensus = e.proofConsensus ? ? new Uint8Array, void 0 !== e.consensusHeight && null !== e.consensusHeight && (t.consensusHeight = i.Height.fromPartial(e.consensusHeight)), t.signer = e.signer ? ? "", t.hostConsensusStateProof = e.hostConsensusStateProof ? ? new Uint8Array, t
                }
            }, t.MsgConnectionOpenAckResponse = {
                typeUrl: "/ibc.core.connection.v1.MsgConnectionOpenAckResponse",
                encode: (e, t = a.BinaryWriter.create()) => t,
                decode(e, t) {
                    let r = e instanceof a.BinaryReader ? e : new a.BinaryReader(e),
                        n = void 0 === t ? r.len : r.pos + t;
                    for (; r.pos < n;) {
                        let e = r.uint32();
                        r.skipType(7 & e)
                    }
                    return {}
                },
                fromJSON: e => ({}),
                toJSON: e => ({}),
                fromPartial: e => ({})
            }, t.MsgConnectionOpenConfirm = {
                typeUrl: "/ibc.core.connection.v1.MsgConnectionOpenConfirm",
                encode: (e, t = a.BinaryWriter.create()) => ("" !== e.connectionId && t.uint32(10).string(e.connectionId), 0 !== e.proofAck.length && t.uint32(18).bytes(e.proofAck), void 0 !== e.proofHeight && i.Height.encode(e.proofHeight, t.uint32(26).fork()).ldelim(), "" !== e.signer && t.uint32(34).string(e.signer), t),
                decode(e, t) {
                    let r = e instanceof a.BinaryReader ? e : new a.BinaryReader(e),
                        n = void 0 === t ? r.len : r.pos + t,
                        o = u();
                    for (; r.pos < n;) {
                        let e = r.uint32();
                        switch (e >>> 3) {
                            case 1:
                                o.connectionId = r.string();
                                break;
                            case 2:
                                o.proofAck = r.bytes();
                                break;
                            case 3:
                                o.proofHeight = i.Height.decode(r, r.uint32());
                                break;
                            case 4:
                                o.signer = r.string();
                                break;
                            default:
                                r.skipType(7 & e)
                        }
                    }
                    return o
                },
                fromJSON(e) {
                    let t = u();
                    return (0, s.isSet)(e.connectionId) && (t.connectionId = String(e.connectionId)), (0, s.isSet)(e.proofAck) && (t.proofAck = (0, s.bytesFromBase64)(e.proofAck)), (0, s.isSet)(e.proofHeight) && (t.proofHeight = i.Height.fromJSON(e.proofHeight)), (0, s.isSet)(e.signer) && (t.signer = String(e.signer)), t
                },
                toJSON(e) {
                    let t = {};
                    return void 0 !== e.connectionId && (t.connectionId = e.connectionId), void 0 !== e.proofAck && (t.proofAck = (0, s.base64FromBytes)(void 0 !== e.proofAck ? e.proofAck : new Uint8Array)), void 0 !== e.proofHeight && (t.proofHeight = e.proofHeight ? i.Height.toJSON(e.proofHeight) : void 0), void 0 !== e.signer && (t.signer = e.signer), t
                },
                fromPartial(e) {
                    let t = u();
                    return t.connectionId = e.connectionId ? ? "", t.proofAck = e.proofAck ? ? new Uint8Array, void 0 !== e.proofHeight && null !== e.proofHeight && (t.proofHeight = i.Height.fromPartial(e.proofHeight)), t.signer = e.signer ? ? "", t
                }
            }, t.MsgConnectionOpenConfirmResponse = {
                typeUrl: "/ibc.core.connection.v1.MsgConnectionOpenConfirmResponse",
                encode: (e, t = a.BinaryWriter.create()) => t,
                decode(e, t) {
                    let r = e instanceof a.BinaryReader ? e : new a.BinaryReader(e),
                        n = void 0 === t ? r.len : r.pos + t;
                    for (; r.pos < n;) {
                        let e = r.uint32();
                        r.skipType(7 & e)
                    }
                    return {}
                },
                fromJSON: e => ({}),
                toJSON: e => ({}),
                fromPartial: e => ({})
            };
            class p {
                constructor(e) {
                    this.rpc = e, this.ConnectionOpenInit = this.ConnectionOpenInit.bind(this), this.ConnectionOpenTry = this.ConnectionOpenTry.bind(this), this.ConnectionOpenAck = this.ConnectionOpenAck.bind(this), this.ConnectionOpenConfirm = this.ConnectionOpenConfirm.bind(this)
                }
                ConnectionOpenInit(e) {
                    let r = t.MsgConnectionOpenInit.encode(e).finish();
                    return this.rpc.request("ibc.core.connection.v1.Msg", "ConnectionOpenInit", r).then(e => t.MsgConnectionOpenInitResponse.decode(new a.BinaryReader(e)))
                }
                ConnectionOpenTry(e) {
                    let r = t.MsgConnectionOpenTry.encode(e).finish();
                    return this.rpc.request("ibc.core.connection.v1.Msg", "ConnectionOpenTry", r).then(e => t.MsgConnectionOpenTryResponse.decode(new a.BinaryReader(e)))
                }
                ConnectionOpenAck(e) {
                    let r = t.MsgConnectionOpenAck.encode(e).finish();
                    return this.rpc.request("ibc.core.connection.v1.Msg", "ConnectionOpenAck", r).then(e => t.MsgConnectionOpenAckResponse.decode(new a.BinaryReader(e)))
                }
                ConnectionOpenConfirm(e) {
                    let r = t.MsgConnectionOpenConfirm.encode(e).finish();
                    return this.rpc.request("ibc.core.connection.v1.Msg", "ConnectionOpenConfirm", r).then(e => t.MsgConnectionOpenConfirmResponse.decode(new a.BinaryReader(e)))
                }
            }
            t.MsgClientImpl = p
        },
        99665: function(e, t, r) {
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: !0
            }), t.Fraction = t.Header = t.Misbehaviour = t.ConsensusState = t.ClientState = t.protobufPackage = void 0;
            let n = r(69441),
                o = r(24648),
                i = r(51570),
                a = r(90614),
                s = r(52673),
                d = r(64255),
                c = r(13002),
                l = r(28486),
                u = r(6476);

            function p() {
                return {
                    chainId: "",
                    trustLevel: t.Fraction.fromPartial({}),
                    trustingPeriod: n.Duration.fromPartial({}),
                    unbondingPeriod: n.Duration.fromPartial({}),
                    maxClockDrift: n.Duration.fromPartial({}),
                    frozenHeight: o.Height.fromPartial({}),
                    latestHeight: o.Height.fromPartial({}),
                    proofSpecs: [],
                    upgradePath: [],
                    allowUpdateAfterExpiry: !1,
                    allowUpdateAfterMisbehaviour: !1
                }
            }

            function m() {
                return {
                    timestamp: a.Timestamp.fromPartial({}),
                    root: s.MerkleRoot.fromPartial({}),
                    nextValidatorsHash: new Uint8Array
                }
            }

            function g() {
                return {
                    clientId: "",
                    header1: void 0,
                    header2: void 0
                }
            }

            function f() {
                return {
                    signedHeader: void 0,
                    validatorSet: void 0,
                    trustedHeight: o.Height.fromPartial({}),
                    trustedValidators: void 0
                }
            }

            function y() {
                return {
                    numerator: BigInt(0),
                    denominator: BigInt(0)
                }
            }
            t.protobufPackage = "ibc.lightclients.tendermint.v1", t.ClientState = {
                typeUrl: "/ibc.lightclients.tendermint.v1.ClientState",
                encode(e, r = l.BinaryWriter.create()) {
                    for (let a of ("" !== e.chainId && r.uint32(10).string(e.chainId), void 0 !== e.trustLevel && t.Fraction.encode(e.trustLevel, r.uint32(18).fork()).ldelim(), void 0 !== e.trustingPeriod && n.Duration.encode(e.trustingPeriod, r.uint32(26).fork()).ldelim(), void 0 !== e.unbondingPeriod && n.Duration.encode(e.unbondingPeriod, r.uint32(34).fork()).ldelim(), void 0 !== e.maxClockDrift && n.Duration.encode(e.maxClockDrift, r.uint32(42).fork()).ldelim(), void 0 !== e.frozenHeight && o.Height.encode(e.frozenHeight, r.uint32(50).fork()).ldelim(), void 0 !== e.latestHeight && o.Height.encode(e.latestHeight, r.uint32(58).fork()).ldelim(), e.proofSpecs)) i.ProofSpec.encode(a, r.uint32(66).fork()).ldelim();
                    for (let t of e.upgradePath) r.uint32(74).string(t);
                    return !0 === e.allowUpdateAfterExpiry && r.uint32(80).bool(e.allowUpdateAfterExpiry), !0 === e.allowUpdateAfterMisbehaviour && r.uint32(88).bool(e.allowUpdateAfterMisbehaviour), r
                },
                decode(e, r) {
                    let a = e instanceof l.BinaryReader ? e : new l.BinaryReader(e),
                        s = void 0 === r ? a.len : a.pos + r,
                        d = p();
                    for (; a.pos < s;) {
                        let e = a.uint32();
                        switch (e >>> 3) {
                            case 1:
                                d.chainId = a.string();
                                break;
                            case 2:
                                d.trustLevel = t.Fraction.decode(a, a.uint32());
                                break;
                            case 3:
                                d.trustingPeriod = n.Duration.decode(a, a.uint32());
                                break;
                            case 4:
                                d.unbondingPeriod = n.Duration.decode(a, a.uint32());
                                break;
                            case 5:
                                d.maxClockDrift = n.Duration.decode(a, a.uint32());
                                break;
                            case 6:
                                d.frozenHeight = o.Height.decode(a, a.uint32());
                                break;
                            case 7:
                                d.latestHeight = o.Height.decode(a, a.uint32());
                                break;
                            case 8:
                                d.proofSpecs.push(i.ProofSpec.decode(a, a.uint32()));
                                break;
                            case 9:
                                d.upgradePath.push(a.string());
                                break;
                            case 10:
                                d.allowUpdateAfterExpiry = a.bool();
                                break;
                            case 11:
                                d.allowUpdateAfterMisbehaviour = a.bool();
                                break;
                            default:
                                a.skipType(7 & e)
                        }
                    }
                    return d
                },
                fromJSON(e) {
                    let r = p();
                    return (0, u.isSet)(e.chainId) && (r.chainId = String(e.chainId)), (0, u.isSet)(e.trustLevel) && (r.trustLevel = t.Fraction.fromJSON(e.trustLevel)), (0, u.isSet)(e.trustingPeriod) && (r.trustingPeriod = n.Duration.fromJSON(e.trustingPeriod)), (0, u.isSet)(e.unbondingPeriod) && (r.unbondingPeriod = n.Duration.fromJSON(e.unbondingPeriod)), (0, u.isSet)(e.maxClockDrift) && (r.maxClockDrift = n.Duration.fromJSON(e.maxClockDrift)), (0, u.isSet)(e.frozenHeight) && (r.frozenHeight = o.Height.fromJSON(e.frozenHeight)), (0, u.isSet)(e.latestHeight) && (r.latestHeight = o.Height.fromJSON(e.latestHeight)), Array.isArray(e ? .proofSpecs) && (r.proofSpecs = e.proofSpecs.map(e => i.ProofSpec.fromJSON(e))), Array.isArray(e ? .upgradePath) && (r.upgradePath = e.upgradePath.map(e => String(e))), (0, u.isSet)(e.allowUpdateAfterExpiry) && (r.allowUpdateAfterExpiry = !!e.allowUpdateAfterExpiry), (0, u.isSet)(e.allowUpdateAfterMisbehaviour) && (r.allowUpdateAfterMisbehaviour = !!e.allowUpdateAfterMisbehaviour), r
                },
                toJSON(e) {
                    let r = {};
                    return void 0 !== e.chainId && (r.chainId = e.chainId), void 0 !== e.trustLevel && (r.trustLevel = e.trustLevel ? t.Fraction.toJSON(e.trustLevel) : void 0), void 0 !== e.trustingPeriod && (r.trustingPeriod = e.trustingPeriod ? n.Duration.toJSON(e.trustingPeriod) : void 0), void 0 !== e.unbondingPeriod && (r.unbondingPeriod = e.unbondingPeriod ? n.Duration.toJSON(e.unbondingPeriod) : void 0), void 0 !== e.maxClockDrift && (r.maxClockDrift = e.maxClockDrift ? n.Duration.toJSON(e.maxClockDrift) : void 0), void 0 !== e.frozenHeight && (r.frozenHeight = e.frozenHeight ? o.Height.toJSON(e.frozenHeight) : void 0), void 0 !== e.latestHeight && (r.latestHeight = e.latestHeight ? o.Height.toJSON(e.latestHeight) : void 0), e.proofSpecs ? r.proofSpecs = e.proofSpecs.map(e => e ? i.ProofSpec.toJSON(e) : void 0) : r.proofSpecs = [], e.upgradePath ? r.upgradePath = e.upgradePath.map(e => e) : r.upgradePath = [], void 0 !== e.allowUpdateAfterExpiry && (r.allowUpdateAfterExpiry = e.allowUpdateAfterExpiry), void 0 !== e.allowUpdateAfterMisbehaviour && (r.allowUpdateAfterMisbehaviour = e.allowUpdateAfterMisbehaviour), r
                },
                fromPartial(e) {
                    let r = p();
                    return r.chainId = e.chainId ? ? "", void 0 !== e.trustLevel && null !== e.trustLevel && (r.trustLevel = t.Fraction.fromPartial(e.trustLevel)), void 0 !== e.trustingPeriod && null !== e.trustingPeriod && (r.trustingPeriod = n.Duration.fromPartial(e.trustingPeriod)), void 0 !== e.unbondingPeriod && null !== e.unbondingPeriod && (r.unbondingPeriod = n.Duration.fromPartial(e.unbondingPeriod)), void 0 !== e.maxClockDrift && null !== e.maxClockDrift && (r.maxClockDrift = n.Duration.fromPartial(e.maxClockDrift)), void 0 !== e.frozenHeight && null !== e.frozenHeight && (r.frozenHeight = o.Height.fromPartial(e.frozenHeight)), void 0 !== e.latestHeight && null !== e.latestHeight && (r.latestHeight = o.Height.fromPartial(e.latestHeight)), r.proofSpecs = e.proofSpecs ? .map(e => i.ProofSpec.fromPartial(e)) || [], r.upgradePath = e.upgradePath ? .map(e => e) || [], r.allowUpdateAfterExpiry = e.allowUpdateAfterExpiry ? ? !1, r.allowUpdateAfterMisbehaviour = e.allowUpdateAfterMisbehaviour ? ? !1, r
                }
            }, t.ConsensusState = {
                typeUrl: "/ibc.lightclients.tendermint.v1.ConsensusState",
                encode: (e, t = l.BinaryWriter.create()) => (void 0 !== e.timestamp && a.Timestamp.encode(e.timestamp, t.uint32(10).fork()).ldelim(), void 0 !== e.root && s.MerkleRoot.encode(e.root, t.uint32(18).fork()).ldelim(), 0 !== e.nextValidatorsHash.length && t.uint32(26).bytes(e.nextValidatorsHash), t),
                decode(e, t) {
                    let r = e instanceof l.BinaryReader ? e : new l.BinaryReader(e),
                        n = void 0 === t ? r.len : r.pos + t,
                        o = m();
                    for (; r.pos < n;) {
                        let e = r.uint32();
                        switch (e >>> 3) {
                            case 1:
                                o.timestamp = a.Timestamp.decode(r, r.uint32());
                                break;
                            case 2:
                                o.root = s.MerkleRoot.decode(r, r.uint32());
                                break;
                            case 3:
                                o.nextValidatorsHash = r.bytes();
                                break;
                            default:
                                r.skipType(7 & e)
                        }
                    }
                    return o
                },
                fromJSON(e) {
                    let t = m();
                    return (0, u.isSet)(e.timestamp) && (t.timestamp = (0, u.fromJsonTimestamp)(e.timestamp)), (0, u.isSet)(e.root) && (t.root = s.MerkleRoot.fromJSON(e.root)), (0, u.isSet)(e.nextValidatorsHash) && (t.nextValidatorsHash = (0, u.bytesFromBase64)(e.nextValidatorsHash)), t
                },
                toJSON(e) {
                    let t = {};
                    return void 0 !== e.timestamp && (t.timestamp = (0, u.fromTimestamp)(e.timestamp).toISOString()), void 0 !== e.root && (t.root = e.root ? s.MerkleRoot.toJSON(e.root) : void 0), void 0 !== e.nextValidatorsHash && (t.nextValidatorsHash = (0, u.base64FromBytes)(void 0 !== e.nextValidatorsHash ? e.nextValidatorsHash : new Uint8Array)), t
                },
                fromPartial(e) {
                    let t = m();
                    return void 0 !== e.timestamp && null !== e.timestamp && (t.timestamp = a.Timestamp.fromPartial(e.timestamp)), void 0 !== e.root && null !== e.root && (t.root = s.MerkleRoot.fromPartial(e.root)), t.nextValidatorsHash = e.nextValidatorsHash ? ? new Uint8Array, t
                }
            }, t.Misbehaviour = {
                typeUrl: "/ibc.lightclients.tendermint.v1.Misbehaviour",
                encode: (e, r = l.BinaryWriter.create()) => ("" !== e.clientId && r.uint32(10).string(e.clientId), void 0 !== e.header1 && t.Header.encode(e.header1, r.uint32(18).fork()).ldelim(), void 0 !== e.header2 && t.Header.encode(e.header2, r.uint32(26).fork()).ldelim(), r),
                decode(e, r) {
                    let n = e instanceof l.BinaryReader ? e : new l.BinaryReader(e),
                        o = void 0 === r ? n.len : n.pos + r,
                        i = g();
                    for (; n.pos < o;) {
                        let e = n.uint32();
                        switch (e >>> 3) {
                            case 1:
                                i.clientId = n.string();
                                break;
                            case 2:
                                i.header1 = t.Header.decode(n, n.uint32());
                                break;
                            case 3:
                                i.header2 = t.Header.decode(n, n.uint32());
                                break;
                            default:
                                n.skipType(7 & e)
                        }
                    }
                    return i
                },
                fromJSON(e) {
                    let r = g();
                    return (0, u.isSet)(e.clientId) && (r.clientId = String(e.clientId)), (0, u.isSet)(e.header1) && (r.header1 = t.Header.fromJSON(e.header1)), (0, u.isSet)(e.header2) && (r.header2 = t.Header.fromJSON(e.header2)), r
                },
                toJSON(e) {
                    let r = {};
                    return void 0 !== e.clientId && (r.clientId = e.clientId), void 0 !== e.header1 && (r.header1 = e.header1 ? t.Header.toJSON(e.header1) : void 0), void 0 !== e.header2 && (r.header2 = e.header2 ? t.Header.toJSON(e.header2) : void 0), r
                },
                fromPartial(e) {
                    let r = g();
                    return r.clientId = e.clientId ? ? "", void 0 !== e.header1 && null !== e.header1 && (r.header1 = t.Header.fromPartial(e.header1)), void 0 !== e.header2 && null !== e.header2 && (r.header2 = t.Header.fromPartial(e.header2)), r
                }
            }, t.Header = {
                typeUrl: "/ibc.lightclients.tendermint.v1.Header",
                encode: (e, t = l.BinaryWriter.create()) => (void 0 !== e.signedHeader && d.SignedHeader.encode(e.signedHeader, t.uint32(10).fork()).ldelim(), void 0 !== e.validatorSet && c.ValidatorSet.encode(e.validatorSet, t.uint32(18).fork()).ldelim(), void 0 !== e.trustedHeight && o.Height.encode(e.trustedHeight, t.uint32(26).fork()).ldelim(), void 0 !== e.trustedValidators && c.ValidatorSet.encode(e.trustedValidators, t.uint32(34).fork()).ldelim(), t),
                decode(e, t) {
                    let r = e instanceof l.BinaryReader ? e : new l.BinaryReader(e),
                        n = void 0 === t ? r.len : r.pos + t,
                        i = f();
                    for (; r.pos < n;) {
                        let e = r.uint32();
                        switch (e >>> 3) {
                            case 1:
                                i.signedHeader = d.SignedHeader.decode(r, r.uint32());
                                break;
                            case 2:
                                i.validatorSet = c.ValidatorSet.decode(r, r.uint32());
                                break;
                            case 3:
                                i.trustedHeight = o.Height.decode(r, r.uint32());
                                break;
                            case 4:
                                i.trustedValidators = c.ValidatorSet.decode(r, r.uint32());
                                break;
                            default:
                                r.skipType(7 & e)
                        }
                    }
                    return i
                },
                fromJSON(e) {
                    let t = f();
                    return (0, u.isSet)(e.signedHeader) && (t.signedHeader = d.SignedHeader.fromJSON(e.signedHeader)), (0, u.isSet)(e.validatorSet) && (t.validatorSet = c.ValidatorSet.fromJSON(e.validatorSet)), (0, u.isSet)(e.trustedHeight) && (t.trustedHeight = o.Height.fromJSON(e.trustedHeight)), (0, u.isSet)(e.trustedValidators) && (t.trustedValidators = c.ValidatorSet.fromJSON(e.trustedValidators)), t
                },
                toJSON(e) {
                    let t = {};
                    return void 0 !== e.signedHeader && (t.signedHeader = e.signedHeader ? d.SignedHeader.toJSON(e.signedHeader) : void 0), void 0 !== e.validatorSet && (t.validatorSet = e.validatorSet ? c.ValidatorSet.toJSON(e.validatorSet) : void 0), void 0 !== e.trustedHeight && (t.trustedHeight = e.trustedHeight ? o.Height.toJSON(e.trustedHeight) : void 0), void 0 !== e.trustedValidators && (t.trustedValidators = e.trustedValidators ? c.ValidatorSet.toJSON(e.trustedValidators) : void 0), t
                },
                fromPartial(e) {
                    let t = f();
                    return void 0 !== e.signedHeader && null !== e.signedHeader && (t.signedHeader = d.SignedHeader.fromPartial(e.signedHeader)), void 0 !== e.validatorSet && null !== e.validatorSet && (t.validatorSet = c.ValidatorSet.fromPartial(e.validatorSet)), void 0 !== e.trustedHeight && null !== e.trustedHeight && (t.trustedHeight = o.Height.fromPartial(e.trustedHeight)), void 0 !== e.trustedValidators && null !== e.trustedValidators && (t.trustedValidators = c.ValidatorSet.fromPartial(e.trustedValidators)), t
                }
            }, t.Fraction = {
                typeUrl: "/ibc.lightclients.tendermint.v1.Fraction",
                encode: (e, t = l.BinaryWriter.create()) => (e.numerator !== BigInt(0) && t.uint32(8).uint64(e.numerator), e.denominator !== BigInt(0) && t.uint32(16).uint64(e.denominator), t),
                decode(e, t) {
                    let r = e instanceof l.BinaryReader ? e : new l.BinaryReader(e),
                        n = void 0 === t ? r.len : r.pos + t,
                        o = y();
                    for (; r.pos < n;) {
                        let e = r.uint32();
                        switch (e >>> 3) {
                            case 1:
                                o.numerator = r.uint64();
                                break;
                            case 2:
                                o.denominator = r.uint64();
                                break;
                            default:
                                r.skipType(7 & e)
                        }
                    }
                    return o
                },
                fromJSON(e) {
                    let t = y();
                    return (0, u.isSet)(e.numerator) && (t.numerator = BigInt(e.numerator.toString())), (0, u.isSet)(e.denominator) && (t.denominator = BigInt(e.denominator.toString())), t
                },
                toJSON(e) {
                    let t = {};
                    return void 0 !== e.numerator && (t.numerator = (e.numerator || BigInt(0)).toString()), void 0 !== e.denominator && (t.denominator = (e.denominator || BigInt(0)).toString()), t
                },
                fromPartial(e) {
                    let t = y();
                    return void 0 !== e.numerator && null !== e.numerator && (t.numerator = BigInt(e.numerator.toString())), void 0 !== e.denominator && null !== e.denominator && (t.denominator = BigInt(e.denominator.toString())), t
                }
            }
        },
        39324: function(e, t, r) {
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: !0
            }), t.PublicKey = t.protobufPackage = void 0;
            let n = r(28486),
                o = r(6476);

            function i() {
                return {
                    ed25519: void 0,
                    secp256k1: void 0
                }
            }
            t.protobufPackage = "tendermint.crypto", t.PublicKey = {
                typeUrl: "/tendermint.crypto.PublicKey",
                encode: (e, t = n.BinaryWriter.create()) => (void 0 !== e.ed25519 && t.uint32(10).bytes(e.ed25519), void 0 !== e.secp256k1 && t.uint32(18).bytes(e.secp256k1), t),
                decode(e, t) {
                    let r = e instanceof n.BinaryReader ? e : new n.BinaryReader(e),
                        o = void 0 === t ? r.len : r.pos + t,
                        a = i();
                    for (; r.pos < o;) {
                        let e = r.uint32();
                        switch (e >>> 3) {
                            case 1:
                                a.ed25519 = r.bytes();
                                break;
                            case 2:
                                a.secp256k1 = r.bytes();
                                break;
                            default:
                                r.skipType(7 & e)
                        }
                    }
                    return a
                },
                fromJSON(e) {
                    let t = i();
                    return (0, o.isSet)(e.ed25519) && (t.ed25519 = (0, o.bytesFromBase64)(e.ed25519)), (0, o.isSet)(e.secp256k1) && (t.secp256k1 = (0, o.bytesFromBase64)(e.secp256k1)), t
                },
                toJSON(e) {
                    let t = {};
                    return void 0 !== e.ed25519 && (t.ed25519 = void 0 !== e.ed25519 ? (0, o.base64FromBytes)(e.ed25519) : void 0), void 0 !== e.secp256k1 && (t.secp256k1 = void 0 !== e.secp256k1 ? (0, o.base64FromBytes)(e.secp256k1) : void 0), t
                },
                fromPartial(e) {
                    let t = i();
                    return t.ed25519 = e.ed25519 ? ? void 0, t.secp256k1 = e.secp256k1 ? ? void 0, t
                }
            }
        },
        16208: function(e, t, r) {
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: !0
            }), t.ProofOps = t.ProofOp = t.DominoOp = t.ValueOp = t.Proof = t.protobufPackage = void 0;
            let n = r(28486),
                o = r(6476);

            function i() {
                return {
                    total: BigInt(0),
                    index: BigInt(0),
                    leafHash: new Uint8Array,
                    aunts: []
                }
            }

            function a() {
                return {
                    key: new Uint8Array,
                    proof: void 0
                }
            }

            function s() {
                return {
                    key: "",
                    input: "",
                    output: ""
                }
            }

            function d() {
                return {
                    type: "",
                    key: new Uint8Array,
                    data: new Uint8Array
                }
            }

            function c() {
                return {
                    ops: []
                }
            }
            t.protobufPackage = "tendermint.crypto", t.Proof = {
                typeUrl: "/tendermint.crypto.Proof",
                encode(e, t = n.BinaryWriter.create()) {
                    for (let r of (e.total !== BigInt(0) && t.uint32(8).int64(e.total), e.index !== BigInt(0) && t.uint32(16).int64(e.index), 0 !== e.leafHash.length && t.uint32(26).bytes(e.leafHash), e.aunts)) t.uint32(34).bytes(r);
                    return t
                },
                decode(e, t) {
                    let r = e instanceof n.BinaryReader ? e : new n.BinaryReader(e),
                        o = void 0 === t ? r.len : r.pos + t,
                        a = i();
                    for (; r.pos < o;) {
                        let e = r.uint32();
                        switch (e >>> 3) {
                            case 1:
                                a.total = r.int64();
                                break;
                            case 2:
                                a.index = r.int64();
                                break;
                            case 3:
                                a.leafHash = r.bytes();
                                break;
                            case 4:
                                a.aunts.push(r.bytes());
                                break;
                            default:
                                r.skipType(7 & e)
                        }
                    }
                    return a
                },
                fromJSON(e) {
                    let t = i();
                    return (0, o.isSet)(e.total) && (t.total = BigInt(e.total.toString())), (0, o.isSet)(e.index) && (t.index = BigInt(e.index.toString())), (0, o.isSet)(e.leafHash) && (t.leafHash = (0, o.bytesFromBase64)(e.leafHash)), Array.isArray(e ? .aunts) && (t.aunts = e.aunts.map(e => (0, o.bytesFromBase64)(e))), t
                },
                toJSON(e) {
                    let t = {};
                    return void 0 !== e.total && (t.total = (e.total || BigInt(0)).toString()), void 0 !== e.index && (t.index = (e.index || BigInt(0)).toString()), void 0 !== e.leafHash && (t.leafHash = (0, o.base64FromBytes)(void 0 !== e.leafHash ? e.leafHash : new Uint8Array)), e.aunts ? t.aunts = e.aunts.map(e => (0, o.base64FromBytes)(void 0 !== e ? e : new Uint8Array)) : t.aunts = [], t
                },
                fromPartial(e) {
                    let t = i();
                    return void 0 !== e.total && null !== e.total && (t.total = BigInt(e.total.toString())), void 0 !== e.index && null !== e.index && (t.index = BigInt(e.index.toString())), t.leafHash = e.leafHash ? ? new Uint8Array, t.aunts = e.aunts ? .map(e => e) || [], t
                }
            }, t.ValueOp = {
                typeUrl: "/tendermint.crypto.ValueOp",
                encode: (e, r = n.BinaryWriter.create()) => (0 !== e.key.length && r.uint32(10).bytes(e.key), void 0 !== e.proof && t.Proof.encode(e.proof, r.uint32(18).fork()).ldelim(), r),
                decode(e, r) {
                    let o = e instanceof n.BinaryReader ? e : new n.BinaryReader(e),
                        i = void 0 === r ? o.len : o.pos + r,
                        s = a();
                    for (; o.pos < i;) {
                        let e = o.uint32();
                        switch (e >>> 3) {
                            case 1:
                                s.key = o.bytes();
                                break;
                            case 2:
                                s.proof = t.Proof.decode(o, o.uint32());
                                break;
                            default:
                                o.skipType(7 & e)
                        }
                    }
                    return s
                },
                fromJSON(e) {
                    let r = a();
                    return (0, o.isSet)(e.key) && (r.key = (0, o.bytesFromBase64)(e.key)), (0, o.isSet)(e.proof) && (r.proof = t.Proof.fromJSON(e.proof)), r
                },
                toJSON(e) {
                    let r = {};
                    return void 0 !== e.key && (r.key = (0, o.base64FromBytes)(void 0 !== e.key ? e.key : new Uint8Array)), void 0 !== e.proof && (r.proof = e.proof ? t.Proof.toJSON(e.proof) : void 0), r
                },
                fromPartial(e) {
                    let r = a();
                    return r.key = e.key ? ? new Uint8Array, void 0 !== e.proof && null !== e.proof && (r.proof = t.Proof.fromPartial(e.proof)), r
                }
            }, t.DominoOp = {
                typeUrl: "/tendermint.crypto.DominoOp",
                encode: (e, t = n.BinaryWriter.create()) => ("" !== e.key && t.uint32(10).string(e.key), "" !== e.input && t.uint32(18).string(e.input), "" !== e.output && t.uint32(26).string(e.output), t),
                decode(e, t) {
                    let r = e instanceof n.BinaryReader ? e : new n.BinaryReader(e),
                        o = void 0 === t ? r.len : r.pos + t,
                        i = s();
                    for (; r.pos < o;) {
                        let e = r.uint32();
                        switch (e >>> 3) {
                            case 1:
                                i.key = r.string();
                                break;
                            case 2:
                                i.input = r.string();
                                break;
                            case 3:
                                i.output = r.string();
                                break;
                            default:
                                r.skipType(7 & e)
                        }
                    }
                    return i
                },
                fromJSON(e) {
                    let t = s();
                    return (0, o.isSet)(e.key) && (t.key = String(e.key)), (0, o.isSet)(e.input) && (t.input = String(e.input)), (0, o.isSet)(e.output) && (t.output = String(e.output)), t
                },
                toJSON(e) {
                    let t = {};
                    return void 0 !== e.key && (t.key = e.key), void 0 !== e.input && (t.input = e.input), void 0 !== e.output && (t.output = e.output), t
                },
                fromPartial(e) {
                    let t = s();
                    return t.key = e.key ? ? "", t.input = e.input ? ? "", t.output = e.output ? ? "", t
                }
            }, t.ProofOp = {
                typeUrl: "/tendermint.crypto.ProofOp",
                encode: (e, t = n.BinaryWriter.create()) => ("" !== e.type && t.uint32(10).string(e.type), 0 !== e.key.length && t.uint32(18).bytes(e.key), 0 !== e.data.length && t.uint32(26).bytes(e.data), t),
                decode(e, t) {
                    let r = e instanceof n.BinaryReader ? e : new n.BinaryReader(e),
                        o = void 0 === t ? r.len : r.pos + t,
                        i = d();
                    for (; r.pos < o;) {
                        let e = r.uint32();
                        switch (e >>> 3) {
                            case 1:
                                i.type = r.string();
                                break;
                            case 2:
                                i.key = r.bytes();
                                break;
                            case 3:
                                i.data = r.bytes();
                                break;
                            default:
                                r.skipType(7 & e)
                        }
                    }
                    return i
                },
                fromJSON(e) {
                    let t = d();
                    return (0, o.isSet)(e.type) && (t.type = String(e.type)), (0, o.isSet)(e.key) && (t.key = (0, o.bytesFromBase64)(e.key)), (0, o.isSet)(e.data) && (t.data = (0, o.bytesFromBase64)(e.data)), t
                },
                toJSON(e) {
                    let t = {};
                    return void 0 !== e.type && (t.type = e.type), void 0 !== e.key && (t.key = (0, o.base64FromBytes)(void 0 !== e.key ? e.key : new Uint8Array)), void 0 !== e.data && (t.data = (0, o.base64FromBytes)(void 0 !== e.data ? e.data : new Uint8Array)), t
                },
                fromPartial(e) {
                    let t = d();
                    return t.type = e.type ? ? "", t.key = e.key ? ? new Uint8Array, t.data = e.data ? ? new Uint8Array, t
                }
            }, t.ProofOps = {
                typeUrl: "/tendermint.crypto.ProofOps",
                encode(e, r = n.BinaryWriter.create()) {
                    for (let n of e.ops) t.ProofOp.encode(n, r.uint32(10).fork()).ldelim();
                    return r
                },
                decode(e, r) {
                    let o = e instanceof n.BinaryReader ? e : new n.BinaryReader(e),
                        i = void 0 === r ? o.len : o.pos + r,
                        a = c();
                    for (; o.pos < i;) {
                        let e = o.uint32();
                        e >>> 3 == 1 ? a.ops.push(t.ProofOp.decode(o, o.uint32())) : o.skipType(7 & e)
                    }
                    return a
                },
                fromJSON(e) {
                    let r = c();
                    return Array.isArray(e ? .ops) && (r.ops = e.ops.map(e => t.ProofOp.fromJSON(e))), r
                },
                toJSON(e) {
                    let r = {};
                    return e.ops ? r.ops = e.ops.map(e => e ? t.ProofOp.toJSON(e) : void 0) : r.ops = [], r
                },
                fromPartial(e) {
                    let r = c();
                    return r.ops = e.ops ? .map(e => t.ProofOp.fromPartial(e)) || [], r
                }
            }
        },
        55042: function(e, t, r) {
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: !0
            }), t.Block = t.protobufPackage = void 0;
            let n = r(64255),
                o = r(44414),
                i = r(28486),
                a = r(6476);

            function s() {
                return {
                    header: n.Header.fromPartial({}),
                    data: n.Data.fromPartial({}),
                    evidence: o.EvidenceList.fromPartial({}),
                    lastCommit: void 0
                }
            }
            t.protobufPackage = "tendermint.types", t.Block = {
                typeUrl: "/tendermint.types.Block",
                encode: (e, t = i.BinaryWriter.create()) => (void 0 !== e.header && n.Header.encode(e.header, t.uint32(10).fork()).ldelim(), void 0 !== e.data && n.Data.encode(e.data, t.uint32(18).fork()).ldelim(), void 0 !== e.evidence && o.EvidenceList.encode(e.evidence, t.uint32(26).fork()).ldelim(), void 0 !== e.lastCommit && n.Commit.encode(e.lastCommit, t.uint32(34).fork()).ldelim(), t),
                decode(e, t) {
                    let r = e instanceof i.BinaryReader ? e : new i.BinaryReader(e),
                        a = void 0 === t ? r.len : r.pos + t,
                        d = s();
                    for (; r.pos < a;) {
                        let e = r.uint32();
                        switch (e >>> 3) {
                            case 1:
                                d.header = n.Header.decode(r, r.uint32());
                                break;
                            case 2:
                                d.data = n.Data.decode(r, r.uint32());
                                break;
                            case 3:
                                d.evidence = o.EvidenceList.decode(r, r.uint32());
                                break;
                            case 4:
                                d.lastCommit = n.Commit.decode(r, r.uint32());
                                break;
                            default:
                                r.skipType(7 & e)
                        }
                    }
                    return d
                },
                fromJSON(e) {
                    let t = s();
                    return (0, a.isSet)(e.header) && (t.header = n.Header.fromJSON(e.header)), (0, a.isSet)(e.data) && (t.data = n.Data.fromJSON(e.data)), (0, a.isSet)(e.evidence) && (t.evidence = o.EvidenceList.fromJSON(e.evidence)), (0, a.isSet)(e.lastCommit) && (t.lastCommit = n.Commit.fromJSON(e.lastCommit)), t
                },
                toJSON(e) {
                    let t = {};
                    return void 0 !== e.header && (t.header = e.header ? n.Header.toJSON(e.header) : void 0), void 0 !== e.data && (t.data = e.data ? n.Data.toJSON(e.data) : void 0), void 0 !== e.evidence && (t.evidence = e.evidence ? o.EvidenceList.toJSON(e.evidence) : void 0), void 0 !== e.lastCommit && (t.lastCommit = e.lastCommit ? n.Commit.toJSON(e.lastCommit) : void 0), t
                },
                fromPartial(e) {
                    let t = s();
                    return void 0 !== e.header && null !== e.header && (t.header = n.Header.fromPartial(e.header)), void 0 !== e.data && null !== e.data && (t.data = n.Data.fromPartial(e.data)), void 0 !== e.evidence && null !== e.evidence && (t.evidence = o.EvidenceList.fromPartial(e.evidence)), void 0 !== e.lastCommit && null !== e.lastCommit && (t.lastCommit = n.Commit.fromPartial(e.lastCommit)), t
                }
            }
        },
        44414: function(e, t, r) {
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: !0
            }), t.EvidenceList = t.LightClientAttackEvidence = t.DuplicateVoteEvidence = t.Evidence = t.protobufPackage = void 0;
            let n = r(64255),
                o = r(90614),
                i = r(13002),
                a = r(28486),
                s = r(6476);

            function d() {
                return {
                    duplicateVoteEvidence: void 0,
                    lightClientAttackEvidence: void 0
                }
            }

            function c() {
                return {
                    voteA: void 0,
                    voteB: void 0,
                    totalVotingPower: BigInt(0),
                    validatorPower: BigInt(0),
                    timestamp: o.Timestamp.fromPartial({})
                }
            }

            function l() {
                return {
                    conflictingBlock: void 0,
                    commonHeight: BigInt(0),
                    byzantineValidators: [],
                    totalVotingPower: BigInt(0),
                    timestamp: o.Timestamp.fromPartial({})
                }
            }

            function u() {
                return {
                    evidence: []
                }
            }
            t.protobufPackage = "tendermint.types", t.Evidence = {
                typeUrl: "/tendermint.types.Evidence",
                encode: (e, r = a.BinaryWriter.create()) => (void 0 !== e.duplicateVoteEvidence && t.DuplicateVoteEvidence.encode(e.duplicateVoteEvidence, r.uint32(10).fork()).ldelim(), void 0 !== e.lightClientAttackEvidence && t.LightClientAttackEvidence.encode(e.lightClientAttackEvidence, r.uint32(18).fork()).ldelim(), r),
                decode(e, r) {
                    let n = e instanceof a.BinaryReader ? e : new a.BinaryReader(e),
                        o = void 0 === r ? n.len : n.pos + r,
                        i = d();
                    for (; n.pos < o;) {
                        let e = n.uint32();
                        switch (e >>> 3) {
                            case 1:
                                i.duplicateVoteEvidence = t.DuplicateVoteEvidence.decode(n, n.uint32());
                                break;
                            case 2:
                                i.lightClientAttackEvidence = t.LightClientAttackEvidence.decode(n, n.uint32());
                                break;
                            default:
                                n.skipType(7 & e)
                        }
                    }
                    return i
                },
                fromJSON(e) {
                    let r = d();
                    return (0, s.isSet)(e.duplicateVoteEvidence) && (r.duplicateVoteEvidence = t.DuplicateVoteEvidence.fromJSON(e.duplicateVoteEvidence)), (0, s.isSet)(e.lightClientAttackEvidence) && (r.lightClientAttackEvidence = t.LightClientAttackEvidence.fromJSON(e.lightClientAttackEvidence)), r
                },
                toJSON(e) {
                    let r = {};
                    return void 0 !== e.duplicateVoteEvidence && (r.duplicateVoteEvidence = e.duplicateVoteEvidence ? t.DuplicateVoteEvidence.toJSON(e.duplicateVoteEvidence) : void 0), void 0 !== e.lightClientAttackEvidence && (r.lightClientAttackEvidence = e.lightClientAttackEvidence ? t.LightClientAttackEvidence.toJSON(e.lightClientAttackEvidence) : void 0), r
                },
                fromPartial(e) {
                    let r = d();
                    return void 0 !== e.duplicateVoteEvidence && null !== e.duplicateVoteEvidence && (r.duplicateVoteEvidence = t.DuplicateVoteEvidence.fromPartial(e.duplicateVoteEvidence)), void 0 !== e.lightClientAttackEvidence && null !== e.lightClientAttackEvidence && (r.lightClientAttackEvidence = t.LightClientAttackEvidence.fromPartial(e.lightClientAttackEvidence)), r
                }
            }, t.DuplicateVoteEvidence = {
                typeUrl: "/tendermint.types.DuplicateVoteEvidence",
                encode: (e, t = a.BinaryWriter.create()) => (void 0 !== e.voteA && n.Vote.encode(e.voteA, t.uint32(10).fork()).ldelim(), void 0 !== e.voteB && n.Vote.encode(e.voteB, t.uint32(18).fork()).ldelim(), e.totalVotingPower !== BigInt(0) && t.uint32(24).int64(e.totalVotingPower), e.validatorPower !== BigInt(0) && t.uint32(32).int64(e.validatorPower), void 0 !== e.timestamp && o.Timestamp.encode(e.timestamp, t.uint32(42).fork()).ldelim(), t),
                decode(e, t) {
                    let r = e instanceof a.BinaryReader ? e : new a.BinaryReader(e),
                        i = void 0 === t ? r.len : r.pos + t,
                        s = c();
                    for (; r.pos < i;) {
                        let e = r.uint32();
                        switch (e >>> 3) {
                            case 1:
                                s.voteA = n.Vote.decode(r, r.uint32());
                                break;
                            case 2:
                                s.voteB = n.Vote.decode(r, r.uint32());
                                break;
                            case 3:
                                s.totalVotingPower = r.int64();
                                break;
                            case 4:
                                s.validatorPower = r.int64();
                                break;
                            case 5:
                                s.timestamp = o.Timestamp.decode(r, r.uint32());
                                break;
                            default:
                                r.skipType(7 & e)
                        }
                    }
                    return s
                },
                fromJSON(e) {
                    let t = c();
                    return (0, s.isSet)(e.voteA) && (t.voteA = n.Vote.fromJSON(e.voteA)), (0, s.isSet)(e.voteB) && (t.voteB = n.Vote.fromJSON(e.voteB)), (0, s.isSet)(e.totalVotingPower) && (t.totalVotingPower = BigInt(e.totalVotingPower.toString())), (0, s.isSet)(e.validatorPower) && (t.validatorPower = BigInt(e.validatorPower.toString())), (0, s.isSet)(e.timestamp) && (t.timestamp = (0, s.fromJsonTimestamp)(e.timestamp)), t
                },
                toJSON(e) {
                    let t = {};
                    return void 0 !== e.voteA && (t.voteA = e.voteA ? n.Vote.toJSON(e.voteA) : void 0), void 0 !== e.voteB && (t.voteB = e.voteB ? n.Vote.toJSON(e.voteB) : void 0), void 0 !== e.totalVotingPower && (t.totalVotingPower = (e.totalVotingPower || BigInt(0)).toString()), void 0 !== e.validatorPower && (t.validatorPower = (e.validatorPower || BigInt(0)).toString()), void 0 !== e.timestamp && (t.timestamp = (0, s.fromTimestamp)(e.timestamp).toISOString()), t
                },
                fromPartial(e) {
                    let t = c();
                    return void 0 !== e.voteA && null !== e.voteA && (t.voteA = n.Vote.fromPartial(e.voteA)), void 0 !== e.voteB && null !== e.voteB && (t.voteB = n.Vote.fromPartial(e.voteB)), void 0 !== e.totalVotingPower && null !== e.totalVotingPower && (t.totalVotingPower = BigInt(e.totalVotingPower.toString())), void 0 !== e.validatorPower && null !== e.validatorPower && (t.validatorPower = BigInt(e.validatorPower.toString())), void 0 !== e.timestamp && null !== e.timestamp && (t.timestamp = o.Timestamp.fromPartial(e.timestamp)), t
                }
            }, t.LightClientAttackEvidence = {
                typeUrl: "/tendermint.types.LightClientAttackEvidence",
                encode(e, t = a.BinaryWriter.create()) {
                    for (let r of (void 0 !== e.conflictingBlock && n.LightBlock.encode(e.conflictingBlock, t.uint32(10).fork()).ldelim(), e.commonHeight !== BigInt(0) && t.uint32(16).int64(e.commonHeight), e.byzantineValidators)) i.Validator.encode(r, t.uint32(26).fork()).ldelim();
                    return e.totalVotingPower !== BigInt(0) && t.uint32(32).int64(e.totalVotingPower), void 0 !== e.timestamp && o.Timestamp.encode(e.timestamp, t.uint32(42).fork()).ldelim(), t
                },
                decode(e, t) {
                    let r = e instanceof a.BinaryReader ? e : new a.BinaryReader(e),
                        s = void 0 === t ? r.len : r.pos + t,
                        d = l();
                    for (; r.pos < s;) {
                        let e = r.uint32();
                        switch (e >>> 3) {
                            case 1:
                                d.conflictingBlock = n.LightBlock.decode(r, r.uint32());
                                break;
                            case 2:
                                d.commonHeight = r.int64();
                                break;
                            case 3:
                                d.byzantineValidators.push(i.Validator.decode(r, r.uint32()));
                                break;
                            case 4:
                                d.totalVotingPower = r.int64();
                                break;
                            case 5:
                                d.timestamp = o.Timestamp.decode(r, r.uint32());
                                break;
                            default:
                                r.skipType(7 & e)
                        }
                    }
                    return d
                },
                fromJSON(e) {
                    let t = l();
                    return (0, s.isSet)(e.conflictingBlock) && (t.conflictingBlock = n.LightBlock.fromJSON(e.conflictingBlock)), (0, s.isSet)(e.commonHeight) && (t.commonHeight = BigInt(e.commonHeight.toString())), Array.isArray(e ? .byzantineValidators) && (t.byzantineValidators = e.byzantineValidators.map(e => i.Validator.fromJSON(e))), (0, s.isSet)(e.totalVotingPower) && (t.totalVotingPower = BigInt(e.totalVotingPower.toString())), (0, s.isSet)(e.timestamp) && (t.timestamp = (0, s.fromJsonTimestamp)(e.timestamp)), t
                },
                toJSON(e) {
                    let t = {};
                    return void 0 !== e.conflictingBlock && (t.conflictingBlock = e.conflictingBlock ? n.LightBlock.toJSON(e.conflictingBlock) : void 0), void 0 !== e.commonHeight && (t.commonHeight = (e.commonHeight || BigInt(0)).toString()), e.byzantineValidators ? t.byzantineValidators = e.byzantineValidators.map(e => e ? i.Validator.toJSON(e) : void 0) : t.byzantineValidators = [], void 0 !== e.totalVotingPower && (t.totalVotingPower = (e.totalVotingPower || BigInt(0)).toString()), void 0 !== e.timestamp && (t.timestamp = (0, s.fromTimestamp)(e.timestamp).toISOString()), t
                },
                fromPartial(e) {
                    let t = l();
                    return void 0 !== e.conflictingBlock && null !== e.conflictingBlock && (t.conflictingBlock = n.LightBlock.fromPartial(e.conflictingBlock)), void 0 !== e.commonHeight && null !== e.commonHeight && (t.commonHeight = BigInt(e.commonHeight.toString())), t.byzantineValidators = e.byzantineValidators ? .map(e => i.Validator.fromPartial(e)) || [], void 0 !== e.totalVotingPower && null !== e.totalVotingPower && (t.totalVotingPower = BigInt(e.totalVotingPower.toString())), void 0 !== e.timestamp && null !== e.timestamp && (t.timestamp = o.Timestamp.fromPartial(e.timestamp)), t
                }
            }, t.EvidenceList = {
                typeUrl: "/tendermint.types.EvidenceList",
                encode(e, r = a.BinaryWriter.create()) {
                    for (let n of e.evidence) t.Evidence.encode(n, r.uint32(10).fork()).ldelim();
                    return r
                },
                decode(e, r) {
                    let n = e instanceof a.BinaryReader ? e : new a.BinaryReader(e),
                        o = void 0 === r ? n.len : n.pos + r,
                        i = u();
                    for (; n.pos < o;) {
                        let e = n.uint32();
                        e >>> 3 == 1 ? i.evidence.push(t.Evidence.decode(n, n.uint32())) : n.skipType(7 & e)
                    }
                    return i
                },
                fromJSON(e) {
                    let r = u();
                    return Array.isArray(e ? .evidence) && (r.evidence = e.evidence.map(e => t.Evidence.fromJSON(e))), r
                },
                toJSON(e) {
                    let r = {};
                    return e.evidence ? r.evidence = e.evidence.map(e => e ? t.Evidence.toJSON(e) : void 0) : r.evidence = [], r
                },
                fromPartial(e) {
                    let r = u();
                    return r.evidence = e.evidence ? .map(e => t.Evidence.fromPartial(e)) || [], r
                }
            }
        },
        47289: function(e, t, r) {
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: !0
            }), t.HashedParams = t.VersionParams = t.ValidatorParams = t.EvidenceParams = t.BlockParams = t.ConsensusParams = t.protobufPackage = void 0;
            let n = r(69441),
                o = r(28486),
                i = r(6476);

            function a() {
                return {
                    block: void 0,
                    evidence: void 0,
                    validator: void 0,
                    version: void 0
                }
            }

            function s() {
                return {
                    maxBytes: BigInt(0),
                    maxGas: BigInt(0)
                }
            }

            function d() {
                return {
                    maxAgeNumBlocks: BigInt(0),
                    maxAgeDuration: n.Duration.fromPartial({}),
                    maxBytes: BigInt(0)
                }
            }

            function c() {
                return {
                    pubKeyTypes: []
                }
            }

            function l() {
                return {
                    app: BigInt(0)
                }
            }

            function u() {
                return {
                    blockMaxBytes: BigInt(0),
                    blockMaxGas: BigInt(0)
                }
            }
            t.protobufPackage = "tendermint.types", t.ConsensusParams = {
                typeUrl: "/tendermint.types.ConsensusParams",
                encode: (e, r = o.BinaryWriter.create()) => (void 0 !== e.block && t.BlockParams.encode(e.block, r.uint32(10).fork()).ldelim(), void 0 !== e.evidence && t.EvidenceParams.encode(e.evidence, r.uint32(18).fork()).ldelim(), void 0 !== e.validator && t.ValidatorParams.encode(e.validator, r.uint32(26).fork()).ldelim(), void 0 !== e.version && t.VersionParams.encode(e.version, r.uint32(34).fork()).ldelim(), r),
                decode(e, r) {
                    let n = e instanceof o.BinaryReader ? e : new o.BinaryReader(e),
                        i = void 0 === r ? n.len : n.pos + r,
                        s = a();
                    for (; n.pos < i;) {
                        let e = n.uint32();
                        switch (e >>> 3) {
                            case 1:
                                s.block = t.BlockParams.decode(n, n.uint32());
                                break;
                            case 2:
                                s.evidence = t.EvidenceParams.decode(n, n.uint32());
                                break;
                            case 3:
                                s.validator = t.ValidatorParams.decode(n, n.uint32());
                                break;
                            case 4:
                                s.version = t.VersionParams.decode(n, n.uint32());
                                break;
                            default:
                                n.skipType(7 & e)
                        }
                    }
                    return s
                },
                fromJSON(e) {
                    let r = a();
                    return (0, i.isSet)(e.block) && (r.block = t.BlockParams.fromJSON(e.block)), (0, i.isSet)(e.evidence) && (r.evidence = t.EvidenceParams.fromJSON(e.evidence)), (0, i.isSet)(e.validator) && (r.validator = t.ValidatorParams.fromJSON(e.validator)), (0, i.isSet)(e.version) && (r.version = t.VersionParams.fromJSON(e.version)), r
                },
                toJSON(e) {
                    let r = {};
                    return void 0 !== e.block && (r.block = e.block ? t.BlockParams.toJSON(e.block) : void 0), void 0 !== e.evidence && (r.evidence = e.evidence ? t.EvidenceParams.toJSON(e.evidence) : void 0), void 0 !== e.validator && (r.validator = e.validator ? t.ValidatorParams.toJSON(e.validator) : void 0), void 0 !== e.version && (r.version = e.version ? t.VersionParams.toJSON(e.version) : void 0), r
                },
                fromPartial(e) {
                    let r = a();
                    return void 0 !== e.block && null !== e.block && (r.block = t.BlockParams.fromPartial(e.block)), void 0 !== e.evidence && null !== e.evidence && (r.evidence = t.EvidenceParams.fromPartial(e.evidence)), void 0 !== e.validator && null !== e.validator && (r.validator = t.ValidatorParams.fromPartial(e.validator)), void 0 !== e.version && null !== e.version && (r.version = t.VersionParams.fromPartial(e.version)), r
                }
            }, t.BlockParams = {
                typeUrl: "/tendermint.types.BlockParams",
                encode: (e, t = o.BinaryWriter.create()) => (e.maxBytes !== BigInt(0) && t.uint32(8).int64(e.maxBytes), e.maxGas !== BigInt(0) && t.uint32(16).int64(e.maxGas), t),
                decode(e, t) {
                    let r = e instanceof o.BinaryReader ? e : new o.BinaryReader(e),
                        n = void 0 === t ? r.len : r.pos + t,
                        i = s();
                    for (; r.pos < n;) {
                        let e = r.uint32();
                        switch (e >>> 3) {
                            case 1:
                                i.maxBytes = r.int64();
                                break;
                            case 2:
                                i.maxGas = r.int64();
                                break;
                            default:
                                r.skipType(7 & e)
                        }
                    }
                    return i
                },
                fromJSON(e) {
                    let t = s();
                    return (0, i.isSet)(e.maxBytes) && (t.maxBytes = BigInt(e.maxBytes.toString())), (0, i.isSet)(e.maxGas) && (t.maxGas = BigInt(e.maxGas.toString())), t
                },
                toJSON(e) {
                    let t = {};
                    return void 0 !== e.maxBytes && (t.maxBytes = (e.maxBytes || BigInt(0)).toString()), void 0 !== e.maxGas && (t.maxGas = (e.maxGas || BigInt(0)).toString()), t
                },
                fromPartial(e) {
                    let t = s();
                    return void 0 !== e.maxBytes && null !== e.maxBytes && (t.maxBytes = BigInt(e.maxBytes.toString())), void 0 !== e.maxGas && null !== e.maxGas && (t.maxGas = BigInt(e.maxGas.toString())), t
                }
            }, t.EvidenceParams = {
                typeUrl: "/tendermint.types.EvidenceParams",
                encode: (e, t = o.BinaryWriter.create()) => (e.maxAgeNumBlocks !== BigInt(0) && t.uint32(8).int64(e.maxAgeNumBlocks), void 0 !== e.maxAgeDuration && n.Duration.encode(e.maxAgeDuration, t.uint32(18).fork()).ldelim(), e.maxBytes !== BigInt(0) && t.uint32(24).int64(e.maxBytes), t),
                decode(e, t) {
                    let r = e instanceof o.BinaryReader ? e : new o.BinaryReader(e),
                        i = void 0 === t ? r.len : r.pos + t,
                        a = d();
                    for (; r.pos < i;) {
                        let e = r.uint32();
                        switch (e >>> 3) {
                            case 1:
                                a.maxAgeNumBlocks = r.int64();
                                break;
                            case 2:
                                a.maxAgeDuration = n.Duration.decode(r, r.uint32());
                                break;
                            case 3:
                                a.maxBytes = r.int64();
                                break;
                            default:
                                r.skipType(7 & e)
                        }
                    }
                    return a
                },
                fromJSON(e) {
                    let t = d();
                    return (0, i.isSet)(e.maxAgeNumBlocks) && (t.maxAgeNumBlocks = BigInt(e.maxAgeNumBlocks.toString())), (0, i.isSet)(e.maxAgeDuration) && (t.maxAgeDuration = n.Duration.fromJSON(e.maxAgeDuration)), (0, i.isSet)(e.maxBytes) && (t.maxBytes = BigInt(e.maxBytes.toString())), t
                },
                toJSON(e) {
                    let t = {};
                    return void 0 !== e.maxAgeNumBlocks && (t.maxAgeNumBlocks = (e.maxAgeNumBlocks || BigInt(0)).toString()), void 0 !== e.maxAgeDuration && (t.maxAgeDuration = e.maxAgeDuration ? n.Duration.toJSON(e.maxAgeDuration) : void 0), void 0 !== e.maxBytes && (t.maxBytes = (e.maxBytes || BigInt(0)).toString()), t
                },
                fromPartial(e) {
                    let t = d();
                    return void 0 !== e.maxAgeNumBlocks && null !== e.maxAgeNumBlocks && (t.maxAgeNumBlocks = BigInt(e.maxAgeNumBlocks.toString())), void 0 !== e.maxAgeDuration && null !== e.maxAgeDuration && (t.maxAgeDuration = n.Duration.fromPartial(e.maxAgeDuration)), void 0 !== e.maxBytes && null !== e.maxBytes && (t.maxBytes = BigInt(e.maxBytes.toString())), t
                }
            }, t.ValidatorParams = {
                typeUrl: "/tendermint.types.ValidatorParams",
                encode(e, t = o.BinaryWriter.create()) {
                    for (let r of e.pubKeyTypes) t.uint32(10).string(r);
                    return t
                },
                decode(e, t) {
                    let r = e instanceof o.BinaryReader ? e : new o.BinaryReader(e),
                        n = void 0 === t ? r.len : r.pos + t,
                        i = c();
                    for (; r.pos < n;) {
                        let e = r.uint32();
                        e >>> 3 == 1 ? i.pubKeyTypes.push(r.string()) : r.skipType(7 & e)
                    }
                    return i
                },
                fromJSON(e) {
                    let t = c();
                    return Array.isArray(e ? .pubKeyTypes) && (t.pubKeyTypes = e.pubKeyTypes.map(e => String(e))), t
                },
                toJSON(e) {
                    let t = {};
                    return e.pubKeyTypes ? t.pubKeyTypes = e.pubKeyTypes.map(e => e) : t.pubKeyTypes = [], t
                },
                fromPartial(e) {
                    let t = c();
                    return t.pubKeyTypes = e.pubKeyTypes ? .map(e => e) || [], t
                }
            }, t.VersionParams = {
                typeUrl: "/tendermint.types.VersionParams",
                encode: (e, t = o.BinaryWriter.create()) => (e.app !== BigInt(0) && t.uint32(8).uint64(e.app), t),
                decode(e, t) {
                    let r = e instanceof o.BinaryReader ? e : new o.BinaryReader(e),
                        n = void 0 === t ? r.len : r.pos + t,
                        i = l();
                    for (; r.pos < n;) {
                        let e = r.uint32();
                        e >>> 3 == 1 ? i.app = r.uint64() : r.skipType(7 & e)
                    }
                    return i
                },
                fromJSON(e) {
                    let t = l();
                    return (0, i.isSet)(e.app) && (t.app = BigInt(e.app.toString())), t
                },
                toJSON(e) {
                    let t = {};
                    return void 0 !== e.app && (t.app = (e.app || BigInt(0)).toString()), t
                },
                fromPartial(e) {
                    let t = l();
                    return void 0 !== e.app && null !== e.app && (t.app = BigInt(e.app.toString())), t
                }
            }, t.HashedParams = {
                typeUrl: "/tendermint.types.HashedParams",
                encode: (e, t = o.BinaryWriter.create()) => (e.blockMaxBytes !== BigInt(0) && t.uint32(8).int64(e.blockMaxBytes), e.blockMaxGas !== BigInt(0) && t.uint32(16).int64(e.blockMaxGas), t),
                decode(e, t) {
                    let r = e instanceof o.BinaryReader ? e : new o.BinaryReader(e),
                        n = void 0 === t ? r.len : r.pos + t,
                        i = u();
                    for (; r.pos < n;) {
                        let e = r.uint32();
                        switch (e >>> 3) {
                            case 1:
                                i.blockMaxBytes = r.int64();
                                break;
                            case 2:
                                i.blockMaxGas = r.int64();
                                break;
                            default:
                                r.skipType(7 & e)
                        }
                    }
                    return i
                },
                fromJSON(e) {
                    let t = u();
                    return (0, i.isSet)(e.blockMaxBytes) && (t.blockMaxBytes = BigInt(e.blockMaxBytes.toString())), (0, i.isSet)(e.blockMaxGas) && (t.blockMaxGas = BigInt(e.blockMaxGas.toString())), t
                },
                toJSON(e) {
                    let t = {};
                    return void 0 !== e.blockMaxBytes && (t.blockMaxBytes = (e.blockMaxBytes || BigInt(0)).toString()), void 0 !== e.blockMaxGas && (t.blockMaxGas = (e.blockMaxGas || BigInt(0)).toString()), t
                },
                fromPartial(e) {
                    let t = u();
                    return void 0 !== e.blockMaxBytes && null !== e.blockMaxBytes && (t.blockMaxBytes = BigInt(e.blockMaxBytes.toString())), void 0 !== e.blockMaxGas && null !== e.blockMaxGas && (t.blockMaxGas = BigInt(e.blockMaxGas.toString())), t
                }
            }
        },
        64255: function(e, t, r) {
            "use strict";
            var n, o, i, a;
            Object.defineProperty(t, "__esModule", {
                value: !0
            }), t.TxProof = t.BlockMeta = t.LightBlock = t.SignedHeader = t.Proposal = t.CommitSig = t.Commit = t.Vote = t.Data = t.Header = t.BlockID = t.Part = t.PartSetHeader = t.signedMsgTypeToJSON = t.signedMsgTypeFromJSON = t.SignedMsgType = t.blockIDFlagToJSON = t.blockIDFlagFromJSON = t.BlockIDFlag = t.protobufPackage = void 0;
            let s = r(16208),
                d = r(95584),
                c = r(90614),
                l = r(13002),
                u = r(28486),
                p = r(6476);

            function m(e) {
                switch (e) {
                    case 0:
                    case "BLOCK_ID_FLAG_UNKNOWN":
                        return n.BLOCK_ID_FLAG_UNKNOWN;
                    case 1:
                    case "BLOCK_ID_FLAG_ABSENT":
                        return n.BLOCK_ID_FLAG_ABSENT;
                    case 2:
                    case "BLOCK_ID_FLAG_COMMIT":
                        return n.BLOCK_ID_FLAG_COMMIT;
                    case 3:
                    case "BLOCK_ID_FLAG_NIL":
                        return n.BLOCK_ID_FLAG_NIL;
                    default:
                        return n.UNRECOGNIZED
                }
            }

            function g(e) {
                switch (e) {
                    case n.BLOCK_ID_FLAG_UNKNOWN:
                        return "BLOCK_ID_FLAG_UNKNOWN";
                    case n.BLOCK_ID_FLAG_ABSENT:
                        return "BLOCK_ID_FLAG_ABSENT";
                    case n.BLOCK_ID_FLAG_COMMIT:
                        return "BLOCK_ID_FLAG_COMMIT";
                    case n.BLOCK_ID_FLAG_NIL:
                        return "BLOCK_ID_FLAG_NIL";
                    case n.UNRECOGNIZED:
                    default:
                        return "UNRECOGNIZED"
                }
            }

            function f(e) {
                switch (e) {
                    case 0:
                    case "SIGNED_MSG_TYPE_UNKNOWN":
                        return o.SIGNED_MSG_TYPE_UNKNOWN;
                    case 1:
                    case "SIGNED_MSG_TYPE_PREVOTE":
                        return o.SIGNED_MSG_TYPE_PREVOTE;
                    case 2:
                    case "SIGNED_MSG_TYPE_PRECOMMIT":
                        return o.SIGNED_MSG_TYPE_PRECOMMIT;
                    case 32:
                    case "SIGNED_MSG_TYPE_PROPOSAL":
                        return o.SIGNED_MSG_TYPE_PROPOSAL;
                    default:
                        return o.UNRECOGNIZED
                }
            }

            function y(e) {
                switch (e) {
                    case o.SIGNED_MSG_TYPE_UNKNOWN:
                        return "SIGNED_MSG_TYPE_UNKNOWN";
                    case o.SIGNED_MSG_TYPE_PREVOTE:
                        return "SIGNED_MSG_TYPE_PREVOTE";
                    case o.SIGNED_MSG_TYPE_PRECOMMIT:
                        return "SIGNED_MSG_TYPE_PRECOMMIT";
                    case o.SIGNED_MSG_TYPE_PROPOSAL:
                        return "SIGNED_MSG_TYPE_PROPOSAL";
                    case o.UNRECOGNIZED:
                    default:
                        return "UNRECOGNIZED"
                }
            }

            function h() {
                return {
                    total: 0,
                    hash: new Uint8Array
                }
            }

            function v() {
                return {
                    index: 0,
                    bytes: new Uint8Array,
                    proof: s.Proof.fromPartial({})
                }
            }

            function b() {
                return {
                    hash: new Uint8Array,
                    partSetHeader: t.PartSetHeader.fromPartial({})
                }
            }

            function S() {
                return {
                    version: d.Consensus.fromPartial({}),
                    chainId: "",
                    height: BigInt(0),
                    time: c.Timestamp.fromPartial({}),
                    lastBlockId: t.BlockID.fromPartial({}),
                    lastCommitHash: new Uint8Array,
                    dataHash: new Uint8Array,
                    validatorsHash: new Uint8Array,
                    nextValidatorsHash: new Uint8Array,
                    consensusHash: new Uint8Array,
                    appHash: new Uint8Array,
                    lastResultsHash: new Uint8Array,
                    evidenceHash: new Uint8Array,
                    proposerAddress: new Uint8Array
                }
            }

            function k() {
                return {
                    txs: []
                }
            }

            function P() {
                return {
                    type: 0,
                    height: BigInt(0),
                    round: 0,
                    blockId: t.BlockID.fromPartial({}),
                    timestamp: c.Timestamp.fromPartial({}),
                    validatorAddress: new Uint8Array,
                    validatorIndex: 0,
                    signature: new Uint8Array
                }
            }

            function _() {
                return {
                    height: BigInt(0),
                    round: 0,
                    blockId: t.BlockID.fromPartial({}),
                    signatures: []
                }
            }

            function B() {
                return {
                    blockIdFlag: 0,
                    validatorAddress: new Uint8Array,
                    timestamp: c.Timestamp.fromPartial({}),
                    signature: new Uint8Array
                }
            }

            function O() {
                return {
                    type: 0,
                    height: BigInt(0),
                    round: 0,
                    polRound: 0,
                    blockId: t.BlockID.fromPartial({}),
                    timestamp: c.Timestamp.fromPartial({}),
                    signature: new Uint8Array
                }
            }

            function R() {
                return {
                    header: void 0,
                    commit: void 0
                }
            }

            function A() {
                return {
                    signedHeader: void 0,
                    validatorSet: void 0
                }
            }

            function I() {
                return {
                    blockId: t.BlockID.fromPartial({}),
                    blockSize: BigInt(0),
                    header: t.Header.fromPartial({}),
                    numTxs: BigInt(0)
                }
            }

            function w() {
                return {
                    rootHash: new Uint8Array,
                    data: new Uint8Array,
                    proof: void 0
                }
            }
            t.protobufPackage = "tendermint.types", (i = n || (t.BlockIDFlag = n = {}))[i.BLOCK_ID_FLAG_UNKNOWN = 0] = "BLOCK_ID_FLAG_UNKNOWN", i[i.BLOCK_ID_FLAG_ABSENT = 1] = "BLOCK_ID_FLAG_ABSENT", i[i.BLOCK_ID_FLAG_COMMIT = 2] = "BLOCK_ID_FLAG_COMMIT", i[i.BLOCK_ID_FLAG_NIL = 3] = "BLOCK_ID_FLAG_NIL", i[i.UNRECOGNIZED = -1] = "UNRECOGNIZED", t.blockIDFlagFromJSON = m, t.blockIDFlagToJSON = g, (a = o || (t.SignedMsgType = o = {}))[a.SIGNED_MSG_TYPE_UNKNOWN = 0] = "SIGNED_MSG_TYPE_UNKNOWN", a[a.SIGNED_MSG_TYPE_PREVOTE = 1] = "SIGNED_MSG_TYPE_PREVOTE", a[a.SIGNED_MSG_TYPE_PRECOMMIT = 2] = "SIGNED_MSG_TYPE_PRECOMMIT", a[a.SIGNED_MSG_TYPE_PROPOSAL = 32] = "SIGNED_MSG_TYPE_PROPOSAL", a[a.UNRECOGNIZED = -1] = "UNRECOGNIZED", t.signedMsgTypeFromJSON = f, t.signedMsgTypeToJSON = y, t.PartSetHeader = {
                typeUrl: "/tendermint.types.PartSetHeader",
                encode: (e, t = u.BinaryWriter.create()) => (0 !== e.total && t.uint32(8).uint32(e.total), 0 !== e.hash.length && t.uint32(18).bytes(e.hash), t),
                decode(e, t) {
                    let r = e instanceof u.BinaryReader ? e : new u.BinaryReader(e),
                        n = void 0 === t ? r.len : r.pos + t,
                        o = h();
                    for (; r.pos < n;) {
                        let e = r.uint32();
                        switch (e >>> 3) {
                            case 1:
                                o.total = r.uint32();
                                break;
                            case 2:
                                o.hash = r.bytes();
                                break;
                            default:
                                r.skipType(7 & e)
                        }
                    }
                    return o
                },
                fromJSON(e) {
                    let t = h();
                    return (0, p.isSet)(e.total) && (t.total = Number(e.total)), (0, p.isSet)(e.hash) && (t.hash = (0, p.bytesFromBase64)(e.hash)), t
                },
                toJSON(e) {
                    let t = {};
                    return void 0 !== e.total && (t.total = Math.round(e.total)), void 0 !== e.hash && (t.hash = (0, p.base64FromBytes)(void 0 !== e.hash ? e.hash : new Uint8Array)), t
                },
                fromPartial(e) {
                    let t = h();
                    return t.total = e.total ? ? 0, t.hash = e.hash ? ? new Uint8Array, t
                }
            }, t.Part = {
                typeUrl: "/tendermint.types.Part",
                encode: (e, t = u.BinaryWriter.create()) => (0 !== e.index && t.uint32(8).uint32(e.index), 0 !== e.bytes.length && t.uint32(18).bytes(e.bytes), void 0 !== e.proof && s.Proof.encode(e.proof, t.uint32(26).fork()).ldelim(), t),
                decode(e, t) {
                    let r = e instanceof u.BinaryReader ? e : new u.BinaryReader(e),
                        n = void 0 === t ? r.len : r.pos + t,
                        o = v();
                    for (; r.pos < n;) {
                        let e = r.uint32();
                        switch (e >>> 3) {
                            case 1:
                                o.index = r.uint32();
                                break;
                            case 2:
                                o.bytes = r.bytes();
                                break;
                            case 3:
                                o.proof = s.Proof.decode(r, r.uint32());
                                break;
                            default:
                                r.skipType(7 & e)
                        }
                    }
                    return o
                },
                fromJSON(e) {
                    let t = v();
                    return (0, p.isSet)(e.index) && (t.index = Number(e.index)), (0, p.isSet)(e.bytes) && (t.bytes = (0, p.bytesFromBase64)(e.bytes)), (0, p.isSet)(e.proof) && (t.proof = s.Proof.fromJSON(e.proof)), t
                },
                toJSON(e) {
                    let t = {};
                    return void 0 !== e.index && (t.index = Math.round(e.index)), void 0 !== e.bytes && (t.bytes = (0, p.base64FromBytes)(void 0 !== e.bytes ? e.bytes : new Uint8Array)), void 0 !== e.proof && (t.proof = e.proof ? s.Proof.toJSON(e.proof) : void 0), t
                },
                fromPartial(e) {
                    let t = v();
                    return t.index = e.index ? ? 0, t.bytes = e.bytes ? ? new Uint8Array, void 0 !== e.proof && null !== e.proof && (t.proof = s.Proof.fromPartial(e.proof)), t
                }
            }, t.BlockID = {
                typeUrl: "/tendermint.types.BlockID",
                encode: (e, r = u.BinaryWriter.create()) => (0 !== e.hash.length && r.uint32(10).bytes(e.hash), void 0 !== e.partSetHeader && t.PartSetHeader.encode(e.partSetHeader, r.uint32(18).fork()).ldelim(), r),
                decode(e, r) {
                    let n = e instanceof u.BinaryReader ? e : new u.BinaryReader(e),
                        o = void 0 === r ? n.len : n.pos + r,
                        i = b();
                    for (; n.pos < o;) {
                        let e = n.uint32();
                        switch (e >>> 3) {
                            case 1:
                                i.hash = n.bytes();
                                break;
                            case 2:
                                i.partSetHeader = t.PartSetHeader.decode(n, n.uint32());
                                break;
                            default:
                                n.skipType(7 & e)
                        }
                    }
                    return i
                },
                fromJSON(e) {
                    let r = b();
                    return (0, p.isSet)(e.hash) && (r.hash = (0, p.bytesFromBase64)(e.hash)), (0, p.isSet)(e.partSetHeader) && (r.partSetHeader = t.PartSetHeader.fromJSON(e.partSetHeader)), r
                },
                toJSON(e) {
                    let r = {};
                    return void 0 !== e.hash && (r.hash = (0, p.base64FromBytes)(void 0 !== e.hash ? e.hash : new Uint8Array)), void 0 !== e.partSetHeader && (r.partSetHeader = e.partSetHeader ? t.PartSetHeader.toJSON(e.partSetHeader) : void 0), r
                },
                fromPartial(e) {
                    let r = b();
                    return r.hash = e.hash ? ? new Uint8Array, void 0 !== e.partSetHeader && null !== e.partSetHeader && (r.partSetHeader = t.PartSetHeader.fromPartial(e.partSetHeader)), r
                }
            }, t.Header = {
                typeUrl: "/tendermint.types.Header",
                encode: (e, r = u.BinaryWriter.create()) => (void 0 !== e.version && d.Consensus.encode(e.version, r.uint32(10).fork()).ldelim(), "" !== e.chainId && r.uint32(18).string(e.chainId), e.height !== BigInt(0) && r.uint32(24).int64(e.height), void 0 !== e.time && c.Timestamp.encode(e.time, r.uint32(34).fork()).ldelim(), void 0 !== e.lastBlockId && t.BlockID.encode(e.lastBlockId, r.uint32(42).fork()).ldelim(), 0 !== e.lastCommitHash.length && r.uint32(50).bytes(e.lastCommitHash), 0 !== e.dataHash.length && r.uint32(58).bytes(e.dataHash), 0 !== e.validatorsHash.length && r.uint32(66).bytes(e.validatorsHash), 0 !== e.nextValidatorsHash.length && r.uint32(74).bytes(e.nextValidatorsHash), 0 !== e.consensusHash.length && r.uint32(82).bytes(e.consensusHash), 0 !== e.appHash.length && r.uint32(90).bytes(e.appHash), 0 !== e.lastResultsHash.length && r.uint32(98).bytes(e.lastResultsHash), 0 !== e.evidenceHash.length && r.uint32(106).bytes(e.evidenceHash), 0 !== e.proposerAddress.length && r.uint32(114).bytes(e.proposerAddress), r),
                decode(e, r) {
                    let n = e instanceof u.BinaryReader ? e : new u.BinaryReader(e),
                        o = void 0 === r ? n.len : n.pos + r,
                        i = S();
                    for (; n.pos < o;) {
                        let e = n.uint32();
                        switch (e >>> 3) {
                            case 1:
                                i.version = d.Consensus.decode(n, n.uint32());
                                break;
                            case 2:
                                i.chainId = n.string();
                                break;
                            case 3:
                                i.height = n.int64();
                                break;
                            case 4:
                                i.time = c.Timestamp.decode(n, n.uint32());
                                break;
                            case 5:
                                i.lastBlockId = t.BlockID.decode(n, n.uint32());
                                break;
                            case 6:
                                i.lastCommitHash = n.bytes();
                                break;
                            case 7:
                                i.dataHash = n.bytes();
                                break;
                            case 8:
                                i.validatorsHash = n.bytes();
                                break;
                            case 9:
                                i.nextValidatorsHash = n.bytes();
                                break;
                            case 10:
                                i.consensusHash = n.bytes();
                                break;
                            case 11:
                                i.appHash = n.bytes();
                                break;
                            case 12:
                                i.lastResultsHash = n.bytes();
                                break;
                            case 13:
                                i.evidenceHash = n.bytes();
                                break;
                            case 14:
                                i.proposerAddress = n.bytes();
                                break;
                            default:
                                n.skipType(7 & e)
                        }
                    }
                    return i
                },
                fromJSON(e) {
                    let r = S();
                    return (0, p.isSet)(e.version) && (r.version = d.Consensus.fromJSON(e.version)), (0, p.isSet)(e.chainId) && (r.chainId = String(e.chainId)), (0, p.isSet)(e.height) && (r.height = BigInt(e.height.toString())), (0, p.isSet)(e.time) && (r.time = (0, p.fromJsonTimestamp)(e.time)), (0, p.isSet)(e.lastBlockId) && (r.lastBlockId = t.BlockID.fromJSON(e.lastBlockId)), (0, p.isSet)(e.lastCommitHash) && (r.lastCommitHash = (0, p.bytesFromBase64)(e.lastCommitHash)), (0, p.isSet)(e.dataHash) && (r.dataHash = (0, p.bytesFromBase64)(e.dataHash)), (0, p.isSet)(e.validatorsHash) && (r.validatorsHash = (0, p.bytesFromBase64)(e.validatorsHash)), (0, p.isSet)(e.nextValidatorsHash) && (r.nextValidatorsHash = (0, p.bytesFromBase64)(e.nextValidatorsHash)), (0, p.isSet)(e.consensusHash) && (r.consensusHash = (0, p.bytesFromBase64)(e.consensusHash)), (0, p.isSet)(e.appHash) && (r.appHash = (0, p.bytesFromBase64)(e.appHash)), (0, p.isSet)(e.lastResultsHash) && (r.lastResultsHash = (0, p.bytesFromBase64)(e.lastResultsHash)), (0, p.isSet)(e.evidenceHash) && (r.evidenceHash = (0, p.bytesFromBase64)(e.evidenceHash)), (0, p.isSet)(e.proposerAddress) && (r.proposerAddress = (0, p.bytesFromBase64)(e.proposerAddress)), r
                },
                toJSON(e) {
                    let r = {};
                    return void 0 !== e.version && (r.version = e.version ? d.Consensus.toJSON(e.version) : void 0), void 0 !== e.chainId && (r.chainId = e.chainId), void 0 !== e.height && (r.height = (e.height || BigInt(0)).toString()), void 0 !== e.time && (r.time = (0, p.fromTimestamp)(e.time).toISOString()), void 0 !== e.lastBlockId && (r.lastBlockId = e.lastBlockId ? t.BlockID.toJSON(e.lastBlockId) : void 0), void 0 !== e.lastCommitHash && (r.lastCommitHash = (0, p.base64FromBytes)(void 0 !== e.lastCommitHash ? e.lastCommitHash : new Uint8Array)), void 0 !== e.dataHash && (r.dataHash = (0, p.base64FromBytes)(void 0 !== e.dataHash ? e.dataHash : new Uint8Array)), void 0 !== e.validatorsHash && (r.validatorsHash = (0, p.base64FromBytes)(void 0 !== e.validatorsHash ? e.validatorsHash : new Uint8Array)), void 0 !== e.nextValidatorsHash && (r.nextValidatorsHash = (0, p.base64FromBytes)(void 0 !== e.nextValidatorsHash ? e.nextValidatorsHash : new Uint8Array)), void 0 !== e.consensusHash && (r.consensusHash = (0, p.base64FromBytes)(void 0 !== e.consensusHash ? e.consensusHash : new Uint8Array)), void 0 !== e.appHash && (r.appHash = (0, p.base64FromBytes)(void 0 !== e.appHash ? e.appHash : new Uint8Array)), void 0 !== e.lastResultsHash && (r.lastResultsHash = (0, p.base64FromBytes)(void 0 !== e.lastResultsHash ? e.lastResultsHash : new Uint8Array)), void 0 !== e.evidenceHash && (r.evidenceHash = (0, p.base64FromBytes)(void 0 !== e.evidenceHash ? e.evidenceHash : new Uint8Array)), void 0 !== e.proposerAddress && (r.proposerAddress = (0, p.base64FromBytes)(void 0 !== e.proposerAddress ? e.proposerAddress : new Uint8Array)), r
                },
                fromPartial(e) {
                    let r = S();
                    return void 0 !== e.version && null !== e.version && (r.version = d.Consensus.fromPartial(e.version)), r.chainId = e.chainId ? ? "", void 0 !== e.height && null !== e.height && (r.height = BigInt(e.height.toString())), void 0 !== e.time && null !== e.time && (r.time = c.Timestamp.fromPartial(e.time)), void 0 !== e.lastBlockId && null !== e.lastBlockId && (r.lastBlockId = t.BlockID.fromPartial(e.lastBlockId)), r.lastCommitHash = e.lastCommitHash ? ? new Uint8Array, r.dataHash = e.dataHash ? ? new Uint8Array, r.validatorsHash = e.validatorsHash ? ? new Uint8Array, r.nextValidatorsHash = e.nextValidatorsHash ? ? new Uint8Array, r.consensusHash = e.consensusHash ? ? new Uint8Array, r.appHash = e.appHash ? ? new Uint8Array, r.lastResultsHash = e.lastResultsHash ? ? new Uint8Array, r.evidenceHash = e.evidenceHash ? ? new Uint8Array, r.proposerAddress = e.proposerAddress ? ? new Uint8Array, r
                }
            }, t.Data = {
                typeUrl: "/tendermint.types.Data",
                encode(e, t = u.BinaryWriter.create()) {
                    for (let r of e.txs) t.uint32(10).bytes(r);
                    return t
                },
                decode(e, t) {
                    let r = e instanceof u.BinaryReader ? e : new u.BinaryReader(e),
                        n = void 0 === t ? r.len : r.pos + t,
                        o = k();
                    for (; r.pos < n;) {
                        let e = r.uint32();
                        e >>> 3 == 1 ? o.txs.push(r.bytes()) : r.skipType(7 & e)
                    }
                    return o
                },
                fromJSON(e) {
                    let t = k();
                    return Array.isArray(e ? .txs) && (t.txs = e.txs.map(e => (0, p.bytesFromBase64)(e))), t
                },
                toJSON(e) {
                    let t = {};
                    return e.txs ? t.txs = e.txs.map(e => (0, p.base64FromBytes)(void 0 !== e ? e : new Uint8Array)) : t.txs = [], t
                },
                fromPartial(e) {
                    let t = k();
                    return t.txs = e.txs ? .map(e => e) || [], t
                }
            }, t.Vote = {
                typeUrl: "/tendermint.types.Vote",
                encode: (e, r = u.BinaryWriter.create()) => (0 !== e.type && r.uint32(8).int32(e.type), e.height !== BigInt(0) && r.uint32(16).int64(e.height), 0 !== e.round && r.uint32(24).int32(e.round), void 0 !== e.blockId && t.BlockID.encode(e.blockId, r.uint32(34).fork()).ldelim(), void 0 !== e.timestamp && c.Timestamp.encode(e.timestamp, r.uint32(42).fork()).ldelim(), 0 !== e.validatorAddress.length && r.uint32(50).bytes(e.validatorAddress), 0 !== e.validatorIndex && r.uint32(56).int32(e.validatorIndex), 0 !== e.signature.length && r.uint32(66).bytes(e.signature), r),
                decode(e, r) {
                    let n = e instanceof u.BinaryReader ? e : new u.BinaryReader(e),
                        o = void 0 === r ? n.len : n.pos + r,
                        i = P();
                    for (; n.pos < o;) {
                        let e = n.uint32();
                        switch (e >>> 3) {
                            case 1:
                                i.type = n.int32();
                                break;
                            case 2:
                                i.height = n.int64();
                                break;
                            case 3:
                                i.round = n.int32();
                                break;
                            case 4:
                                i.blockId = t.BlockID.decode(n, n.uint32());
                                break;
                            case 5:
                                i.timestamp = c.Timestamp.decode(n, n.uint32());
                                break;
                            case 6:
                                i.validatorAddress = n.bytes();
                                break;
                            case 7:
                                i.validatorIndex = n.int32();
                                break;
                            case 8:
                                i.signature = n.bytes();
                                break;
                            default:
                                n.skipType(7 & e)
                        }
                    }
                    return i
                },
                fromJSON(e) {
                    let r = P();
                    return (0, p.isSet)(e.type) && (r.type = f(e.type)), (0, p.isSet)(e.height) && (r.height = BigInt(e.height.toString())), (0, p.isSet)(e.round) && (r.round = Number(e.round)), (0, p.isSet)(e.blockId) && (r.blockId = t.BlockID.fromJSON(e.blockId)), (0, p.isSet)(e.timestamp) && (r.timestamp = (0, p.fromJsonTimestamp)(e.timestamp)), (0, p.isSet)(e.validatorAddress) && (r.validatorAddress = (0, p.bytesFromBase64)(e.validatorAddress)), (0, p.isSet)(e.validatorIndex) && (r.validatorIndex = Number(e.validatorIndex)), (0, p.isSet)(e.signature) && (r.signature = (0, p.bytesFromBase64)(e.signature)), r
                },
                toJSON(e) {
                    let r = {};
                    return void 0 !== e.type && (r.type = y(e.type)), void 0 !== e.height && (r.height = (e.height || BigInt(0)).toString()), void 0 !== e.round && (r.round = Math.round(e.round)), void 0 !== e.blockId && (r.blockId = e.blockId ? t.BlockID.toJSON(e.blockId) : void 0), void 0 !== e.timestamp && (r.timestamp = (0, p.fromTimestamp)(e.timestamp).toISOString()), void 0 !== e.validatorAddress && (r.validatorAddress = (0, p.base64FromBytes)(void 0 !== e.validatorAddress ? e.validatorAddress : new Uint8Array)), void 0 !== e.validatorIndex && (r.validatorIndex = Math.round(e.validatorIndex)), void 0 !== e.signature && (r.signature = (0, p.base64FromBytes)(void 0 !== e.signature ? e.signature : new Uint8Array)), r
                },
                fromPartial(e) {
                    let r = P();
                    return r.type = e.type ? ? 0, void 0 !== e.height && null !== e.height && (r.height = BigInt(e.height.toString())), r.round = e.round ? ? 0, void 0 !== e.blockId && null !== e.blockId && (r.blockId = t.BlockID.fromPartial(e.blockId)), void 0 !== e.timestamp && null !== e.timestamp && (r.timestamp = c.Timestamp.fromPartial(e.timestamp)), r.validatorAddress = e.validatorAddress ? ? new Uint8Array, r.validatorIndex = e.validatorIndex ? ? 0, r.signature = e.signature ? ? new Uint8Array, r
                }
            }, t.Commit = {
                typeUrl: "/tendermint.types.Commit",
                encode(e, r = u.BinaryWriter.create()) {
                    for (let n of (e.height !== BigInt(0) && r.uint32(8).int64(e.height), 0 !== e.round && r.uint32(16).int32(e.round), void 0 !== e.blockId && t.BlockID.encode(e.blockId, r.uint32(26).fork()).ldelim(), e.signatures)) t.CommitSig.encode(n, r.uint32(34).fork()).ldelim();
                    return r
                },
                decode(e, r) {
                    let n = e instanceof u.BinaryReader ? e : new u.BinaryReader(e),
                        o = void 0 === r ? n.len : n.pos + r,
                        i = _();
                    for (; n.pos < o;) {
                        let e = n.uint32();
                        switch (e >>> 3) {
                            case 1:
                                i.height = n.int64();
                                break;
                            case 2:
                                i.round = n.int32();
                                break;
                            case 3:
                                i.blockId = t.BlockID.decode(n, n.uint32());
                                break;
                            case 4:
                                i.signatures.push(t.CommitSig.decode(n, n.uint32()));
                                break;
                            default:
                                n.skipType(7 & e)
                        }
                    }
                    return i
                },
                fromJSON(e) {
                    let r = _();
                    return (0, p.isSet)(e.height) && (r.height = BigInt(e.height.toString())), (0, p.isSet)(e.round) && (r.round = Number(e.round)), (0, p.isSet)(e.blockId) && (r.blockId = t.BlockID.fromJSON(e.blockId)), Array.isArray(e ? .signatures) && (r.signatures = e.signatures.map(e => t.CommitSig.fromJSON(e))), r
                },
                toJSON(e) {
                    let r = {};
                    return void 0 !== e.height && (r.height = (e.height || BigInt(0)).toString()), void 0 !== e.round && (r.round = Math.round(e.round)), void 0 !== e.blockId && (r.blockId = e.blockId ? t.BlockID.toJSON(e.blockId) : void 0), e.signatures ? r.signatures = e.signatures.map(e => e ? t.CommitSig.toJSON(e) : void 0) : r.signatures = [], r
                },
                fromPartial(e) {
                    let r = _();
                    return void 0 !== e.height && null !== e.height && (r.height = BigInt(e.height.toString())), r.round = e.round ? ? 0, void 0 !== e.blockId && null !== e.blockId && (r.blockId = t.BlockID.fromPartial(e.blockId)), r.signatures = e.signatures ? .map(e => t.CommitSig.fromPartial(e)) || [], r
                }
            }, t.CommitSig = {
                typeUrl: "/tendermint.types.CommitSig",
                encode: (e, t = u.BinaryWriter.create()) => (0 !== e.blockIdFlag && t.uint32(8).int32(e.blockIdFlag), 0 !== e.validatorAddress.length && t.uint32(18).bytes(e.validatorAddress), void 0 !== e.timestamp && c.Timestamp.encode(e.timestamp, t.uint32(26).fork()).ldelim(), 0 !== e.signature.length && t.uint32(34).bytes(e.signature), t),
                decode(e, t) {
                    let r = e instanceof u.BinaryReader ? e : new u.BinaryReader(e),
                        n = void 0 === t ? r.len : r.pos + t,
                        o = B();
                    for (; r.pos < n;) {
                        let e = r.uint32();
                        switch (e >>> 3) {
                            case 1:
                                o.blockIdFlag = r.int32();
                                break;
                            case 2:
                                o.validatorAddress = r.bytes();
                                break;
                            case 3:
                                o.timestamp = c.Timestamp.decode(r, r.uint32());
                                break;
                            case 4:
                                o.signature = r.bytes();
                                break;
                            default:
                                r.skipType(7 & e)
                        }
                    }
                    return o
                },
                fromJSON(e) {
                    let t = B();
                    return (0, p.isSet)(e.blockIdFlag) && (t.blockIdFlag = m(e.blockIdFlag)), (0, p.isSet)(e.validatorAddress) && (t.validatorAddress = (0, p.bytesFromBase64)(e.validatorAddress)), (0, p.isSet)(e.timestamp) && (t.timestamp = (0, p.fromJsonTimestamp)(e.timestamp)), (0, p.isSet)(e.signature) && (t.signature = (0, p.bytesFromBase64)(e.signature)), t
                },
                toJSON(e) {
                    let t = {};
                    return void 0 !== e.blockIdFlag && (t.blockIdFlag = g(e.blockIdFlag)), void 0 !== e.validatorAddress && (t.validatorAddress = (0, p.base64FromBytes)(void 0 !== e.validatorAddress ? e.validatorAddress : new Uint8Array)), void 0 !== e.timestamp && (t.timestamp = (0, p.fromTimestamp)(e.timestamp).toISOString()), void 0 !== e.signature && (t.signature = (0, p.base64FromBytes)(void 0 !== e.signature ? e.signature : new Uint8Array)), t
                },
                fromPartial(e) {
                    let t = B();
                    return t.blockIdFlag = e.blockIdFlag ? ? 0, t.validatorAddress = e.validatorAddress ? ? new Uint8Array, void 0 !== e.timestamp && null !== e.timestamp && (t.timestamp = c.Timestamp.fromPartial(e.timestamp)), t.signature = e.signature ? ? new Uint8Array, t
                }
            }, t.Proposal = {
                typeUrl: "/tendermint.types.Proposal",
                encode: (e, r = u.BinaryWriter.create()) => (0 !== e.type && r.uint32(8).int32(e.type), e.height !== BigInt(0) && r.uint32(16).int64(e.height), 0 !== e.round && r.uint32(24).int32(e.round), 0 !== e.polRound && r.uint32(32).int32(e.polRound), void 0 !== e.blockId && t.BlockID.encode(e.blockId, r.uint32(42).fork()).ldelim(), void 0 !== e.timestamp && c.Timestamp.encode(e.timestamp, r.uint32(50).fork()).ldelim(), 0 !== e.signature.length && r.uint32(58).bytes(e.signature), r),
                decode(e, r) {
                    let n = e instanceof u.BinaryReader ? e : new u.BinaryReader(e),
                        o = void 0 === r ? n.len : n.pos + r,
                        i = O();
                    for (; n.pos < o;) {
                        let e = n.uint32();
                        switch (e >>> 3) {
                            case 1:
                                i.type = n.int32();
                                break;
                            case 2:
                                i.height = n.int64();
                                break;
                            case 3:
                                i.round = n.int32();
                                break;
                            case 4:
                                i.polRound = n.int32();
                                break;
                            case 5:
                                i.blockId = t.BlockID.decode(n, n.uint32());
                                break;
                            case 6:
                                i.timestamp = c.Timestamp.decode(n, n.uint32());
                                break;
                            case 7:
                                i.signature = n.bytes();
                                break;
                            default:
                                n.skipType(7 & e)
                        }
                    }
                    return i
                },
                fromJSON(e) {
                    let r = O();
                    return (0, p.isSet)(e.type) && (r.type = f(e.type)), (0, p.isSet)(e.height) && (r.height = BigInt(e.height.toString())), (0, p.isSet)(e.round) && (r.round = Number(e.round)), (0, p.isSet)(e.polRound) && (r.polRound = Number(e.polRound)), (0, p.isSet)(e.blockId) && (r.blockId = t.BlockID.fromJSON(e.blockId)), (0, p.isSet)(e.timestamp) && (r.timestamp = (0, p.fromJsonTimestamp)(e.timestamp)), (0, p.isSet)(e.signature) && (r.signature = (0, p.bytesFromBase64)(e.signature)), r
                },
                toJSON(e) {
                    let r = {};
                    return void 0 !== e.type && (r.type = y(e.type)), void 0 !== e.height && (r.height = (e.height || BigInt(0)).toString()), void 0 !== e.round && (r.round = Math.round(e.round)), void 0 !== e.polRound && (r.polRound = Math.round(e.polRound)), void 0 !== e.blockId && (r.blockId = e.blockId ? t.BlockID.toJSON(e.blockId) : void 0), void 0 !== e.timestamp && (r.timestamp = (0, p.fromTimestamp)(e.timestamp).toISOString()), void 0 !== e.signature && (r.signature = (0, p.base64FromBytes)(void 0 !== e.signature ? e.signature : new Uint8Array)), r
                },
                fromPartial(e) {
                    let r = O();
                    return r.type = e.type ? ? 0, void 0 !== e.height && null !== e.height && (r.height = BigInt(e.height.toString())), r.round = e.round ? ? 0, r.polRound = e.polRound ? ? 0, void 0 !== e.blockId && null !== e.blockId && (r.blockId = t.BlockID.fromPartial(e.blockId)), void 0 !== e.timestamp && null !== e.timestamp && (r.timestamp = c.Timestamp.fromPartial(e.timestamp)), r.signature = e.signature ? ? new Uint8Array, r
                }
            }, t.SignedHeader = {
                typeUrl: "/tendermint.types.SignedHeader",
                encode: (e, r = u.BinaryWriter.create()) => (void 0 !== e.header && t.Header.encode(e.header, r.uint32(10).fork()).ldelim(), void 0 !== e.commit && t.Commit.encode(e.commit, r.uint32(18).fork()).ldelim(), r),
                decode(e, r) {
                    let n = e instanceof u.BinaryReader ? e : new u.BinaryReader(e),
                        o = void 0 === r ? n.len : n.pos + r,
                        i = R();
                    for (; n.pos < o;) {
                        let e = n.uint32();
                        switch (e >>> 3) {
                            case 1:
                                i.header = t.Header.decode(n, n.uint32());
                                break;
                            case 2:
                                i.commit = t.Commit.decode(n, n.uint32());
                                break;
                            default:
                                n.skipType(7 & e)
                        }
                    }
                    return i
                },
                fromJSON(e) {
                    let r = R();
                    return (0, p.isSet)(e.header) && (r.header = t.Header.fromJSON(e.header)), (0, p.isSet)(e.commit) && (r.commit = t.Commit.fromJSON(e.commit)), r
                },
                toJSON(e) {
                    let r = {};
                    return void 0 !== e.header && (r.header = e.header ? t.Header.toJSON(e.header) : void 0), void 0 !== e.commit && (r.commit = e.commit ? t.Commit.toJSON(e.commit) : void 0), r
                },
                fromPartial(e) {
                    let r = R();
                    return void 0 !== e.header && null !== e.header && (r.header = t.Header.fromPartial(e.header)), void 0 !== e.commit && null !== e.commit && (r.commit = t.Commit.fromPartial(e.commit)), r
                }
            }, t.LightBlock = {
                typeUrl: "/tendermint.types.LightBlock",
                encode: (e, r = u.BinaryWriter.create()) => (void 0 !== e.signedHeader && t.SignedHeader.encode(e.signedHeader, r.uint32(10).fork()).ldelim(), void 0 !== e.validatorSet && l.ValidatorSet.encode(e.validatorSet, r.uint32(18).fork()).ldelim(), r),
                decode(e, r) {
                    let n = e instanceof u.BinaryReader ? e : new u.BinaryReader(e),
                        o = void 0 === r ? n.len : n.pos + r,
                        i = A();
                    for (; n.pos < o;) {
                        let e = n.uint32();
                        switch (e >>> 3) {
                            case 1:
                                i.signedHeader = t.SignedHeader.decode(n, n.uint32());
                                break;
                            case 2:
                                i.validatorSet = l.ValidatorSet.decode(n, n.uint32());
                                break;
                            default:
                                n.skipType(7 & e)
                        }
                    }
                    return i
                },
                fromJSON(e) {
                    let r = A();
                    return (0, p.isSet)(e.signedHeader) && (r.signedHeader = t.SignedHeader.fromJSON(e.signedHeader)), (0, p.isSet)(e.validatorSet) && (r.validatorSet = l.ValidatorSet.fromJSON(e.validatorSet)), r
                },
                toJSON(e) {
                    let r = {};
                    return void 0 !== e.signedHeader && (r.signedHeader = e.signedHeader ? t.SignedHeader.toJSON(e.signedHeader) : void 0), void 0 !== e.validatorSet && (r.validatorSet = e.validatorSet ? l.ValidatorSet.toJSON(e.validatorSet) : void 0), r
                },
                fromPartial(e) {
                    let r = A();
                    return void 0 !== e.signedHeader && null !== e.signedHeader && (r.signedHeader = t.SignedHeader.fromPartial(e.signedHeader)), void 0 !== e.validatorSet && null !== e.validatorSet && (r.validatorSet = l.ValidatorSet.fromPartial(e.validatorSet)), r
                }
            }, t.BlockMeta = {
                typeUrl: "/tendermint.types.BlockMeta",
                encode: (e, r = u.BinaryWriter.create()) => (void 0 !== e.blockId && t.BlockID.encode(e.blockId, r.uint32(10).fork()).ldelim(), e.blockSize !== BigInt(0) && r.uint32(16).int64(e.blockSize), void 0 !== e.header && t.Header.encode(e.header, r.uint32(26).fork()).ldelim(), e.numTxs !== BigInt(0) && r.uint32(32).int64(e.numTxs), r),
                decode(e, r) {
                    let n = e instanceof u.BinaryReader ? e : new u.BinaryReader(e),
                        o = void 0 === r ? n.len : n.pos + r,
                        i = I();
                    for (; n.pos < o;) {
                        let e = n.uint32();
                        switch (e >>> 3) {
                            case 1:
                                i.blockId = t.BlockID.decode(n, n.uint32());
                                break;
                            case 2:
                                i.blockSize = n.int64();
                                break;
                            case 3:
                                i.header = t.Header.decode(n, n.uint32());
                                break;
                            case 4:
                                i.numTxs = n.int64();
                                break;
                            default:
                                n.skipType(7 & e)
                        }
                    }
                    return i
                },
                fromJSON(e) {
                    let r = I();
                    return (0, p.isSet)(e.blockId) && (r.blockId = t.BlockID.fromJSON(e.blockId)), (0, p.isSet)(e.blockSize) && (r.blockSize = BigInt(e.blockSize.toString())), (0, p.isSet)(e.header) && (r.header = t.Header.fromJSON(e.header)), (0, p.isSet)(e.numTxs) && (r.numTxs = BigInt(e.numTxs.toString())), r
                },
                toJSON(e) {
                    let r = {};
                    return void 0 !== e.blockId && (r.blockId = e.blockId ? t.BlockID.toJSON(e.blockId) : void 0), void 0 !== e.blockSize && (r.blockSize = (e.blockSize || BigInt(0)).toString()), void 0 !== e.header && (r.header = e.header ? t.Header.toJSON(e.header) : void 0), void 0 !== e.numTxs && (r.numTxs = (e.numTxs || BigInt(0)).toString()), r
                },
                fromPartial(e) {
                    let r = I();
                    return void 0 !== e.blockId && null !== e.blockId && (r.blockId = t.BlockID.fromPartial(e.blockId)), void 0 !== e.blockSize && null !== e.blockSize && (r.blockSize = BigInt(e.blockSize.toString())), void 0 !== e.header && null !== e.header && (r.header = t.Header.fromPartial(e.header)), void 0 !== e.numTxs && null !== e.numTxs && (r.numTxs = BigInt(e.numTxs.toString())), r
                }
            }, t.TxProof = {
                typeUrl: "/tendermint.types.TxProof",
                encode: (e, t = u.BinaryWriter.create()) => (0 !== e.rootHash.length && t.uint32(10).bytes(e.rootHash), 0 !== e.data.length && t.uint32(18).bytes(e.data), void 0 !== e.proof && s.Proof.encode(e.proof, t.uint32(26).fork()).ldelim(), t),
                decode(e, t) {
                    let r = e instanceof u.BinaryReader ? e : new u.BinaryReader(e),
                        n = void 0 === t ? r.len : r.pos + t,
                        o = w();
                    for (; r.pos < n;) {
                        let e = r.uint32();
                        switch (e >>> 3) {
                            case 1:
                                o.rootHash = r.bytes();
                                break;
                            case 2:
                                o.data = r.bytes();
                                break;
                            case 3:
                                o.proof = s.Proof.decode(r, r.uint32());
                                break;
                            default:
                                r.skipType(7 & e)
                        }
                    }
                    return o
                },
                fromJSON(e) {
                    let t = w();
                    return (0, p.isSet)(e.rootHash) && (t.rootHash = (0, p.bytesFromBase64)(e.rootHash)), (0, p.isSet)(e.data) && (t.data = (0, p.bytesFromBase64)(e.data)), (0, p.isSet)(e.proof) && (t.proof = s.Proof.fromJSON(e.proof)), t
                },
                toJSON(e) {
                    let t = {};
                    return void 0 !== e.rootHash && (t.rootHash = (0, p.base64FromBytes)(void 0 !== e.rootHash ? e.rootHash : new Uint8Array)), void 0 !== e.data && (t.data = (0, p.base64FromBytes)(void 0 !== e.data ? e.data : new Uint8Array)), void 0 !== e.proof && (t.proof = e.proof ? s.Proof.toJSON(e.proof) : void 0), t
                },
                fromPartial(e) {
                    let t = w();
                    return t.rootHash = e.rootHash ? ? new Uint8Array, t.data = e.data ? ? new Uint8Array, void 0 !== e.proof && null !== e.proof && (t.proof = s.Proof.fromPartial(e.proof)), t
                }
            }
        },
        13002: function(e, t, r) {
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: !0
            }), t.SimpleValidator = t.Validator = t.ValidatorSet = t.protobufPackage = void 0;
            let n = r(39324),
                o = r(28486),
                i = r(6476);

            function a() {
                return {
                    validators: [],
                    proposer: void 0,
                    totalVotingPower: BigInt(0)
                }
            }

            function s() {
                return {
                    address: new Uint8Array,
                    pubKey: n.PublicKey.fromPartial({}),
                    votingPower: BigInt(0),
                    proposerPriority: BigInt(0)
                }
            }

            function d() {
                return {
                    pubKey: void 0,
                    votingPower: BigInt(0)
                }
            }
            t.protobufPackage = "tendermint.types", t.ValidatorSet = {
                typeUrl: "/tendermint.types.ValidatorSet",
                encode(e, r = o.BinaryWriter.create()) {
                    for (let n of e.validators) t.Validator.encode(n, r.uint32(10).fork()).ldelim();
                    return void 0 !== e.proposer && t.Validator.encode(e.proposer, r.uint32(18).fork()).ldelim(), e.totalVotingPower !== BigInt(0) && r.uint32(24).int64(e.totalVotingPower), r
                },
                decode(e, r) {
                    let n = e instanceof o.BinaryReader ? e : new o.BinaryReader(e),
                        i = void 0 === r ? n.len : n.pos + r,
                        s = a();
                    for (; n.pos < i;) {
                        let e = n.uint32();
                        switch (e >>> 3) {
                            case 1:
                                s.validators.push(t.Validator.decode(n, n.uint32()));
                                break;
                            case 2:
                                s.proposer = t.Validator.decode(n, n.uint32());
                                break;
                            case 3:
                                s.totalVotingPower = n.int64();
                                break;
                            default:
                                n.skipType(7 & e)
                        }
                    }
                    return s
                },
                fromJSON(e) {
                    let r = a();
                    return Array.isArray(e ? .validators) && (r.validators = e.validators.map(e => t.Validator.fromJSON(e))), (0, i.isSet)(e.proposer) && (r.proposer = t.Validator.fromJSON(e.proposer)), (0, i.isSet)(e.totalVotingPower) && (r.totalVotingPower = BigInt(e.totalVotingPower.toString())), r
                },
                toJSON(e) {
                    let r = {};
                    return e.validators ? r.validators = e.validators.map(e => e ? t.Validator.toJSON(e) : void 0) : r.validators = [], void 0 !== e.proposer && (r.proposer = e.proposer ? t.Validator.toJSON(e.proposer) : void 0), void 0 !== e.totalVotingPower && (r.totalVotingPower = (e.totalVotingPower || BigInt(0)).toString()), r
                },
                fromPartial(e) {
                    let r = a();
                    return r.validators = e.validators ? .map(e => t.Validator.fromPartial(e)) || [], void 0 !== e.proposer && null !== e.proposer && (r.proposer = t.Validator.fromPartial(e.proposer)), void 0 !== e.totalVotingPower && null !== e.totalVotingPower && (r.totalVotingPower = BigInt(e.totalVotingPower.toString())), r
                }
            }, t.Validator = {
                typeUrl: "/tendermint.types.Validator",
                encode: (e, t = o.BinaryWriter.create()) => (0 !== e.address.length && t.uint32(10).bytes(e.address), void 0 !== e.pubKey && n.PublicKey.encode(e.pubKey, t.uint32(18).fork()).ldelim(), e.votingPower !== BigInt(0) && t.uint32(24).int64(e.votingPower), e.proposerPriority !== BigInt(0) && t.uint32(32).int64(e.proposerPriority), t),
                decode(e, t) {
                    let r = e instanceof o.BinaryReader ? e : new o.BinaryReader(e),
                        i = void 0 === t ? r.len : r.pos + t,
                        a = s();
                    for (; r.pos < i;) {
                        let e = r.uint32();
                        switch (e >>> 3) {
                            case 1:
                                a.address = r.bytes();
                                break;
                            case 2:
                                a.pubKey = n.PublicKey.decode(r, r.uint32());
                                break;
                            case 3:
                                a.votingPower = r.int64();
                                break;
                            case 4:
                                a.proposerPriority = r.int64();
                                break;
                            default:
                                r.skipType(7 & e)
                        }
                    }
                    return a
                },
                fromJSON(e) {
                    let t = s();
                    return (0, i.isSet)(e.address) && (t.address = (0, i.bytesFromBase64)(e.address)), (0, i.isSet)(e.pubKey) && (t.pubKey = n.PublicKey.fromJSON(e.pubKey)), (0, i.isSet)(e.votingPower) && (t.votingPower = BigInt(e.votingPower.toString())), (0, i.isSet)(e.proposerPriority) && (t.proposerPriority = BigInt(e.proposerPriority.toString())), t
                },
                toJSON(e) {
                    let t = {};
                    return void 0 !== e.address && (t.address = (0, i.base64FromBytes)(void 0 !== e.address ? e.address : new Uint8Array)), void 0 !== e.pubKey && (t.pubKey = e.pubKey ? n.PublicKey.toJSON(e.pubKey) : void 0), void 0 !== e.votingPower && (t.votingPower = (e.votingPower || BigInt(0)).toString()), void 0 !== e.proposerPriority && (t.proposerPriority = (e.proposerPriority || BigInt(0)).toString()), t
                },
                fromPartial(e) {
                    let t = s();
                    return t.address = e.address ? ? new Uint8Array, void 0 !== e.pubKey && null !== e.pubKey && (t.pubKey = n.PublicKey.fromPartial(e.pubKey)), void 0 !== e.votingPower && null !== e.votingPower && (t.votingPower = BigInt(e.votingPower.toString())), void 0 !== e.proposerPriority && null !== e.proposerPriority && (t.proposerPriority = BigInt(e.proposerPriority.toString())), t
                }
            }, t.SimpleValidator = {
                typeUrl: "/tendermint.types.SimpleValidator",
                encode: (e, t = o.BinaryWriter.create()) => (void 0 !== e.pubKey && n.PublicKey.encode(e.pubKey, t.uint32(10).fork()).ldelim(), e.votingPower !== BigInt(0) && t.uint32(16).int64(e.votingPower), t),
                decode(e, t) {
                    let r = e instanceof o.BinaryReader ? e : new o.BinaryReader(e),
                        i = void 0 === t ? r.len : r.pos + t,
                        a = d();
                    for (; r.pos < i;) {
                        let e = r.uint32();
                        switch (e >>> 3) {
                            case 1:
                                a.pubKey = n.PublicKey.decode(r, r.uint32());
                                break;
                            case 2:
                                a.votingPower = r.int64();
                                break;
                            default:
                                r.skipType(7 & e)
                        }
                    }
                    return a
                },
                fromJSON(e) {
                    let t = d();
                    return (0, i.isSet)(e.pubKey) && (t.pubKey = n.PublicKey.fromJSON(e.pubKey)), (0, i.isSet)(e.votingPower) && (t.votingPower = BigInt(e.votingPower.toString())), t
                },
                toJSON(e) {
                    let t = {};
                    return void 0 !== e.pubKey && (t.pubKey = e.pubKey ? n.PublicKey.toJSON(e.pubKey) : void 0), void 0 !== e.votingPower && (t.votingPower = (e.votingPower || BigInt(0)).toString()), t
                },
                fromPartial(e) {
                    let t = d();
                    return void 0 !== e.pubKey && null !== e.pubKey && (t.pubKey = n.PublicKey.fromPartial(e.pubKey)), void 0 !== e.votingPower && null !== e.votingPower && (t.votingPower = BigInt(e.votingPower.toString())), t
                }
            }
        },
        95584: function(e, t, r) {
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: !0
            }), t.Consensus = t.App = t.protobufPackage = void 0;
            let n = r(28486),
                o = r(6476);

            function i() {
                return {
                    protocol: BigInt(0),
                    software: ""
                }
            }

            function a() {
                return {
                    block: BigInt(0),
                    app: BigInt(0)
                }
            }
            t.protobufPackage = "tendermint.version", t.App = {
                typeUrl: "/tendermint.version.App",
                encode: (e, t = n.BinaryWriter.create()) => (e.protocol !== BigInt(0) && t.uint32(8).uint64(e.protocol), "" !== e.software && t.uint32(18).string(e.software), t),
                decode(e, t) {
                    let r = e instanceof n.BinaryReader ? e : new n.BinaryReader(e),
                        o = void 0 === t ? r.len : r.pos + t,
                        a = i();
                    for (; r.pos < o;) {
                        let e = r.uint32();
                        switch (e >>> 3) {
                            case 1:
                                a.protocol = r.uint64();
                                break;
                            case 2:
                                a.software = r.string();
                                break;
                            default:
                                r.skipType(7 & e)
                        }
                    }
                    return a
                },
                fromJSON(e) {
                    let t = i();
                    return (0, o.isSet)(e.protocol) && (t.protocol = BigInt(e.protocol.toString())), (0, o.isSet)(e.software) && (t.software = String(e.software)), t
                },
                toJSON(e) {
                    let t = {};
                    return void 0 !== e.protocol && (t.protocol = (e.protocol || BigInt(0)).toString()), void 0 !== e.software && (t.software = e.software), t
                },
                fromPartial(e) {
                    let t = i();
                    return void 0 !== e.protocol && null !== e.protocol && (t.protocol = BigInt(e.protocol.toString())), t.software = e.software ? ? "", t
                }
            }, t.Consensus = {
                typeUrl: "/tendermint.version.Consensus",
                encode: (e, t = n.BinaryWriter.create()) => (e.block !== BigInt(0) && t.uint32(8).uint64(e.block), e.app !== BigInt(0) && t.uint32(16).uint64(e.app), t),
                decode(e, t) {
                    let r = e instanceof n.BinaryReader ? e : new n.BinaryReader(e),
                        o = void 0 === t ? r.len : r.pos + t,
                        i = a();
                    for (; r.pos < o;) {
                        let e = r.uint32();
                        switch (e >>> 3) {
                            case 1:
                                i.block = r.uint64();
                                break;
                            case 2:
                                i.app = r.uint64();
                                break;
                            default:
                                r.skipType(7 & e)
                        }
                    }
                    return i
                },
                fromJSON(e) {
                    let t = a();
                    return (0, o.isSet)(e.block) && (t.block = BigInt(e.block.toString())), (0, o.isSet)(e.app) && (t.app = BigInt(e.app.toString())), t
                },
                toJSON(e) {
                    let t = {};
                    return void 0 !== e.block && (t.block = (e.block || BigInt(0)).toString()), void 0 !== e.app && (t.app = (e.app || BigInt(0)).toString()), t
                },
                fromPartial(e) {
                    let t = a();
                    return void 0 !== e.block && null !== e.block && (t.block = BigInt(e.block.toString())), void 0 !== e.app && null !== e.app && (t.app = BigInt(e.app.toString())), t
                }
            }
        },
        83578: function(e, t) {
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: !0
            }), t.utf8Write = t.utf8Read = t.utf8Length = void 0, t.utf8Length = function(e) {
                let t = 0,
                    r = 0;
                for (let n = 0; n < e.length; ++n)(r = e.charCodeAt(n)) < 128 ? t += 1 : r < 2048 ? t += 2 : (64512 & r) == 55296 && (64512 & e.charCodeAt(n + 1)) == 56320 ? (++n, t += 4) : t += 3;
                return t
            }, t.utf8Read = function(e, t, r) {
                if (r - t < 1) return "";
                let n = [],
                    o = [],
                    i = 0,
                    a;
                for (; t < r;)(a = e[t++]) < 128 ? n[i++] = a : a > 191 && a < 224 ? n[i++] = (31 & a) << 6 | 63 & e[t++] : a > 239 && a < 365 ? (a = ((7 & a) << 18 | (63 & e[t++]) << 12 | (63 & e[t++]) << 6 | 63 & e[t++]) - 65536, n[i++] = 55296 + (a >> 10), n[i++] = 56320 + (1023 & a)) : n[i++] = (15 & a) << 12 | (63 & e[t++]) << 6 | 63 & e[t++], i > 8191 && ((o || (o = [])).push(String.fromCharCode(...n)), i = 0);
                return o ? (i && o.push(String.fromCharCode(...n.slice(0, i))), o.join("")) : String.fromCharCode(...n.slice(0, i))
            }, t.utf8Write = function(e, t, r) {
                let n, o;
                let i = r;
                for (let i = 0; i < e.length; ++i)(n = e.charCodeAt(i)) < 128 ? t[r++] = n : (n < 2048 ? t[r++] = n >> 6 | 192 : ((64512 & n) == 55296 && (64512 & (o = e.charCodeAt(i + 1))) == 56320 ? (n = 65536 + ((1023 & n) << 10) + (1023 & o), ++i, t[r++] = n >> 18 | 240, t[r++] = n >> 12 & 63 | 128) : t[r++] = n >> 12 | 224, t[r++] = n >> 6 & 63 | 128), t[r++] = 63 & n | 128);
                return r - i
            }
        },
        88767: function(e, t) {
            "use strict";

            function r(e, t) {
                if ({
                        lo: e,
                        hi: t
                    } = {
                        lo: e >>> 0,
                        hi: t >>> 0
                    }, t <= 2097151) return String(4294967296 * t + e);
                let r = 16777215 & e,
                    n = (e >>> 24 | t << 8) & 16777215,
                    o = t >> 16 & 65535,
                    a = r + 6777216 * n + 6710656 * o,
                    s = n + 8147497 * o,
                    d = 2 * o;
                return a >= 1e7 && (s += Math.floor(a / 1e7), a %= 1e7), s >= 1e7 && (d += Math.floor(s / 1e7), s %= 1e7), d.toString() + i(s) + i(a)
            }

            function n(e, t) {
                return {
                    lo: 0 | e,
                    hi: 0 | t
                }
            }

            function o(e, t) {
                return t = ~t, e ? e = ~e + 1 : t += 1, n(e, t)
            }
            Object.defineProperty(t, "__esModule", {
                value: !0
            }), t.writeByte = t.writeFixed32 = t.int64Length = t.writeVarint64 = t.writeVarint32 = t.readInt32 = t.readUInt32 = t.zzDecode = t.zzEncode = t.varint32read = t.varint32write = t.uInt64ToString = t.int64ToString = t.int64FromString = t.varint64write = t.varint64read = void 0, t.varint64read = function() {
                let e = 0,
                    t = 0;
                for (let r = 0; r < 28; r += 7) {
                    let n = this.buf[this.pos++];
                    if (e |= (127 & n) << r, (128 & n) == 0) return this.assertBounds(), [e, t]
                }
                let r = this.buf[this.pos++];
                if (e |= (15 & r) << 28, t = (112 & r) >> 4, (128 & r) == 0) return this.assertBounds(), [e, t];
                for (let r = 3; r <= 31; r += 7) {
                    let n = this.buf[this.pos++];
                    if (t |= (127 & n) << r, (128 & n) == 0) return this.assertBounds(), [e, t]
                }
                throw Error("invalid varint")
            }, t.varint64write = function(e, t, r) {
                for (let n = 0; n < 28; n += 7) {
                    let o = e >>> n,
                        i = !(o >>> 7 == 0 && 0 == t),
                        a = (i ? 128 | o : o) & 255;
                    if (r.push(a), !i) return
                }
                let n = e >>> 28 & 15 | (7 & t) << 4,
                    o = t >> 3 != 0;
                if (r.push((o ? 128 | n : n) & 255), o) {
                    for (let e = 3; e < 31; e += 7) {
                        let n = t >>> e,
                            o = n >>> 7 != 0,
                            i = (o ? 128 | n : n) & 255;
                        if (r.push(i), !o) return
                    }
                    r.push(t >>> 31 & 1)
                }
            }, t.int64FromString = function(e) {
                let t = "-" === e[0];
                t && (e = e.slice(1));
                let r = 0,
                    i = 0;

                function a(t, n) {
                    let o = Number(e.slice(t, n));
                    i *= 1e6, (r = 1e6 * r + o) >= 4294967296 && (i += r / 4294967296 | 0, r %= 4294967296)
                }
                return a(-24, -18), a(-18, -12), a(-12, -6), a(-6), t ? o(r, i) : n(r, i)
            }, t.int64ToString = function(e, t) {
                let i = n(e, t),
                    a = 2147483648 & i.hi;
                a && (i = o(i.lo, i.hi));
                let s = r(i.lo, i.hi);
                return a ? "-" + s : s
            }, t.uInt64ToString = r;
            let i = e => {
                let t = String(e);
                return "0000000".slice(t.length) + t
            };
            t.varint32write = function(e, t) {
                if (e >= 0) {
                    for (; e > 127;) t.push(127 & e | 128), e >>>= 7;
                    t.push(e)
                } else {
                    for (let r = 0; r < 9; r++) t.push(127 & e | 128), e >>= 7;
                    t.push(1)
                }
            }, t.varint32read = function() {
                let e = this.buf[this.pos++],
                    t = 127 & e;
                if ((128 & e) == 0 || (t |= (127 & (e = this.buf[this.pos++])) << 7, (128 & e) == 0) || (t |= (127 & (e = this.buf[this.pos++])) << 14, (128 & e) == 0) || (t |= (127 & (e = this.buf[this.pos++])) << 21, (128 & e) == 0)) return this.assertBounds(), t;
                t |= (15 & (e = this.buf[this.pos++])) << 28;
                for (let t = 5;
                    (128 & e) != 0 && t < 10; t++) e = this.buf[this.pos++];
                if ((128 & e) != 0) throw Error("invalid varint");
                return this.assertBounds(), t >>> 0
            }, t.zzEncode = function(e, t) {
                let r = t >> 31;
                return t = ((t << 1 | e >>> 31) ^ r) >>> 0, [e = (e << 1 ^ r) >>> 0, t]
            }, t.zzDecode = function(e, t) {
                let r = -(1 & e);
                return [e = ((e >>> 1 | t << 31) ^ r) >>> 0, t = (t >>> 1 ^ r) >>> 0]
            }, t.readUInt32 = function(e, t) {
                return (e[t] | e[t + 1] << 8 | e[t + 2] << 16) + 16777216 * e[t + 3]
            }, t.readInt32 = function(e, t) {
                return (e[t] | e[t + 1] << 8 | e[t + 2] << 16) + (e[t + 3] << 24)
            }, t.writeVarint32 = function(e, t, r) {
                for (; e > 127;) t[r++] = 127 & e | 128, e >>>= 7;
                t[r] = e
            }, t.writeVarint64 = function(e, t, r) {
                for (; e.hi;) t[r++] = 127 & e.lo | 128, e.lo = (e.lo >>> 7 | e.hi << 25) >>> 0, e.hi >>>= 7;
                for (; e.lo > 127;) t[r++] = 127 & e.lo | 128, e.lo = e.lo >>> 7;
                t[r++] = e.lo
            }, t.int64Length = function(e, t) {
                let r = (e >>> 28 | t << 4) >>> 0,
                    n = t >>> 24;
                return 0 === n ? 0 === r ? e < 16384 ? e < 128 ? 1 : 2 : e < 2097152 ? 3 : 4 : r < 16384 ? r < 128 ? 5 : 6 : r < 2097152 ? 7 : 8 : n < 128 ? 9 : 10
            }, t.writeFixed32 = function(e, t, r) {
                t[r] = 255 & e, t[r + 1] = e >>> 8 & 255, t[r + 2] = e >>> 16 & 255, t[r + 3] = e >>> 24
            }, t.writeByte = function(e, t, r) {
                t[r] = 255 & e
            }
        },
        98948: function(e, t, r) {
            var n, o, i, a, s;
            a = this, s = "object" == typeof a.sodium && "function" == typeof a.sodium.onload ? a.sodium.onload : null, o = [t, r(77544)], void 0 !== (i = "function" == typeof(n = function(e, t) {
                "use strict";
                var r, n = t.ready.then(function() {
                    function n() {
                        if (0 !== r._sodium_init()) throw Error("libsodium was not correctly initialized.");
                        for (var t, n = ["crypto_aead_aegis128l_decrypt", "crypto_aead_aegis128l_decrypt_detached", "crypto_aead_aegis128l_encrypt", "crypto_aead_aegis128l_encrypt_detached", "crypto_aead_aegis128l_keygen", "crypto_aead_aegis256_decrypt", "crypto_aead_aegis256_decrypt_detached", "crypto_aead_aegis256_encrypt", "crypto_aead_aegis256_encrypt_detached", "crypto_aead_aegis256_keygen", "crypto_aead_chacha20poly1305_decrypt", "crypto_aead_chacha20poly1305_decrypt_detached", "crypto_aead_chacha20poly1305_encrypt", "crypto_aead_chacha20poly1305_encrypt_detached", "crypto_aead_chacha20poly1305_ietf_decrypt", "crypto_aead_chacha20poly1305_ietf_decrypt_detached", "crypto_aead_chacha20poly1305_ietf_encrypt", "crypto_aead_chacha20poly1305_ietf_encrypt_detached", "crypto_aead_chacha20poly1305_ietf_keygen", "crypto_aead_chacha20poly1305_keygen", "crypto_aead_xchacha20poly1305_ietf_decrypt", "crypto_aead_xchacha20poly1305_ietf_decrypt_detached", "crypto_aead_xchacha20poly1305_ietf_encrypt", "crypto_aead_xchacha20poly1305_ietf_encrypt_detached", "crypto_aead_xchacha20poly1305_ietf_keygen", "crypto_auth", "crypto_auth_hmacsha256", "crypto_auth_hmacsha256_final", "crypto_auth_hmacsha256_init", "crypto_auth_hmacsha256_keygen", "crypto_auth_hmacsha256_update", "crypto_auth_hmacsha256_verify", "crypto_auth_hmacsha512", "crypto_auth_hmacsha512_final", "crypto_auth_hmacsha512_init", "crypto_auth_hmacsha512_keygen", "crypto_auth_hmacsha512_update", "crypto_auth_hmacsha512_verify", "crypto_auth_keygen", "crypto_auth_verify", "crypto_box_beforenm", "crypto_box_curve25519xchacha20poly1305_beforenm", "crypto_box_curve25519xchacha20poly1305_detached", "crypto_box_curve25519xchacha20poly1305_detached_afternm", "crypto_box_curve25519xchacha20poly1305_easy", "crypto_box_curve25519xchacha20poly1305_easy_afternm", "crypto_box_curve25519xchacha20poly1305_keypair", "crypto_box_curve25519xchacha20poly1305_open_detached", "crypto_box_curve25519xchacha20poly1305_open_detached_afternm", "crypto_box_curve25519xchacha20poly1305_open_easy", "crypto_box_curve25519xchacha20poly1305_open_easy_afternm", "crypto_box_curve25519xchacha20poly1305_seal", "crypto_box_curve25519xchacha20poly1305_seal_open", "crypto_box_curve25519xchacha20poly1305_seed_keypair", "crypto_box_detached", "crypto_box_easy", "crypto_box_easy_afternm", "crypto_box_keypair", "crypto_box_open_detached", "crypto_box_open_easy", "crypto_box_open_easy_afternm", "crypto_box_seal", "crypto_box_seal_open", "crypto_box_seed_keypair", "crypto_core_ed25519_add", "crypto_core_ed25519_from_hash", "crypto_core_ed25519_from_uniform", "crypto_core_ed25519_is_valid_point", "crypto_core_ed25519_random", "crypto_core_ed25519_scalar_add", "crypto_core_ed25519_scalar_complement", "crypto_core_ed25519_scalar_invert", "crypto_core_ed25519_scalar_mul", "crypto_core_ed25519_scalar_negate", "crypto_core_ed25519_scalar_random", "crypto_core_ed25519_scalar_reduce", "crypto_core_ed25519_scalar_sub", "crypto_core_ed25519_sub", "crypto_core_hchacha20", "crypto_core_hsalsa20", "crypto_core_ristretto255_add", "crypto_core_ristretto255_from_hash", "crypto_core_ristretto255_is_valid_point", "crypto_core_ristretto255_random", "crypto_core_ristretto255_scalar_add", "crypto_core_ristretto255_scalar_complement", "crypto_core_ristretto255_scalar_invert", "crypto_core_ristretto255_scalar_mul", "crypto_core_ristretto255_scalar_negate", "crypto_core_ristretto255_scalar_random", "crypto_core_ristretto255_scalar_reduce", "crypto_core_ristretto255_scalar_sub", "crypto_core_ristretto255_sub", "crypto_generichash", "crypto_generichash_blake2b_salt_personal", "crypto_generichash_final", "crypto_generichash_init", "crypto_generichash_keygen", "crypto_generichash_update", "crypto_hash", "crypto_hash_sha256", "crypto_hash_sha256_final", "crypto_hash_sha256_init", "crypto_hash_sha256_update", "crypto_hash_sha512", "crypto_hash_sha512_final", "crypto_hash_sha512_init", "crypto_hash_sha512_update", "crypto_kdf_derive_from_key", "crypto_kdf_keygen", "crypto_kx_client_session_keys", "crypto_kx_keypair", "crypto_kx_seed_keypair", "crypto_kx_server_session_keys", "crypto_onetimeauth", "crypto_onetimeauth_final", "crypto_onetimeauth_init", "crypto_onetimeauth_keygen", "crypto_onetimeauth_update", "crypto_onetimeauth_verify", "crypto_pwhash", "crypto_pwhash_scryptsalsa208sha256", "crypto_pwhash_scryptsalsa208sha256_ll", "crypto_pwhash_scryptsalsa208sha256_str", "crypto_pwhash_scryptsalsa208sha256_str_verify", "crypto_pwhash_str", "crypto_pwhash_str_needs_rehash", "crypto_pwhash_str_verify", "crypto_scalarmult", "crypto_scalarmult_base", "crypto_scalarmult_ed25519", "crypto_scalarmult_ed25519_base", "crypto_scalarmult_ed25519_base_noclamp", "crypto_scalarmult_ed25519_noclamp", "crypto_scalarmult_ristretto255", "crypto_scalarmult_ristretto255_base", "crypto_secretbox_detached", "crypto_secretbox_easy", "crypto_secretbox_keygen", "crypto_secretbox_open_detached", "crypto_secretbox_open_easy", "crypto_secretstream_xchacha20poly1305_init_pull", "crypto_secretstream_xchacha20poly1305_init_push", "crypto_secretstream_xchacha20poly1305_keygen", "crypto_secretstream_xchacha20poly1305_pull", "crypto_secretstream_xchacha20poly1305_push", "crypto_secretstream_xchacha20poly1305_rekey", "crypto_shorthash", "crypto_shorthash_keygen", "crypto_shorthash_siphashx24", "crypto_sign", "crypto_sign_detached", "crypto_sign_ed25519_pk_to_curve25519", "crypto_sign_ed25519_sk_to_curve25519", "crypto_sign_ed25519_sk_to_pk", "crypto_sign_ed25519_sk_to_seed", "crypto_sign_final_create", "crypto_sign_final_verify", "crypto_sign_init", "crypto_sign_keypair", "crypto_sign_open", "crypto_sign_seed_keypair", "crypto_sign_update", "crypto_sign_verify_detached", "crypto_stream_chacha20", "crypto_stream_chacha20_ietf_xor", "crypto_stream_chacha20_ietf_xor_ic", "crypto_stream_chacha20_keygen", "crypto_stream_chacha20_xor", "crypto_stream_chacha20_xor_ic", "crypto_stream_keygen", "crypto_stream_xchacha20_keygen", "crypto_stream_xchacha20_xor", "crypto_stream_xchacha20_xor_ic", "randombytes_buf", "randombytes_buf_deterministic", "randombytes_close", "randombytes_random", "randombytes_set_implementation", "randombytes_stir", "randombytes_uniform", "sodium_version_string"], o = [k, P, _, B, O, R, A, I, w, T, N, C, E, x, U, D, M, J, H, j, V, q, W, F, Q, G, L, K, Y, z, $, Z, X, ee, et, er, en, eo, ei, ea, es, ed, ec, el, eu, ep, em, eg, ef, ey, eh, ev, eb, eS, ek, eP, e_, eB, eO, eR, eA, eI, ew, eT, eN, eC, eE, ex, eU, eD, eM, eJ, eH, ej, eV, eq, eW, eF, eQ, eG, eL, eK, eY, ez, e$, eZ, eX, e0, e2, e1, e3, e6, e5, e4, e8, e7, e9, te, tt, tr, tn, to, ti, ta, ts, td, tc, tl, tu, tp, tm, tg, tf, ty, th, tv, tb, tS, tk, tP, t_, tB, tO, tR, tA, tI, tw, tT, tN, tC, tE, tx, tU, tD, tM, tJ, tH, tj, tV, tq, tW, tF, tQ, tG, tL, tK, tY, tz, t$, tZ, tX, t0, t2, t1, t3, t6, t5, t4, t8, t7, t9, re, rt, rr, rn, ro, ri, ra, rs, rd, rc, rl, ru, rp, rm, rg, rf, ry, rh, rv, rb, rS], i = 0; i < o.length; i++) "function" == typeof r["_" + n[i]] && (e[n[i]] = o[i]);
                        var a = ["SODIUM_LIBRARY_VERSION_MAJOR", "SODIUM_LIBRARY_VERSION_MINOR", "crypto_aead_chacha20poly1305_ABYTES", "crypto_aead_chacha20poly1305_IETF_ABYTES", "crypto_aead_chacha20poly1305_IETF_KEYBYTES", "crypto_aead_chacha20poly1305_IETF_MESSAGEBYTES_MAX", "crypto_aead_chacha20poly1305_IETF_NPUBBYTES", "crypto_aead_chacha20poly1305_IETF_NSECBYTES", "crypto_aead_chacha20poly1305_KEYBYTES", "crypto_aead_chacha20poly1305_MESSAGEBYTES_MAX", "crypto_aead_chacha20poly1305_NPUBBYTES", "crypto_aead_chacha20poly1305_NSECBYTES", "crypto_aead_chacha20poly1305_ietf_ABYTES", "crypto_aead_chacha20poly1305_ietf_KEYBYTES", "crypto_aead_chacha20poly1305_ietf_MESSAGEBYTES_MAX", "crypto_aead_chacha20poly1305_ietf_NPUBBYTES", "crypto_aead_chacha20poly1305_ietf_NSECBYTES", "crypto_aead_xchacha20poly1305_IETF_ABYTES", "crypto_aead_xchacha20poly1305_IETF_KEYBYTES", "crypto_aead_xchacha20poly1305_IETF_MESSAGEBYTES_MAX", "crypto_aead_xchacha20poly1305_IETF_NPUBBYTES", "crypto_aead_xchacha20poly1305_IETF_NSECBYTES", "crypto_aead_xchacha20poly1305_ietf_ABYTES", "crypto_aead_xchacha20poly1305_ietf_KEYBYTES", "crypto_aead_xchacha20poly1305_ietf_MESSAGEBYTES_MAX", "crypto_aead_xchacha20poly1305_ietf_NPUBBYTES", "crypto_aead_xchacha20poly1305_ietf_NSECBYTES", "crypto_auth_BYTES", "crypto_auth_KEYBYTES", "crypto_auth_hmacsha256_BYTES", "crypto_auth_hmacsha256_KEYBYTES", "crypto_auth_hmacsha512256_BYTES", "crypto_auth_hmacsha512256_KEYBYTES", "crypto_auth_hmacsha512_BYTES", "crypto_auth_hmacsha512_KEYBYTES", "crypto_box_BEFORENMBYTES", "crypto_box_MACBYTES", "crypto_box_MESSAGEBYTES_MAX", "crypto_box_NONCEBYTES", "crypto_box_PUBLICKEYBYTES", "crypto_box_SEALBYTES", "crypto_box_SECRETKEYBYTES", "crypto_box_SEEDBYTES", "crypto_box_curve25519xchacha20poly1305_BEFORENMBYTES", "crypto_box_curve25519xchacha20poly1305_MACBYTES", "crypto_box_curve25519xchacha20poly1305_MESSAGEBYTES_MAX", "crypto_box_curve25519xchacha20poly1305_NONCEBYTES", "crypto_box_curve25519xchacha20poly1305_PUBLICKEYBYTES", "crypto_box_curve25519xchacha20poly1305_SEALBYTES", "crypto_box_curve25519xchacha20poly1305_SECRETKEYBYTES", "crypto_box_curve25519xchacha20poly1305_SEEDBYTES", "crypto_box_curve25519xsalsa20poly1305_BEFORENMBYTES", "crypto_box_curve25519xsalsa20poly1305_MACBYTES", "crypto_box_curve25519xsalsa20poly1305_MESSAGEBYTES_MAX", "crypto_box_curve25519xsalsa20poly1305_NONCEBYTES", "crypto_box_curve25519xsalsa20poly1305_PUBLICKEYBYTES", "crypto_box_curve25519xsalsa20poly1305_SECRETKEYBYTES", "crypto_box_curve25519xsalsa20poly1305_SEEDBYTES", "crypto_core_ed25519_BYTES", "crypto_core_ed25519_HASHBYTES", "crypto_core_ed25519_NONREDUCEDSCALARBYTES", "crypto_core_ed25519_SCALARBYTES", "crypto_core_ed25519_UNIFORMBYTES", "crypto_core_hchacha20_CONSTBYTES", "crypto_core_hchacha20_INPUTBYTES", "crypto_core_hchacha20_KEYBYTES", "crypto_core_hchacha20_OUTPUTBYTES", "crypto_core_hsalsa20_CONSTBYTES", "crypto_core_hsalsa20_INPUTBYTES", "crypto_core_hsalsa20_KEYBYTES", "crypto_core_hsalsa20_OUTPUTBYTES", "crypto_core_ristretto255_BYTES", "crypto_core_ristretto255_HASHBYTES", "crypto_core_ristretto255_NONREDUCEDSCALARBYTES", "crypto_core_ristretto255_SCALARBYTES", "crypto_core_salsa2012_CONSTBYTES", "crypto_core_salsa2012_INPUTBYTES", "crypto_core_salsa2012_KEYBYTES", "crypto_core_salsa2012_OUTPUTBYTES", "crypto_core_salsa20_CONSTBYTES", "crypto_core_salsa20_INPUTBYTES", "crypto_core_salsa20_KEYBYTES", "crypto_core_salsa20_OUTPUTBYTES", "crypto_generichash_BYTES", "crypto_generichash_BYTES_MAX", "crypto_generichash_BYTES_MIN", "crypto_generichash_KEYBYTES", "crypto_generichash_KEYBYTES_MAX", "crypto_generichash_KEYBYTES_MIN", "crypto_generichash_blake2b_BYTES", "crypto_generichash_blake2b_BYTES_MAX", "crypto_generichash_blake2b_BYTES_MIN", "crypto_generichash_blake2b_KEYBYTES", "crypto_generichash_blake2b_KEYBYTES_MAX", "crypto_generichash_blake2b_KEYBYTES_MIN", "crypto_generichash_blake2b_PERSONALBYTES", "crypto_generichash_blake2b_SALTBYTES", "crypto_hash_BYTES", "crypto_hash_sha256_BYTES", "crypto_hash_sha512_BYTES", "crypto_kdf_BYTES_MAX", "crypto_kdf_BYTES_MIN", "crypto_kdf_CONTEXTBYTES", "crypto_kdf_KEYBYTES", "crypto_kdf_blake2b_BYTES_MAX", "crypto_kdf_blake2b_BYTES_MIN", "crypto_kdf_blake2b_CONTEXTBYTES", "crypto_kdf_blake2b_KEYBYTES", "crypto_kx_PUBLICKEYBYTES", "crypto_kx_SECRETKEYBYTES", "crypto_kx_SEEDBYTES", "crypto_kx_SESSIONKEYBYTES", "crypto_onetimeauth_BYTES", "crypto_onetimeauth_KEYBYTES", "crypto_onetimeauth_poly1305_BYTES", "crypto_onetimeauth_poly1305_KEYBYTES", "crypto_pwhash_ALG_ARGON2I13", "crypto_pwhash_ALG_ARGON2ID13", "crypto_pwhash_ALG_DEFAULT", "crypto_pwhash_BYTES_MAX", "crypto_pwhash_BYTES_MIN", "crypto_pwhash_MEMLIMIT_INTERACTIVE", "crypto_pwhash_MEMLIMIT_MAX", "crypto_pwhash_MEMLIMIT_MIN", "crypto_pwhash_MEMLIMIT_MODERATE", "crypto_pwhash_MEMLIMIT_SENSITIVE", "crypto_pwhash_OPSLIMIT_INTERACTIVE", "crypto_pwhash_OPSLIMIT_MAX", "crypto_pwhash_OPSLIMIT_MIN", "crypto_pwhash_OPSLIMIT_MODERATE", "crypto_pwhash_OPSLIMIT_SENSITIVE", "crypto_pwhash_PASSWD_MAX", "crypto_pwhash_PASSWD_MIN", "crypto_pwhash_SALTBYTES", "crypto_pwhash_STRBYTES", "crypto_pwhash_argon2i_BYTES_MAX", "crypto_pwhash_argon2i_BYTES_MIN", "crypto_pwhash_argon2i_SALTBYTES", "crypto_pwhash_argon2i_STRBYTES", "crypto_pwhash_argon2id_BYTES_MAX", "crypto_pwhash_argon2id_BYTES_MIN", "crypto_pwhash_argon2id_SALTBYTES", "crypto_pwhash_argon2id_STRBYTES", "crypto_pwhash_scryptsalsa208sha256_BYTES_MAX", "crypto_pwhash_scryptsalsa208sha256_BYTES_MIN", "crypto_pwhash_scryptsalsa208sha256_MEMLIMIT_INTERACTIVE", "crypto_pwhash_scryptsalsa208sha256_MEMLIMIT_MAX", "crypto_pwhash_scryptsalsa208sha256_MEMLIMIT_MIN", "crypto_pwhash_scryptsalsa208sha256_MEMLIMIT_SENSITIVE", "crypto_pwhash_scryptsalsa208sha256_OPSLIMIT_INTERACTIVE", "crypto_pwhash_scryptsalsa208sha256_OPSLIMIT_MAX", "crypto_pwhash_scryptsalsa208sha256_OPSLIMIT_MIN", "crypto_pwhash_scryptsalsa208sha256_OPSLIMIT_SENSITIVE", "crypto_pwhash_scryptsalsa208sha256_SALTBYTES", "crypto_pwhash_scryptsalsa208sha256_STRBYTES", "crypto_scalarmult_BYTES", "crypto_scalarmult_SCALARBYTES", "crypto_scalarmult_curve25519_BYTES", "crypto_scalarmult_curve25519_SCALARBYTES", "crypto_scalarmult_ed25519_BYTES", "crypto_scalarmult_ed25519_SCALARBYTES", "crypto_scalarmult_ristretto255_BYTES", "crypto_scalarmult_ristretto255_SCALARBYTES", "crypto_secretbox_KEYBYTES", "crypto_secretbox_MACBYTES", "crypto_secretbox_MESSAGEBYTES_MAX", "crypto_secretbox_NONCEBYTES", "crypto_secretbox_xchacha20poly1305_KEYBYTES", "crypto_secretbox_xchacha20poly1305_MACBYTES", "crypto_secretbox_xchacha20poly1305_MESSAGEBYTES_MAX", "crypto_secretbox_xchacha20poly1305_NONCEBYTES", "crypto_secretbox_xsalsa20poly1305_KEYBYTES", "crypto_secretbox_xsalsa20poly1305_MACBYTES", "crypto_secretbox_xsalsa20poly1305_MESSAGEBYTES_MAX", "crypto_secretbox_xsalsa20poly1305_NONCEBYTES", "crypto_secretstream_xchacha20poly1305_ABYTES", "crypto_secretstream_xchacha20poly1305_HEADERBYTES", "crypto_secretstream_xchacha20poly1305_KEYBYTES", "crypto_secretstream_xchacha20poly1305_MESSAGEBYTES_MAX", "crypto_secretstream_xchacha20poly1305_TAG_FINAL", "crypto_secretstream_xchacha20poly1305_TAG_MESSAGE", "crypto_secretstream_xchacha20poly1305_TAG_PUSH", "crypto_secretstream_xchacha20poly1305_TAG_REKEY", "crypto_shorthash_BYTES", "crypto_shorthash_KEYBYTES", "crypto_shorthash_siphash24_BYTES", "crypto_shorthash_siphash24_KEYBYTES", "crypto_shorthash_siphashx24_BYTES", "crypto_shorthash_siphashx24_KEYBYTES", "crypto_sign_BYTES", "crypto_sign_MESSAGEBYTES_MAX", "crypto_sign_PUBLICKEYBYTES", "crypto_sign_SECRETKEYBYTES", "crypto_sign_SEEDBYTES", "crypto_sign_ed25519_BYTES", "crypto_sign_ed25519_MESSAGEBYTES_MAX", "crypto_sign_ed25519_PUBLICKEYBYTES", "crypto_sign_ed25519_SECRETKEYBYTES", "crypto_sign_ed25519_SEEDBYTES", "crypto_stream_KEYBYTES", "crypto_stream_MESSAGEBYTES_MAX", "crypto_stream_NONCEBYTES", "crypto_stream_chacha20_IETF_KEYBYTES", "crypto_stream_chacha20_IETF_MESSAGEBYTES_MAX", "crypto_stream_chacha20_IETF_NONCEBYTES", "crypto_stream_chacha20_KEYBYTES", "crypto_stream_chacha20_MESSAGEBYTES_MAX", "crypto_stream_chacha20_NONCEBYTES", "crypto_stream_chacha20_ietf_KEYBYTES", "crypto_stream_chacha20_ietf_MESSAGEBYTES_MAX", "crypto_stream_chacha20_ietf_NONCEBYTES", "crypto_stream_salsa2012_KEYBYTES", "crypto_stream_salsa2012_MESSAGEBYTES_MAX", "crypto_stream_salsa2012_NONCEBYTES", "crypto_stream_salsa208_KEYBYTES", "crypto_stream_salsa208_MESSAGEBYTES_MAX", "crypto_stream_salsa208_NONCEBYTES", "crypto_stream_salsa20_KEYBYTES", "crypto_stream_salsa20_MESSAGEBYTES_MAX", "crypto_stream_salsa20_NONCEBYTES", "crypto_stream_xchacha20_KEYBYTES", "crypto_stream_xchacha20_MESSAGEBYTES_MAX", "crypto_stream_xchacha20_NONCEBYTES", "crypto_stream_xsalsa20_KEYBYTES", "crypto_stream_xsalsa20_MESSAGEBYTES_MAX", "crypto_stream_xsalsa20_NONCEBYTES", "crypto_verify_16_BYTES", "crypto_verify_32_BYTES", "crypto_verify_64_BYTES"];
                        for (i = 0; i < a.length; i++) "function" == typeof(t = r["_" + a[i].toLowerCase()]) && (e[a[i]] = t());
                        var s = ["SODIUM_VERSION_STRING", "crypto_pwhash_STRPREFIX", "crypto_pwhash_scryptsalsa208sha256_STRPREFIX"];
                        for (i = 0; i < s.length; i++) "function" == typeof(t = r["_" + s[i].toLowerCase()]) && (e[s[i]] = r.UTF8ToString(t()))
                    }
                    r = t;
                    try {
                        n();
                        var o = new Uint8Array([98, 97, 108, 108, 115]),
                            i = e.randombytes_buf(e.crypto_secretbox_NONCEBYTES),
                            a = e.randombytes_buf(e.crypto_secretbox_KEYBYTES),
                            s = e.crypto_secretbox_easy(o, i, a),
                            d = e.crypto_secretbox_open_easy(s, i, a);
                        if (e.memcmp(o, d)) return
                    } catch (e) {
                        if (null == r.useBackupModule) throw Error("Both wasm and asm failed to load" + e)
                    }
                    r.useBackupModule(), n()
                });

                function o(e) {
                    if ("function" == typeof TextEncoder) return (new TextEncoder).encode(e);
                    e = unescape(encodeURIComponent(e));
                    for (var t = new Uint8Array(e.length), r = 0, n = e.length; r < n; r++) t[r] = e.charCodeAt(r);
                    return t
                }

                function i(e) {
                    if ("function" == typeof TextDecoder) return new TextDecoder("utf-8", {
                        fatal: !0
                    }).decode(e);
                    var t = Math.ceil(e.length / 8192);
                    if (t <= 1) try {
                        return decodeURIComponent(escape(String.fromCharCode.apply(null, e)))
                    } catch (e) {
                        throw TypeError("The encoded data was not valid.")
                    }
                    for (var r = "", n = 0, o = 0; o < t; o++) {
                        var a = Array.prototype.slice.call(e, 8192 * o + n, (o + 1) * 8192 + n);
                        if (0 != a.length) {
                            var s, d = a.length,
                                c = 0;
                            do {
                                var l = a[--d];
                                l >= 240 ? (c = 4, s = !0) : l >= 224 ? (c = 3, s = !0) : l >= 192 ? (c = 2, s = !0) : l < 128 && (c = 1, s = !0)
                            } while (!s);
                            for (var u = c - (a.length - d), p = 0; p < u; p++) n--, a.pop();
                            r += i(a)
                        }
                    }
                    return r
                }

                function a(e) {
                    e = S(null, e, "input");
                    for (var t, r, n, o = "", i = 0; i < e.length; i++) o += String.fromCharCode(255 & (n = 87 + (r = 15 & e[i]) + (r - 10 >> 8 & -39) << 8 | 87 + (t = e[i] >>> 4) + (t - 10 >> 8 & -39))) + String.fromCharCode(n >>> 8);
                    return o
                }
                var s = {
                    ORIGINAL: 1,
                    ORIGINAL_NO_PADDING: 3,
                    URLSAFE: 5,
                    URLSAFE_NO_PADDING: 7
                };

                function d(e) {
                    if (null == e) return s.URLSAFE_NO_PADDING;
                    if (e !== s.ORIGINAL && e !== s.ORIGINAL_NO_PADDING && e !== s.URLSAFE && e != s.URLSAFE_NO_PADDING) throw Error("unsupported base64 variant");
                    return e
                }

                function c(e, t) {
                    t = d(t);
                    var n, o = [],
                        a = 0 | Math.floor((e = S(o, e, "input")).length / 3),
                        s = e.length - 3 * a,
                        c = 4 * a + (0 !== s ? 0 == (2 & t) ? 4 : 2 + (s >>> 1) : 0),
                        l = new m(c + 1),
                        u = g(e);
                    return o.push(u), o.push(l.address), 0 === r._sodium_bin2base64(l.address, l.length, u, e.length, t) && h(o, "conversion failed"), l.length = c, n = i(l.to_Uint8Array()), y(o), n
                }

                function l(e, t) {
                    var r = t || "uint8array";
                    if (!u(r)) throw Error(r + " output format is not available");
                    if (e instanceof m) {
                        if ("uint8array" === r) return e.to_Uint8Array();
                        if ("text" === r) return i(e.to_Uint8Array());
                        if ("hex" === r) return a(e.to_Uint8Array());
                        if ("base64" === r) return c(e.to_Uint8Array(), s.URLSAFE_NO_PADDING);
                        throw Error('What is output format "' + r + '"?')
                    }
                    if ("object" == typeof e) {
                        for (var n = Object.keys(e), o = {}, d = 0; d < n.length; d++) o[n[d]] = l(e[n[d]], r);
                        return o
                    }
                    if ("string" == typeof e) return e;
                    throw TypeError("Cannot format output")
                }

                function u(e) {
                    for (var t = ["uint8array", "text", "hex", "base64"], r = 0; r < t.length; r++)
                        if (t[r] === e) return !0;
                    return !1
                }

                function p(e) {
                    if (e) {
                        if ("string" != typeof e) throw TypeError("When defined, the output format must be a string");
                        if (!u(e)) throw Error(e + " is not a supported output format")
                    }
                }

                function m(e) {
                    this.length = e, this.address = f(e)
                }

                function g(e) {
                    var t = f(e.length);
                    return r.HEAPU8.set(e, t), t
                }

                function f(e) {
                    var t = r._malloc(e);
                    if (0 === t) throw {
                        message: "_malloc() failed",
                        length: e
                    };
                    return t
                }

                function y(e) {
                    if (e)
                        for (var t, n = 0; n < e.length; n++) t = e[n], r._free(t)
                }

                function h(e, t) {
                    throw y(e), Error(t)
                }

                function v(e, t) {
                    throw y(e), TypeError(t)
                }

                function b(e, t, r) {
                    null == t && v(e, r + " cannot be null or undefined")
                }

                function S(e, t, r) {
                    return b(e, t, r), t instanceof Uint8Array ? t : "string" == typeof t ? o(t) : void v(e, "unsupported input type for " + r)
                }

                function k(e, t, n, o, i, a) {
                    var s = [];
                    p(a);
                    var d = null;
                    null != e && (d = g(e = S(s, e, "secret_nonce")), e.length, s.push(d)), t = S(s, t, "ciphertext");
                    var c, u = r._crypto_aead_aegis128l_abytes(),
                        f = t.length;
                    f < u && v(s, "ciphertext is too short"), c = g(t), s.push(c);
                    var b = null,
                        k = 0;
                    null != n && (b = g(n = S(s, n, "additional_data")), k = n.length, s.push(b)), o = S(s, o, "public_nonce");
                    var P, _ = 0 | r._crypto_aead_aegis128l_npubbytes();
                    o.length !== _ && v(s, "invalid public_nonce length"), P = g(o), s.push(P), i = S(s, i, "key");
                    var B, O = 0 | r._crypto_aead_aegis128l_keybytes();
                    i.length !== O && v(s, "invalid key length"), B = g(i), s.push(B);
                    var R = new m(f - r._crypto_aead_aegis128l_abytes() | 0),
                        A = R.address;
                    if (s.push(A), 0 === r._crypto_aead_aegis128l_decrypt(A, null, d, c, f, 0, b, k, 0, P, B)) {
                        var I = l(R, a);
                        return y(s), I
                    }
                    h(s, "ciphertext cannot be decrypted using that key")
                }

                function P(e, t, n, o, i, a, s) {
                    var d = [];
                    p(s);
                    var c = null;
                    null != e && (c = g(e = S(d, e, "secret_nonce")), e.length, d.push(c));
                    var u = g(t = S(d, t, "ciphertext")),
                        f = t.length;
                    d.push(u), n = S(d, n, "mac");
                    var b, k = 0 | r._crypto_box_macbytes();
                    n.length !== k && v(d, "invalid mac length"), b = g(n), d.push(b);
                    var P = null,
                        _ = 0;
                    null != o && (P = g(o = S(d, o, "additional_data")), _ = o.length, d.push(P)), i = S(d, i, "public_nonce");
                    var B, O = 0 | r._crypto_aead_aegis128l_npubbytes();
                    i.length !== O && v(d, "invalid public_nonce length"), B = g(i), d.push(B), a = S(d, a, "key");
                    var R, A = 0 | r._crypto_aead_aegis128l_keybytes();
                    a.length !== A && v(d, "invalid key length"), R = g(a), d.push(R);
                    var I = new m(0 | f),
                        w = I.address;
                    if (d.push(w), 0 === r._crypto_aead_aegis128l_decrypt_detached(w, c, u, f, 0, b, P, _, 0, B, R)) {
                        var T = l(I, s);
                        return y(d), T
                    }
                    h(d, "ciphertext cannot be decrypted using that key")
                }

                function _(e, t, n, o, i, a) {
                    var s = [];
                    p(a);
                    var d = g(e = S(s, e, "message")),
                        c = e.length;
                    s.push(d);
                    var u = null,
                        f = 0;
                    null != t && (u = g(t = S(s, t, "additional_data")), f = t.length, s.push(u));
                    var b = null;
                    null != n && (b = g(n = S(s, n, "secret_nonce")), n.length, s.push(b)), o = S(s, o, "public_nonce");
                    var k, P = 0 | r._crypto_aead_aegis128l_npubbytes();
                    o.length !== P && v(s, "invalid public_nonce length"), k = g(o), s.push(k), i = S(s, i, "key");
                    var _, B = 0 | r._crypto_aead_aegis128l_keybytes();
                    i.length !== B && v(s, "invalid key length"), _ = g(i), s.push(_);
                    var O = new m(c + r._crypto_aead_aegis128l_abytes() | 0),
                        R = O.address;
                    if (s.push(R), 0 === r._crypto_aead_aegis128l_encrypt(R, null, d, c, 0, u, f, 0, b, k, _)) {
                        var A = l(O, a);
                        return y(s), A
                    }
                    h(s, "invalid usage")
                }

                function B(e, t, n, o, i, a) {
                    var s = [];
                    p(a);
                    var d = g(e = S(s, e, "message")),
                        c = e.length;
                    s.push(d);
                    var u = null,
                        f = 0;
                    null != t && (u = g(t = S(s, t, "additional_data")), f = t.length, s.push(u));
                    var b = null;
                    null != n && (b = g(n = S(s, n, "secret_nonce")), n.length, s.push(b)), o = S(s, o, "public_nonce");
                    var k, P = 0 | r._crypto_aead_aegis128l_npubbytes();
                    o.length !== P && v(s, "invalid public_nonce length"), k = g(o), s.push(k), i = S(s, i, "key");
                    var _, B = 0 | r._crypto_aead_aegis128l_keybytes();
                    i.length !== B && v(s, "invalid key length"), _ = g(i), s.push(_);
                    var O = new m(0 | c),
                        R = O.address;
                    s.push(R);
                    var A = new m(0 | r._crypto_aead_aegis128l_abytes()),
                        I = A.address;
                    if (s.push(I), 0 === r._crypto_aead_aegis128l_encrypt_detached(R, I, null, d, c, 0, u, f, 0, b, k, _)) {
                        var w = l({
                            ciphertext: O,
                            mac: A
                        }, a);
                        return y(s), w
                    }
                    h(s, "invalid usage")
                }

                function O(e) {
                    var t = [];
                    p(e);
                    var n = new m(0 | r._crypto_aead_aegis128l_keybytes()),
                        o = n.address;
                    t.push(o), r._crypto_aead_aegis128l_keygen(o);
                    var i = l(n, e);
                    return y(t), i
                }

                function R(e, t, n, o, i, a) {
                    var s = [];
                    p(a);
                    var d = null;
                    null != e && (d = g(e = S(s, e, "secret_nonce")), e.length, s.push(d)), t = S(s, t, "ciphertext");
                    var c, u = r._crypto_aead_aegis256_abytes(),
                        f = t.length;
                    f < u && v(s, "ciphertext is too short"), c = g(t), s.push(c);
                    var b = null,
                        k = 0;
                    null != n && (b = g(n = S(s, n, "additional_data")), k = n.length, s.push(b)), o = S(s, o, "public_nonce");
                    var P, _ = 0 | r._crypto_aead_aegis256_npubbytes();
                    o.length !== _ && v(s, "invalid public_nonce length"), P = g(o), s.push(P), i = S(s, i, "key");
                    var B, O = 0 | r._crypto_aead_aegis256_keybytes();
                    i.length !== O && v(s, "invalid key length"), B = g(i), s.push(B);
                    var R = new m(f - r._crypto_aead_aegis256_abytes() | 0),
                        A = R.address;
                    if (s.push(A), 0 === r._crypto_aead_aegis256_decrypt(A, null, d, c, f, 0, b, k, 0, P, B)) {
                        var I = l(R, a);
                        return y(s), I
                    }
                    h(s, "ciphertext cannot be decrypted using that key")
                }

                function A(e, t, n, o, i, a, s) {
                    var d = [];
                    p(s);
                    var c = null;
                    null != e && (c = g(e = S(d, e, "secret_nonce")), e.length, d.push(c));
                    var u = g(t = S(d, t, "ciphertext")),
                        f = t.length;
                    d.push(u), n = S(d, n, "mac");
                    var b, k = 0 | r._crypto_box_macbytes();
                    n.length !== k && v(d, "invalid mac length"), b = g(n), d.push(b);
                    var P = null,
                        _ = 0;
                    null != o && (P = g(o = S(d, o, "additional_data")), _ = o.length, d.push(P)), i = S(d, i, "public_nonce");
                    var B, O = 0 | r._crypto_aead_aegis256_npubbytes();
                    i.length !== O && v(d, "invalid public_nonce length"), B = g(i), d.push(B), a = S(d, a, "key");
                    var R, A = 0 | r._crypto_aead_aegis256_keybytes();
                    a.length !== A && v(d, "invalid key length"), R = g(a), d.push(R);
                    var I = new m(0 | f),
                        w = I.address;
                    if (d.push(w), 0 === r._crypto_aead_aegis256_decrypt_detached(w, c, u, f, 0, b, P, _, 0, B, R)) {
                        var T = l(I, s);
                        return y(d), T
                    }
                    h(d, "ciphertext cannot be decrypted using that key")
                }

                function I(e, t, n, o, i, a) {
                    var s = [];
                    p(a);
                    var d = g(e = S(s, e, "message")),
                        c = e.length;
                    s.push(d);
                    var u = null,
                        f = 0;
                    null != t && (u = g(t = S(s, t, "additional_data")), f = t.length, s.push(u));
                    var b = null;
                    null != n && (b = g(n = S(s, n, "secret_nonce")), n.length, s.push(b)), o = S(s, o, "public_nonce");
                    var k, P = 0 | r._crypto_aead_aegis256_npubbytes();
                    o.length !== P && v(s, "invalid public_nonce length"), k = g(o), s.push(k), i = S(s, i, "key");
                    var _, B = 0 | r._crypto_aead_aegis256_keybytes();
                    i.length !== B && v(s, "invalid key length"), _ = g(i), s.push(_);
                    var O = new m(c + r._crypto_aead_aegis256_abytes() | 0),
                        R = O.address;
                    if (s.push(R), 0 === r._crypto_aead_aegis256_encrypt(R, null, d, c, 0, u, f, 0, b, k, _)) {
                        var A = l(O, a);
                        return y(s), A
                    }
                    h(s, "invalid usage")
                }

                function w(e, t, n, o, i, a) {
                    var s = [];
                    p(a);
                    var d = g(e = S(s, e, "message")),
                        c = e.length;
                    s.push(d);
                    var u = null,
                        f = 0;
                    null != t && (u = g(t = S(s, t, "additional_data")), f = t.length, s.push(u));
                    var b = null;
                    null != n && (b = g(n = S(s, n, "secret_nonce")), n.length, s.push(b)), o = S(s, o, "public_nonce");
                    var k, P = 0 | r._crypto_aead_aegis256_npubbytes();
                    o.length !== P && v(s, "invalid public_nonce length"), k = g(o), s.push(k), i = S(s, i, "key");
                    var _, B = 0 | r._crypto_aead_aegis256_keybytes();
                    i.length !== B && v(s, "invalid key length"), _ = g(i), s.push(_);
                    var O = new m(0 | c),
                        R = O.address;
                    s.push(R);
                    var A = new m(0 | r._crypto_aead_aegis256_abytes()),
                        I = A.address;
                    if (s.push(I), 0 === r._crypto_aead_aegis256_encrypt_detached(R, I, null, d, c, 0, u, f, 0, b, k, _)) {
                        var w = l({
                            ciphertext: O,
                            mac: A
                        }, a);
                        return y(s), w
                    }
                    h(s, "invalid usage")
                }

                function T(e) {
                    var t = [];
                    p(e);
                    var n = new m(0 | r._crypto_aead_aegis256_keybytes()),
                        o = n.address;
                    t.push(o), r._crypto_aead_aegis256_keygen(o);
                    var i = l(n, e);
                    return y(t), i
                }

                function N(e, t, n, o, i, a) {
                    var s = [];
                    p(a);
                    var d = null;
                    null != e && (d = g(e = S(s, e, "secret_nonce")), e.length, s.push(d)), t = S(s, t, "ciphertext");
                    var c, u = r._crypto_aead_chacha20poly1305_abytes(),
                        f = t.length;
                    f < u && v(s, "ciphertext is too short"), c = g(t), s.push(c);
                    var b = null,
                        k = 0;
                    null != n && (b = g(n = S(s, n, "additional_data")), k = n.length, s.push(b)), o = S(s, o, "public_nonce");
                    var P, _ = 0 | r._crypto_aead_chacha20poly1305_npubbytes();
                    o.length !== _ && v(s, "invalid public_nonce length"), P = g(o), s.push(P), i = S(s, i, "key");
                    var B, O = 0 | r._crypto_aead_chacha20poly1305_keybytes();
                    i.length !== O && v(s, "invalid key length"), B = g(i), s.push(B);
                    var R = new m(f - r._crypto_aead_chacha20poly1305_abytes() | 0),
                        A = R.address;
                    if (s.push(A), 0 === r._crypto_aead_chacha20poly1305_decrypt(A, null, d, c, f, 0, b, k, 0, P, B)) {
                        var I = l(R, a);
                        return y(s), I
                    }
                    h(s, "ciphertext cannot be decrypted using that key")
                }

                function C(e, t, n, o, i, a, s) {
                    var d = [];
                    p(s);
                    var c = null;
                    null != e && (c = g(e = S(d, e, "secret_nonce")), e.length, d.push(c));
                    var u = g(t = S(d, t, "ciphertext")),
                        f = t.length;
                    d.push(u), n = S(d, n, "mac");
                    var b, k = 0 | r._crypto_box_macbytes();
                    n.length !== k && v(d, "invalid mac length"), b = g(n), d.push(b);
                    var P = null,
                        _ = 0;
                    null != o && (P = g(o = S(d, o, "additional_data")), _ = o.length, d.push(P)), i = S(d, i, "public_nonce");
                    var B, O = 0 | r._crypto_aead_chacha20poly1305_npubbytes();
                    i.length !== O && v(d, "invalid public_nonce length"), B = g(i), d.push(B), a = S(d, a, "key");
                    var R, A = 0 | r._crypto_aead_chacha20poly1305_keybytes();
                    a.length !== A && v(d, "invalid key length"), R = g(a), d.push(R);
                    var I = new m(0 | f),
                        w = I.address;
                    if (d.push(w), 0 === r._crypto_aead_chacha20poly1305_decrypt_detached(w, c, u, f, 0, b, P, _, 0, B, R)) {
                        var T = l(I, s);
                        return y(d), T
                    }
                    h(d, "ciphertext cannot be decrypted using that key")
                }

                function E(e, t, n, o, i, a) {
                    var s = [];
                    p(a);
                    var d = g(e = S(s, e, "message")),
                        c = e.length;
                    s.push(d);
                    var u = null,
                        f = 0;
                    null != t && (u = g(t = S(s, t, "additional_data")), f = t.length, s.push(u));
                    var b = null;
                    null != n && (b = g(n = S(s, n, "secret_nonce")), n.length, s.push(b)), o = S(s, o, "public_nonce");
                    var k, P = 0 | r._crypto_aead_chacha20poly1305_npubbytes();
                    o.length !== P && v(s, "invalid public_nonce length"), k = g(o), s.push(k), i = S(s, i, "key");
                    var _, B = 0 | r._crypto_aead_chacha20poly1305_keybytes();
                    i.length !== B && v(s, "invalid key length"), _ = g(i), s.push(_);
                    var O = new m(c + r._crypto_aead_chacha20poly1305_abytes() | 0),
                        R = O.address;
                    if (s.push(R), 0 === r._crypto_aead_chacha20poly1305_encrypt(R, null, d, c, 0, u, f, 0, b, k, _)) {
                        var A = l(O, a);
                        return y(s), A
                    }
                    h(s, "invalid usage")
                }

                function x(e, t, n, o, i, a) {
                    var s = [];
                    p(a);
                    var d = g(e = S(s, e, "message")),
                        c = e.length;
                    s.push(d);
                    var u = null,
                        f = 0;
                    null != t && (u = g(t = S(s, t, "additional_data")), f = t.length, s.push(u));
                    var b = null;
                    null != n && (b = g(n = S(s, n, "secret_nonce")), n.length, s.push(b)), o = S(s, o, "public_nonce");
                    var k, P = 0 | r._crypto_aead_chacha20poly1305_npubbytes();
                    o.length !== P && v(s, "invalid public_nonce length"), k = g(o), s.push(k), i = S(s, i, "key");
                    var _, B = 0 | r._crypto_aead_chacha20poly1305_keybytes();
                    i.length !== B && v(s, "invalid key length"), _ = g(i), s.push(_);
                    var O = new m(0 | c),
                        R = O.address;
                    s.push(R);
                    var A = new m(0 | r._crypto_aead_chacha20poly1305_abytes()),
                        I = A.address;
                    if (s.push(I), 0 === r._crypto_aead_chacha20poly1305_encrypt_detached(R, I, null, d, c, 0, u, f, 0, b, k, _)) {
                        var w = l({
                            ciphertext: O,
                            mac: A
                        }, a);
                        return y(s), w
                    }
                    h(s, "invalid usage")
                }

                function U(e, t, n, o, i, a) {
                    var s = [];
                    p(a);
                    var d = null;
                    null != e && (d = g(e = S(s, e, "secret_nonce")), e.length, s.push(d)), t = S(s, t, "ciphertext");
                    var c, u = r._crypto_aead_chacha20poly1305_ietf_abytes(),
                        f = t.length;
                    f < u && v(s, "ciphertext is too short"), c = g(t), s.push(c);
                    var b = null,
                        k = 0;
                    null != n && (b = g(n = S(s, n, "additional_data")), k = n.length, s.push(b)), o = S(s, o, "public_nonce");
                    var P, _ = 0 | r._crypto_aead_chacha20poly1305_ietf_npubbytes();
                    o.length !== _ && v(s, "invalid public_nonce length"), P = g(o), s.push(P), i = S(s, i, "key");
                    var B, O = 0 | r._crypto_aead_chacha20poly1305_ietf_keybytes();
                    i.length !== O && v(s, "invalid key length"), B = g(i), s.push(B);
                    var R = new m(f - r._crypto_aead_chacha20poly1305_ietf_abytes() | 0),
                        A = R.address;
                    if (s.push(A), 0 === r._crypto_aead_chacha20poly1305_ietf_decrypt(A, null, d, c, f, 0, b, k, 0, P, B)) {
                        var I = l(R, a);
                        return y(s), I
                    }
                    h(s, "ciphertext cannot be decrypted using that key")
                }

                function D(e, t, n, o, i, a, s) {
                    var d = [];
                    p(s);
                    var c = null;
                    null != e && (c = g(e = S(d, e, "secret_nonce")), e.length, d.push(c));
                    var u = g(t = S(d, t, "ciphertext")),
                        f = t.length;
                    d.push(u), n = S(d, n, "mac");
                    var b, k = 0 | r._crypto_box_macbytes();
                    n.length !== k && v(d, "invalid mac length"), b = g(n), d.push(b);
                    var P = null,
                        _ = 0;
                    null != o && (P = g(o = S(d, o, "additional_data")), _ = o.length, d.push(P)), i = S(d, i, "public_nonce");
                    var B, O = 0 | r._crypto_aead_chacha20poly1305_ietf_npubbytes();
                    i.length !== O && v(d, "invalid public_nonce length"), B = g(i), d.push(B), a = S(d, a, "key");
                    var R, A = 0 | r._crypto_aead_chacha20poly1305_ietf_keybytes();
                    a.length !== A && v(d, "invalid key length"), R = g(a), d.push(R);
                    var I = new m(0 | f),
                        w = I.address;
                    if (d.push(w), 0 === r._crypto_aead_chacha20poly1305_ietf_decrypt_detached(w, c, u, f, 0, b, P, _, 0, B, R)) {
                        var T = l(I, s);
                        return y(d), T
                    }
                    h(d, "ciphertext cannot be decrypted using that key")
                }

                function M(e, t, n, o, i, a) {
                    var s = [];
                    p(a);
                    var d = g(e = S(s, e, "message")),
                        c = e.length;
                    s.push(d);
                    var u = null,
                        f = 0;
                    null != t && (u = g(t = S(s, t, "additional_data")), f = t.length, s.push(u));
                    var b = null;
                    null != n && (b = g(n = S(s, n, "secret_nonce")), n.length, s.push(b)), o = S(s, o, "public_nonce");
                    var k, P = 0 | r._crypto_aead_chacha20poly1305_ietf_npubbytes();
                    o.length !== P && v(s, "invalid public_nonce length"), k = g(o), s.push(k), i = S(s, i, "key");
                    var _, B = 0 | r._crypto_aead_chacha20poly1305_ietf_keybytes();
                    i.length !== B && v(s, "invalid key length"), _ = g(i), s.push(_);
                    var O = new m(c + r._crypto_aead_chacha20poly1305_ietf_abytes() | 0),
                        R = O.address;
                    if (s.push(R), 0 === r._crypto_aead_chacha20poly1305_ietf_encrypt(R, null, d, c, 0, u, f, 0, b, k, _)) {
                        var A = l(O, a);
                        return y(s), A
                    }
                    h(s, "invalid usage")
                }

                function J(e, t, n, o, i, a) {
                    var s = [];
                    p(a);
                    var d = g(e = S(s, e, "message")),
                        c = e.length;
                    s.push(d);
                    var u = null,
                        f = 0;
                    null != t && (u = g(t = S(s, t, "additional_data")), f = t.length, s.push(u));
                    var b = null;
                    null != n && (b = g(n = S(s, n, "secret_nonce")), n.length, s.push(b)), o = S(s, o, "public_nonce");
                    var k, P = 0 | r._crypto_aead_chacha20poly1305_ietf_npubbytes();
                    o.length !== P && v(s, "invalid public_nonce length"), k = g(o), s.push(k), i = S(s, i, "key");
                    var _, B = 0 | r._crypto_aead_chacha20poly1305_ietf_keybytes();
                    i.length !== B && v(s, "invalid key length"), _ = g(i), s.push(_);
                    var O = new m(0 | c),
                        R = O.address;
                    s.push(R);
                    var A = new m(0 | r._crypto_aead_chacha20poly1305_ietf_abytes()),
                        I = A.address;
                    if (s.push(I), 0 === r._crypto_aead_chacha20poly1305_ietf_encrypt_detached(R, I, null, d, c, 0, u, f, 0, b, k, _)) {
                        var w = l({
                            ciphertext: O,
                            mac: A
                        }, a);
                        return y(s), w
                    }
                    h(s, "invalid usage")
                }

                function H(e) {
                    var t = [];
                    p(e);
                    var n = new m(0 | r._crypto_aead_chacha20poly1305_ietf_keybytes()),
                        o = n.address;
                    t.push(o), r._crypto_aead_chacha20poly1305_ietf_keygen(o);
                    var i = l(n, e);
                    return y(t), i
                }

                function j(e) {
                    var t = [];
                    p(e);
                    var n = new m(0 | r._crypto_aead_chacha20poly1305_keybytes()),
                        o = n.address;
                    t.push(o), r._crypto_aead_chacha20poly1305_keygen(o);
                    var i = l(n, e);
                    return y(t), i
                }

                function V(e, t, n, o, i, a) {
                    var s = [];
                    p(a);
                    var d = null;
                    null != e && (d = g(e = S(s, e, "secret_nonce")), e.length, s.push(d)), t = S(s, t, "ciphertext");
                    var c, u = r._crypto_aead_xchacha20poly1305_ietf_abytes(),
                        f = t.length;
                    f < u && v(s, "ciphertext is too short"), c = g(t), s.push(c);
                    var b = null,
                        k = 0;
                    null != n && (b = g(n = S(s, n, "additional_data")), k = n.length, s.push(b)), o = S(s, o, "public_nonce");
                    var P, _ = 0 | r._crypto_aead_xchacha20poly1305_ietf_npubbytes();
                    o.length !== _ && v(s, "invalid public_nonce length"), P = g(o), s.push(P), i = S(s, i, "key");
                    var B, O = 0 | r._crypto_aead_xchacha20poly1305_ietf_keybytes();
                    i.length !== O && v(s, "invalid key length"), B = g(i), s.push(B);
                    var R = new m(f - r._crypto_aead_xchacha20poly1305_ietf_abytes() | 0),
                        A = R.address;
                    if (s.push(A), 0 === r._crypto_aead_xchacha20poly1305_ietf_decrypt(A, null, d, c, f, 0, b, k, 0, P, B)) {
                        var I = l(R, a);
                        return y(s), I
                    }
                    h(s, "ciphertext cannot be decrypted using that key")
                }

                function q(e, t, n, o, i, a, s) {
                    var d = [];
                    p(s);
                    var c = null;
                    null != e && (c = g(e = S(d, e, "secret_nonce")), e.length, d.push(c));
                    var u = g(t = S(d, t, "ciphertext")),
                        f = t.length;
                    d.push(u), n = S(d, n, "mac");
                    var b, k = 0 | r._crypto_box_macbytes();
                    n.length !== k && v(d, "invalid mac length"), b = g(n), d.push(b);
                    var P = null,
                        _ = 0;
                    null != o && (P = g(o = S(d, o, "additional_data")), _ = o.length, d.push(P)), i = S(d, i, "public_nonce");
                    var B, O = 0 | r._crypto_aead_xchacha20poly1305_ietf_npubbytes();
                    i.length !== O && v(d, "invalid public_nonce length"), B = g(i), d.push(B), a = S(d, a, "key");
                    var R, A = 0 | r._crypto_aead_xchacha20poly1305_ietf_keybytes();
                    a.length !== A && v(d, "invalid key length"), R = g(a), d.push(R);
                    var I = new m(0 | f),
                        w = I.address;
                    if (d.push(w), 0 === r._crypto_aead_xchacha20poly1305_ietf_decrypt_detached(w, c, u, f, 0, b, P, _, 0, B, R)) {
                        var T = l(I, s);
                        return y(d), T
                    }
                    h(d, "ciphertext cannot be decrypted using that key")
                }

                function W(e, t, n, o, i, a) {
                    var s = [];
                    p(a);
                    var d = g(e = S(s, e, "message")),
                        c = e.length;
                    s.push(d);
                    var u = null,
                        f = 0;
                    null != t && (u = g(t = S(s, t, "additional_data")), f = t.length, s.push(u));
                    var b = null;
                    null != n && (b = g(n = S(s, n, "secret_nonce")), n.length, s.push(b)), o = S(s, o, "public_nonce");
                    var k, P = 0 | r._crypto_aead_xchacha20poly1305_ietf_npubbytes();
                    o.length !== P && v(s, "invalid public_nonce length"), k = g(o), s.push(k), i = S(s, i, "key");
                    var _, B = 0 | r._crypto_aead_xchacha20poly1305_ietf_keybytes();
                    i.length !== B && v(s, "invalid key length"), _ = g(i), s.push(_);
                    var O = new m(c + r._crypto_aead_xchacha20poly1305_ietf_abytes() | 0),
                        R = O.address;
                    if (s.push(R), 0 === r._crypto_aead_xchacha20poly1305_ietf_encrypt(R, null, d, c, 0, u, f, 0, b, k, _)) {
                        var A = l(O, a);
                        return y(s), A
                    }
                    h(s, "invalid usage")
                }

                function F(e, t, n, o, i, a) {
                    var s = [];
                    p(a);
                    var d = g(e = S(s, e, "message")),
                        c = e.length;
                    s.push(d);
                    var u = null,
                        f = 0;
                    null != t && (u = g(t = S(s, t, "additional_data")), f = t.length, s.push(u));
                    var b = null;
                    null != n && (b = g(n = S(s, n, "secret_nonce")), n.length, s.push(b)), o = S(s, o, "public_nonce");
                    var k, P = 0 | r._crypto_aead_xchacha20poly1305_ietf_npubbytes();
                    o.length !== P && v(s, "invalid public_nonce length"), k = g(o), s.push(k), i = S(s, i, "key");
                    var _, B = 0 | r._crypto_aead_xchacha20poly1305_ietf_keybytes();
                    i.length !== B && v(s, "invalid key length"), _ = g(i), s.push(_);
                    var O = new m(0 | c),
                        R = O.address;
                    s.push(R);
                    var A = new m(0 | r._crypto_aead_xchacha20poly1305_ietf_abytes()),
                        I = A.address;
                    if (s.push(I), 0 === r._crypto_aead_xchacha20poly1305_ietf_encrypt_detached(R, I, null, d, c, 0, u, f, 0, b, k, _)) {
                        var w = l({
                            ciphertext: O,
                            mac: A
                        }, a);
                        return y(s), w
                    }
                    h(s, "invalid usage")
                }

                function Q(e) {
                    var t = [];
                    p(e);
                    var n = new m(0 | r._crypto_aead_xchacha20poly1305_ietf_keybytes()),
                        o = n.address;
                    t.push(o), r._crypto_aead_xchacha20poly1305_ietf_keygen(o);
                    var i = l(n, e);
                    return y(t), i
                }

                function G(e, t, n) {
                    var o = [];
                    p(n);
                    var i = g(e = S(o, e, "message")),
                        a = e.length;
                    o.push(i), t = S(o, t, "key");
                    var s, d = 0 | r._crypto_auth_keybytes();
                    t.length !== d && v(o, "invalid key length"), s = g(t), o.push(s);
                    var c = new m(0 | r._crypto_auth_bytes()),
                        u = c.address;
                    if (o.push(u), 0 == (0 | r._crypto_auth(u, i, a, 0, s))) {
                        var f = l(c, n);
                        return y(o), f
                    }
                    h(o, "invalid usage")
                }

                function L(e, t, n) {
                    var o = [];
                    p(n);
                    var i = g(e = S(o, e, "message")),
                        a = e.length;
                    o.push(i), t = S(o, t, "key");
                    var s, d = 0 | r._crypto_auth_hmacsha256_keybytes();
                    t.length !== d && v(o, "invalid key length"), s = g(t), o.push(s);
                    var c = new m(0 | r._crypto_auth_hmacsha256_bytes()),
                        u = c.address;
                    if (o.push(u), 0 == (0 | r._crypto_auth_hmacsha256(u, i, a, 0, s))) {
                        var f = l(c, n);
                        return y(o), f
                    }
                    h(o, "invalid usage")
                }

                function K(e, t) {
                    var n = [];
                    p(t), b(n, e, "state_address");
                    var o = new m(0 | r._crypto_auth_hmacsha256_bytes()),
                        i = o.address;
                    if (n.push(i), 0 == (0 | r._crypto_auth_hmacsha256_final(e, i))) {
                        var a = (r._free(e), l(o, t));
                        return y(n), a
                    }
                    h(n, "invalid usage")
                }

                function Y(e, t) {
                    var n = [];
                    p(t);
                    var o = null,
                        i = 0;
                    null != e && (o = g(e = S(n, e, "key")), i = e.length, n.push(o));
                    var a = new m(208).address;
                    if (0 == (0 | r._crypto_auth_hmacsha256_init(a, o, i))) return y(n), a;
                    h(n, "invalid usage")
                }

                function z(e) {
                    var t = [];
                    p(e);
                    var n = new m(0 | r._crypto_auth_hmacsha256_keybytes()),
                        o = n.address;
                    t.push(o), r._crypto_auth_hmacsha256_keygen(o);
                    var i = l(n, e);
                    return y(t), i
                }

                function $(e, t, n) {
                    var o = [];
                    p(n), b(o, e, "state_address");
                    var i = g(t = S(o, t, "message_chunk")),
                        a = t.length;
                    o.push(i), 0 != (0 | r._crypto_auth_hmacsha256_update(e, i, a)) && h(o, "invalid usage"), y(o)
                }

                function Z(e, t, n) {
                    var o = [];
                    e = S(o, e, "tag");
                    var i, a = 0 | r._crypto_auth_hmacsha256_bytes();
                    e.length !== a && v(o, "invalid tag length"), i = g(e), o.push(i);
                    var s = g(t = S(o, t, "message")),
                        d = t.length;
                    o.push(s), n = S(o, n, "key");
                    var c, l = 0 | r._crypto_auth_hmacsha256_keybytes();
                    n.length !== l && v(o, "invalid key length"), c = g(n), o.push(c);
                    var u = 0 == (0 | r._crypto_auth_hmacsha256_verify(i, s, d, 0, c));
                    return y(o), u
                }

                function X(e, t, n) {
                    var o = [];
                    p(n);
                    var i = g(e = S(o, e, "message")),
                        a = e.length;
                    o.push(i), t = S(o, t, "key");
                    var s, d = 0 | r._crypto_auth_hmacsha512_keybytes();
                    t.length !== d && v(o, "invalid key length"), s = g(t), o.push(s);
                    var c = new m(0 | r._crypto_auth_hmacsha512_bytes()),
                        u = c.address;
                    if (o.push(u), 0 == (0 | r._crypto_auth_hmacsha512(u, i, a, 0, s))) {
                        var f = l(c, n);
                        return y(o), f
                    }
                    h(o, "invalid usage")
                }

                function ee(e, t) {
                    var n = [];
                    p(t), b(n, e, "state_address");
                    var o = new m(0 | r._crypto_auth_hmacsha512_bytes()),
                        i = o.address;
                    if (n.push(i), 0 == (0 | r._crypto_auth_hmacsha512_final(e, i))) {
                        var a = (r._free(e), l(o, t));
                        return y(n), a
                    }
                    h(n, "invalid usage")
                }

                function et(e, t) {
                    var n = [];
                    p(t);
                    var o = null,
                        i = 0;
                    null != e && (o = g(e = S(n, e, "key")), i = e.length, n.push(o));
                    var a = new m(416).address;
                    if (0 == (0 | r._crypto_auth_hmacsha512_init(a, o, i))) return y(n), a;
                    h(n, "invalid usage")
                }

                function er(e) {
                    var t = [];
                    p(e);
                    var n = new m(0 | r._crypto_auth_hmacsha512_keybytes()),
                        o = n.address;
                    t.push(o), r._crypto_auth_hmacsha512_keygen(o);
                    var i = l(n, e);
                    return y(t), i
                }

                function en(e, t, n) {
                    var o = [];
                    p(n), b(o, e, "state_address");
                    var i = g(t = S(o, t, "message_chunk")),
                        a = t.length;
                    o.push(i), 0 != (0 | r._crypto_auth_hmacsha512_update(e, i, a)) && h(o, "invalid usage"), y(o)
                }

                function eo(e, t, n) {
                    var o = [];
                    e = S(o, e, "tag");
                    var i, a = 0 | r._crypto_auth_hmacsha512_bytes();
                    e.length !== a && v(o, "invalid tag length"), i = g(e), o.push(i);
                    var s = g(t = S(o, t, "message")),
                        d = t.length;
                    o.push(s), n = S(o, n, "key");
                    var c, l = 0 | r._crypto_auth_hmacsha512_keybytes();
                    n.length !== l && v(o, "invalid key length"), c = g(n), o.push(c);
                    var u = 0 == (0 | r._crypto_auth_hmacsha512_verify(i, s, d, 0, c));
                    return y(o), u
                }

                function ei(e) {
                    var t = [];
                    p(e);
                    var n = new m(0 | r._crypto_auth_keybytes()),
                        o = n.address;
                    t.push(o), r._crypto_auth_keygen(o);
                    var i = l(n, e);
                    return y(t), i
                }

                function ea(e, t, n) {
                    var o = [];
                    e = S(o, e, "tag");
                    var i, a = 0 | r._crypto_auth_bytes();
                    e.length !== a && v(o, "invalid tag length"), i = g(e), o.push(i);
                    var s = g(t = S(o, t, "message")),
                        d = t.length;
                    o.push(s), n = S(o, n, "key");
                    var c, l = 0 | r._crypto_auth_keybytes();
                    n.length !== l && v(o, "invalid key length"), c = g(n), o.push(c);
                    var u = 0 == (0 | r._crypto_auth_verify(i, s, d, 0, c));
                    return y(o), u
                }

                function es(e, t, n) {
                    var o = [];
                    p(n), e = S(o, e, "publicKey");
                    var i, a = 0 | r._crypto_box_publickeybytes();
                    e.length !== a && v(o, "invalid publicKey length"), i = g(e), o.push(i), t = S(o, t, "privateKey");
                    var s, d = 0 | r._crypto_box_secretkeybytes();
                    t.length !== d && v(o, "invalid privateKey length"), s = g(t), o.push(s);
                    var c = new m(0 | r._crypto_box_beforenmbytes()),
                        u = c.address;
                    if (o.push(u), 0 == (0 | r._crypto_box_beforenm(u, i, s))) {
                        var f = l(c, n);
                        return y(o), f
                    }
                    h(o, "invalid usage")
                }

                function ed(e, t, n) {
                    var o = [];
                    p(n), e = S(o, e, "publicKey");
                    var i, a = 0 | r._crypto_box_curve25519xchacha20poly1305_publickeybytes();
                    e.length !== a && v(o, "invalid publicKey length"), i = g(e), o.push(i), t = S(o, t, "privateKey");
                    var s, d = 0 | r._crypto_box_curve25519xchacha20poly1305_secretkeybytes();
                    t.length !== d && v(o, "invalid privateKey length"), s = g(t), o.push(s);
                    var c = new m(0 | r._crypto_box_curve25519xchacha20poly1305_beforenmbytes()),
                        u = c.address;
                    if (o.push(u), 0 == (0 | r._crypto_box_curve25519xchacha20poly1305_beforenm(u, i, s))) {
                        var f = l(c, n);
                        return y(o), f
                    }
                    h(o, "invalid usage")
                }

                function ec(e, t, n, o, i) {
                    var a = [];
                    p(i);
                    var s = g(e = S(a, e, "message")),
                        d = e.length;
                    a.push(s), t = S(a, t, "nonce");
                    var c, u = 0 | r._crypto_box_curve25519xchacha20poly1305_noncebytes();
                    t.length !== u && v(a, "invalid nonce length"), c = g(t), a.push(c), n = S(a, n, "publicKey");
                    var f, b = 0 | r._crypto_box_curve25519xchacha20poly1305_publickeybytes();
                    n.length !== b && v(a, "invalid publicKey length"), f = g(n), a.push(f), o = S(a, o, "privateKey");
                    var k, P = 0 | r._crypto_box_curve25519xchacha20poly1305_secretkeybytes();
                    o.length !== P && v(a, "invalid privateKey length"), k = g(o), a.push(k);
                    var _ = new m(0 | d),
                        B = _.address;
                    a.push(B);
                    var O = new m(0 | r._crypto_box_curve25519xchacha20poly1305_macbytes()),
                        R = O.address;
                    if (a.push(R), 0 == (0 | r._crypto_box_curve25519xchacha20poly1305_detached(B, R, s, d, 0, c, f, k))) {
                        var A = l({
                            ciphertext: _,
                            mac: O
                        }, i);
                        return y(a), A
                    }
                    h(a, "invalid usage")
                }

                function el(e, t, n, o) {
                    var i = [];
                    p(o);
                    var a = g(e = S(i, e, "message")),
                        s = e.length;
                    i.push(a), t = S(i, t, "nonce");
                    var d, c = 0 | r._crypto_box_curve25519xchacha20poly1305_noncebytes();
                    t.length !== c && v(i, "invalid nonce length"), d = g(t), i.push(d), n = S(i, n, "sharedKey");
                    var u, f = 0 | r._crypto_box_curve25519xchacha20poly1305_beforenmbytes();
                    n.length !== f && v(i, "invalid sharedKey length"), u = g(n), i.push(u);
                    var b = new m(0 | s),
                        k = b.address;
                    i.push(k);
                    var P = new m(0 | r._crypto_box_curve25519xchacha20poly1305_macbytes()),
                        _ = P.address;
                    if (i.push(_), 0 == (0 | r._crypto_box_curve25519xchacha20poly1305_detached_afternm(k, _, a, s, 0, d, u))) {
                        var B = l({
                            ciphertext: b,
                            mac: P
                        }, o);
                        return y(i), B
                    }
                    h(i, "invalid usage")
                }

                function eu(e, t, n, o, i) {
                    var a = [];
                    p(i);
                    var s = g(e = S(a, e, "message")),
                        d = e.length;
                    a.push(s), t = S(a, t, "nonce");
                    var c, u = 0 | r._crypto_box_curve25519xchacha20poly1305_noncebytes();
                    t.length !== u && v(a, "invalid nonce length"), c = g(t), a.push(c), n = S(a, n, "publicKey");
                    var f, b = 0 | r._crypto_box_curve25519xchacha20poly1305_publickeybytes();
                    n.length !== b && v(a, "invalid publicKey length"), f = g(n), a.push(f), o = S(a, o, "privateKey");
                    var k, P = 0 | r._crypto_box_curve25519xchacha20poly1305_secretkeybytes();
                    o.length !== P && v(a, "invalid privateKey length"), k = g(o), a.push(k);
                    var _ = new m(d + r._crypto_box_curve25519xchacha20poly1305_macbytes() | 0),
                        B = _.address;
                    if (a.push(B), 0 == (0 | r._crypto_box_curve25519xchacha20poly1305_easy(B, s, d, 0, c, f, k))) {
                        var O = l(_, i);
                        return y(a), O
                    }
                    h(a, "invalid usage")
                }

                function ep(e, t, n, o) {
                    var i = [];
                    p(o);
                    var a = g(e = S(i, e, "message")),
                        s = e.length;
                    i.push(a), t = S(i, t, "nonce");
                    var d, c = 0 | r._crypto_box_curve25519xchacha20poly1305_noncebytes();
                    t.length !== c && v(i, "invalid nonce length"), d = g(t), i.push(d), n = S(i, n, "sharedKey");
                    var u, f = 0 | r._crypto_box_curve25519xchacha20poly1305_beforenmbytes();
                    n.length !== f && v(i, "invalid sharedKey length"), u = g(n), i.push(u);
                    var b = new m(s + r._crypto_box_curve25519xchacha20poly1305_macbytes() | 0),
                        k = b.address;
                    if (i.push(k), 0 == (0 | r._crypto_box_curve25519xchacha20poly1305_easy_afternm(k, a, s, 0, d, u))) {
                        var P = l(b, o);
                        return y(i), P
                    }
                    h(i, "invalid usage")
                }

                function em(e) {
                    var t = [];
                    p(e);
                    var n = new m(0 | r._crypto_box_curve25519xchacha20poly1305_publickeybytes()),
                        o = n.address;
                    t.push(o);
                    var i = new m(0 | r._crypto_box_curve25519xchacha20poly1305_secretkeybytes()),
                        a = i.address;
                    t.push(a), r._crypto_box_curve25519xchacha20poly1305_keypair(o, a);
                    var s = l({
                        publicKey: n,
                        privateKey: i,
                        keyType: "curve25519"
                    }, e);
                    return y(t), s
                }

                function eg(e, t, n, o, i, a) {
                    var s = [];
                    p(a);
                    var d = g(e = S(s, e, "ciphertext")),
                        c = e.length;
                    s.push(d), t = S(s, t, "mac");
                    var u, f = 0 | r._crypto_box_curve25519xchacha20poly1305_macbytes();
                    t.length !== f && v(s, "invalid mac length"), u = g(t), s.push(u), n = S(s, n, "nonce");
                    var b, k = 0 | r._crypto_box_curve25519xchacha20poly1305_noncebytes();
                    n.length !== k && v(s, "invalid nonce length"), b = g(n), s.push(b), o = S(s, o, "publicKey");
                    var P, _ = 0 | r._crypto_box_curve25519xchacha20poly1305_publickeybytes();
                    o.length !== _ && v(s, "invalid publicKey length"), P = g(o), s.push(P), i = S(s, i, "privateKey");
                    var B, O = 0 | r._crypto_box_curve25519xchacha20poly1305_secretkeybytes();
                    i.length !== O && v(s, "invalid privateKey length"), B = g(i), s.push(B);
                    var R = new m(0 | c),
                        A = R.address;
                    if (s.push(A), 0 == (0 | r._crypto_box_curve25519xchacha20poly1305_open_detached(A, d, u, c, 0, b, P, B))) {
                        var I = l(R, a);
                        return y(s), I
                    }
                    h(s, "incorrect key pair for the given ciphertext")
                }

                function ef(e, t, n, o, i) {
                    var a = [];
                    p(i);
                    var s = g(e = S(a, e, "ciphertext")),
                        d = e.length;
                    a.push(s), t = S(a, t, "mac");
                    var c, u = 0 | r._crypto_box_curve25519xchacha20poly1305_macbytes();
                    t.length !== u && v(a, "invalid mac length"), c = g(t), a.push(c), n = S(a, n, "nonce");
                    var f, b = 0 | r._crypto_box_curve25519xchacha20poly1305_noncebytes();
                    n.length !== b && v(a, "invalid nonce length"), f = g(n), a.push(f), o = S(a, o, "sharedKey");
                    var k, P = 0 | r._crypto_box_curve25519xchacha20poly1305_beforenmbytes();
                    o.length !== P && v(a, "invalid sharedKey length"), k = g(o), a.push(k);
                    var _ = new m(0 | d),
                        B = _.address;
                    if (a.push(B), 0 == (0 | r._crypto_box_curve25519xchacha20poly1305_open_detached_afternm(B, s, c, d, 0, f, k))) {
                        var O = l(_, i);
                        return y(a), O
                    }
                    h(a, "incorrect secret key for the given ciphertext")
                }

                function ey(e, t, n, o, i) {
                    var a = [];
                    p(i), e = S(a, e, "ciphertext");
                    var s, d = r._crypto_box_curve25519xchacha20poly1305_macbytes(),
                        c = e.length;
                    c < d && v(a, "ciphertext is too short"), s = g(e), a.push(s), t = S(a, t, "nonce");
                    var u, f = 0 | r._crypto_box_curve25519xchacha20poly1305_noncebytes();
                    t.length !== f && v(a, "invalid nonce length"), u = g(t), a.push(u), n = S(a, n, "publicKey");
                    var b, k = 0 | r._crypto_box_curve25519xchacha20poly1305_publickeybytes();
                    n.length !== k && v(a, "invalid publicKey length"), b = g(n), a.push(b), o = S(a, o, "privateKey");
                    var P, _ = 0 | r._crypto_box_curve25519xchacha20poly1305_secretkeybytes();
                    o.length !== _ && v(a, "invalid privateKey length"), P = g(o), a.push(P);
                    var B = new m(c - r._crypto_box_curve25519xchacha20poly1305_macbytes() | 0),
                        O = B.address;
                    if (a.push(O), 0 == (0 | r._crypto_box_curve25519xchacha20poly1305_open_easy(O, s, c, 0, u, b, P))) {
                        var R = l(B, i);
                        return y(a), R
                    }
                    h(a, "incorrect key pair for the given ciphertext")
                }

                function eh(e, t, n, o) {
                    var i = [];
                    p(o);
                    var a = g(e = S(i, e, "ciphertext")),
                        s = e.length;
                    i.push(a), t = S(i, t, "nonce");
                    var d, c = 0 | r._crypto_box_curve25519xchacha20poly1305_noncebytes();
                    t.length !== c && v(i, "invalid nonce length"), d = g(t), i.push(d), n = S(i, n, "sharedKey");
                    var u, f = 0 | r._crypto_box_curve25519xchacha20poly1305_beforenmbytes();
                    n.length !== f && v(i, "invalid sharedKey length"), u = g(n), i.push(u);
                    var b = new m(s - r._crypto_box_curve25519xchacha20poly1305_macbytes() | 0),
                        k = b.address;
                    if (i.push(k), 0 == (0 | r._crypto_box_curve25519xchacha20poly1305_open_easy_afternm(k, a, s, 0, d, u))) {
                        var P = l(b, o);
                        return y(i), P
                    }
                    h(i, "incorrect secret key for the given ciphertext")
                }

                function ev(e, t, n) {
                    var o = [];
                    p(n);
                    var i = g(e = S(o, e, "message")),
                        a = e.length;
                    o.push(i), t = S(o, t, "publicKey");
                    var s, d = 0 | r._crypto_box_curve25519xchacha20poly1305_publickeybytes();
                    t.length !== d && v(o, "invalid publicKey length"), s = g(t), o.push(s);
                    var c = new m(a + r._crypto_box_curve25519xchacha20poly1305_sealbytes() | 0),
                        u = c.address;
                    o.push(u), r._crypto_box_curve25519xchacha20poly1305_seal(u, i, a, 0, s);
                    var f = l(c, n);
                    return y(o), f
                }

                function eb(e, t, n, o) {
                    var i = [];
                    p(o), e = S(i, e, "ciphertext");
                    var a, s = r._crypto_box_curve25519xchacha20poly1305_sealbytes(),
                        d = e.length;
                    d < s && v(i, "ciphertext is too short"), a = g(e), i.push(a), t = S(i, t, "publicKey");
                    var c, u = 0 | r._crypto_box_curve25519xchacha20poly1305_publickeybytes();
                    t.length !== u && v(i, "invalid publicKey length"), c = g(t), i.push(c), n = S(i, n, "secretKey");
                    var f, h = 0 | r._crypto_box_curve25519xchacha20poly1305_secretkeybytes();
                    n.length !== h && v(i, "invalid secretKey length"), f = g(n), i.push(f);
                    var b = new m(d - r._crypto_box_curve25519xchacha20poly1305_sealbytes() | 0),
                        k = b.address;
                    i.push(k), r._crypto_box_curve25519xchacha20poly1305_seal_open(k, a, d, 0, c, f);
                    var P = l(b, o);
                    return y(i), P
                }

                function eS(e, t) {
                    var n = [];
                    p(t), e = S(n, e, "seed");
                    var o, i = 0 | r._crypto_box_curve25519xchacha20poly1305_seedbytes();
                    e.length !== i && v(n, "invalid seed length"), o = g(e), n.push(o);
                    var a = new m(0 | r._crypto_box_curve25519xchacha20poly1305_publickeybytes()),
                        s = a.address;
                    n.push(s);
                    var d = new m(0 | r._crypto_box_curve25519xchacha20poly1305_secretkeybytes()),
                        c = d.address;
                    if (n.push(c), 0 == (0 | r._crypto_box_curve25519xchacha20poly1305_seed_keypair(s, c, o))) {
                        var u = {
                            publicKey: l(a, t),
                            privateKey: l(d, t),
                            keyType: "x25519"
                        };
                        return y(n), u
                    }
                    h(n, "invalid usage")
                }

                function ek(e, t, n, o, i) {
                    var a = [];
                    p(i);
                    var s = g(e = S(a, e, "message")),
                        d = e.length;
                    a.push(s), t = S(a, t, "nonce");
                    var c, u = 0 | r._crypto_box_noncebytes();
                    t.length !== u && v(a, "invalid nonce length"), c = g(t), a.push(c), n = S(a, n, "publicKey");
                    var f, b = 0 | r._crypto_box_publickeybytes();
                    n.length !== b && v(a, "invalid publicKey length"), f = g(n), a.push(f), o = S(a, o, "privateKey");
                    var k, P = 0 | r._crypto_box_secretkeybytes();
                    o.length !== P && v(a, "invalid privateKey length"), k = g(o), a.push(k);
                    var _ = new m(0 | d),
                        B = _.address;
                    a.push(B);
                    var O = new m(0 | r._crypto_box_macbytes()),
                        R = O.address;
                    if (a.push(R), 0 == (0 | r._crypto_box_detached(B, R, s, d, 0, c, f, k))) {
                        var A = l({
                            ciphertext: _,
                            mac: O
                        }, i);
                        return y(a), A
                    }
                    h(a, "invalid usage")
                }

                function eP(e, t, n, o, i) {
                    var a = [];
                    p(i);
                    var s = g(e = S(a, e, "message")),
                        d = e.length;
                    a.push(s), t = S(a, t, "nonce");
                    var c, u = 0 | r._crypto_box_noncebytes();
                    t.length !== u && v(a, "invalid nonce length"), c = g(t), a.push(c), n = S(a, n, "publicKey");
                    var f, b = 0 | r._crypto_box_publickeybytes();
                    n.length !== b && v(a, "invalid publicKey length"), f = g(n), a.push(f), o = S(a, o, "privateKey");
                    var k, P = 0 | r._crypto_box_secretkeybytes();
                    o.length !== P && v(a, "invalid privateKey length"), k = g(o), a.push(k);
                    var _ = new m(d + r._crypto_box_macbytes() | 0),
                        B = _.address;
                    if (a.push(B), 0 == (0 | r._crypto_box_easy(B, s, d, 0, c, f, k))) {
                        var O = l(_, i);
                        return y(a), O
                    }
                    h(a, "invalid usage")
                }

                function e_(e, t, n, o) {
                    var i = [];
                    p(o);
                    var a = g(e = S(i, e, "message")),
                        s = e.length;
                    i.push(a), t = S(i, t, "nonce");
                    var d, c = 0 | r._crypto_box_noncebytes();
                    t.length !== c && v(i, "invalid nonce length"), d = g(t), i.push(d), n = S(i, n, "sharedKey");
                    var u, f = 0 | r._crypto_box_beforenmbytes();
                    n.length !== f && v(i, "invalid sharedKey length"), u = g(n), i.push(u);
                    var b = new m(s + r._crypto_box_macbytes() | 0),
                        k = b.address;
                    if (i.push(k), 0 == (0 | r._crypto_box_easy_afternm(k, a, s, 0, d, u))) {
                        var P = l(b, o);
                        return y(i), P
                    }
                    h(i, "invalid usage")
                }

                function eB(e) {
                    var t = [];
                    p(e);
                    var n = new m(0 | r._crypto_box_publickeybytes()),
                        o = n.address;
                    t.push(o);
                    var i = new m(0 | r._crypto_box_secretkeybytes()),
                        a = i.address;
                    if (t.push(a), 0 == (0 | r._crypto_box_keypair(o, a))) {
                        var s = {
                            publicKey: l(n, e),
                            privateKey: l(i, e),
                            keyType: "x25519"
                        };
                        return y(t), s
                    }
                    h(t, "internal error")
                }

                function eO(e, t, n, o, i, a) {
                    var s = [];
                    p(a);
                    var d = g(e = S(s, e, "ciphertext")),
                        c = e.length;
                    s.push(d), t = S(s, t, "mac");
                    var u, f = 0 | r._crypto_box_macbytes();
                    t.length !== f && v(s, "invalid mac length"), u = g(t), s.push(u), n = S(s, n, "nonce");
                    var b, k = 0 | r._crypto_box_noncebytes();
                    n.length !== k && v(s, "invalid nonce length"), b = g(n), s.push(b), o = S(s, o, "publicKey");
                    var P, _ = 0 | r._crypto_box_publickeybytes();
                    o.length !== _ && v(s, "invalid publicKey length"), P = g(o), s.push(P), i = S(s, i, "privateKey");
                    var B, O = 0 | r._crypto_box_secretkeybytes();
                    i.length !== O && v(s, "invalid privateKey length"), B = g(i), s.push(B);
                    var R = new m(0 | c),
                        A = R.address;
                    if (s.push(A), 0 == (0 | r._crypto_box_open_detached(A, d, u, c, 0, b, P, B))) {
                        var I = l(R, a);
                        return y(s), I
                    }
                    h(s, "incorrect key pair for the given ciphertext")
                }

                function eR(e, t, n, o, i) {
                    var a = [];
                    p(i), e = S(a, e, "ciphertext");
                    var s, d = r._crypto_box_macbytes(),
                        c = e.length;
                    c < d && v(a, "ciphertext is too short"), s = g(e), a.push(s), t = S(a, t, "nonce");
                    var u, f = 0 | r._crypto_box_noncebytes();
                    t.length !== f && v(a, "invalid nonce length"), u = g(t), a.push(u), n = S(a, n, "publicKey");
                    var b, k = 0 | r._crypto_box_publickeybytes();
                    n.length !== k && v(a, "invalid publicKey length"), b = g(n), a.push(b), o = S(a, o, "privateKey");
                    var P, _ = 0 | r._crypto_box_secretkeybytes();
                    o.length !== _ && v(a, "invalid privateKey length"), P = g(o), a.push(P);
                    var B = new m(c - r._crypto_box_macbytes() | 0),
                        O = B.address;
                    if (a.push(O), 0 == (0 | r._crypto_box_open_easy(O, s, c, 0, u, b, P))) {
                        var R = l(B, i);
                        return y(a), R
                    }
                    h(a, "incorrect key pair for the given ciphertext")
                }

                function eA(e, t, n, o) {
                    var i = [];
                    p(o);
                    var a = g(e = S(i, e, "ciphertext")),
                        s = e.length;
                    i.push(a), t = S(i, t, "nonce");
                    var d, c = 0 | r._crypto_box_noncebytes();
                    t.length !== c && v(i, "invalid nonce length"), d = g(t), i.push(d), n = S(i, n, "sharedKey");
                    var u, f = 0 | r._crypto_box_beforenmbytes();
                    n.length !== f && v(i, "invalid sharedKey length"), u = g(n), i.push(u);
                    var b = new m(s - r._crypto_box_macbytes() | 0),
                        k = b.address;
                    if (i.push(k), 0 == (0 | r._crypto_box_open_easy_afternm(k, a, s, 0, d, u))) {
                        var P = l(b, o);
                        return y(i), P
                    }
                    h(i, "incorrect secret key for the given ciphertext")
                }

                function eI(e, t, n) {
                    var o = [];
                    p(n);
                    var i = g(e = S(o, e, "message")),
                        a = e.length;
                    o.push(i), t = S(o, t, "publicKey");
                    var s, d = 0 | r._crypto_box_publickeybytes();
                    t.length !== d && v(o, "invalid publicKey length"), s = g(t), o.push(s);
                    var c = new m(a + r._crypto_box_sealbytes() | 0),
                        u = c.address;
                    if (o.push(u), 0 == (0 | r._crypto_box_seal(u, i, a, 0, s))) {
                        var f = l(c, n);
                        return y(o), f
                    }
                    h(o, "invalid usage")
                }

                function ew(e, t, n, o) {
                    var i = [];
                    p(o), e = S(i, e, "ciphertext");
                    var a, s = r._crypto_box_sealbytes(),
                        d = e.length;
                    d < s && v(i, "ciphertext is too short"), a = g(e), i.push(a), t = S(i, t, "publicKey");
                    var c, u = 0 | r._crypto_box_publickeybytes();
                    t.length !== u && v(i, "invalid publicKey length"), c = g(t), i.push(c), n = S(i, n, "privateKey");
                    var f, b = 0 | r._crypto_box_secretkeybytes();
                    n.length !== b && v(i, "invalid privateKey length"), f = g(n), i.push(f);
                    var k = new m(d - r._crypto_box_sealbytes() | 0),
                        P = k.address;
                    if (i.push(P), 0 == (0 | r._crypto_box_seal_open(P, a, d, 0, c, f))) {
                        var _ = l(k, o);
                        return y(i), _
                    }
                    h(i, "incorrect key pair for the given ciphertext")
                }

                function eT(e, t) {
                    var n = [];
                    p(t), e = S(n, e, "seed");
                    var o, i = 0 | r._crypto_box_seedbytes();
                    e.length !== i && v(n, "invalid seed length"), o = g(e), n.push(o);
                    var a = new m(0 | r._crypto_box_publickeybytes()),
                        s = a.address;
                    n.push(s);
                    var d = new m(0 | r._crypto_box_secretkeybytes()),
                        c = d.address;
                    if (n.push(c), 0 == (0 | r._crypto_box_seed_keypair(s, c, o))) {
                        var u = {
                            publicKey: l(a, t),
                            privateKey: l(d, t),
                            keyType: "x25519"
                        };
                        return y(n), u
                    }
                    h(n, "invalid usage")
                }

                function eN(e, t, n) {
                    var o = [];
                    p(n), e = S(o, e, "p");
                    var i, a = 0 | r._crypto_core_ed25519_bytes();
                    e.length !== a && v(o, "invalid p length"), i = g(e), o.push(i), t = S(o, t, "q");
                    var s, d = 0 | r._crypto_core_ed25519_bytes();
                    t.length !== d && v(o, "invalid q length"), s = g(t), o.push(s);
                    var c = new m(0 | r._crypto_core_ed25519_bytes()),
                        u = c.address;
                    if (o.push(u), 0 == (0 | r._crypto_core_ed25519_add(u, i, s))) {
                        var f = l(c, n);
                        return y(o), f
                    }
                    h(o, "input is an invalid element")
                }

                function eC(e, t) {
                    var n = [];
                    p(t);
                    var o = g(e = S(n, e, "r"));
                    e.length, n.push(o);
                    var i = new m(0 | r._crypto_core_ed25519_bytes()),
                        a = i.address;
                    if (n.push(a), 0 == (0 | r._crypto_core_ed25519_from_hash(a, o))) {
                        var s = l(i, t);
                        return y(n), s
                    }
                    h(n, "invalid usage")
                }

                function eE(e, t) {
                    var n = [];
                    p(t);
                    var o = g(e = S(n, e, "r"));
                    e.length, n.push(o);
                    var i = new m(0 | r._crypto_core_ed25519_bytes()),
                        a = i.address;
                    if (n.push(a), 0 == (0 | r._crypto_core_ed25519_from_uniform(a, o))) {
                        var s = l(i, t);
                        return y(n), s
                    }
                    h(n, "invalid usage")
                }

                function ex(e, t) {
                    var n = [];
                    p(t), e = S(n, e, "repr");
                    var o, i = 0 | r._crypto_core_ed25519_bytes();
                    e.length !== i && v(n, "invalid repr length"), o = g(e), n.push(o);
                    var a = 1 == (0 | r._crypto_core_ed25519_is_valid_point(o));
                    return y(n), a
                }

                function eU(e) {
                    var t = [];
                    p(e);
                    var n = new m(0 | r._crypto_core_ed25519_bytes()),
                        o = n.address;
                    t.push(o), r._crypto_core_ed25519_random(o);
                    var i = l(n, e);
                    return y(t), i
                }

                function eD(e, t, n) {
                    var o = [];
                    p(n), e = S(o, e, "x");
                    var i, a = 0 | r._crypto_core_ed25519_scalarbytes();
                    e.length !== a && v(o, "invalid x length"), i = g(e), o.push(i), t = S(o, t, "y");
                    var s, d = 0 | r._crypto_core_ed25519_scalarbytes();
                    t.length !== d && v(o, "invalid y length"), s = g(t), o.push(s);
                    var c = new m(0 | r._crypto_core_ed25519_scalarbytes()),
                        u = c.address;
                    o.push(u), r._crypto_core_ed25519_scalar_add(u, i, s);
                    var f = l(c, n);
                    return y(o), f
                }

                function eM(e, t) {
                    var n = [];
                    p(t), e = S(n, e, "s");
                    var o, i = 0 | r._crypto_core_ed25519_scalarbytes();
                    e.length !== i && v(n, "invalid s length"), o = g(e), n.push(o);
                    var a = new m(0 | r._crypto_core_ed25519_scalarbytes()),
                        s = a.address;
                    n.push(s), r._crypto_core_ed25519_scalar_complement(s, o);
                    var d = l(a, t);
                    return y(n), d
                }

                function eJ(e, t) {
                    var n = [];
                    p(t), e = S(n, e, "s");
                    var o, i = 0 | r._crypto_core_ed25519_scalarbytes();
                    e.length !== i && v(n, "invalid s length"), o = g(e), n.push(o);
                    var a = new m(0 | r._crypto_core_ed25519_scalarbytes()),
                        s = a.address;
                    if (n.push(s), 0 == (0 | r._crypto_core_ed25519_scalar_invert(s, o))) {
                        var d = l(a, t);
                        return y(n), d
                    }
                    h(n, "invalid reciprocate")
                }

                function eH(e, t, n) {
                    var o = [];
                    p(n), e = S(o, e, "x");
                    var i, a = 0 | r._crypto_core_ed25519_scalarbytes();
                    e.length !== a && v(o, "invalid x length"), i = g(e), o.push(i), t = S(o, t, "y");
                    var s, d = 0 | r._crypto_core_ed25519_scalarbytes();
                    t.length !== d && v(o, "invalid y length"), s = g(t), o.push(s);
                    var c = new m(0 | r._crypto_core_ed25519_scalarbytes()),
                        u = c.address;
                    o.push(u), r._crypto_core_ed25519_scalar_mul(u, i, s);
                    var f = l(c, n);
                    return y(o), f
                }

                function ej(e, t) {
                    var n = [];
                    p(t), e = S(n, e, "s");
                    var o, i = 0 | r._crypto_core_ed25519_scalarbytes();
                    e.length !== i && v(n, "invalid s length"), o = g(e), n.push(o);
                    var a = new m(0 | r._crypto_core_ed25519_scalarbytes()),
                        s = a.address;
                    n.push(s), r._crypto_core_ed25519_scalar_negate(s, o);
                    var d = l(a, t);
                    return y(n), d
                }

                function eV(e) {
                    var t = [];
                    p(e);
                    var n = new m(0 | r._crypto_core_ed25519_scalarbytes()),
                        o = n.address;
                    t.push(o), r._crypto_core_ed25519_scalar_random(o);
                    var i = l(n, e);
                    return y(t), i
                }

                function eq(e, t) {
                    var n = [];
                    p(t), e = S(n, e, "sample");
                    var o, i = 0 | r._crypto_core_ed25519_nonreducedscalarbytes();
                    e.length !== i && v(n, "invalid sample length"), o = g(e), n.push(o);
                    var a = new m(0 | r._crypto_core_ed25519_scalarbytes()),
                        s = a.address;
                    n.push(s), r._crypto_core_ed25519_scalar_reduce(s, o);
                    var d = l(a, t);
                    return y(n), d
                }

                function eW(e, t, n) {
                    var o = [];
                    p(n), e = S(o, e, "x");
                    var i, a = 0 | r._crypto_core_ed25519_scalarbytes();
                    e.length !== a && v(o, "invalid x length"), i = g(e), o.push(i), t = S(o, t, "y");
                    var s, d = 0 | r._crypto_core_ed25519_scalarbytes();
                    t.length !== d && v(o, "invalid y length"), s = g(t), o.push(s);
                    var c = new m(0 | r._crypto_core_ed25519_scalarbytes()),
                        u = c.address;
                    o.push(u), r._crypto_core_ed25519_scalar_sub(u, i, s);
                    var f = l(c, n);
                    return y(o), f
                }

                function eF(e, t, n) {
                    var o = [];
                    p(n), e = S(o, e, "p");
                    var i, a = 0 | r._crypto_core_ed25519_bytes();
                    e.length !== a && v(o, "invalid p length"), i = g(e), o.push(i), t = S(o, t, "q");
                    var s, d = 0 | r._crypto_core_ed25519_bytes();
                    t.length !== d && v(o, "invalid q length"), s = g(t), o.push(s);
                    var c = new m(0 | r._crypto_core_ed25519_bytes()),
                        u = c.address;
                    if (o.push(u), 0 == (0 | r._crypto_core_ed25519_sub(u, i, s))) {
                        var f = l(c, n);
                        return y(o), f
                    }
                    h(o, "input is an invalid element")
                }

                function eQ(e, t, n, o) {
                    var i = [];
                    p(o), e = S(i, e, "input");
                    var a, s = 0 | r._crypto_core_hchacha20_inputbytes();
                    e.length !== s && v(i, "invalid input length"), a = g(e), i.push(a), t = S(i, t, "privateKey");
                    var d, c = 0 | r._crypto_core_hchacha20_keybytes();
                    t.length !== c && v(i, "invalid privateKey length"), d = g(t), i.push(d);
                    var u = null;
                    null != n && (u = g(n = S(i, n, "constant")), n.length, i.push(u));
                    var f = new m(0 | r._crypto_core_hchacha20_outputbytes()),
                        b = f.address;
                    if (i.push(b), 0 == (0 | r._crypto_core_hchacha20(b, a, d, u))) {
                        var k = l(f, o);
                        return y(i), k
                    }
                    h(i, "invalid usage")
                }

                function eG(e, t, n, o) {
                    var i = [];
                    p(o), e = S(i, e, "input");
                    var a, s = 0 | r._crypto_core_hsalsa20_inputbytes();
                    e.length !== s && v(i, "invalid input length"), a = g(e), i.push(a), t = S(i, t, "privateKey");
                    var d, c = 0 | r._crypto_core_hsalsa20_keybytes();
                    t.length !== c && v(i, "invalid privateKey length"), d = g(t), i.push(d);
                    var u = null;
                    null != n && (u = g(n = S(i, n, "constant")), n.length, i.push(u));
                    var f = new m(0 | r._crypto_core_hsalsa20_outputbytes()),
                        b = f.address;
                    if (i.push(b), 0 == (0 | r._crypto_core_hsalsa20(b, a, d, u))) {
                        var k = l(f, o);
                        return y(i), k
                    }
                    h(i, "invalid usage")
                }

                function eL(e, t, n) {
                    var o = [];
                    p(n), e = S(o, e, "p");
                    var i, a = 0 | r._crypto_core_ristretto255_bytes();
                    e.length !== a && v(o, "invalid p length"), i = g(e), o.push(i), t = S(o, t, "q");
                    var s, d = 0 | r._crypto_core_ristretto255_bytes();
                    t.length !== d && v(o, "invalid q length"), s = g(t), o.push(s);
                    var c = new m(0 | r._crypto_core_ristretto255_bytes()),
                        u = c.address;
                    if (o.push(u), 0 == (0 | r._crypto_core_ristretto255_add(u, i, s))) {
                        var f = l(c, n);
                        return y(o), f
                    }
                    h(o, "input is an invalid element")
                }

                function eK(e, t) {
                    var n = [];
                    p(t);
                    var o = g(e = S(n, e, "r"));
                    e.length, n.push(o);
                    var i = new m(0 | r._crypto_core_ristretto255_bytes()),
                        a = i.address;
                    if (n.push(a), 0 == (0 | r._crypto_core_ristretto255_from_hash(a, o))) {
                        var s = l(i, t);
                        return y(n), s
                    }
                    h(n, "invalid usage")
                }

                function eY(e, t) {
                    var n = [];
                    p(t), e = S(n, e, "repr");
                    var o, i = 0 | r._crypto_core_ristretto255_bytes();
                    e.length !== i && v(n, "invalid repr length"), o = g(e), n.push(o);
                    var a = 1 == (0 | r._crypto_core_ristretto255_is_valid_point(o));
                    return y(n), a
                }

                function ez(e) {
                    var t = [];
                    p(e);
                    var n = new m(0 | r._crypto_core_ristretto255_bytes()),
                        o = n.address;
                    t.push(o), r._crypto_core_ristretto255_random(o);
                    var i = l(n, e);
                    return y(t), i
                }

                function e$(e, t, n) {
                    var o = [];
                    p(n), e = S(o, e, "x");
                    var i, a = 0 | r._crypto_core_ristretto255_scalarbytes();
                    e.length !== a && v(o, "invalid x length"), i = g(e), o.push(i), t = S(o, t, "y");
                    var s, d = 0 | r._crypto_core_ristretto255_scalarbytes();
                    t.length !== d && v(o, "invalid y length"), s = g(t), o.push(s);
                    var c = new m(0 | r._crypto_core_ristretto255_scalarbytes()),
                        u = c.address;
                    o.push(u), r._crypto_core_ristretto255_scalar_add(u, i, s);
                    var f = l(c, n);
                    return y(o), f
                }

                function eZ(e, t) {
                    var n = [];
                    p(t), e = S(n, e, "s");
                    var o, i = 0 | r._crypto_core_ristretto255_scalarbytes();
                    e.length !== i && v(n, "invalid s length"), o = g(e), n.push(o);
                    var a = new m(0 | r._crypto_core_ristretto255_scalarbytes()),
                        s = a.address;
                    n.push(s), r._crypto_core_ristretto255_scalar_complement(s, o);
                    var d = l(a, t);
                    return y(n), d
                }

                function eX(e, t) {
                    var n = [];
                    p(t), e = S(n, e, "s");
                    var o, i = 0 | r._crypto_core_ristretto255_scalarbytes();
                    e.length !== i && v(n, "invalid s length"), o = g(e), n.push(o);
                    var a = new m(0 | r._crypto_core_ristretto255_scalarbytes()),
                        s = a.address;
                    if (n.push(s), 0 == (0 | r._crypto_core_ristretto255_scalar_invert(s, o))) {
                        var d = l(a, t);
                        return y(n), d
                    }
                    h(n, "invalid reciprocate")
                }

                function e0(e, t, n) {
                    var o = [];
                    p(n), e = S(o, e, "x");
                    var i, a = 0 | r._crypto_core_ristretto255_scalarbytes();
                    e.length !== a && v(o, "invalid x length"), i = g(e), o.push(i), t = S(o, t, "y");
                    var s, d = 0 | r._crypto_core_ristretto255_scalarbytes();
                    t.length !== d && v(o, "invalid y length"), s = g(t), o.push(s);
                    var c = new m(0 | r._crypto_core_ristretto255_scalarbytes()),
                        u = c.address;
                    o.push(u), r._crypto_core_ristretto255_scalar_mul(u, i, s);
                    var f = l(c, n);
                    return y(o), f
                }

                function e2(e, t) {
                    var n = [];
                    p(t), e = S(n, e, "s");
                    var o, i = 0 | r._crypto_core_ristretto255_scalarbytes();
                    e.length !== i && v(n, "invalid s length"), o = g(e), n.push(o);
                    var a = new m(0 | r._crypto_core_ristretto255_scalarbytes()),
                        s = a.address;
                    n.push(s), r._crypto_core_ristretto255_scalar_negate(s, o);
                    var d = l(a, t);
                    return y(n), d
                }

                function e1(e) {
                    var t = [];
                    p(e);
                    var n = new m(0 | r._crypto_core_ristretto255_scalarbytes()),
                        o = n.address;
                    t.push(o), r._crypto_core_ristretto255_scalar_random(o);
                    var i = l(n, e);
                    return y(t), i
                }

                function e3(e, t) {
                    var n = [];
                    p(t), e = S(n, e, "sample");
                    var o, i = 0 | r._crypto_core_ristretto255_nonreducedscalarbytes();
                    e.length !== i && v(n, "invalid sample length"), o = g(e), n.push(o);
                    var a = new m(0 | r._crypto_core_ristretto255_scalarbytes()),
                        s = a.address;
                    n.push(s), r._crypto_core_ristretto255_scalar_reduce(s, o);
                    var d = l(a, t);
                    return y(n), d
                }

                function e6(e, t, n) {
                    var o = [];
                    p(n), e = S(o, e, "x");
                    var i, a = 0 | r._crypto_core_ristretto255_scalarbytes();
                    e.length !== a && v(o, "invalid x length"), i = g(e), o.push(i), t = S(o, t, "y");
                    var s, d = 0 | r._crypto_core_ristretto255_scalarbytes();
                    t.length !== d && v(o, "invalid y length"), s = g(t), o.push(s);
                    var c = new m(0 | r._crypto_core_ristretto255_scalarbytes()),
                        u = c.address;
                    o.push(u), r._crypto_core_ristretto255_scalar_sub(u, i, s);
                    var f = l(c, n);
                    return y(o), f
                }

                function e5(e, t, n) {
                    var o = [];
                    p(n), e = S(o, e, "p");
                    var i, a = 0 | r._crypto_core_ristretto255_bytes();
                    e.length !== a && v(o, "invalid p length"), i = g(e), o.push(i), t = S(o, t, "q");
                    var s, d = 0 | r._crypto_core_ristretto255_bytes();
                    t.length !== d && v(o, "invalid q length"), s = g(t), o.push(s);
                    var c = new m(0 | r._crypto_core_ristretto255_bytes()),
                        u = c.address;
                    if (o.push(u), 0 == (0 | r._crypto_core_ristretto255_sub(u, i, s))) {
                        var f = l(c, n);
                        return y(o), f
                    }
                    h(o, "input is an invalid element")
                }

                function e4(e, t, n, o) {
                    var i = [];
                    p(o), b(i, e, "hash_length"), ("number" != typeof e || (0 | e) !== e || e < 0) && v(i, "hash_length must be an unsigned integer");
                    var a = g(t = S(i, t, "message")),
                        s = t.length;
                    i.push(a);
                    var d = null,
                        c = 0;
                    null != n && (d = g(n = S(i, n, "key")), c = n.length, i.push(d));
                    var u = new m(e |= 0),
                        f = u.address;
                    if (i.push(f), 0 == (0 | r._crypto_generichash(f, e, a, s, 0, d, c))) {
                        var k = l(u, o);
                        return y(i), k
                    }
                    h(i, "invalid usage")
                }

                function e8(e, t, n, o, i) {
                    var a = [];
                    p(i), b(a, e, "subkey_len"), ("number" != typeof e || (0 | e) !== e || e < 0) && v(a, "subkey_len must be an unsigned integer");
                    var s = null,
                        d = 0;
                    null != t && (s = g(t = S(a, t, "key")), d = t.length, a.push(s));
                    var c = null,
                        u = 0;
                    null != n && (n = S(a, n, "id"), u = 0 | r._crypto_generichash_blake2b_saltbytes(), n.length !== u && v(a, "invalid id length"), c = g(n), a.push(c));
                    var f = null,
                        k = 0;
                    null != o && (o = S(a, o, "ctx"), k = 0 | r._crypto_generichash_blake2b_personalbytes(), o.length !== k && v(a, "invalid ctx length"), f = g(o), a.push(f));
                    var P = new m(0 | e),
                        _ = P.address;
                    if (a.push(_), 0 == (0 | r._crypto_generichash_blake2b_salt_personal(_, e, null, 0, 0, s, d, c, f))) {
                        var B = l(P, i);
                        return y(a), B
                    }
                    h(a, "invalid usage")
                }

                function e7(e, t, n) {
                    var o = [];
                    p(n), b(o, e, "state_address"), b(o, t, "hash_length"), ("number" != typeof t || (0 | t) !== t || t < 0) && v(o, "hash_length must be an unsigned integer");
                    var i = new m(t |= 0),
                        a = i.address;
                    if (o.push(a), 0 == (0 | r._crypto_generichash_final(e, a, t))) {
                        var s = (r._free(e), l(i, n));
                        return y(o), s
                    }
                    h(o, "invalid usage")
                }

                function e9(e, t, n) {
                    var o = [];
                    p(n);
                    var i = null,
                        a = 0;
                    null != e && (i = g(e = S(o, e, "key")), a = e.length, o.push(i)), b(o, t, "hash_length"), ("number" != typeof t || (0 | t) !== t || t < 0) && v(o, "hash_length must be an unsigned integer");
                    var s = new m(357).address;
                    if (0 == (0 | r._crypto_generichash_init(s, i, a, t))) return y(o), s;
                    h(o, "invalid usage")
                }

                function te(e) {
                    var t = [];
                    p(e);
                    var n = new m(0 | r._crypto_generichash_keybytes()),
                        o = n.address;
                    t.push(o), r._crypto_generichash_keygen(o);
                    var i = l(n, e);
                    return y(t), i
                }

                function tt(e, t, n) {
                    var o = [];
                    p(n), b(o, e, "state_address");
                    var i = g(t = S(o, t, "message_chunk")),
                        a = t.length;
                    o.push(i), 0 != (0 | r._crypto_generichash_update(e, i, a)) && h(o, "invalid usage"), y(o)
                }

                function tr(e, t) {
                    var n = [];
                    p(t);
                    var o = g(e = S(n, e, "message")),
                        i = e.length;
                    n.push(o);
                    var a = new m(0 | r._crypto_hash_bytes()),
                        s = a.address;
                    if (n.push(s), 0 == (0 | r._crypto_hash(s, o, i, 0))) {
                        var d = l(a, t);
                        return y(n), d
                    }
                    h(n, "invalid usage")
                }

                function tn(e, t) {
                    var n = [];
                    p(t);
                    var o = g(e = S(n, e, "message")),
                        i = e.length;
                    n.push(o);
                    var a = new m(0 | r._crypto_hash_sha256_bytes()),
                        s = a.address;
                    if (n.push(s), 0 == (0 | r._crypto_hash_sha256(s, o, i, 0))) {
                        var d = l(a, t);
                        return y(n), d
                    }
                    h(n, "invalid usage")
                }

                function to(e, t) {
                    var n = [];
                    p(t), b(n, e, "state_address");
                    var o = new m(0 | r._crypto_hash_sha256_bytes()),
                        i = o.address;
                    if (n.push(i), 0 == (0 | r._crypto_hash_sha256_final(e, i))) {
                        var a = (r._free(e), l(o, t));
                        return y(n), a
                    }
                    h(n, "invalid usage")
                }

                function ti(e) {
                    var t = [];
                    p(e);
                    var n = new m(104).address;
                    if (0 == (0 | r._crypto_hash_sha256_init(n))) return y(t), n;
                    h(t, "invalid usage")
                }

                function ta(e, t, n) {
                    var o = [];
                    p(n), b(o, e, "state_address");
                    var i = g(t = S(o, t, "message_chunk")),
                        a = t.length;
                    o.push(i), 0 != (0 | r._crypto_hash_sha256_update(e, i, a)) && h(o, "invalid usage"), y(o)
                }

                function ts(e, t) {
                    var n = [];
                    p(t);
                    var o = g(e = S(n, e, "message")),
                        i = e.length;
                    n.push(o);
                    var a = new m(0 | r._crypto_hash_sha512_bytes()),
                        s = a.address;
                    if (n.push(s), 0 == (0 | r._crypto_hash_sha512(s, o, i, 0))) {
                        var d = l(a, t);
                        return y(n), d
                    }
                    h(n, "invalid usage")
                }

                function td(e, t) {
                    var n = [];
                    p(t), b(n, e, "state_address");
                    var o = new m(0 | r._crypto_hash_sha512_bytes()),
                        i = o.address;
                    if (n.push(i), 0 == (0 | r._crypto_hash_sha512_final(e, i))) {
                        var a = (r._free(e), l(o, t));
                        return y(n), a
                    }
                    h(n, "invalid usage")
                }

                function tc(e) {
                    var t = [];
                    p(e);
                    var n = new m(208).address;
                    if (0 == (0 | r._crypto_hash_sha512_init(n))) return y(t), n;
                    h(t, "invalid usage")
                }

                function tl(e, t, n) {
                    var o = [];
                    p(n), b(o, e, "state_address");
                    var i = g(t = S(o, t, "message_chunk")),
                        a = t.length;
                    o.push(i), 0 != (0 | r._crypto_hash_sha512_update(e, i, a)) && h(o, "invalid usage"), y(o)
                }

                function tu(e, t, n, i, a) {
                    var s = [];
                    p(a), b(s, e, "subkey_len"), ("number" != typeof e || (0 | e) !== e || e < 0) && v(s, "subkey_len must be an unsigned integer"), b(s, t, "subkey_id"), ("number" != typeof t || (0 | t) !== t || t < 0) && v(s, "subkey_id must be an unsigned integer"), "string" != typeof n && v(s, "ctx must be a string"), n = o(n + "\x00"), null != c && n.length - 1 !== c && v(s, "invalid ctx length");
                    var d = g(n),
                        c = n.length - 1;
                    s.push(d), i = S(s, i, "key");
                    var u, f = 0 | r._crypto_kdf_keybytes();
                    i.length !== f && v(s, "invalid key length"), u = g(i), s.push(u);
                    var h = new m(0 | e),
                        k = h.address;
                    s.push(k), r._crypto_kdf_derive_from_key(k, e, t, t >>> 24 >>> 8, d, u);
                    var P = l(h, a);
                    return y(s), P
                }

                function tp(e) {
                    var t = [];
                    p(e);
                    var n = new m(0 | r._crypto_kdf_keybytes()),
                        o = n.address;
                    t.push(o), r._crypto_kdf_keygen(o);
                    var i = l(n, e);
                    return y(t), i
                }

                function tm(e, t, n, o) {
                    var i = [];
                    p(o), e = S(i, e, "clientPublicKey");
                    var a, s = 0 | r._crypto_kx_publickeybytes();
                    e.length !== s && v(i, "invalid clientPublicKey length"), a = g(e), i.push(a), t = S(i, t, "clientSecretKey");
                    var d, c = 0 | r._crypto_kx_secretkeybytes();
                    t.length !== c && v(i, "invalid clientSecretKey length"), d = g(t), i.push(d), n = S(i, n, "serverPublicKey");
                    var u, f = 0 | r._crypto_kx_publickeybytes();
                    n.length !== f && v(i, "invalid serverPublicKey length"), u = g(n), i.push(u);
                    var b = new m(0 | r._crypto_kx_sessionkeybytes()),
                        k = b.address;
                    i.push(k);
                    var P = new m(0 | r._crypto_kx_sessionkeybytes()),
                        _ = P.address;
                    if (i.push(_), 0 == (0 | r._crypto_kx_client_session_keys(k, _, a, d, u))) {
                        var B = l({
                            sharedRx: b,
                            sharedTx: P
                        }, o);
                        return y(i), B
                    }
                    h(i, "invalid usage")
                }

                function tg(e) {
                    var t = [];
                    p(e);
                    var n = new m(0 | r._crypto_kx_publickeybytes()),
                        o = n.address;
                    t.push(o);
                    var i = new m(0 | r._crypto_kx_secretkeybytes()),
                        a = i.address;
                    if (t.push(a), 0 == (0 | r._crypto_kx_keypair(o, a))) {
                        var s = {
                            publicKey: l(n, e),
                            privateKey: l(i, e),
                            keyType: "x25519"
                        };
                        return y(t), s
                    }
                    h(t, "internal error")
                }

                function tf(e, t) {
                    var n = [];
                    p(t), e = S(n, e, "seed");
                    var o, i = 0 | r._crypto_kx_seedbytes();
                    e.length !== i && v(n, "invalid seed length"), o = g(e), n.push(o);
                    var a = new m(0 | r._crypto_kx_publickeybytes()),
                        s = a.address;
                    n.push(s);
                    var d = new m(0 | r._crypto_kx_secretkeybytes()),
                        c = d.address;
                    if (n.push(c), 0 == (0 | r._crypto_kx_seed_keypair(s, c, o))) {
                        var u = {
                            publicKey: l(a, t),
                            privateKey: l(d, t),
                            keyType: "x25519"
                        };
                        return y(n), u
                    }
                    h(n, "internal error")
                }

                function ty(e, t, n, o) {
                    var i = [];
                    p(o), e = S(i, e, "serverPublicKey");
                    var a, s = 0 | r._crypto_kx_publickeybytes();
                    e.length !== s && v(i, "invalid serverPublicKey length"), a = g(e), i.push(a), t = S(i, t, "serverSecretKey");
                    var d, c = 0 | r._crypto_kx_secretkeybytes();
                    t.length !== c && v(i, "invalid serverSecretKey length"), d = g(t), i.push(d), n = S(i, n, "clientPublicKey");
                    var u, f = 0 | r._crypto_kx_publickeybytes();
                    n.length !== f && v(i, "invalid clientPublicKey length"), u = g(n), i.push(u);
                    var b = new m(0 | r._crypto_kx_sessionkeybytes()),
                        k = b.address;
                    i.push(k);
                    var P = new m(0 | r._crypto_kx_sessionkeybytes()),
                        _ = P.address;
                    if (i.push(_), 0 == (0 | r._crypto_kx_server_session_keys(k, _, a, d, u))) {
                        var B = l({
                            sharedRx: b,
                            sharedTx: P
                        }, o);
                        return y(i), B
                    }
                    h(i, "invalid usage")
                }

                function th(e, t, n) {
                    var o = [];
                    p(n);
                    var i = g(e = S(o, e, "message")),
                        a = e.length;
                    o.push(i), t = S(o, t, "key");
                    var s, d = 0 | r._crypto_onetimeauth_keybytes();
                    t.length !== d && v(o, "invalid key length"), s = g(t), o.push(s);
                    var c = new m(0 | r._crypto_onetimeauth_bytes()),
                        u = c.address;
                    if (o.push(u), 0 == (0 | r._crypto_onetimeauth(u, i, a, 0, s))) {
                        var f = l(c, n);
                        return y(o), f
                    }
                    h(o, "invalid usage")
                }

                function tv(e, t) {
                    var n = [];
                    p(t), b(n, e, "state_address");
                    var o = new m(0 | r._crypto_onetimeauth_bytes()),
                        i = o.address;
                    if (n.push(i), 0 == (0 | r._crypto_onetimeauth_final(e, i))) {
                        var a = (r._free(e), l(o, t));
                        return y(n), a
                    }
                    h(n, "invalid usage")
                }

                function tb(e, t) {
                    var n = [];
                    p(t);
                    var o = null;
                    null != e && (o = g(e = S(n, e, "key")), e.length, n.push(o));
                    var i = new m(144).address;
                    if (0 == (0 | r._crypto_onetimeauth_init(i, o))) return y(n), i;
                    h(n, "invalid usage")
                }

                function tS(e) {
                    var t = [];
                    p(e);
                    var n = new m(0 | r._crypto_onetimeauth_keybytes()),
                        o = n.address;
                    t.push(o), r._crypto_onetimeauth_keygen(o);
                    var i = l(n, e);
                    return y(t), i
                }

                function tk(e, t, n) {
                    var o = [];
                    p(n), b(o, e, "state_address");
                    var i = g(t = S(o, t, "message_chunk")),
                        a = t.length;
                    o.push(i), 0 != (0 | r._crypto_onetimeauth_update(e, i, a)) && h(o, "invalid usage"), y(o)
                }

                function tP(e, t, n) {
                    var o = [];
                    e = S(o, e, "hash");
                    var i, a = 0 | r._crypto_onetimeauth_bytes();
                    e.length !== a && v(o, "invalid hash length"), i = g(e), o.push(i);
                    var s = g(t = S(o, t, "message")),
                        d = t.length;
                    o.push(s), n = S(o, n, "key");
                    var c, l = 0 | r._crypto_onetimeauth_keybytes();
                    n.length !== l && v(o, "invalid key length"), c = g(n), o.push(c);
                    var u = 0 == (0 | r._crypto_onetimeauth_verify(i, s, d, 0, c));
                    return y(o), u
                }

                function t_(e, t, n, o, i, a, s) {
                    var d = [];
                    p(s), b(d, e, "keyLength"), ("number" != typeof e || (0 | e) !== e || e < 0) && v(d, "keyLength must be an unsigned integer");
                    var c = g(t = S(d, t, "password")),
                        u = t.length;
                    d.push(c), n = S(d, n, "salt");
                    var f, k = 0 | r._crypto_pwhash_saltbytes();
                    n.length !== k && v(d, "invalid salt length"), f = g(n), d.push(f), b(d, o, "opsLimit"), ("number" != typeof o || (0 | o) !== o || o < 0) && v(d, "opsLimit must be an unsigned integer"), b(d, i, "memLimit"), ("number" != typeof i || (0 | i) !== i || i < 0) && v(d, "memLimit must be an unsigned integer"), b(d, a, "algorithm"), ("number" != typeof a || (0 | a) !== a || a < 0) && v(d, "algorithm must be an unsigned integer");
                    var P = new m(0 | e),
                        _ = P.address;
                    if (d.push(_), 0 == (0 | r._crypto_pwhash(_, e, 0, c, u, 0, f, o, 0, i, a))) {
                        var B = l(P, s);
                        return y(d), B
                    }
                    h(d, "invalid usage")
                }

                function tB(e, t, n, o, i, a) {
                    var s = [];
                    p(a), b(s, e, "keyLength"), ("number" != typeof e || (0 | e) !== e || e < 0) && v(s, "keyLength must be an unsigned integer");
                    var d = g(t = S(s, t, "password")),
                        c = t.length;
                    s.push(d), n = S(s, n, "salt");
                    var u, f = 0 | r._crypto_pwhash_scryptsalsa208sha256_saltbytes();
                    n.length !== f && v(s, "invalid salt length"), u = g(n), s.push(u), b(s, o, "opsLimit"), ("number" != typeof o || (0 | o) !== o || o < 0) && v(s, "opsLimit must be an unsigned integer"), b(s, i, "memLimit"), ("number" != typeof i || (0 | i) !== i || i < 0) && v(s, "memLimit must be an unsigned integer");
                    var k = new m(0 | e),
                        P = k.address;
                    if (s.push(P), 0 == (0 | r._crypto_pwhash_scryptsalsa208sha256(P, e, 0, d, c, 0, u, o, 0, i))) {
                        var _ = l(k, a);
                        return y(s), _
                    }
                    h(s, "invalid usage")
                }

                function tO(e, t, n, o, i, a, s) {
                    var d = [];
                    p(s);
                    var c = g(e = S(d, e, "password")),
                        u = e.length;
                    d.push(c);
                    var f = g(t = S(d, t, "salt")),
                        k = t.length;
                    d.push(f), b(d, n, "opsLimit"), ("number" != typeof n || (0 | n) !== n || n < 0) && v(d, "opsLimit must be an unsigned integer"), b(d, o, "r"), ("number" != typeof o || (0 | o) !== o || o < 0) && v(d, "r must be an unsigned integer"), b(d, i, "p"), ("number" != typeof i || (0 | i) !== i || i < 0) && v(d, "p must be an unsigned integer"), b(d, a, "keyLength"), ("number" != typeof a || (0 | a) !== a || a < 0) && v(d, "keyLength must be an unsigned integer");
                    var P = new m(0 | a),
                        _ = P.address;
                    if (d.push(_), 0 == (0 | r._crypto_pwhash_scryptsalsa208sha256_ll(c, u, f, k, n, 0, o, i, _, a))) {
                        var B = l(P, s);
                        return y(d), B
                    }
                    h(d, "invalid usage")
                }

                function tR(e, t, n, o) {
                    var i = [];
                    p(o);
                    var a = g(e = S(i, e, "password")),
                        s = e.length;
                    i.push(a), b(i, t, "opsLimit"), ("number" != typeof t || (0 | t) !== t || t < 0) && v(i, "opsLimit must be an unsigned integer"), b(i, n, "memLimit"), ("number" != typeof n || (0 | n) !== n || n < 0) && v(i, "memLimit must be an unsigned integer");
                    var d = new m(0 | r._crypto_pwhash_scryptsalsa208sha256_strbytes()).address;
                    if (i.push(d), 0 == (0 | r._crypto_pwhash_scryptsalsa208sha256_str(d, a, s, 0, t, 0, n))) {
                        var c = r.UTF8ToString(d);
                        return y(i), c
                    }
                    h(i, "invalid usage")
                }

                function tA(e, t, n) {
                    var i = [];
                    p(n), "string" != typeof e && v(i, "hashed_password must be a string"), e = o(e + "\x00"), null != s && e.length - 1 !== s && v(i, "invalid hashed_password length");
                    var a = g(e),
                        s = e.length - 1;
                    i.push(a);
                    var d = g(t = S(i, t, "password")),
                        c = t.length;
                    i.push(d);
                    var l = 0 == (0 | r._crypto_pwhash_scryptsalsa208sha256_str_verify(a, d, c, 0));
                    return y(i), l
                }

                function tI(e, t, n, o) {
                    var i = [];
                    p(o);
                    var a = g(e = S(i, e, "password")),
                        s = e.length;
                    i.push(a), b(i, t, "opsLimit"), ("number" != typeof t || (0 | t) !== t || t < 0) && v(i, "opsLimit must be an unsigned integer"), b(i, n, "memLimit"), ("number" != typeof n || (0 | n) !== n || n < 0) && v(i, "memLimit must be an unsigned integer");
                    var d = new m(0 | r._crypto_pwhash_strbytes()).address;
                    if (i.push(d), 0 == (0 | r._crypto_pwhash_str(d, a, s, 0, t, 0, n))) {
                        var c = r.UTF8ToString(d);
                        return y(i), c
                    }
                    h(i, "invalid usage")
                }

                function tw(e, t, n, i) {
                    var a = [];
                    p(i), "string" != typeof e && v(a, "hashed_password must be a string"), e = o(e + "\x00"), null != d && e.length - 1 !== d && v(a, "invalid hashed_password length");
                    var s = g(e),
                        d = e.length - 1;
                    a.push(s), b(a, t, "opsLimit"), ("number" != typeof t || (0 | t) !== t || t < 0) && v(a, "opsLimit must be an unsigned integer"), b(a, n, "memLimit"), ("number" != typeof n || (0 | n) !== n || n < 0) && v(a, "memLimit must be an unsigned integer");
                    var c = 0 != (0 | r._crypto_pwhash_str_needs_rehash(s, t, 0, n));
                    return y(a), c
                }

                function tT(e, t, n) {
                    var i = [];
                    p(n), "string" != typeof e && v(i, "hashed_password must be a string"), e = o(e + "\x00"), null != s && e.length - 1 !== s && v(i, "invalid hashed_password length");
                    var a = g(e),
                        s = e.length - 1;
                    i.push(a);
                    var d = g(t = S(i, t, "password")),
                        c = t.length;
                    i.push(d);
                    var l = 0 == (0 | r._crypto_pwhash_str_verify(a, d, c, 0));
                    return y(i), l
                }

                function tN(e, t, n) {
                    var o = [];
                    p(n), e = S(o, e, "privateKey");
                    var i, a = 0 | r._crypto_scalarmult_scalarbytes();
                    e.length !== a && v(o, "invalid privateKey length"), i = g(e), o.push(i), t = S(o, t, "publicKey");
                    var s, d = 0 | r._crypto_scalarmult_bytes();
                    t.length !== d && v(o, "invalid publicKey length"), s = g(t), o.push(s);
                    var c = new m(0 | r._crypto_scalarmult_bytes()),
                        u = c.address;
                    if (o.push(u), 0 == (0 | r._crypto_scalarmult(u, i, s))) {
                        var f = l(c, n);
                        return y(o), f
                    }
                    h(o, "weak public key")
                }

                function tC(e, t) {
                    var n = [];
                    p(t), e = S(n, e, "privateKey");
                    var o, i = 0 | r._crypto_scalarmult_scalarbytes();
                    e.length !== i && v(n, "invalid privateKey length"), o = g(e), n.push(o);
                    var a = new m(0 | r._crypto_scalarmult_bytes()),
                        s = a.address;
                    if (n.push(s), 0 == (0 | r._crypto_scalarmult_base(s, o))) {
                        var d = l(a, t);
                        return y(n), d
                    }
                    h(n, "unknown error")
                }

                function tE(e, t, n) {
                    var o = [];
                    p(n), e = S(o, e, "n");
                    var i, a = 0 | r._crypto_scalarmult_ed25519_scalarbytes();
                    e.length !== a && v(o, "invalid n length"), i = g(e), o.push(i), t = S(o, t, "p");
                    var s, d = 0 | r._crypto_scalarmult_ed25519_bytes();
                    t.length !== d && v(o, "invalid p length"), s = g(t), o.push(s);
                    var c = new m(0 | r._crypto_scalarmult_ed25519_bytes()),
                        u = c.address;
                    if (o.push(u), 0 == (0 | r._crypto_scalarmult_ed25519(u, i, s))) {
                        var f = l(c, n);
                        return y(o), f
                    }
                    h(o, "invalid point or scalar is 0")
                }

                function tx(e, t) {
                    var n = [];
                    p(t), e = S(n, e, "scalar");
                    var o, i = 0 | r._crypto_scalarmult_ed25519_scalarbytes();
                    e.length !== i && v(n, "invalid scalar length"), o = g(e), n.push(o);
                    var a = new m(0 | r._crypto_scalarmult_ed25519_bytes()),
                        s = a.address;
                    if (n.push(s), 0 == (0 | r._crypto_scalarmult_ed25519_base(s, o))) {
                        var d = l(a, t);
                        return y(n), d
                    }
                    h(n, "scalar is 0")
                }

                function tU(e, t) {
                    var n = [];
                    p(t), e = S(n, e, "scalar");
                    var o, i = 0 | r._crypto_scalarmult_ed25519_scalarbytes();
                    e.length !== i && v(n, "invalid scalar length"), o = g(e), n.push(o);
                    var a = new m(0 | r._crypto_scalarmult_ed25519_bytes()),
                        s = a.address;
                    if (n.push(s), 0 == (0 | r._crypto_scalarmult_ed25519_base_noclamp(s, o))) {
                        var d = l(a, t);
                        return y(n), d
                    }
                    h(n, "scalar is 0")
                }

                function tD(e, t, n) {
                    var o = [];
                    p(n), e = S(o, e, "n");
                    var i, a = 0 | r._crypto_scalarmult_ed25519_scalarbytes();
                    e.length !== a && v(o, "invalid n length"), i = g(e), o.push(i), t = S(o, t, "p");
                    var s, d = 0 | r._crypto_scalarmult_ed25519_bytes();
                    t.length !== d && v(o, "invalid p length"), s = g(t), o.push(s);
                    var c = new m(0 | r._crypto_scalarmult_ed25519_bytes()),
                        u = c.address;
                    if (o.push(u), 0 == (0 | r._crypto_scalarmult_ed25519_noclamp(u, i, s))) {
                        var f = l(c, n);
                        return y(o), f
                    }
                    h(o, "invalid point or scalar is 0")
                }

                function tM(e, t, n) {
                    var o = [];
                    p(n), e = S(o, e, "scalar");
                    var i, a = 0 | r._crypto_scalarmult_ristretto255_scalarbytes();
                    e.length !== a && v(o, "invalid scalar length"), i = g(e), o.push(i), t = S(o, t, "element");
                    var s, d = 0 | r._crypto_scalarmult_ristretto255_bytes();
                    t.length !== d && v(o, "invalid element length"), s = g(t), o.push(s);
                    var c = new m(0 | r._crypto_scalarmult_ristretto255_bytes()),
                        u = c.address;
                    if (o.push(u), 0 == (0 | r._crypto_scalarmult_ristretto255(u, i, s))) {
                        var f = l(c, n);
                        return y(o), f
                    }
                    h(o, "result is identity element")
                }

                function tJ(e, t) {
                    var n = [];
                    p(t), e = S(n, e, "scalar");
                    var o, i = 0 | r._crypto_core_ristretto255_scalarbytes();
                    e.length !== i && v(n, "invalid scalar length"), o = g(e), n.push(o);
                    var a = new m(0 | r._crypto_core_ristretto255_bytes()),
                        s = a.address;
                    if (n.push(s), 0 == (0 | r._crypto_scalarmult_ristretto255_base(s, o))) {
                        var d = l(a, t);
                        return y(n), d
                    }
                    h(n, "scalar is 0")
                }

                function tH(e, t, n, o) {
                    var i = [];
                    p(o);
                    var a = g(e = S(i, e, "message")),
                        s = e.length;
                    i.push(a), t = S(i, t, "nonce");
                    var d, c = 0 | r._crypto_secretbox_noncebytes();
                    t.length !== c && v(i, "invalid nonce length"), d = g(t), i.push(d), n = S(i, n, "key");
                    var u, f = 0 | r._crypto_secretbox_keybytes();
                    n.length !== f && v(i, "invalid key length"), u = g(n), i.push(u);
                    var b = new m(0 | s),
                        k = b.address;
                    i.push(k);
                    var P = new m(0 | r._crypto_secretbox_macbytes()),
                        _ = P.address;
                    if (i.push(_), 0 == (0 | r._crypto_secretbox_detached(k, _, a, s, 0, d, u))) {
                        var B = l({
                            mac: P,
                            cipher: b
                        }, o);
                        return y(i), B
                    }
                    h(i, "invalid usage")
                }

                function tj(e, t, n, o) {
                    var i = [];
                    p(o);
                    var a = g(e = S(i, e, "message")),
                        s = e.length;
                    i.push(a), t = S(i, t, "nonce");
                    var d, c = 0 | r._crypto_secretbox_noncebytes();
                    t.length !== c && v(i, "invalid nonce length"), d = g(t), i.push(d), n = S(i, n, "key");
                    var u, f = 0 | r._crypto_secretbox_keybytes();
                    n.length !== f && v(i, "invalid key length"), u = g(n), i.push(u);
                    var b = new m(s + r._crypto_secretbox_macbytes() | 0),
                        k = b.address;
                    if (i.push(k), 0 == (0 | r._crypto_secretbox_easy(k, a, s, 0, d, u))) {
                        var P = l(b, o);
                        return y(i), P
                    }
                    h(i, "invalid usage")
                }

                function tV(e) {
                    var t = [];
                    p(e);
                    var n = new m(0 | r._crypto_secretbox_keybytes()),
                        o = n.address;
                    t.push(o), r._crypto_secretbox_keygen(o);
                    var i = l(n, e);
                    return y(t), i
                }

                function tq(e, t, n, o, i) {
                    var a = [];
                    p(i);
                    var s = g(e = S(a, e, "ciphertext")),
                        d = e.length;
                    a.push(s), t = S(a, t, "mac");
                    var c, u = 0 | r._crypto_secretbox_macbytes();
                    t.length !== u && v(a, "invalid mac length"), c = g(t), a.push(c), n = S(a, n, "nonce");
                    var f, b = 0 | r._crypto_secretbox_noncebytes();
                    n.length !== b && v(a, "invalid nonce length"), f = g(n), a.push(f), o = S(a, o, "key");
                    var k, P = 0 | r._crypto_secretbox_keybytes();
                    o.length !== P && v(a, "invalid key length"), k = g(o), a.push(k);
                    var _ = new m(0 | d),
                        B = _.address;
                    if (a.push(B), 0 == (0 | r._crypto_secretbox_open_detached(B, s, c, d, 0, f, k))) {
                        var O = l(_, i);
                        return y(a), O
                    }
                    h(a, "wrong secret key for the given ciphertext")
                }

                function tW(e, t, n, o) {
                    var i = [];
                    p(o), e = S(i, e, "ciphertext");
                    var a, s = r._crypto_secretbox_macbytes(),
                        d = e.length;
                    d < s && v(i, "ciphertext is too short"), a = g(e), i.push(a), t = S(i, t, "nonce");
                    var c, u = 0 | r._crypto_secretbox_noncebytes();
                    t.length !== u && v(i, "invalid nonce length"), c = g(t), i.push(c), n = S(i, n, "key");
                    var f, b = 0 | r._crypto_secretbox_keybytes();
                    n.length !== b && v(i, "invalid key length"), f = g(n), i.push(f);
                    var k = new m(d - r._crypto_secretbox_macbytes() | 0),
                        P = k.address;
                    if (i.push(P), 0 == (0 | r._crypto_secretbox_open_easy(P, a, d, 0, c, f))) {
                        var _ = l(k, o);
                        return y(i), _
                    }
                    h(i, "wrong secret key for the given ciphertext")
                }

                function tF(e, t, n) {
                    var o = [];
                    p(n), e = S(o, e, "header");
                    var i, a = 0 | r._crypto_secretstream_xchacha20poly1305_headerbytes();
                    e.length !== a && v(o, "invalid header length"), i = g(e), o.push(i), t = S(o, t, "key");
                    var s, d = 0 | r._crypto_secretstream_xchacha20poly1305_keybytes();
                    t.length !== d && v(o, "invalid key length"), s = g(t), o.push(s);
                    var c = new m(52).address;
                    if (0 == (0 | r._crypto_secretstream_xchacha20poly1305_init_pull(c, i, s))) return y(o), c;
                    h(o, "invalid usage")
                }

                function tQ(e, t) {
                    var n = [];
                    p(t), e = S(n, e, "key");
                    var o, i = 0 | r._crypto_secretstream_xchacha20poly1305_keybytes();
                    e.length !== i && v(n, "invalid key length"), o = g(e), n.push(o);
                    var a = new m(52).address,
                        s = new m(0 | r._crypto_secretstream_xchacha20poly1305_headerbytes()),
                        d = s.address;
                    if (n.push(d), 0 == (0 | r._crypto_secretstream_xchacha20poly1305_init_push(a, d, o))) {
                        var c = {
                            state: a,
                            header: l(s, t)
                        };
                        return y(n), c
                    }
                    h(n, "invalid usage")
                }

                function tG(e) {
                    var t = [];
                    p(e);
                    var n = new m(0 | r._crypto_secretstream_xchacha20poly1305_keybytes()),
                        o = n.address;
                    t.push(o), r._crypto_secretstream_xchacha20poly1305_keygen(o);
                    var i = l(n, e);
                    return y(t), i
                }

                function tL(e, t, n, o) {
                    var i = [];
                    p(o), b(i, e, "state_address"), t = S(i, t, "cipher");
                    var a, s = r._crypto_secretstream_xchacha20poly1305_abytes(),
                        d = t.length;
                    d < s && v(i, "cipher is too short"), a = g(t), i.push(a);
                    var c = null,
                        u = 0;
                    null != n && (c = g(n = S(i, n, "ad")), u = n.length, i.push(c));
                    var h = new m(d - r._crypto_secretstream_xchacha20poly1305_abytes() | 0),
                        k = h.address;
                    i.push(k);
                    var P, _ = (P = f(1), i.push(P), (_ = 0 === r._crypto_secretstream_xchacha20poly1305_pull(e, k, 0, P, a, d, 0, c, u) && {
                        tag: r.HEAPU8[P],
                        message: h
                    }) && {
                        message: l(_.message, o),
                        tag: _.tag
                    });
                    return y(i), _
                }

                function tK(e, t, n, o, i) {
                    var a = [];
                    p(i), b(a, e, "state_address");
                    var s = g(t = S(a, t, "message_chunk")),
                        d = t.length;
                    a.push(s);
                    var c = null,
                        u = 0;
                    null != n && (c = g(n = S(a, n, "ad")), u = n.length, a.push(c)), b(a, o, "tag"), ("number" != typeof o || (0 | o) !== o || o < 0) && v(a, "tag must be an unsigned integer");
                    var f = new m(d + r._crypto_secretstream_xchacha20poly1305_abytes() | 0),
                        k = f.address;
                    if (a.push(k), 0 == (0 | r._crypto_secretstream_xchacha20poly1305_push(e, k, 0, s, d, 0, c, u, 0, o))) {
                        var P = l(f, i);
                        return y(a), P
                    }
                    h(a, "invalid usage")
                }

                function tY(e, t) {
                    var n = [];
                    return p(t), b(n, e, "state_address"), r._crypto_secretstream_xchacha20poly1305_rekey(e), y(n), !0
                }

                function tz(e, t, n) {
                    var o = [];
                    p(n);
                    var i = g(e = S(o, e, "message")),
                        a = e.length;
                    o.push(i), t = S(o, t, "key");
                    var s, d = 0 | r._crypto_shorthash_keybytes();
                    t.length !== d && v(o, "invalid key length"), s = g(t), o.push(s);
                    var c = new m(0 | r._crypto_shorthash_bytes()),
                        u = c.address;
                    if (o.push(u), 0 == (0 | r._crypto_shorthash(u, i, a, 0, s))) {
                        var f = l(c, n);
                        return y(o), f
                    }
                    h(o, "invalid usage")
                }

                function t$(e) {
                    var t = [];
                    p(e);
                    var n = new m(0 | r._crypto_shorthash_keybytes()),
                        o = n.address;
                    t.push(o), r._crypto_shorthash_keygen(o);
                    var i = l(n, e);
                    return y(t), i
                }

                function tZ(e, t, n) {
                    var o = [];
                    p(n);
                    var i = g(e = S(o, e, "message")),
                        a = e.length;
                    o.push(i), t = S(o, t, "key");
                    var s, d = 0 | r._crypto_shorthash_siphashx24_keybytes();
                    t.length !== d && v(o, "invalid key length"), s = g(t), o.push(s);
                    var c = new m(0 | r._crypto_shorthash_siphashx24_bytes()),
                        u = c.address;
                    if (o.push(u), 0 == (0 | r._crypto_shorthash_siphashx24(u, i, a, 0, s))) {
                        var f = l(c, n);
                        return y(o), f
                    }
                    h(o, "invalid usage")
                }

                function tX(e, t, n) {
                    var o = [];
                    p(n);
                    var i = g(e = S(o, e, "message")),
                        a = e.length;
                    o.push(i), t = S(o, t, "privateKey");
                    var s, d = 0 | r._crypto_sign_secretkeybytes();
                    t.length !== d && v(o, "invalid privateKey length"), s = g(t), o.push(s);
                    var c = new m(e.length + r._crypto_sign_bytes() | 0),
                        u = c.address;
                    if (o.push(u), 0 == (0 | r._crypto_sign(u, null, i, a, 0, s))) {
                        var f = l(c, n);
                        return y(o), f
                    }
                    h(o, "invalid usage")
                }

                function t0(e, t, n) {
                    var o = [];
                    p(n);
                    var i = g(e = S(o, e, "message")),
                        a = e.length;
                    o.push(i), t = S(o, t, "privateKey");
                    var s, d = 0 | r._crypto_sign_secretkeybytes();
                    t.length !== d && v(o, "invalid privateKey length"), s = g(t), o.push(s);
                    var c = new m(0 | r._crypto_sign_bytes()),
                        u = c.address;
                    if (o.push(u), 0 == (0 | r._crypto_sign_detached(u, null, i, a, 0, s))) {
                        var f = l(c, n);
                        return y(o), f
                    }
                    h(o, "invalid usage")
                }

                function t2(e, t) {
                    var n = [];
                    p(t), e = S(n, e, "edPk");
                    var o, i = 0 | r._crypto_sign_publickeybytes();
                    e.length !== i && v(n, "invalid edPk length"), o = g(e), n.push(o);
                    var a = new m(0 | r._crypto_scalarmult_scalarbytes()),
                        s = a.address;
                    if (n.push(s), 0 == (0 | r._crypto_sign_ed25519_pk_to_curve25519(s, o))) {
                        var d = l(a, t);
                        return y(n), d
                    }
                    h(n, "invalid key")
                }

                function t1(e, t) {
                    var n = [];
                    p(t), e = S(n, e, "edSk");
                    var o, i = 0 | r._crypto_sign_secretkeybytes();
                    e.length !== i && v(n, "invalid edSk length"), o = g(e), n.push(o);
                    var a = new m(0 | r._crypto_scalarmult_scalarbytes()),
                        s = a.address;
                    if (n.push(s), 0 == (0 | r._crypto_sign_ed25519_sk_to_curve25519(s, o))) {
                        var d = l(a, t);
                        return y(n), d
                    }
                    h(n, "invalid key")
                }

                function t3(e, t) {
                    var n = [];
                    p(t), e = S(n, e, "privateKey");
                    var o, i = 0 | r._crypto_sign_secretkeybytes();
                    e.length !== i && v(n, "invalid privateKey length"), o = g(e), n.push(o);
                    var a = new m(0 | r._crypto_sign_publickeybytes()),
                        s = a.address;
                    if (n.push(s), 0 == (0 | r._crypto_sign_ed25519_sk_to_pk(s, o))) {
                        var d = l(a, t);
                        return y(n), d
                    }
                    h(n, "invalid key")
                }

                function t6(e, t) {
                    var n = [];
                    p(t), e = S(n, e, "privateKey");
                    var o, i = 0 | r._crypto_sign_secretkeybytes();
                    e.length !== i && v(n, "invalid privateKey length"), o = g(e), n.push(o);
                    var a = new m(0 | r._crypto_sign_seedbytes()),
                        s = a.address;
                    if (n.push(s), 0 == (0 | r._crypto_sign_ed25519_sk_to_seed(s, o))) {
                        var d = l(a, t);
                        return y(n), d
                    }
                    h(n, "invalid key")
                }

                function t5(e, t, n) {
                    var o = [];
                    p(n), b(o, e, "state_address"), t = S(o, t, "privateKey");
                    var i, a = 0 | r._crypto_sign_secretkeybytes();
                    t.length !== a && v(o, "invalid privateKey length"), i = g(t), o.push(i);
                    var s = new m(0 | r._crypto_sign_bytes()),
                        d = s.address;
                    if (o.push(d), 0 == (0 | r._crypto_sign_final_create(e, d, null, i))) {
                        var c = (r._free(e), l(s, n));
                        return y(o), c
                    }
                    h(o, "invalid usage")
                }

                function t4(e, t, n, o) {
                    var i = [];
                    p(o), b(i, e, "state_address"), t = S(i, t, "signature");
                    var a, s = 0 | r._crypto_sign_bytes();
                    t.length !== s && v(i, "invalid signature length"), a = g(t), i.push(a), n = S(i, n, "publicKey");
                    var d, c = 0 | r._crypto_sign_publickeybytes();
                    n.length !== c && v(i, "invalid publicKey length"), d = g(n), i.push(d);
                    var l = 0 == (0 | r._crypto_sign_final_verify(e, a, d));
                    return y(i), l
                }

                function t8(e) {
                    var t = [];
                    p(e);
                    var n = new m(208).address;
                    if (0 == (0 | r._crypto_sign_init(n))) return y(t), n;
                    h(t, "internal error")
                }

                function t7(e) {
                    var t = [];
                    p(e);
                    var n = new m(0 | r._crypto_sign_publickeybytes()),
                        o = n.address;
                    t.push(o);
                    var i = new m(0 | r._crypto_sign_secretkeybytes()),
                        a = i.address;
                    if (t.push(a), 0 == (0 | r._crypto_sign_keypair(o, a))) {
                        var s = {
                            publicKey: l(n, e),
                            privateKey: l(i, e),
                            keyType: "ed25519"
                        };
                        return y(t), s
                    }
                    h(t, "internal error")
                }

                function t9(e, t, n) {
                    var o = [];
                    p(n), e = S(o, e, "signedMessage");
                    var i, a = r._crypto_sign_bytes(),
                        s = e.length;
                    s < a && v(o, "signedMessage is too short"), i = g(e), o.push(i), t = S(o, t, "publicKey");
                    var d, c = 0 | r._crypto_sign_publickeybytes();
                    t.length !== c && v(o, "invalid publicKey length"), d = g(t), o.push(d);
                    var u = new m(s - r._crypto_sign_bytes() | 0),
                        f = u.address;
                    if (o.push(f), 0 == (0 | r._crypto_sign_open(f, null, i, s, 0, d))) {
                        var b = l(u, n);
                        return y(o), b
                    }
                    h(o, "incorrect signature for the given public key")
                }

                function re(e, t) {
                    var n = [];
                    p(t), e = S(n, e, "seed");
                    var o, i = 0 | r._crypto_sign_seedbytes();
                    e.length !== i && v(n, "invalid seed length"), o = g(e), n.push(o);
                    var a = new m(0 | r._crypto_sign_publickeybytes()),
                        s = a.address;
                    n.push(s);
                    var d = new m(0 | r._crypto_sign_secretkeybytes()),
                        c = d.address;
                    if (n.push(c), 0 == (0 | r._crypto_sign_seed_keypair(s, c, o))) {
                        var u = {
                            publicKey: l(a, t),
                            privateKey: l(d, t),
                            keyType: "ed25519"
                        };
                        return y(n), u
                    }
                    h(n, "invalid usage")
                }

                function rt(e, t, n) {
                    var o = [];
                    p(n), b(o, e, "state_address");
                    var i = g(t = S(o, t, "message_chunk")),
                        a = t.length;
                    o.push(i), 0 != (0 | r._crypto_sign_update(e, i, a, 0)) && h(o, "invalid usage"), y(o)
                }

                function rr(e, t, n) {
                    var o = [];
                    e = S(o, e, "signature");
                    var i, a = 0 | r._crypto_sign_bytes();
                    e.length !== a && v(o, "invalid signature length"), i = g(e), o.push(i);
                    var s = g(t = S(o, t, "message")),
                        d = t.length;
                    o.push(s), n = S(o, n, "publicKey");
                    var c, l = 0 | r._crypto_sign_publickeybytes();
                    n.length !== l && v(o, "invalid publicKey length"), c = g(n), o.push(c);
                    var u = 0 == (0 | r._crypto_sign_verify_detached(i, s, d, 0, c));
                    return y(o), u
                }

                function rn(e, t, n, o) {
                    var i = [];
                    p(o), b(i, e, "outLength"), ("number" != typeof e || (0 | e) !== e || e < 0) && v(i, "outLength must be an unsigned integer"), t = S(i, t, "key");
                    var a, s = 0 | r._crypto_stream_chacha20_keybytes();
                    t.length !== s && v(i, "invalid key length"), a = g(t), i.push(a), n = S(i, n, "nonce");
                    var d, c = 0 | r._crypto_stream_chacha20_noncebytes();
                    n.length !== c && v(i, "invalid nonce length"), d = g(n), i.push(d);
                    var u = new m(0 | e),
                        f = u.address;
                    i.push(f), r._crypto_stream_chacha20(f, e, 0, d, a);
                    var h = l(u, o);
                    return y(i), h
                }

                function ro(e, t, n, o) {
                    var i = [];
                    p(o);
                    var a = g(e = S(i, e, "input_message")),
                        s = e.length;
                    i.push(a), t = S(i, t, "nonce");
                    var d, c = 0 | r._crypto_stream_chacha20_ietf_noncebytes();
                    t.length !== c && v(i, "invalid nonce length"), d = g(t), i.push(d), n = S(i, n, "key");
                    var u, f = 0 | r._crypto_stream_chacha20_ietf_keybytes();
                    n.length !== f && v(i, "invalid key length"), u = g(n), i.push(u);
                    var b = new m(0 | s),
                        k = b.address;
                    if (i.push(k), 0 === r._crypto_stream_chacha20_ietf_xor(k, a, s, 0, d, u)) {
                        var P = l(b, o);
                        return y(i), P
                    }
                    h(i, "invalid usage")
                }

                function ri(e, t, n, o, i) {
                    var a = [];
                    p(i);
                    var s = g(e = S(a, e, "input_message")),
                        d = e.length;
                    a.push(s), t = S(a, t, "nonce");
                    var c, u = 0 | r._crypto_stream_chacha20_ietf_noncebytes();
                    t.length !== u && v(a, "invalid nonce length"), c = g(t), a.push(c), b(a, n, "nonce_increment"), ("number" != typeof n || (0 | n) !== n || n < 0) && v(a, "nonce_increment must be an unsigned integer"), o = S(a, o, "key");
                    var f, k = 0 | r._crypto_stream_chacha20_ietf_keybytes();
                    o.length !== k && v(a, "invalid key length"), f = g(o), a.push(f);
                    var P = new m(0 | d),
                        _ = P.address;
                    if (a.push(_), 0 === r._crypto_stream_chacha20_ietf_xor_ic(_, s, d, 0, c, n, f)) {
                        var B = l(P, i);
                        return y(a), B
                    }
                    h(a, "invalid usage")
                }

                function ra(e) {
                    var t = [];
                    p(e);
                    var n = new m(0 | r._crypto_stream_chacha20_keybytes()),
                        o = n.address;
                    t.push(o), r._crypto_stream_chacha20_keygen(o);
                    var i = l(n, e);
                    return y(t), i
                }

                function rs(e, t, n, o) {
                    var i = [];
                    p(o);
                    var a = g(e = S(i, e, "input_message")),
                        s = e.length;
                    i.push(a), t = S(i, t, "nonce");
                    var d, c = 0 | r._crypto_stream_chacha20_noncebytes();
                    t.length !== c && v(i, "invalid nonce length"), d = g(t), i.push(d), n = S(i, n, "key");
                    var u, f = 0 | r._crypto_stream_chacha20_keybytes();
                    n.length !== f && v(i, "invalid key length"), u = g(n), i.push(u);
                    var b = new m(0 | s),
                        k = b.address;
                    if (i.push(k), 0 === r._crypto_stream_chacha20_xor(k, a, s, 0, d, u)) {
                        var P = l(b, o);
                        return y(i), P
                    }
                    h(i, "invalid usage")
                }

                function rd(e, t, n, o, i) {
                    var a = [];
                    p(i);
                    var s = g(e = S(a, e, "input_message")),
                        d = e.length;
                    a.push(s), t = S(a, t, "nonce");
                    var c, u = 0 | r._crypto_stream_chacha20_noncebytes();
                    t.length !== u && v(a, "invalid nonce length"), c = g(t), a.push(c), b(a, n, "nonce_increment"), ("number" != typeof n || (0 | n) !== n || n < 0) && v(a, "nonce_increment must be an unsigned integer"), o = S(a, o, "key");
                    var f, k = 0 | r._crypto_stream_chacha20_keybytes();
                    o.length !== k && v(a, "invalid key length"), f = g(o), a.push(f);
                    var P = new m(0 | d),
                        _ = P.address;
                    if (a.push(_), 0 === r._crypto_stream_chacha20_xor_ic(_, s, d, 0, c, n, 0, f)) {
                        var B = l(P, i);
                        return y(a), B
                    }
                    h(a, "invalid usage")
                }

                function rc(e) {
                    var t = [];
                    p(e);
                    var n = new m(0 | r._crypto_stream_keybytes()),
                        o = n.address;
                    t.push(o), r._crypto_stream_keygen(o);
                    var i = l(n, e);
                    return y(t), i
                }

                function rl(e) {
                    var t = [];
                    p(e);
                    var n = new m(0 | r._crypto_stream_xchacha20_keybytes()),
                        o = n.address;
                    t.push(o), r._crypto_stream_xchacha20_keygen(o);
                    var i = l(n, e);
                    return y(t), i
                }

                function ru(e, t, n, o) {
                    var i = [];
                    p(o);
                    var a = g(e = S(i, e, "input_message")),
                        s = e.length;
                    i.push(a), t = S(i, t, "nonce");
                    var d, c = 0 | r._crypto_stream_xchacha20_noncebytes();
                    t.length !== c && v(i, "invalid nonce length"), d = g(t), i.push(d), n = S(i, n, "key");
                    var u, f = 0 | r._crypto_stream_xchacha20_keybytes();
                    n.length !== f && v(i, "invalid key length"), u = g(n), i.push(u);
                    var b = new m(0 | s),
                        k = b.address;
                    if (i.push(k), 0 === r._crypto_stream_xchacha20_xor(k, a, s, 0, d, u)) {
                        var P = l(b, o);
                        return y(i), P
                    }
                    h(i, "invalid usage")
                }

                function rp(e, t, n, o, i) {
                    var a = [];
                    p(i);
                    var s = g(e = S(a, e, "input_message")),
                        d = e.length;
                    a.push(s), t = S(a, t, "nonce");
                    var c, u = 0 | r._crypto_stream_xchacha20_noncebytes();
                    t.length !== u && v(a, "invalid nonce length"), c = g(t), a.push(c), b(a, n, "nonce_increment"), ("number" != typeof n || (0 | n) !== n || n < 0) && v(a, "nonce_increment must be an unsigned integer"), o = S(a, o, "key");
                    var f, k = 0 | r._crypto_stream_xchacha20_keybytes();
                    o.length !== k && v(a, "invalid key length"), f = g(o), a.push(f);
                    var P = new m(0 | d),
                        _ = P.address;
                    if (a.push(_), 0 === r._crypto_stream_xchacha20_xor_ic(_, s, d, 0, c, n, 0, f)) {
                        var B = l(P, i);
                        return y(a), B
                    }
                    h(a, "invalid usage")
                }

                function rm(e, t) {
                    var n = [];
                    p(t), b(n, e, "length"), ("number" != typeof e || (0 | e) !== e || e < 0) && v(n, "length must be an unsigned integer");
                    var o = new m(0 | e),
                        i = o.address;
                    n.push(i), r._randombytes_buf(i, e);
                    var a = l(o, t);
                    return y(n), a
                }

                function rg(e, t, n) {
                    var o = [];
                    p(n), b(o, e, "length"), ("number" != typeof e || (0 | e) !== e || e < 0) && v(o, "length must be an unsigned integer"), t = S(o, t, "seed");
                    var i, a = 0 | r._randombytes_seedbytes();
                    t.length !== a && v(o, "invalid seed length"), i = g(t), o.push(i);
                    var s = new m(0 | e),
                        d = s.address;
                    o.push(d), r._randombytes_buf_deterministic(d, e, i);
                    var c = l(s, n);
                    return y(o), c
                }

                function rf(e) {
                    p(e), r._randombytes_close()
                }

                function ry(e) {
                    p(e);
                    var t = r._randombytes_random() >>> 0;
                    return y([]), t
                }

                function rh(e, t) {
                    var n = [];
                    p(t);
                    for (var o = r._malloc(24), i = 0; i < 6; i++) r.setValue(o + 4 * i, r.Runtime.addFunction(e[["implementation_name", "random", "stir", "uniform", "buf", "close"][i]]), "i32");
                    0 != (0 | r._randombytes_set_implementation(o)) && h(n, "unsupported implementation"), y(n)
                }

                function rv(e) {
                    p(e), r._randombytes_stir()
                }

                function rb(e, t) {
                    var n = [];
                    p(t), b(n, e, "upper_bound"), ("number" != typeof e || (0 | e) !== e || e < 0) && v(n, "upper_bound must be an unsigned integer");
                    var o = r._randombytes_uniform(e) >>> 0;
                    return y(n), o
                }

                function rS() {
                    var e = r._sodium_version_string(),
                        t = r.UTF8ToString(e);
                    return y([]), t
                }
                return m.prototype.to_Uint8Array = function() {
                    var e = new Uint8Array(this.length);
                    return e.set(r.HEAPU8.subarray(this.address, this.address + this.length)), e
                }, e.add = function(e, t) {
                    if (!(e instanceof Uint8Array && t instanceof Uint8Array)) throw TypeError("Only Uint8Array instances can added");
                    var r = e.length,
                        n = 0,
                        o = 0;
                    if (t.length != e.length) throw TypeError("Arguments must have the same length");
                    for (o = 0; o < r; o++) n >>= 8, n += e[o] + t[o], e[o] = 255 & n
                }, e.base64_variants = s, e.compare = function(e, t) {
                    if (!(e instanceof Uint8Array && t instanceof Uint8Array)) throw TypeError("Only Uint8Array instances can be compared");
                    if (e.length !== t.length) throw TypeError("Only instances of identical length can be compared");
                    for (var r = 0, n = 1, o = e.length; o-- > 0;) r |= t[o] - e[o] >> 8 & n, n &= (t[o] ^ e[o]) - 1 >> 8;
                    return r + r + n - 1
                }, e.from_base64 = function(e, t) {
                    t = d(t);
                    var n, o = [],
                        i = new m(3 * (e = S(o, e, "input")).length / 4),
                        a = g(e),
                        s = f(4),
                        c = f(4);
                    return o.push(a), o.push(i.address), o.push(i.result_bin_len_p), o.push(i.b64_end_p), 0 !== r._sodium_base642bin(i.address, i.length, a, e.length, 0, s, c, t) && h(o, "invalid input"), r.getValue(c, "i32") - a !== e.length && h(o, "incomplete input"), i.length = r.getValue(s, "i32"), n = i.to_Uint8Array(), y(o), n
                }, e.from_hex = function(e) {
                    var t, n = [],
                        o = new m((e = S(n, e, "input")).length / 2),
                        i = g(e),
                        a = f(4);
                    return n.push(i), n.push(o.address), n.push(o.hex_end_p), 0 !== r._sodium_hex2bin(o.address, o.length, i, e.length, 0, 0, a) && h(n, "invalid input"), r.getValue(a, "i32") - i !== e.length && h(n, "incomplete input"), t = o.to_Uint8Array(), y(n), t
                }, e.from_string = o, e.increment = function(e) {
                    if (!(e instanceof Uint8Array)) throw TypeError("Only Uint8Array instances can be incremented");
                    for (var t = 256, r = 0, n = e.length; r < n; r++) t >>= 8, t += e[r], e[r] = 255 & t
                }, e.is_zero = function(e) {
                    if (!(e instanceof Uint8Array)) throw TypeError("Only Uint8Array instances can be checked");
                    for (var t = 0, r = 0, n = e.length; r < n; r++) t |= e[r];
                    return 0 === t
                }, e.libsodium = t, e.memcmp = function(e, t) {
                    if (!(e instanceof Uint8Array && t instanceof Uint8Array)) throw TypeError("Only Uint8Array instances can be compared");
                    if (e.length !== t.length) throw TypeError("Only instances of identical length can be compared");
                    for (var r = 0, n = 0, o = e.length; n < o; n++) r |= e[n] ^ t[n];
                    return 0 === r
                }, e.memzero = function(e) {
                    if (!(e instanceof Uint8Array)) throw TypeError("Only Uint8Array instances can be wiped");
                    for (var t = 0, r = e.length; t < r; t++) e[t] = 0
                }, e.output_formats = function() {
                    return ["uint8array", "text", "hex", "base64"]
                }, e.pad = function(e, t) {
                    if (!(e instanceof Uint8Array)) throw TypeError("buffer must be a Uint8Array");
                    if ((t |= 0) <= 0) throw Error("block size must be > 0");
                    var n, o = [],
                        i = f(4),
                        a = 1,
                        s = 0,
                        d = 0 | e.length,
                        c = new m(d + t);
                    o.push(i), o.push(c.address);
                    for (var l = c.address, u = c.address + d + t; l < u; l++) r.HEAPU8[l] = e[s], s += a = 1 & ~((65535 & ((d -= a) >>> 48 | d >>> 32 | d >>> 16 | d)) - 1 >> 16);
                    return 0 !== r._sodium_pad(i, c.address, e.length, t, c.length) && h(o, "internal error"), c.length = r.getValue(i, "i32"), n = c.to_Uint8Array(), y(o), n
                }, e.unpad = function(e, t) {
                    if (!(e instanceof Uint8Array)) throw TypeError("buffer must be a Uint8Array");
                    if ((t |= 0) <= 0) throw Error("block size must be > 0");
                    var n = [],
                        o = g(e),
                        i = f(4);
                    return n.push(o), n.push(i), 0 !== r._sodium_unpad(i, o, e.length, t) && h(n, "unsupported/invalid padding"), e = (e = new Uint8Array(e)).subarray(0, r.getValue(i, "i32")), y(n), e
                }, e.ready = n, e.symbols = function() {
                    return Object.keys(e).sort()
                }, e.to_base64 = c, e.to_hex = a, e.to_string = i, e
            }) ? n.apply(t, o) : n) && (e.exports = i), s && a.sodium.ready.then(function() {
                s(a.sodium)
            })
        },
        48772: function(e, t, r) {
            "use strict";
            var n, o, i, a = r(48764).Buffer;

            function s(e, t) {
                return function() {
                    return e.apply(t, arguments)
                }
            }
            let {
                toString: d
            } = Object.prototype, {
                getPrototypeOf: c
            } = Object, l = (n = Object.create(null), e => {
                let t = d.call(e);
                return n[t] || (n[t] = t.slice(8, -1).toLowerCase())
            }), u = e => (e = e.toLowerCase(), t => l(t) === e), p = e => t => typeof t === e, {
                isArray: m
            } = Array, g = p("undefined"), f = u("ArrayBuffer"), y = p("string"), h = p("function"), v = p("number"), b = e => null !== e && "object" == typeof e, S = e => {
                if ("object" !== l(e)) return !1;
                let t = c(e);
                return (null === t || t === Object.prototype || null === Object.getPrototypeOf(t)) && !(Symbol.toStringTag in e) && !(Symbol.iterator in e)
            }, k = u("Date"), P = u("File"), _ = u("Blob"), B = u("FileList"), O = u("URLSearchParams");

            function R(e, t, {
                allOwnKeys: r = !1
            } = {}) {
                let n, o;
                if (null != e) {
                    if ("object" != typeof e && (e = [e]), m(e))
                        for (n = 0, o = e.length; n < o; n++) t.call(null, e[n], n, e);
                    else {
                        let o;
                        let i = r ? Object.getOwnPropertyNames(e) : Object.keys(e),
                            a = i.length;
                        for (n = 0; n < a; n++) o = i[n], t.call(null, e[o], o, e)
                    }
                }
            }

            function A(e, t) {
                let r;
                t = t.toLowerCase();
                let n = Object.keys(e),
                    o = n.length;
                for (; o-- > 0;)
                    if (t === (r = n[o]).toLowerCase()) return r;
                return null
            }
            let I = "undefined" != typeof globalThis ? globalThis : "undefined" != typeof self ? self : "undefined" != typeof window ? window : r.g,
                w = e => !g(e) && e !== I,
                T = (o = "undefined" != typeof Uint8Array && c(Uint8Array), e => o && e instanceof o),
                N = u("HTMLFormElement"),
                C = (({
                    hasOwnProperty: e
                }) => (t, r) => e.call(t, r))(Object.prototype),
                E = u("RegExp"),
                x = (e, t) => {
                    let r = Object.getOwnPropertyDescriptors(e),
                        n = {};
                    R(r, (r, o) => {
                        let i;
                        !1 !== (i = t(r, o, e)) && (n[o] = i || r)
                    }), Object.defineProperties(e, n)
                },
                U = "abcdefghijklmnopqrstuvwxyz",
                D = "0123456789",
                M = {
                    DIGIT: D,
                    ALPHA: U,
                    ALPHA_DIGIT: U + U.toUpperCase() + D
                },
                J = u("AsyncFunction");
            var H = {
                isArray: m,
                isArrayBuffer: f,
                isBuffer: function(e) {
                    return null !== e && !g(e) && null !== e.constructor && !g(e.constructor) && h(e.constructor.isBuffer) && e.constructor.isBuffer(e)
                },
                isFormData: e => {
                    let t;
                    return e && ("function" == typeof FormData && e instanceof FormData || h(e.append) && ("formdata" === (t = l(e)) || "object" === t && h(e.toString) && "[object FormData]" === e.toString()))
                },
                isArrayBufferView: function(e) {
                    return "undefined" != typeof ArrayBuffer && ArrayBuffer.isView ? ArrayBuffer.isView(e) : e && e.buffer && f(e.buffer)
                },
                isString: y,
                isNumber: v,
                isBoolean: e => !0 === e || !1 === e,
                isObject: b,
                isPlainObject: S,
                isUndefined: g,
                isDate: k,
                isFile: P,
                isBlob: _,
                isRegExp: E,
                isFunction: h,
                isStream: e => b(e) && h(e.pipe),
                isURLSearchParams: O,
                isTypedArray: T,
                isFileList: B,
                forEach: R,
                merge: function e() {
                    let {
                        caseless: t
                    } = w(this) && this || {}, r = {}, n = (n, o) => {
                        let i = t && A(r, o) || o;
                        S(r[i]) && S(n) ? r[i] = e(r[i], n) : S(n) ? r[i] = e({}, n) : m(n) ? r[i] = n.slice() : r[i] = n
                    };
                    for (let e = 0, t = arguments.length; e < t; e++) arguments[e] && R(arguments[e], n);
                    return r
                },
                extend: (e, t, r, {
                    allOwnKeys: n
                } = {}) => (R(t, (t, n) => {
                    r && h(t) ? e[n] = s(t, r) : e[n] = t
                }, {
                    allOwnKeys: n
                }), e),
                trim: e => e.trim ? e.trim() : e.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, ""),
                stripBOM: e => (65279 === e.charCodeAt(0) && (e = e.slice(1)), e),
                inherits: (e, t, r, n) => {
                    e.prototype = Object.create(t.prototype, n), e.prototype.constructor = e, Object.defineProperty(e, "super", {
                        value: t.prototype
                    }), r && Object.assign(e.prototype, r)
                },
                toFlatObject: (e, t, r, n) => {
                    let o, i, a;
                    let s = {};
                    if (t = t || {}, null == e) return t;
                    do {
                        for (i = (o = Object.getOwnPropertyNames(e)).length; i-- > 0;) a = o[i], (!n || n(a, e, t)) && !s[a] && (t[a] = e[a], s[a] = !0);
                        e = !1 !== r && c(e)
                    } while (e && (!r || r(e, t)) && e !== Object.prototype);
                    return t
                },
                kindOf: l,
                kindOfTest: u,
                endsWith: (e, t, r) => {
                    e = String(e), (void 0 === r || r > e.length) && (r = e.length), r -= t.length;
                    let n = e.indexOf(t, r);
                    return -1 !== n && n === r
                },
                toArray: e => {
                    if (!e) return null;
                    if (m(e)) return e;
                    let t = e.length;
                    if (!v(t)) return null;
                    let r = Array(t);
                    for (; t-- > 0;) r[t] = e[t];
                    return r
                },
                forEachEntry: (e, t) => {
                    let r;
                    let n = (e && e[Symbol.iterator]).call(e);
                    for (;
                        (r = n.next()) && !r.done;) {
                        let n = r.value;
                        t.call(e, n[0], n[1])
                    }
                },
                matchAll: (e, t) => {
                    let r;
                    let n = [];
                    for (; null !== (r = e.exec(t));) n.push(r);
                    return n
                },
                isHTMLForm: N,
                hasOwnProperty: C,
                hasOwnProp: C,
                reduceDescriptors: x,
                freezeMethods: e => {
                    x(e, (t, r) => {
                        if (h(e) && -1 !== ["arguments", "caller", "callee"].indexOf(r)) return !1;
                        if (h(e[r])) {
                            if (t.enumerable = !1, "writable" in t) {
                                t.writable = !1;
                                return
                            }
                            t.set || (t.set = () => {
                                throw Error("Can not rewrite read-only method '" + r + "'")
                            })
                        }
                    })
                },
                toObjectSet: (e, t) => {
                    let r = {};
                    return (e => {
                        e.forEach(e => {
                            r[e] = !0
                        })
                    })(m(e) ? e : String(e).split(t)), r
                },
                toCamelCase: e => e.toLowerCase().replace(/[-_\s]([a-z\d])(\w*)/g, function(e, t, r) {
                    return t.toUpperCase() + r
                }),
                noop: () => {},
                toFiniteNumber: (e, t) => Number.isFinite(e = +e) ? e : t,
                findKey: A,
                global: I,
                isContextDefined: w,
                ALPHABET: M,
                generateString: (e = 16, t = M.ALPHA_DIGIT) => {
                    let r = "",
                        {
                            length: n
                        } = t;
                    for (; e--;) r += t[Math.random() * n | 0];
                    return r
                },
                isSpecCompliantForm: function(e) {
                    return !!(e && h(e.append) && "FormData" === e[Symbol.toStringTag] && e[Symbol.iterator])
                },
                toJSONObject: e => {
                    let t = Array(10),
                        r = (e, n) => {
                            if (b(e)) {
                                if (t.indexOf(e) >= 0) return;
                                if (!("toJSON" in e)) {
                                    t[n] = e;
                                    let o = m(e) ? [] : {};
                                    return R(e, (e, t) => {
                                        let i = r(e, n + 1);
                                        g(i) || (o[t] = i)
                                    }), t[n] = void 0, o
                                }
                            }
                            return e
                        };
                    return r(e, 0)
                },
                isAsyncFn: J,
                isThenable: e => e && (b(e) || h(e)) && h(e.then) && h(e.catch)
            };

            function j(e, t, r, n, o) {
                Error.call(this), Error.captureStackTrace ? Error.captureStackTrace(this, this.constructor) : this.stack = Error().stack, this.message = e, this.name = "AxiosError", t && (this.code = t), r && (this.config = r), n && (this.request = n), o && (this.response = o)
            }
            H.inherits(j, Error, {
                toJSON: function() {
                    return {
                        message: this.message,
                        name: this.name,
                        description: this.description,
                        number: this.number,
                        fileName: this.fileName,
                        lineNumber: this.lineNumber,
                        columnNumber: this.columnNumber,
                        stack: this.stack,
                        config: H.toJSONObject(this.config),
                        code: this.code,
                        status: this.response && this.response.status ? this.response.status : null
                    }
                }
            });
            let V = j.prototype,
                q = {};

            function W(e) {
                return H.isPlainObject(e) || H.isArray(e)
            }

            function F(e) {
                return H.endsWith(e, "[]") ? e.slice(0, -2) : e
            }

            function Q(e, t, r) {
                return e ? e.concat(t).map(function(e, t) {
                    return e = F(e), !r && t ? "[" + e + "]" : e
                }).join(r ? "." : "") : t
            }["ERR_BAD_OPTION_VALUE", "ERR_BAD_OPTION", "ECONNABORTED", "ETIMEDOUT", "ERR_NETWORK", "ERR_FR_TOO_MANY_REDIRECTS", "ERR_DEPRECATED", "ERR_BAD_RESPONSE", "ERR_BAD_REQUEST", "ERR_CANCELED", "ERR_NOT_SUPPORT", "ERR_INVALID_URL"].forEach(e => {
                q[e] = {
                    value: e
                }
            }), Object.defineProperties(j, q), Object.defineProperty(V, "isAxiosError", {
                value: !0
            }), j.from = (e, t, r, n, o, i) => {
                let a = Object.create(V);
                return H.toFlatObject(e, a, function(e) {
                    return e !== Error.prototype
                }, e => "isAxiosError" !== e), j.call(a, e.message, t, r, n, o), a.cause = e, a.name = e.name, i && Object.assign(a, i), a
            };
            let G = H.toFlatObject(H, {}, null, function(e) {
                return /^is[A-Z]/.test(e)
            });

            function L(e, t, r) {
                if (!H.isObject(e)) throw TypeError("target must be an object");
                t = t || new FormData;
                let n = (r = H.toFlatObject(r, {
                        metaTokens: !0,
                        dots: !1,
                        indexes: !1
                    }, !1, function(e, t) {
                        return !H.isUndefined(t[e])
                    })).metaTokens,
                    o = r.visitor || l,
                    i = r.dots,
                    s = r.indexes,
                    d = (r.Blob || "undefined" != typeof Blob && Blob) && H.isSpecCompliantForm(t);
                if (!H.isFunction(o)) throw TypeError("visitor must be a function");

                function c(e) {
                    if (null === e) return "";
                    if (H.isDate(e)) return e.toISOString();
                    if (!d && H.isBlob(e)) throw new j("Blob is not supported. Use a Buffer instead.");
                    return H.isArrayBuffer(e) || H.isTypedArray(e) ? d && "function" == typeof Blob ? new Blob([e]) : a.from(e) : e
                }

                function l(e, r, o) {
                    let a = e;
                    if (e && !o && "object" == typeof e) {
                        if (H.endsWith(r, "{}")) r = n ? r : r.slice(0, -2), e = JSON.stringify(e);
                        else {
                            var d;
                            if (H.isArray(e) && (d = e, H.isArray(d) && !d.some(W)) || (H.isFileList(e) || H.endsWith(r, "[]")) && (a = H.toArray(e))) return r = F(r), a.forEach(function(e, n) {
                                H.isUndefined(e) || null === e || t.append(!0 === s ? Q([r], n, i) : null === s ? r : r + "[]", c(e))
                            }), !1
                        }
                    }
                    return !!W(e) || (t.append(Q(o, r, i), c(e)), !1)
                }
                let u = [],
                    p = Object.assign(G, {
                        defaultVisitor: l,
                        convertValue: c,
                        isVisitable: W
                    });
                if (!H.isObject(e)) throw TypeError("data must be an object");
                return ! function e(r, n) {
                    if (!H.isUndefined(r)) {
                        if (-1 !== u.indexOf(r)) throw Error("Circular reference detected in " + n.join("."));
                        u.push(r), H.forEach(r, function(r, i) {
                            !0 === (!(H.isUndefined(r) || null === r) && o.call(t, r, H.isString(i) ? i.trim() : i, n, p)) && e(r, n ? n.concat(i) : [i])
                        }), u.pop()
                    }
                }(e), t
            }

            function K(e) {
                let t = {
                    "!": "%21",
                    "'": "%27",
                    "(": "%28",
                    ")": "%29",
                    "~": "%7E",
                    "%20": "+",
                    "%00": "\x00"
                };
                return encodeURIComponent(e).replace(/[!'()~]|%20|%00/g, function(e) {
                    return t[e]
                })
            }

            function Y(e, t) {
                this._pairs = [], e && L(e, this, t)
            }
            let z = Y.prototype;

            function $(e) {
                return encodeURIComponent(e).replace(/%3A/gi, ":").replace(/%24/g, "$").replace(/%2C/gi, ",").replace(/%20/g, "+").replace(/%5B/gi, "[").replace(/%5D/gi, "]")
            }

            function Z(e, t, r) {
                let n;
                if (!t) return e;
                let o = r && r.encode || $,
                    i = r && r.serialize;
                if (n = i ? i(t, r) : H.isURLSearchParams(t) ? t.toString() : new Y(t, r).toString(o)) {
                    let t = e.indexOf("#"); - 1 !== t && (e = e.slice(0, t)), e += (-1 === e.indexOf("?") ? "?" : "&") + n
                }
                return e
            }
            z.append = function(e, t) {
                this._pairs.push([e, t])
            }, z.toString = function(e) {
                let t = e ? function(t) {
                    return e.call(this, t, K)
                } : K;
                return this._pairs.map(function(e) {
                    return t(e[0]) + "=" + t(e[1])
                }, "").join("&")
            };
            class X {
                constructor() {
                    this.handlers = []
                }
                use(e, t, r) {
                    return this.handlers.push({
                        fulfilled: e,
                        rejected: t,
                        synchronous: !!r && r.synchronous,
                        runWhen: r ? r.runWhen : null
                    }), this.handlers.length - 1
                }
                eject(e) {
                    this.handlers[e] && (this.handlers[e] = null)
                }
                clear() {
                    this.handlers && (this.handlers = [])
                }
                forEach(e) {
                    H.forEach(this.handlers, function(t) {
                        null !== t && e(t)
                    })
                }
            }
            var ee = {
                    silentJSONParsing: !0,
                    forcedJSONParsing: !0,
                    clarifyTimeoutError: !1
                },
                et = "undefined" != typeof URLSearchParams ? URLSearchParams : Y,
                er = "undefined" != typeof FormData ? FormData : null,
                en = "undefined" != typeof Blob ? Blob : null;
            let eo = "undefined" != typeof window && "undefined" != typeof document,
                ei = (i = "undefined" != typeof navigator && navigator.product, eo && 0 > ["ReactNative", "NativeScript", "NS"].indexOf(i));
            var ea = { ...Object.freeze({
                    __proto__: null,
                    hasBrowserEnv: eo,
                    hasStandardBrowserWebWorkerEnv: "undefined" != typeof WorkerGlobalScope && self instanceof WorkerGlobalScope && "function" == typeof self.importScripts,
                    hasStandardBrowserEnv: ei
                }),
                isBrowser: !0,
                classes: {
                    URLSearchParams: et,
                    FormData: er,
                    Blob: en
                },
                protocols: ["http", "https", "file", "blob", "url", "data"]
            };

            function es(e) {
                if (H.isFormData(e) && H.isFunction(e.entries)) {
                    let t = {};
                    return H.forEachEntry(e, (e, r) => {
                        ! function e(t, r, n, o) {
                            let i = t[o++];
                            if ("__proto__" === i) return !0;
                            let a = Number.isFinite(+i),
                                s = o >= t.length;
                            return (i = !i && H.isArray(n) ? n.length : i, s) ? H.hasOwnProp(n, i) ? n[i] = [n[i], r] : n[i] = r : (n[i] && H.isObject(n[i]) || (n[i] = []), e(t, r, n[i], o) && H.isArray(n[i]) && (n[i] = function(e) {
                                let t, r;
                                let n = {},
                                    o = Object.keys(e),
                                    i = o.length;
                                for (t = 0; t < i; t++) n[r = o[t]] = e[r];
                                return n
                            }(n[i]))), !a
                        }(H.matchAll(/\w+|\[(\w*)]/g, e).map(e => "[]" === e[0] ? "" : e[1] || e[0]), r, t, 0)
                    }), t
                }
                return null
            }
            let ed = {
                transitional: ee,
                adapter: ["xhr", "http"],
                transformRequest: [function(e, t) {
                    let r;
                    let n = t.getContentType() || "",
                        o = n.indexOf("application/json") > -1,
                        i = H.isObject(e);
                    if (i && H.isHTMLForm(e) && (e = new FormData(e)), H.isFormData(e)) return o && o ? JSON.stringify(es(e)) : e;
                    if (H.isArrayBuffer(e) || H.isBuffer(e) || H.isStream(e) || H.isFile(e) || H.isBlob(e)) return e;
                    if (H.isArrayBufferView(e)) return e.buffer;
                    if (H.isURLSearchParams(e)) return t.setContentType("application/x-www-form-urlencoded;charset=utf-8", !1), e.toString();
                    if (i) {
                        if (n.indexOf("application/x-www-form-urlencoded") > -1) {
                            var a, s;
                            return (a = e, s = this.formSerializer, L(a, new ea.classes.URLSearchParams, Object.assign({
                                visitor: function(e, t, r, n) {
                                    return ea.isNode && H.isBuffer(e) ? (this.append(t, e.toString("base64")), !1) : n.defaultVisitor.apply(this, arguments)
                                }
                            }, s))).toString()
                        }
                        if ((r = H.isFileList(e)) || n.indexOf("multipart/form-data") > -1) {
                            let t = this.env && this.env.FormData;
                            return L(r ? {
                                "files[]": e
                            } : e, t && new t, this.formSerializer)
                        }
                    }
                    return i || o ? (t.setContentType("application/json", !1), function(e, t, r) {
                        if (H.isString(e)) try {
                            return (0, JSON.parse)(e), H.trim(e)
                        } catch (e) {
                            if ("SyntaxError" !== e.name) throw e
                        }
                        return (0, JSON.stringify)(e)
                    }(e)) : e
                }],
                transformResponse: [function(e) {
                    let t = this.transitional || ed.transitional,
                        r = t && t.forcedJSONParsing,
                        n = "json" === this.responseType;
                    if (e && H.isString(e) && (r && !this.responseType || n)) {
                        let r = t && t.silentJSONParsing;
                        try {
                            return JSON.parse(e)
                        } catch (e) {
                            if (!r && n) {
                                if ("SyntaxError" === e.name) throw j.from(e, j.ERR_BAD_RESPONSE, this, null, this.response);
                                throw e
                            }
                        }
                    }
                    return e
                }],
                timeout: 0,
                xsrfCookieName: "XSRF-TOKEN",
                xsrfHeaderName: "X-XSRF-TOKEN",
                maxContentLength: -1,
                maxBodyLength: -1,
                env: {
                    FormData: ea.classes.FormData,
                    Blob: ea.classes.Blob
                },
                validateStatus: function(e) {
                    return e >= 200 && e < 300
                },
                headers: {
                    common: {
                        Accept: "application/json, text/plain, */*",
                        "Content-Type": void 0
                    }
                }
            };
            H.forEach(["delete", "get", "head", "post", "put", "patch"], e => {
                ed.headers[e] = {}
            });
            let ec = H.toObjectSet(["age", "authorization", "content-length", "content-type", "etag", "expires", "from", "host", "if-modified-since", "if-unmodified-since", "last-modified", "location", "max-forwards", "proxy-authorization", "referer", "retry-after", "user-agent"]);
            var el = e => {
                let t, r, n;
                let o = {};
                return e && e.split("\n").forEach(function(e) {
                    n = e.indexOf(":"), t = e.substring(0, n).trim().toLowerCase(), r = e.substring(n + 1).trim(), !t || o[t] && ec[t] || ("set-cookie" === t ? o[t] ? o[t].push(r) : o[t] = [r] : o[t] = o[t] ? o[t] + ", " + r : r)
                }), o
            };
            let eu = Symbol("internals");

            function ep(e) {
                return e && String(e).trim().toLowerCase()
            }

            function em(e) {
                return !1 === e || null == e ? e : H.isArray(e) ? e.map(em) : String(e)
            }
            let eg = e => /^[-_a-zA-Z0-9^`|~,!#$%&'*+.]+$/.test(e.trim());

            function ef(e, t, r, n, o) {
                if (H.isFunction(n)) return n.call(this, t, r);
                if (o && (t = r), H.isString(t)) {
                    if (H.isString(n)) return -1 !== t.indexOf(n);
                    if (H.isRegExp(n)) return n.test(t)
                }
            }
            class ey {
                constructor(e) {
                    e && this.set(e)
                }
                set(e, t, r) {
                    let n = this;

                    function o(e, t, r) {
                        let o = ep(t);
                        if (!o) throw Error("header name must be a non-empty string");
                        let i = H.findKey(n, o);
                        i && void 0 !== n[i] && !0 !== r && (void 0 !== r || !1 === n[i]) || (n[i || t] = em(e))
                    }
                    let i = (e, t) => H.forEach(e, (e, r) => o(e, r, t));
                    return H.isPlainObject(e) || e instanceof this.constructor ? i(e, t) : H.isString(e) && (e = e.trim()) && !eg(e) ? i(el(e), t) : null != e && o(t, e, r), this
                }
                get(e, t) {
                    if (e = ep(e)) {
                        let r = H.findKey(this, e);
                        if (r) {
                            let e = this[r];
                            if (!t) return e;
                            if (!0 === t) return function(e) {
                                let t;
                                let r = Object.create(null),
                                    n = /([^\s,;=]+)\s*(?:=\s*([^,;]+))?/g;
                                for (; t = n.exec(e);) r[t[1]] = t[2];
                                return r
                            }(e);
                            if (H.isFunction(t)) return t.call(this, e, r);
                            if (H.isRegExp(t)) return t.exec(e);
                            throw TypeError("parser must be boolean|regexp|function")
                        }
                    }
                }
                has(e, t) {
                    if (e = ep(e)) {
                        let r = H.findKey(this, e);
                        return !!(r && void 0 !== this[r] && (!t || ef(this, this[r], r, t)))
                    }
                    return !1
                }
                delete(e, t) {
                    let r = this,
                        n = !1;

                    function o(e) {
                        if (e = ep(e)) {
                            let o = H.findKey(r, e);
                            o && (!t || ef(r, r[o], o, t)) && (delete r[o], n = !0)
                        }
                    }
                    return H.isArray(e) ? e.forEach(o) : o(e), n
                }
                clear(e) {
                    let t = Object.keys(this),
                        r = t.length,
                        n = !1;
                    for (; r--;) {
                        let o = t[r];
                        (!e || ef(this, this[o], o, e, !0)) && (delete this[o], n = !0)
                    }
                    return n
                }
                normalize(e) {
                    let t = this,
                        r = {};
                    return H.forEach(this, (n, o) => {
                        let i = H.findKey(r, o);
                        if (i) {
                            t[i] = em(n), delete t[o];
                            return
                        }
                        let a = e ? o.trim().toLowerCase().replace(/([a-z\d])(\w*)/g, (e, t, r) => t.toUpperCase() + r) : String(o).trim();
                        a !== o && delete t[o], t[a] = em(n), r[a] = !0
                    }), this
                }
                concat(...e) {
                    return this.constructor.concat(this, ...e)
                }
                toJSON(e) {
                    let t = Object.create(null);
                    return H.forEach(this, (r, n) => {
                        null != r && !1 !== r && (t[n] = e && H.isArray(r) ? r.join(", ") : r)
                    }), t
                }[Symbol.iterator]() {
                    return Object.entries(this.toJSON())[Symbol.iterator]()
                }
                toString() {
                    return Object.entries(this.toJSON()).map(([e, t]) => e + ": " + t).join("\n")
                }
                get[Symbol.toStringTag]() {
                    return "AxiosHeaders"
                }
                static from(e) {
                    return e instanceof this ? e : new this(e)
                }
                static concat(e, ...t) {
                    let r = new this(e);
                    return t.forEach(e => r.set(e)), r
                }
                static accessor(e) {
                    let t = (this[eu] = this[eu] = {
                            accessors: {}
                        }).accessors,
                        r = this.prototype;

                    function n(e) {
                        let n = ep(e);
                        t[n] || (! function(e, t) {
                            let r = H.toCamelCase(" " + t);
                            ["get", "set", "has"].forEach(n => {
                                Object.defineProperty(e, n + r, {
                                    value: function(e, r, o) {
                                        return this[n].call(this, t, e, r, o)
                                    },
                                    configurable: !0
                                })
                            })
                        }(r, e), t[n] = !0)
                    }
                    return H.isArray(e) ? e.forEach(n) : n(e), this
                }
            }

            function eh(e, t) {
                let r = this || ed,
                    n = t || r,
                    o = ey.from(n.headers),
                    i = n.data;
                return H.forEach(e, function(e) {
                    i = e.call(r, i, o.normalize(), t ? t.status : void 0)
                }), o.normalize(), i
            }

            function ev(e) {
                return !!(e && e.__CANCEL__)
            }

            function eb(e, t, r) {
                j.call(this, null == e ? "canceled" : e, j.ERR_CANCELED, t, r), this.name = "CanceledError"
            }
            ey.accessor(["Content-Type", "Content-Length", "Accept", "Accept-Encoding", "User-Agent", "Authorization"]), H.reduceDescriptors(ey.prototype, ({
                value: e
            }, t) => {
                let r = t[0].toUpperCase() + t.slice(1);
                return {
                    get: () => e,
                    set(e) {
                        this[r] = e
                    }
                }
            }), H.freezeMethods(ey), H.inherits(eb, j, {
                __CANCEL__: !0
            });
            var eS = ea.hasStandardBrowserEnv ? {
                write(e, t, r, n, o, i) {
                    let a = [e + "=" + encodeURIComponent(t)];
                    H.isNumber(r) && a.push("expires=" + new Date(r).toGMTString()), H.isString(n) && a.push("path=" + n), H.isString(o) && a.push("domain=" + o), !0 === i && a.push("secure"), document.cookie = a.join("; ")
                },
                read(e) {
                    let t = document.cookie.match(RegExp("(^|;\\s*)(" + e + ")=([^;]*)"));
                    return t ? decodeURIComponent(t[3]) : null
                },
                remove(e) {
                    this.write(e, "", Date.now() - 864e5)
                }
            } : {
                write() {},
                read: () => null,
                remove() {}
            };

            function ek(e, t) {
                return e && !/^([a-z][a-z\d+\-.]*:)?\/\//i.test(t) ? t ? e.replace(/\/?\/$/, "") + "/" + t.replace(/^\/+/, "") : e : t
            }
            var eP = ea.hasStandardBrowserEnv ? function() {
                let e;
                let t = /(msie|trident)/i.test(navigator.userAgent),
                    r = document.createElement("a");

                function n(e) {
                    let n = e;
                    return t && (r.setAttribute("href", n), n = r.href), r.setAttribute("href", n), {
                        href: r.href,
                        protocol: r.protocol ? r.protocol.replace(/:$/, "") : "",
                        host: r.host,
                        search: r.search ? r.search.replace(/^\?/, "") : "",
                        hash: r.hash ? r.hash.replace(/^#/, "") : "",
                        hostname: r.hostname,
                        port: r.port,
                        pathname: "/" === r.pathname.charAt(0) ? r.pathname : "/" + r.pathname
                    }
                }
                return e = n(window.location.href),
                    function(t) {
                        let r = H.isString(t) ? n(t) : t;
                        return r.protocol === e.protocol && r.host === e.host
                    }
            }() : function() {
                return !0
            };

            function e_(e, t) {
                let r = 0,
                    n = function(e, t) {
                        let r;
                        let n = Array(e = e || 10),
                            o = Array(e),
                            i = 0,
                            a = 0;
                        return t = void 0 !== t ? t : 1e3,
                            function(s) {
                                let d = Date.now(),
                                    c = o[a];
                                r || (r = d), n[i] = s, o[i] = d;
                                let l = a,
                                    u = 0;
                                for (; l !== i;) u += n[l++], l %= e;
                                if ((i = (i + 1) % e) === a && (a = (a + 1) % e), d - r < t) return;
                                let p = c && d - c;
                                return p ? Math.round(1e3 * u / p) : void 0
                            }
                    }(50, 250);
                return o => {
                    let i = o.loaded,
                        a = o.lengthComputable ? o.total : void 0,
                        s = i - r,
                        d = n(s);
                    r = i;
                    let c = {
                        loaded: i,
                        total: a,
                        progress: a ? i / a : void 0,
                        bytes: s,
                        rate: d || void 0,
                        estimated: d && a && i <= a ? (a - i) / d : void 0,
                        event: o
                    };
                    c[t ? "download" : "upload"] = !0, e(c)
                }
            }
            let eB = {
                http: null,
                xhr: "undefined" != typeof XMLHttpRequest && function(e) {
                    return new Promise(function(t, r) {
                        let n, o, i = e.data,
                            a = ey.from(e.headers).normalize(),
                            {
                                responseType: s,
                                withXSRFToken: d
                            } = e;

                        function c() {
                            e.cancelToken && e.cancelToken.unsubscribe(n), e.signal && e.signal.removeEventListener("abort", n)
                        }
                        if (H.isFormData(i)) {
                            if (ea.hasStandardBrowserEnv || ea.hasStandardBrowserWebWorkerEnv) a.setContentType(!1);
                            else if (!1 !== (o = a.getContentType())) {
                                let [e, ...t] = o ? o.split(";").map(e => e.trim()).filter(Boolean) : [];
                                a.setContentType([e || "multipart/form-data", ...t].join("; "))
                            }
                        }
                        let l = new XMLHttpRequest;
                        if (e.auth) {
                            let t = e.auth.username || "",
                                r = e.auth.password ? unescape(encodeURIComponent(e.auth.password)) : "";
                            a.set("Authorization", "Basic " + btoa(t + ":" + r))
                        }
                        let u = ek(e.baseURL, e.url);

                        function p() {
                            if (!l) return;
                            let n = ey.from("getAllResponseHeaders" in l && l.getAllResponseHeaders());
                            ! function(e, t, r) {
                                let n = r.config.validateStatus;
                                !r.status || !n || n(r.status) ? e(r) : t(new j("Request failed with status code " + r.status, [j.ERR_BAD_REQUEST, j.ERR_BAD_RESPONSE][Math.floor(r.status / 100) - 4], r.config, r.request, r))
                            }(function(e) {
                                t(e), c()
                            }, function(e) {
                                r(e), c()
                            }, {
                                data: s && "text" !== s && "json" !== s ? l.response : l.responseText,
                                status: l.status,
                                statusText: l.statusText,
                                headers: n,
                                config: e,
                                request: l
                            }), l = null
                        }
                        if (l.open(e.method.toUpperCase(), Z(u, e.params, e.paramsSerializer), !0), l.timeout = e.timeout, "onloadend" in l ? l.onloadend = p : l.onreadystatechange = function() {
                                l && 4 === l.readyState && (0 !== l.status || l.responseURL && 0 === l.responseURL.indexOf("file:")) && setTimeout(p)
                            }, l.onabort = function() {
                                l && (r(new j("Request aborted", j.ECONNABORTED, e, l)), l = null)
                            }, l.onerror = function() {
                                r(new j("Network Error", j.ERR_NETWORK, e, l)), l = null
                            }, l.ontimeout = function() {
                                let t = e.timeout ? "timeout of " + e.timeout + "ms exceeded" : "timeout exceeded",
                                    n = e.transitional || ee;
                                e.timeoutErrorMessage && (t = e.timeoutErrorMessage), r(new j(t, n.clarifyTimeoutError ? j.ETIMEDOUT : j.ECONNABORTED, e, l)), l = null
                            }, ea.hasStandardBrowserEnv && (d && H.isFunction(d) && (d = d(e)), d || !1 !== d && eP(u))) {
                            let t = e.xsrfHeaderName && e.xsrfCookieName && eS.read(e.xsrfCookieName);
                            t && a.set(e.xsrfHeaderName, t)
                        }
                        void 0 === i && a.setContentType(null), "setRequestHeader" in l && H.forEach(a.toJSON(), function(e, t) {
                            l.setRequestHeader(t, e)
                        }), H.isUndefined(e.withCredentials) || (l.withCredentials = !!e.withCredentials), s && "json" !== s && (l.responseType = e.responseType), "function" == typeof e.onDownloadProgress && l.addEventListener("progress", e_(e.onDownloadProgress, !0)), "function" == typeof e.onUploadProgress && l.upload && l.upload.addEventListener("progress", e_(e.onUploadProgress)), (e.cancelToken || e.signal) && (n = t => {
                            l && (r(!t || t.type ? new eb(null, e, l) : t), l.abort(), l = null)
                        }, e.cancelToken && e.cancelToken.subscribe(n), e.signal && (e.signal.aborted ? n() : e.signal.addEventListener("abort", n)));
                        let m = function(e) {
                            let t = /^([-+\w]{1,25})(:?\/\/|:)/.exec(e);
                            return t && t[1] || ""
                        }(u);
                        if (m && -1 === ea.protocols.indexOf(m)) {
                            r(new j("Unsupported protocol " + m + ":", j.ERR_BAD_REQUEST, e));
                            return
                        }
                        l.send(i || null)
                    })
                }
            };
            H.forEach(eB, (e, t) => {
                if (e) {
                    try {
                        Object.defineProperty(e, "name", {
                            value: t
                        })
                    } catch (e) {}
                    Object.defineProperty(e, "adapterName", {
                        value: t
                    })
                }
            });
            let eO = e => `- ${e}`,
                eR = e => H.isFunction(e) || null === e || !1 === e;
            var eA = {
                getAdapter: e => {
                    let t, r;
                    let {
                        length: n
                    } = e = H.isArray(e) ? e : [e], o = {};
                    for (let i = 0; i < n; i++) {
                        let n;
                        if (r = t = e[i], !eR(t) && void 0 === (r = eB[(n = String(t)).toLowerCase()])) throw new j(`Unknown adapter '${n}'`);
                        if (r) break;
                        o[n || "#" + i] = r
                    }
                    if (!r) {
                        let e = Object.entries(o).map(([e, t]) => `adapter ${e} ` + (!1 === t ? "is not supported by the environment" : "is not available in the build"));
                        throw new j("There is no suitable adapter to dispatch the request " + (n ? e.length > 1 ? "since :\n" + e.map(eO).join("\n") : " " + eO(e[0]) : "as no adapter specified"), "ERR_NOT_SUPPORT")
                    }
                    return r
                },
                adapters: eB
            };

            function eI(e) {
                if (e.cancelToken && e.cancelToken.throwIfRequested(), e.signal && e.signal.aborted) throw new eb(null, e)
            }

            function ew(e) {
                return eI(e), e.headers = ey.from(e.headers), e.data = eh.call(e, e.transformRequest), -1 !== ["post", "put", "patch"].indexOf(e.method) && e.headers.setContentType("application/x-www-form-urlencoded", !1), eA.getAdapter(e.adapter || ed.adapter)(e).then(function(t) {
                    return eI(e), t.data = eh.call(e, e.transformResponse, t), t.headers = ey.from(t.headers), t
                }, function(t) {
                    return !ev(t) && (eI(e), t && t.response && (t.response.data = eh.call(e, e.transformResponse, t.response), t.response.headers = ey.from(t.response.headers))), Promise.reject(t)
                })
            }
            let eT = e => e instanceof ey ? e.toJSON() : e;

            function eN(e, t) {
                t = t || {};
                let r = {};

                function n(e, t, r) {
                    return H.isPlainObject(e) && H.isPlainObject(t) ? H.merge.call({
                        caseless: r
                    }, e, t) : H.isPlainObject(t) ? H.merge({}, t) : H.isArray(t) ? t.slice() : t
                }

                function o(e, t, r) {
                    return H.isUndefined(t) ? H.isUndefined(e) ? void 0 : n(void 0, e, r) : n(e, t, r)
                }

                function i(e, t) {
                    if (!H.isUndefined(t)) return n(void 0, t)
                }

                function a(e, t) {
                    return H.isUndefined(t) ? H.isUndefined(e) ? void 0 : n(void 0, e) : n(void 0, t)
                }

                function s(r, o, i) {
                    return i in t ? n(r, o) : i in e ? n(void 0, r) : void 0
                }
                let d = {
                    url: i,
                    method: i,
                    data: i,
                    baseURL: a,
                    transformRequest: a,
                    transformResponse: a,
                    paramsSerializer: a,
                    timeout: a,
                    timeoutMessage: a,
                    withCredentials: a,
                    withXSRFToken: a,
                    adapter: a,
                    responseType: a,
                    xsrfCookieName: a,
                    xsrfHeaderName: a,
                    onUploadProgress: a,
                    onDownloadProgress: a,
                    decompress: a,
                    maxContentLength: a,
                    maxBodyLength: a,
                    beforeRedirect: a,
                    transport: a,
                    httpAgent: a,
                    httpsAgent: a,
                    cancelToken: a,
                    socketPath: a,
                    responseEncoding: a,
                    validateStatus: s,
                    headers: (e, t) => o(eT(e), eT(t), !0)
                };
                return H.forEach(Object.keys(Object.assign({}, e, t)), function(n) {
                    let i = d[n] || o,
                        a = i(e[n], t[n], n);
                    H.isUndefined(a) && i !== s || (r[n] = a)
                }), r
            }
            let eC = "1.6.5",
                eE = {};
            ["object", "boolean", "number", "function", "string", "symbol"].forEach((e, t) => {
                eE[e] = function(r) {
                    return typeof r === e || "a" + (t < 1 ? "n " : " ") + e
                }
            });
            let ex = {};
            eE.transitional = function(e, t, r) {
                function n(e, t) {
                    return "[Axios v" + eC + "] Transitional option '" + e + "'" + t + (r ? ". " + r : "")
                }
                return (r, o, i) => {
                    if (!1 === e) throw new j(n(o, " has been removed" + (t ? " in " + t : "")), j.ERR_DEPRECATED);
                    return t && !ex[o] && (ex[o] = !0, console.warn(n(o, " has been deprecated since v" + t + " and will be removed in the near future"))), !e || e(r, o, i)
                }
            };
            var eU = {
                assertOptions: function(e, t, r) {
                    if ("object" != typeof e) throw new j("options must be an object", j.ERR_BAD_OPTION_VALUE);
                    let n = Object.keys(e),
                        o = n.length;
                    for (; o-- > 0;) {
                        let i = n[o],
                            a = t[i];
                        if (a) {
                            let t = e[i],
                                r = void 0 === t || a(t, i, e);
                            if (!0 !== r) throw new j("option " + i + " must be " + r, j.ERR_BAD_OPTION_VALUE);
                            continue
                        }
                        if (!0 !== r) throw new j("Unknown option " + i, j.ERR_BAD_OPTION)
                    }
                },
                validators: eE
            };
            let eD = eU.validators;
            class eM {
                constructor(e) {
                    this.defaults = e, this.interceptors = {
                        request: new X,
                        response: new X
                    }
                }
                request(e, t) {
                    let r, n;
                    "string" == typeof e ? (t = t || {}).url = e : t = e || {};
                    let {
                        transitional: o,
                        paramsSerializer: i,
                        headers: a
                    } = t = eN(this.defaults, t);
                    void 0 !== o && eU.assertOptions(o, {
                        silentJSONParsing: eD.transitional(eD.boolean),
                        forcedJSONParsing: eD.transitional(eD.boolean),
                        clarifyTimeoutError: eD.transitional(eD.boolean)
                    }, !1), null != i && (H.isFunction(i) ? t.paramsSerializer = {
                        serialize: i
                    } : eU.assertOptions(i, {
                        encode: eD.function,
                        serialize: eD.function
                    }, !0)), t.method = (t.method || this.defaults.method || "get").toLowerCase();
                    let s = a && H.merge(a.common, a[t.method]);
                    a && H.forEach(["delete", "get", "head", "post", "put", "patch", "common"], e => {
                        delete a[e]
                    }), t.headers = ey.concat(s, a);
                    let d = [],
                        c = !0;
                    this.interceptors.request.forEach(function(e) {
                        ("function" != typeof e.runWhen || !1 !== e.runWhen(t)) && (c = c && e.synchronous, d.unshift(e.fulfilled, e.rejected))
                    });
                    let l = [];
                    this.interceptors.response.forEach(function(e) {
                        l.push(e.fulfilled, e.rejected)
                    });
                    let u = 0;
                    if (!c) {
                        let e = [ew.bind(this), void 0];
                        for (e.unshift.apply(e, d), e.push.apply(e, l), n = e.length, r = Promise.resolve(t); u < n;) r = r.then(e[u++], e[u++]);
                        return r
                    }
                    n = d.length;
                    let p = t;
                    for (u = 0; u < n;) {
                        let e = d[u++],
                            t = d[u++];
                        try {
                            p = e(p)
                        } catch (e) {
                            t.call(this, e);
                            break
                        }
                    }
                    try {
                        r = ew.call(this, p)
                    } catch (e) {
                        return Promise.reject(e)
                    }
                    for (u = 0, n = l.length; u < n;) r = r.then(l[u++], l[u++]);
                    return r
                }
                getUri(e) {
                    return Z(ek((e = eN(this.defaults, e)).baseURL, e.url), e.params, e.paramsSerializer)
                }
            }
            H.forEach(["delete", "get", "head", "options"], function(e) {
                eM.prototype[e] = function(t, r) {
                    return this.request(eN(r || {}, {
                        method: e,
                        url: t,
                        data: (r || {}).data
                    }))
                }
            }), H.forEach(["post", "put", "patch"], function(e) {
                function t(t) {
                    return function(r, n, o) {
                        return this.request(eN(o || {}, {
                            method: e,
                            headers: t ? {
                                "Content-Type": "multipart/form-data"
                            } : {},
                            url: r,
                            data: n
                        }))
                    }
                }
                eM.prototype[e] = t(), eM.prototype[e + "Form"] = t(!0)
            });
            class eJ {
                constructor(e) {
                    let t;
                    if ("function" != typeof e) throw TypeError("executor must be a function.");
                    this.promise = new Promise(function(e) {
                        t = e
                    });
                    let r = this;
                    this.promise.then(e => {
                        if (!r._listeners) return;
                        let t = r._listeners.length;
                        for (; t-- > 0;) r._listeners[t](e);
                        r._listeners = null
                    }), this.promise.then = e => {
                        let t;
                        let n = new Promise(e => {
                            r.subscribe(e), t = e
                        }).then(e);
                        return n.cancel = function() {
                            r.unsubscribe(t)
                        }, n
                    }, e(function(e, n, o) {
                        r.reason || (r.reason = new eb(e, n, o), t(r.reason))
                    })
                }
                throwIfRequested() {
                    if (this.reason) throw this.reason
                }
                subscribe(e) {
                    if (this.reason) {
                        e(this.reason);
                        return
                    }
                    this._listeners ? this._listeners.push(e) : this._listeners = [e]
                }
                unsubscribe(e) {
                    if (!this._listeners) return;
                    let t = this._listeners.indexOf(e); - 1 !== t && this._listeners.splice(t, 1)
                }
                static source() {
                    let e;
                    return {
                        token: new eJ(function(t) {
                            e = t
                        }),
                        cancel: e
                    }
                }
            }
            let eH = {
                Continue: 100,
                SwitchingProtocols: 101,
                Processing: 102,
                EarlyHints: 103,
                Ok: 200,
                Created: 201,
                Accepted: 202,
                NonAuthoritativeInformation: 203,
                NoContent: 204,
                ResetContent: 205,
                PartialContent: 206,
                MultiStatus: 207,
                AlreadyReported: 208,
                ImUsed: 226,
                MultipleChoices: 300,
                MovedPermanently: 301,
                Found: 302,
                SeeOther: 303,
                NotModified: 304,
                UseProxy: 305,
                Unused: 306,
                TemporaryRedirect: 307,
                PermanentRedirect: 308,
                BadRequest: 400,
                Unauthorized: 401,
                PaymentRequired: 402,
                Forbidden: 403,
                NotFound: 404,
                MethodNotAllowed: 405,
                NotAcceptable: 406,
                ProxyAuthenticationRequired: 407,
                RequestTimeout: 408,
                Conflict: 409,
                Gone: 410,
                LengthRequired: 411,
                PreconditionFailed: 412,
                PayloadTooLarge: 413,
                UriTooLong: 414,
                UnsupportedMediaType: 415,
                RangeNotSatisfiable: 416,
                ExpectationFailed: 417,
                ImATeapot: 418,
                MisdirectedRequest: 421,
                UnprocessableEntity: 422,
                Locked: 423,
                FailedDependency: 424,
                TooEarly: 425,
                UpgradeRequired: 426,
                PreconditionRequired: 428,
                TooManyRequests: 429,
                RequestHeaderFieldsTooLarge: 431,
                UnavailableForLegalReasons: 451,
                InternalServerError: 500,
                NotImplemented: 501,
                BadGateway: 502,
                ServiceUnavailable: 503,
                GatewayTimeout: 504,
                HttpVersionNotSupported: 505,
                VariantAlsoNegotiates: 506,
                InsufficientStorage: 507,
                LoopDetected: 508,
                NotExtended: 510,
                NetworkAuthenticationRequired: 511
            };
            Object.entries(eH).forEach(([e, t]) => {
                eH[t] = e
            });
            let ej = function e(t) {
                let r = new eM(t),
                    n = s(eM.prototype.request, r);
                return H.extend(n, eM.prototype, r, {
                    allOwnKeys: !0
                }), H.extend(n, r, null, {
                    allOwnKeys: !0
                }), n.create = function(r) {
                    return e(eN(t, r))
                }, n
            }(ed);
            ej.Axios = eM, ej.CanceledError = eb, ej.CancelToken = eJ, ej.isCancel = ev, ej.VERSION = eC, ej.toFormData = L, ej.AxiosError = j, ej.Cancel = ej.CanceledError, ej.all = function(e) {
                return Promise.all(e)
            }, ej.spread = function(e) {
                return function(t) {
                    return e.apply(null, t)
                }
            }, ej.isAxiosError = function(e) {
                return H.isObject(e) && !0 === e.isAxiosError
            }, ej.mergeConfig = eN, ej.AxiosHeaders = ey, ej.formToJSON = e => es(H.isHTMLForm(e) ? new FormData(e) : e), ej.getAdapter = eA.getAdapter, ej.HttpStatusCode = eH, ej.default = ej, e.exports = ej
        },
        41161: function(e, t, r) {
            "use strict";
            var n, o, i, a = r(48764).Buffer;

            function s(e, t) {
                return function() {
                    return e.apply(t, arguments)
                }
            }
            let {
                toString: d
            } = Object.prototype, {
                getPrototypeOf: c
            } = Object, l = (n = Object.create(null), e => {
                let t = d.call(e);
                return n[t] || (n[t] = t.slice(8, -1).toLowerCase())
            }), u = e => (e = e.toLowerCase(), t => l(t) === e), p = e => t => typeof t === e, {
                isArray: m
            } = Array, g = p("undefined"), f = u("ArrayBuffer"), y = p("string"), h = p("function"), v = p("number"), b = e => null !== e && "object" == typeof e, S = e => {
                if ("object" !== l(e)) return !1;
                let t = c(e);
                return (null === t || t === Object.prototype || null === Object.getPrototypeOf(t)) && !(Symbol.toStringTag in e) && !(Symbol.iterator in e)
            }, k = u("Date"), P = u("File"), _ = u("Blob"), B = u("FileList"), O = u("URLSearchParams");

            function R(e, t, {
                allOwnKeys: r = !1
            } = {}) {
                let n, o;
                if (null != e) {
                    if ("object" != typeof e && (e = [e]), m(e))
                        for (n = 0, o = e.length; n < o; n++) t.call(null, e[n], n, e);
                    else {
                        let o;
                        let i = r ? Object.getOwnPropertyNames(e) : Object.keys(e),
                            a = i.length;
                        for (n = 0; n < a; n++) o = i[n], t.call(null, e[o], o, e)
                    }
                }
            }

            function A(e, t) {
                let r;
                t = t.toLowerCase();
                let n = Object.keys(e),
                    o = n.length;
                for (; o-- > 0;)
                    if (t === (r = n[o]).toLowerCase()) return r;
                return null
            }
            let I = "undefined" != typeof globalThis ? globalThis : "undefined" != typeof self ? self : "undefined" != typeof window ? window : r.g,
                w = e => !g(e) && e !== I,
                T = (o = "undefined" != typeof Uint8Array && c(Uint8Array), e => o && e instanceof o),
                N = u("HTMLFormElement"),
                C = (({
                    hasOwnProperty: e
                }) => (t, r) => e.call(t, r))(Object.prototype),
                E = u("RegExp"),
                x = (e, t) => {
                    let r = Object.getOwnPropertyDescriptors(e),
                        n = {};
                    R(r, (r, o) => {
                        let i;
                        !1 !== (i = t(r, o, e)) && (n[o] = i || r)
                    }), Object.defineProperties(e, n)
                },
                U = "abcdefghijklmnopqrstuvwxyz",
                D = "0123456789",
                M = {
                    DIGIT: D,
                    ALPHA: U,
                    ALPHA_DIGIT: U + U.toUpperCase() + D
                },
                J = u("AsyncFunction");
            var H = {
                isArray: m,
                isArrayBuffer: f,
                isBuffer: function(e) {
                    return null !== e && !g(e) && null !== e.constructor && !g(e.constructor) && h(e.constructor.isBuffer) && e.constructor.isBuffer(e)
                },
                isFormData: e => {
                    let t;
                    return e && ("function" == typeof FormData && e instanceof FormData || h(e.append) && ("formdata" === (t = l(e)) || "object" === t && h(e.toString) && "[object FormData]" === e.toString()))
                },
                isArrayBufferView: function(e) {
                    return "undefined" != typeof ArrayBuffer && ArrayBuffer.isView ? ArrayBuffer.isView(e) : e && e.buffer && f(e.buffer)
                },
                isString: y,
                isNumber: v,
                isBoolean: e => !0 === e || !1 === e,
                isObject: b,
                isPlainObject: S,
                isUndefined: g,
                isDate: k,
                isFile: P,
                isBlob: _,
                isRegExp: E,
                isFunction: h,
                isStream: e => b(e) && h(e.pipe),
                isURLSearchParams: O,
                isTypedArray: T,
                isFileList: B,
                forEach: R,
                merge: function e() {
                    let {
                        caseless: t
                    } = w(this) && this || {}, r = {}, n = (n, o) => {
                        let i = t && A(r, o) || o;
                        S(r[i]) && S(n) ? r[i] = e(r[i], n) : S(n) ? r[i] = e({}, n) : m(n) ? r[i] = n.slice() : r[i] = n
                    };
                    for (let e = 0, t = arguments.length; e < t; e++) arguments[e] && R(arguments[e], n);
                    return r
                },
                extend: (e, t, r, {
                    allOwnKeys: n
                } = {}) => (R(t, (t, n) => {
                    r && h(t) ? e[n] = s(t, r) : e[n] = t
                }, {
                    allOwnKeys: n
                }), e),
                trim: e => e.trim ? e.trim() : e.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, ""),
                stripBOM: e => (65279 === e.charCodeAt(0) && (e = e.slice(1)), e),
                inherits: (e, t, r, n) => {
                    e.prototype = Object.create(t.prototype, n), e.prototype.constructor = e, Object.defineProperty(e, "super", {
                        value: t.prototype
                    }), r && Object.assign(e.prototype, r)
                },
                toFlatObject: (e, t, r, n) => {
                    let o, i, a;
                    let s = {};
                    if (t = t || {}, null == e) return t;
                    do {
                        for (i = (o = Object.getOwnPropertyNames(e)).length; i-- > 0;) a = o[i], (!n || n(a, e, t)) && !s[a] && (t[a] = e[a], s[a] = !0);
                        e = !1 !== r && c(e)
                    } while (e && (!r || r(e, t)) && e !== Object.prototype);
                    return t
                },
                kindOf: l,
                kindOfTest: u,
                endsWith: (e, t, r) => {
                    e = String(e), (void 0 === r || r > e.length) && (r = e.length), r -= t.length;
                    let n = e.indexOf(t, r);
                    return -1 !== n && n === r
                },
                toArray: e => {
                    if (!e) return null;
                    if (m(e)) return e;
                    let t = e.length;
                    if (!v(t)) return null;
                    let r = Array(t);
                    for (; t-- > 0;) r[t] = e[t];
                    return r
                },
                forEachEntry: (e, t) => {
                    let r;
                    let n = (e && e[Symbol.iterator]).call(e);
                    for (;
                        (r = n.next()) && !r.done;) {
                        let n = r.value;
                        t.call(e, n[0], n[1])
                    }
                },
                matchAll: (e, t) => {
                    let r;
                    let n = [];
                    for (; null !== (r = e.exec(t));) n.push(r);
                    return n
                },
                isHTMLForm: N,
                hasOwnProperty: C,
                hasOwnProp: C,
                reduceDescriptors: x,
                freezeMethods: e => {
                    x(e, (t, r) => {
                        if (h(e) && -1 !== ["arguments", "caller", "callee"].indexOf(r)) return !1;
                        if (h(e[r])) {
                            if (t.enumerable = !1, "writable" in t) {
                                t.writable = !1;
                                return
                            }
                            t.set || (t.set = () => {
                                throw Error("Can not rewrite read-only method '" + r + "'")
                            })
                        }
                    })
                },
                toObjectSet: (e, t) => {
                    let r = {};
                    return (e => {
                        e.forEach(e => {
                            r[e] = !0
                        })
                    })(m(e) ? e : String(e).split(t)), r
                },
                toCamelCase: e => e.toLowerCase().replace(/[-_\s]([a-z\d])(\w*)/g, function(e, t, r) {
                    return t.toUpperCase() + r
                }),
                noop: () => {},
                toFiniteNumber: (e, t) => Number.isFinite(e = +e) ? e : t,
                findKey: A,
                global: I,
                isContextDefined: w,
                ALPHABET: M,
                generateString: (e = 16, t = M.ALPHA_DIGIT) => {
                    let r = "",
                        {
                            length: n
                        } = t;
                    for (; e--;) r += t[Math.random() * n | 0];
                    return r
                },
                isSpecCompliantForm: function(e) {
                    return !!(e && h(e.append) && "FormData" === e[Symbol.toStringTag] && e[Symbol.iterator])
                },
                toJSONObject: e => {
                    let t = Array(10),
                        r = (e, n) => {
                            if (b(e)) {
                                if (t.indexOf(e) >= 0) return;
                                if (!("toJSON" in e)) {
                                    t[n] = e;
                                    let o = m(e) ? [] : {};
                                    return R(e, (e, t) => {
                                        let i = r(e, n + 1);
                                        g(i) || (o[t] = i)
                                    }), t[n] = void 0, o
                                }
                            }
                            return e
                        };
                    return r(e, 0)
                },
                isAsyncFn: J,
                isThenable: e => e && (b(e) || h(e)) && h(e.then) && h(e.catch)
            };

            function j(e, t, r, n, o) {
                Error.call(this), Error.captureStackTrace ? Error.captureStackTrace(this, this.constructor) : this.stack = Error().stack, this.message = e, this.name = "AxiosError", t && (this.code = t), r && (this.config = r), n && (this.request = n), o && (this.response = o)
            }
            H.inherits(j, Error, {
                toJSON: function() {
                    return {
                        message: this.message,
                        name: this.name,
                        description: this.description,
                        number: this.number,
                        fileName: this.fileName,
                        lineNumber: this.lineNumber,
                        columnNumber: this.columnNumber,
                        stack: this.stack,
                        config: H.toJSONObject(this.config),
                        code: this.code,
                        status: this.response && this.response.status ? this.response.status : null
                    }
                }
            });
            let V = j.prototype,
                q = {};

            function W(e) {
                return H.isPlainObject(e) || H.isArray(e)
            }

            function F(e) {
                return H.endsWith(e, "[]") ? e.slice(0, -2) : e
            }

            function Q(e, t, r) {
                return e ? e.concat(t).map(function(e, t) {
                    return e = F(e), !r && t ? "[" + e + "]" : e
                }).join(r ? "." : "") : t
            }["ERR_BAD_OPTION_VALUE", "ERR_BAD_OPTION", "ECONNABORTED", "ETIMEDOUT", "ERR_NETWORK", "ERR_FR_TOO_MANY_REDIRECTS", "ERR_DEPRECATED", "ERR_BAD_RESPONSE", "ERR_BAD_REQUEST", "ERR_CANCELED", "ERR_NOT_SUPPORT", "ERR_INVALID_URL"].forEach(e => {
                q[e] = {
                    value: e
                }
            }), Object.defineProperties(j, q), Object.defineProperty(V, "isAxiosError", {
                value: !0
            }), j.from = (e, t, r, n, o, i) => {
                let a = Object.create(V);
                return H.toFlatObject(e, a, function(e) {
                    return e !== Error.prototype
                }, e => "isAxiosError" !== e), j.call(a, e.message, t, r, n, o), a.cause = e, a.name = e.name, i && Object.assign(a, i), a
            };
            let G = H.toFlatObject(H, {}, null, function(e) {
                return /^is[A-Z]/.test(e)
            });

            function L(e, t, r) {
                if (!H.isObject(e)) throw TypeError("target must be an object");
                t = t || new FormData;
                let n = (r = H.toFlatObject(r, {
                        metaTokens: !0,
                        dots: !1,
                        indexes: !1
                    }, !1, function(e, t) {
                        return !H.isUndefined(t[e])
                    })).metaTokens,
                    o = r.visitor || l,
                    i = r.dots,
                    s = r.indexes,
                    d = (r.Blob || "undefined" != typeof Blob && Blob) && H.isSpecCompliantForm(t);
                if (!H.isFunction(o)) throw TypeError("visitor must be a function");

                function c(e) {
                    if (null === e) return "";
                    if (H.isDate(e)) return e.toISOString();
                    if (!d && H.isBlob(e)) throw new j("Blob is not supported. Use a Buffer instead.");
                    return H.isArrayBuffer(e) || H.isTypedArray(e) ? d && "function" == typeof Blob ? new Blob([e]) : a.from(e) : e
                }

                function l(e, r, o) {
                    let a = e;
                    if (e && !o && "object" == typeof e) {
                        if (H.endsWith(r, "{}")) r = n ? r : r.slice(0, -2), e = JSON.stringify(e);
                        else {
                            var d;
                            if (H.isArray(e) && (d = e, H.isArray(d) && !d.some(W)) || (H.isFileList(e) || H.endsWith(r, "[]")) && (a = H.toArray(e))) return r = F(r), a.forEach(function(e, n) {
                                H.isUndefined(e) || null === e || t.append(!0 === s ? Q([r], n, i) : null === s ? r : r + "[]", c(e))
                            }), !1
                        }
                    }
                    return !!W(e) || (t.append(Q(o, r, i), c(e)), !1)
                }
                let u = [],
                    p = Object.assign(G, {
                        defaultVisitor: l,
                        convertValue: c,
                        isVisitable: W
                    });
                if (!H.isObject(e)) throw TypeError("data must be an object");
                return ! function e(r, n) {
                    if (!H.isUndefined(r)) {
                        if (-1 !== u.indexOf(r)) throw Error("Circular reference detected in " + n.join("."));
                        u.push(r), H.forEach(r, function(r, i) {
                            !0 === (!(H.isUndefined(r) || null === r) && o.call(t, r, H.isString(i) ? i.trim() : i, n, p)) && e(r, n ? n.concat(i) : [i])
                        }), u.pop()
                    }
                }(e), t
            }

            function K(e) {
                let t = {
                    "!": "%21",
                    "'": "%27",
                    "(": "%28",
                    ")": "%29",
                    "~": "%7E",
                    "%20": "+",
                    "%00": "\x00"
                };
                return encodeURIComponent(e).replace(/[!'()~]|%20|%00/g, function(e) {
                    return t[e]
                })
            }

            function Y(e, t) {
                this._pairs = [], e && L(e, this, t)
            }
            let z = Y.prototype;

            function $(e) {
                return encodeURIComponent(e).replace(/%3A/gi, ":").replace(/%24/g, "$").replace(/%2C/gi, ",").replace(/%20/g, "+").replace(/%5B/gi, "[").replace(/%5D/gi, "]")
            }

            function Z(e, t, r) {
                let n;
                if (!t) return e;
                let o = r && r.encode || $,
                    i = r && r.serialize;
                if (n = i ? i(t, r) : H.isURLSearchParams(t) ? t.toString() : new Y(t, r).toString(o)) {
                    let t = e.indexOf("#"); - 1 !== t && (e = e.slice(0, t)), e += (-1 === e.indexOf("?") ? "?" : "&") + n
                }
                return e
            }
            z.append = function(e, t) {
                this._pairs.push([e, t])
            }, z.toString = function(e) {
                let t = e ? function(t) {
                    return e.call(this, t, K)
                } : K;
                return this._pairs.map(function(e) {
                    return t(e[0]) + "=" + t(e[1])
                }, "").join("&")
            };
            class X {
                constructor() {
                    this.handlers = []
                }
                use(e, t, r) {
                    return this.handlers.push({
                        fulfilled: e,
                        rejected: t,
                        synchronous: !!r && r.synchronous,
                        runWhen: r ? r.runWhen : null
                    }), this.handlers.length - 1
                }
                eject(e) {
                    this.handlers[e] && (this.handlers[e] = null)
                }
                clear() {
                    this.handlers && (this.handlers = [])
                }
                forEach(e) {
                    H.forEach(this.handlers, function(t) {
                        null !== t && e(t)
                    })
                }
            }
            var ee = {
                    silentJSONParsing: !0,
                    forcedJSONParsing: !0,
                    clarifyTimeoutError: !1
                },
                et = "undefined" != typeof URLSearchParams ? URLSearchParams : Y,
                er = "undefined" != typeof FormData ? FormData : null,
                en = "undefined" != typeof Blob ? Blob : null;
            let eo = "undefined" != typeof window && "undefined" != typeof document,
                ei = (i = "undefined" != typeof navigator && navigator.product, eo && 0 > ["ReactNative", "NativeScript", "NS"].indexOf(i));
            var ea = { ...Object.freeze({
                    __proto__: null,
                    hasBrowserEnv: eo,
                    hasStandardBrowserWebWorkerEnv: "undefined" != typeof WorkerGlobalScope && self instanceof WorkerGlobalScope && "function" == typeof self.importScripts,
                    hasStandardBrowserEnv: ei
                }),
                isBrowser: !0,
                classes: {
                    URLSearchParams: et,
                    FormData: er,
                    Blob: en
                },
                protocols: ["http", "https", "file", "blob", "url", "data"]
            };

            function es(e) {
                if (H.isFormData(e) && H.isFunction(e.entries)) {
                    let t = {};
                    return H.forEachEntry(e, (e, r) => {
                        ! function e(t, r, n, o) {
                            let i = t[o++];
                            if ("__proto__" === i) return !0;
                            let a = Number.isFinite(+i),
                                s = o >= t.length;
                            return (i = !i && H.isArray(n) ? n.length : i, s) ? H.hasOwnProp(n, i) ? n[i] = [n[i], r] : n[i] = r : (n[i] && H.isObject(n[i]) || (n[i] = []), e(t, r, n[i], o) && H.isArray(n[i]) && (n[i] = function(e) {
                                let t, r;
                                let n = {},
                                    o = Object.keys(e),
                                    i = o.length;
                                for (t = 0; t < i; t++) n[r = o[t]] = e[r];
                                return n
                            }(n[i]))), !a
                        }(H.matchAll(/\w+|\[(\w*)]/g, e).map(e => "[]" === e[0] ? "" : e[1] || e[0]), r, t, 0)
                    }), t
                }
                return null
            }
            let ed = {
                transitional: ee,
                adapter: ["xhr", "http"],
                transformRequest: [function(e, t) {
                    let r;
                    let n = t.getContentType() || "",
                        o = n.indexOf("application/json") > -1,
                        i = H.isObject(e);
                    if (i && H.isHTMLForm(e) && (e = new FormData(e)), H.isFormData(e)) return o && o ? JSON.stringify(es(e)) : e;
                    if (H.isArrayBuffer(e) || H.isBuffer(e) || H.isStream(e) || H.isFile(e) || H.isBlob(e)) return e;
                    if (H.isArrayBufferView(e)) return e.buffer;
                    if (H.isURLSearchParams(e)) return t.setContentType("application/x-www-form-urlencoded;charset=utf-8", !1), e.toString();
                    if (i) {
                        if (n.indexOf("application/x-www-form-urlencoded") > -1) {
                            var a, s;
                            return (a = e, s = this.formSerializer, L(a, new ea.classes.URLSearchParams, Object.assign({
                                visitor: function(e, t, r, n) {
                                    return ea.isNode && H.isBuffer(e) ? (this.append(t, e.toString("base64")), !1) : n.defaultVisitor.apply(this, arguments)
                                }
                            }, s))).toString()
                        }
                        if ((r = H.isFileList(e)) || n.indexOf("multipart/form-data") > -1) {
                            let t = this.env && this.env.FormData;
                            return L(r ? {
                                "files[]": e
                            } : e, t && new t, this.formSerializer)
                        }
                    }
                    return i || o ? (t.setContentType("application/json", !1), function(e, t, r) {
                        if (H.isString(e)) try {
                            return (0, JSON.parse)(e), H.trim(e)
                        } catch (e) {
                            if ("SyntaxError" !== e.name) throw e
                        }
                        return (0, JSON.stringify)(e)
                    }(e)) : e
                }],
                transformResponse: [function(e) {
                    let t = this.transitional || ed.transitional,
                        r = t && t.forcedJSONParsing,
                        n = "json" === this.responseType;
                    if (e && H.isString(e) && (r && !this.responseType || n)) {
                        let r = t && t.silentJSONParsing;
                        try {
                            return JSON.parse(e)
                        } catch (e) {
                            if (!r && n) {
                                if ("SyntaxError" === e.name) throw j.from(e, j.ERR_BAD_RESPONSE, this, null, this.response);
                                throw e
                            }
                        }
                    }
                    return e
                }],
                timeout: 0,
                xsrfCookieName: "XSRF-TOKEN",
                xsrfHeaderName: "X-XSRF-TOKEN",
                maxContentLength: -1,
                maxBodyLength: -1,
                env: {
                    FormData: ea.classes.FormData,
                    Blob: ea.classes.Blob
                },
                validateStatus: function(e) {
                    return e >= 200 && e < 300
                },
                headers: {
                    common: {
                        Accept: "application/json, text/plain, */*",
                        "Content-Type": void 0
                    }
                }
            };
            H.forEach(["delete", "get", "head", "post", "put", "patch"], e => {
                ed.headers[e] = {}
            });
            let ec = H.toObjectSet(["age", "authorization", "content-length", "content-type", "etag", "expires", "from", "host", "if-modified-since", "if-unmodified-since", "last-modified", "location", "max-forwards", "proxy-authorization", "referer", "retry-after", "user-agent"]);
            var el = e => {
                let t, r, n;
                let o = {};
                return e && e.split("\n").forEach(function(e) {
                    n = e.indexOf(":"), t = e.substring(0, n).trim().toLowerCase(), r = e.substring(n + 1).trim(), !t || o[t] && ec[t] || ("set-cookie" === t ? o[t] ? o[t].push(r) : o[t] = [r] : o[t] = o[t] ? o[t] + ", " + r : r)
                }), o
            };
            let eu = Symbol("internals");

            function ep(e) {
                return e && String(e).trim().toLowerCase()
            }

            function em(e) {
                return !1 === e || null == e ? e : H.isArray(e) ? e.map(em) : String(e)
            }
            let eg = e => /^[-_a-zA-Z0-9^`|~,!#$%&'*+.]+$/.test(e.trim());

            function ef(e, t, r, n, o) {
                if (H.isFunction(n)) return n.call(this, t, r);
                if (o && (t = r), H.isString(t)) {
                    if (H.isString(n)) return -1 !== t.indexOf(n);
                    if (H.isRegExp(n)) return n.test(t)
                }
            }
            class ey {
                constructor(e) {
                    e && this.set(e)
                }
                set(e, t, r) {
                    let n = this;

                    function o(e, t, r) {
                        let o = ep(t);
                        if (!o) throw Error("header name must be a non-empty string");
                        let i = H.findKey(n, o);
                        i && void 0 !== n[i] && !0 !== r && (void 0 !== r || !1 === n[i]) || (n[i || t] = em(e))
                    }
                    let i = (e, t) => H.forEach(e, (e, r) => o(e, r, t));
                    return H.isPlainObject(e) || e instanceof this.constructor ? i(e, t) : H.isString(e) && (e = e.trim()) && !eg(e) ? i(el(e), t) : null != e && o(t, e, r), this
                }
                get(e, t) {
                    if (e = ep(e)) {
                        let r = H.findKey(this, e);
                        if (r) {
                            let e = this[r];
                            if (!t) return e;
                            if (!0 === t) return function(e) {
                                let t;
                                let r = Object.create(null),
                                    n = /([^\s,;=]+)\s*(?:=\s*([^,;]+))?/g;
                                for (; t = n.exec(e);) r[t[1]] = t[2];
                                return r
                            }(e);
                            if (H.isFunction(t)) return t.call(this, e, r);
                            if (H.isRegExp(t)) return t.exec(e);
                            throw TypeError("parser must be boolean|regexp|function")
                        }
                    }
                }
                has(e, t) {
                    if (e = ep(e)) {
                        let r = H.findKey(this, e);
                        return !!(r && void 0 !== this[r] && (!t || ef(this, this[r], r, t)))
                    }
                    return !1
                }
                delete(e, t) {
                    let r = this,
                        n = !1;

                    function o(e) {
                        if (e = ep(e)) {
                            let o = H.findKey(r, e);
                            o && (!t || ef(r, r[o], o, t)) && (delete r[o], n = !0)
                        }
                    }
                    return H.isArray(e) ? e.forEach(o) : o(e), n
                }
                clear(e) {
                    let t = Object.keys(this),
                        r = t.length,
                        n = !1;
                    for (; r--;) {
                        let o = t[r];
                        (!e || ef(this, this[o], o, e, !0)) && (delete this[o], n = !0)
                    }
                    return n
                }
                normalize(e) {
                    let t = this,
                        r = {};
                    return H.forEach(this, (n, o) => {
                        let i = H.findKey(r, o);
                        if (i) {
                            t[i] = em(n), delete t[o];
                            return
                        }
                        let a = e ? o.trim().toLowerCase().replace(/([a-z\d])(\w*)/g, (e, t, r) => t.toUpperCase() + r) : String(o).trim();
                        a !== o && delete t[o], t[a] = em(n), r[a] = !0
                    }), this
                }
                concat(...e) {
                    return this.constructor.concat(this, ...e)
                }
                toJSON(e) {
                    let t = Object.create(null);
                    return H.forEach(this, (r, n) => {
                        null != r && !1 !== r && (t[n] = e && H.isArray(r) ? r.join(", ") : r)
                    }), t
                }[Symbol.iterator]() {
                    return Object.entries(this.toJSON())[Symbol.iterator]()
                }
                toString() {
                    return Object.entries(this.toJSON()).map(([e, t]) => e + ": " + t).join("\n")
                }
                get[Symbol.toStringTag]() {
                    return "AxiosHeaders"
                }
                static from(e) {
                    return e instanceof this ? e : new this(e)
                }
                static concat(e, ...t) {
                    let r = new this(e);
                    return t.forEach(e => r.set(e)), r
                }
                static accessor(e) {
                    let t = (this[eu] = this[eu] = {
                            accessors: {}
                        }).accessors,
                        r = this.prototype;

                    function n(e) {
                        let n = ep(e);
                        t[n] || (! function(e, t) {
                            let r = H.toCamelCase(" " + t);
                            ["get", "set", "has"].forEach(n => {
                                Object.defineProperty(e, n + r, {
                                    value: function(e, r, o) {
                                        return this[n].call(this, t, e, r, o)
                                    },
                                    configurable: !0
                                })
                            })
                        }(r, e), t[n] = !0)
                    }
                    return H.isArray(e) ? e.forEach(n) : n(e), this
                }
            }

            function eh(e, t) {
                let r = this || ed,
                    n = t || r,
                    o = ey.from(n.headers),
                    i = n.data;
                return H.forEach(e, function(e) {
                    i = e.call(r, i, o.normalize(), t ? t.status : void 0)
                }), o.normalize(), i
            }

            function ev(e) {
                return !!(e && e.__CANCEL__)
            }

            function eb(e, t, r) {
                j.call(this, null == e ? "canceled" : e, j.ERR_CANCELED, t, r), this.name = "CanceledError"
            }
            ey.accessor(["Content-Type", "Content-Length", "Accept", "Accept-Encoding", "User-Agent", "Authorization"]), H.reduceDescriptors(ey.prototype, ({
                value: e
            }, t) => {
                let r = t[0].toUpperCase() + t.slice(1);
                return {
                    get: () => e,
                    set(e) {
                        this[r] = e
                    }
                }
            }), H.freezeMethods(ey), H.inherits(eb, j, {
                __CANCEL__: !0
            });
            var eS = ea.hasStandardBrowserEnv ? {
                write(e, t, r, n, o, i) {
                    let a = [e + "=" + encodeURIComponent(t)];
                    H.isNumber(r) && a.push("expires=" + new Date(r).toGMTString()), H.isString(n) && a.push("path=" + n), H.isString(o) && a.push("domain=" + o), !0 === i && a.push("secure"), document.cookie = a.join("; ")
                },
                read(e) {
                    let t = document.cookie.match(RegExp("(^|;\\s*)(" + e + ")=([^;]*)"));
                    return t ? decodeURIComponent(t[3]) : null
                },
                remove(e) {
                    this.write(e, "", Date.now() - 864e5)
                }
            } : {
                write() {},
                read: () => null,
                remove() {}
            };

            function ek(e, t) {
                return e && !/^([a-z][a-z\d+\-.]*:)?\/\//i.test(t) ? t ? e.replace(/\/?\/$/, "") + "/" + t.replace(/^\/+/, "") : e : t
            }
            var eP = ea.hasStandardBrowserEnv ? function() {
                let e;
                let t = /(msie|trident)/i.test(navigator.userAgent),
                    r = document.createElement("a");

                function n(e) {
                    let n = e;
                    return t && (r.setAttribute("href", n), n = r.href), r.setAttribute("href", n), {
                        href: r.href,
                        protocol: r.protocol ? r.protocol.replace(/:$/, "") : "",
                        host: r.host,
                        search: r.search ? r.search.replace(/^\?/, "") : "",
                        hash: r.hash ? r.hash.replace(/^#/, "") : "",
                        hostname: r.hostname,
                        port: r.port,
                        pathname: "/" === r.pathname.charAt(0) ? r.pathname : "/" + r.pathname
                    }
                }
                return e = n(window.location.href),
                    function(t) {
                        let r = H.isString(t) ? n(t) : t;
                        return r.protocol === e.protocol && r.host === e.host
                    }
            }() : function() {
                return !0
            };

            function e_(e, t) {
                let r = 0,
                    n = function(e, t) {
                        let r;
                        let n = Array(e = e || 10),
                            o = Array(e),
                            i = 0,
                            a = 0;
                        return t = void 0 !== t ? t : 1e3,
                            function(s) {
                                let d = Date.now(),
                                    c = o[a];
                                r || (r = d), n[i] = s, o[i] = d;
                                let l = a,
                                    u = 0;
                                for (; l !== i;) u += n[l++], l %= e;
                                if ((i = (i + 1) % e) === a && (a = (a + 1) % e), d - r < t) return;
                                let p = c && d - c;
                                return p ? Math.round(1e3 * u / p) : void 0
                            }
                    }(50, 250);
                return o => {
                    let i = o.loaded,
                        a = o.lengthComputable ? o.total : void 0,
                        s = i - r,
                        d = n(s);
                    r = i;
                    let c = {
                        loaded: i,
                        total: a,
                        progress: a ? i / a : void 0,
                        bytes: s,
                        rate: d || void 0,
                        estimated: d && a && i <= a ? (a - i) / d : void 0,
                        event: o
                    };
                    c[t ? "download" : "upload"] = !0, e(c)
                }
            }
            let eB = {
                http: null,
                xhr: "undefined" != typeof XMLHttpRequest && function(e) {
                    return new Promise(function(t, r) {
                        let n, o, i = e.data,
                            a = ey.from(e.headers).normalize(),
                            {
                                responseType: s,
                                withXSRFToken: d
                            } = e;

                        function c() {
                            e.cancelToken && e.cancelToken.unsubscribe(n), e.signal && e.signal.removeEventListener("abort", n)
                        }
                        if (H.isFormData(i)) {
                            if (ea.hasStandardBrowserEnv || ea.hasStandardBrowserWebWorkerEnv) a.setContentType(!1);
                            else if (!1 !== (o = a.getContentType())) {
                                let [e, ...t] = o ? o.split(";").map(e => e.trim()).filter(Boolean) : [];
                                a.setContentType([e || "multipart/form-data", ...t].join("; "))
                            }
                        }
                        let l = new XMLHttpRequest;
                        if (e.auth) {
                            let t = e.auth.username || "",
                                r = e.auth.password ? unescape(encodeURIComponent(e.auth.password)) : "";
                            a.set("Authorization", "Basic " + btoa(t + ":" + r))
                        }
                        let u = ek(e.baseURL, e.url);

                        function p() {
                            if (!l) return;
                            let n = ey.from("getAllResponseHeaders" in l && l.getAllResponseHeaders());
                            ! function(e, t, r) {
                                let n = r.config.validateStatus;
                                !r.status || !n || n(r.status) ? e(r) : t(new j("Request failed with status code " + r.status, [j.ERR_BAD_REQUEST, j.ERR_BAD_RESPONSE][Math.floor(r.status / 100) - 4], r.config, r.request, r))
                            }(function(e) {
                                t(e), c()
                            }, function(e) {
                                r(e), c()
                            }, {
                                data: s && "text" !== s && "json" !== s ? l.response : l.responseText,
                                status: l.status,
                                statusText: l.statusText,
                                headers: n,
                                config: e,
                                request: l
                            }), l = null
                        }
                        if (l.open(e.method.toUpperCase(), Z(u, e.params, e.paramsSerializer), !0), l.timeout = e.timeout, "onloadend" in l ? l.onloadend = p : l.onreadystatechange = function() {
                                l && 4 === l.readyState && (0 !== l.status || l.responseURL && 0 === l.responseURL.indexOf("file:")) && setTimeout(p)
                            }, l.onabort = function() {
                                l && (r(new j("Request aborted", j.ECONNABORTED, e, l)), l = null)
                            }, l.onerror = function() {
                                r(new j("Network Error", j.ERR_NETWORK, e, l)), l = null
                            }, l.ontimeout = function() {
                                let t = e.timeout ? "timeout of " + e.timeout + "ms exceeded" : "timeout exceeded",
                                    n = e.transitional || ee;
                                e.timeoutErrorMessage && (t = e.timeoutErrorMessage), r(new j(t, n.clarifyTimeoutError ? j.ETIMEDOUT : j.ECONNABORTED, e, l)), l = null
                            }, ea.hasStandardBrowserEnv && (d && H.isFunction(d) && (d = d(e)), d || !1 !== d && eP(u))) {
                            let t = e.xsrfHeaderName && e.xsrfCookieName && eS.read(e.xsrfCookieName);
                            t && a.set(e.xsrfHeaderName, t)
                        }
                        void 0 === i && a.setContentType(null), "setRequestHeader" in l && H.forEach(a.toJSON(), function(e, t) {
                            l.setRequestHeader(t, e)
                        }), H.isUndefined(e.withCredentials) || (l.withCredentials = !!e.withCredentials), s && "json" !== s && (l.responseType = e.responseType), "function" == typeof e.onDownloadProgress && l.addEventListener("progress", e_(e.onDownloadProgress, !0)), "function" == typeof e.onUploadProgress && l.upload && l.upload.addEventListener("progress", e_(e.onUploadProgress)), (e.cancelToken || e.signal) && (n = t => {
                            l && (r(!t || t.type ? new eb(null, e, l) : t), l.abort(), l = null)
                        }, e.cancelToken && e.cancelToken.subscribe(n), e.signal && (e.signal.aborted ? n() : e.signal.addEventListener("abort", n)));
                        let m = function(e) {
                            let t = /^([-+\w]{1,25})(:?\/\/|:)/.exec(e);
                            return t && t[1] || ""
                        }(u);
                        if (m && -1 === ea.protocols.indexOf(m)) {
                            r(new j("Unsupported protocol " + m + ":", j.ERR_BAD_REQUEST, e));
                            return
                        }
                        l.send(i || null)
                    })
                }
            };
            H.forEach(eB, (e, t) => {
                if (e) {
                    try {
                        Object.defineProperty(e, "name", {
                            value: t
                        })
                    } catch (e) {}
                    Object.defineProperty(e, "adapterName", {
                        value: t
                    })
                }
            });
            let eO = e => `- ${e}`,
                eR = e => H.isFunction(e) || null === e || !1 === e;
            var eA = {
                getAdapter: e => {
                    let t, r;
                    let {
                        length: n
                    } = e = H.isArray(e) ? e : [e], o = {};
                    for (let i = 0; i < n; i++) {
                        let n;
                        if (r = t = e[i], !eR(t) && void 0 === (r = eB[(n = String(t)).toLowerCase()])) throw new j(`Unknown adapter '${n}'`);
                        if (r) break;
                        o[n || "#" + i] = r
                    }
                    if (!r) {
                        let e = Object.entries(o).map(([e, t]) => `adapter ${e} ` + (!1 === t ? "is not supported by the environment" : "is not available in the build"));
                        throw new j("There is no suitable adapter to dispatch the request " + (n ? e.length > 1 ? "since :\n" + e.map(eO).join("\n") : " " + eO(e[0]) : "as no adapter specified"), "ERR_NOT_SUPPORT")
                    }
                    return r
                },
                adapters: eB
            };

            function eI(e) {
                if (e.cancelToken && e.cancelToken.throwIfRequested(), e.signal && e.signal.aborted) throw new eb(null, e)
            }

            function ew(e) {
                return eI(e), e.headers = ey.from(e.headers), e.data = eh.call(e, e.transformRequest), -1 !== ["post", "put", "patch"].indexOf(e.method) && e.headers.setContentType("application/x-www-form-urlencoded", !1), eA.getAdapter(e.adapter || ed.adapter)(e).then(function(t) {
                    return eI(e), t.data = eh.call(e, e.transformResponse, t), t.headers = ey.from(t.headers), t
                }, function(t) {
                    return !ev(t) && (eI(e), t && t.response && (t.response.data = eh.call(e, e.transformResponse, t.response), t.response.headers = ey.from(t.response.headers))), Promise.reject(t)
                })
            }
            let eT = e => e instanceof ey ? e.toJSON() : e;

            function eN(e, t) {
                t = t || {};
                let r = {};

                function n(e, t, r) {
                    return H.isPlainObject(e) && H.isPlainObject(t) ? H.merge.call({
                        caseless: r
                    }, e, t) : H.isPlainObject(t) ? H.merge({}, t) : H.isArray(t) ? t.slice() : t
                }

                function o(e, t, r) {
                    return H.isUndefined(t) ? H.isUndefined(e) ? void 0 : n(void 0, e, r) : n(e, t, r)
                }

                function i(e, t) {
                    if (!H.isUndefined(t)) return n(void 0, t)
                }

                function a(e, t) {
                    return H.isUndefined(t) ? H.isUndefined(e) ? void 0 : n(void 0, e) : n(void 0, t)
                }

                function s(r, o, i) {
                    return i in t ? n(r, o) : i in e ? n(void 0, r) : void 0
                }
                let d = {
                    url: i,
                    method: i,
                    data: i,
                    baseURL: a,
                    transformRequest: a,
                    transformResponse: a,
                    paramsSerializer: a,
                    timeout: a,
                    timeoutMessage: a,
                    withCredentials: a,
                    withXSRFToken: a,
                    adapter: a,
                    responseType: a,
                    xsrfCookieName: a,
                    xsrfHeaderName: a,
                    onUploadProgress: a,
                    onDownloadProgress: a,
                    decompress: a,
                    maxContentLength: a,
                    maxBodyLength: a,
                    beforeRedirect: a,
                    transport: a,
                    httpAgent: a,
                    httpsAgent: a,
                    cancelToken: a,
                    socketPath: a,
                    responseEncoding: a,
                    validateStatus: s,
                    headers: (e, t) => o(eT(e), eT(t), !0)
                };
                return H.forEach(Object.keys(Object.assign({}, e, t)), function(n) {
                    let i = d[n] || o,
                        a = i(e[n], t[n], n);
                    H.isUndefined(a) && i !== s || (r[n] = a)
                }), r
            }
            let eC = "1.6.5",
                eE = {};
            ["object", "boolean", "number", "function", "string", "symbol"].forEach((e, t) => {
                eE[e] = function(r) {
                    return typeof r === e || "a" + (t < 1 ? "n " : " ") + e
                }
            });
            let ex = {};
            eE.transitional = function(e, t, r) {
                function n(e, t) {
                    return "[Axios v" + eC + "] Transitional option '" + e + "'" + t + (r ? ". " + r : "")
                }
                return (r, o, i) => {
                    if (!1 === e) throw new j(n(o, " has been removed" + (t ? " in " + t : "")), j.ERR_DEPRECATED);
                    return t && !ex[o] && (ex[o] = !0, console.warn(n(o, " has been deprecated since v" + t + " and will be removed in the near future"))), !e || e(r, o, i)
                }
            };
            var eU = {
                assertOptions: function(e, t, r) {
                    if ("object" != typeof e) throw new j("options must be an object", j.ERR_BAD_OPTION_VALUE);
                    let n = Object.keys(e),
                        o = n.length;
                    for (; o-- > 0;) {
                        let i = n[o],
                            a = t[i];
                        if (a) {
                            let t = e[i],
                                r = void 0 === t || a(t, i, e);
                            if (!0 !== r) throw new j("option " + i + " must be " + r, j.ERR_BAD_OPTION_VALUE);
                            continue
                        }
                        if (!0 !== r) throw new j("Unknown option " + i, j.ERR_BAD_OPTION)
                    }
                },
                validators: eE
            };
            let eD = eU.validators;
            class eM {
                constructor(e) {
                    this.defaults = e, this.interceptors = {
                        request: new X,
                        response: new X
                    }
                }
                request(e, t) {
                    let r, n;
                    "string" == typeof e ? (t = t || {}).url = e : t = e || {};
                    let {
                        transitional: o,
                        paramsSerializer: i,
                        headers: a
                    } = t = eN(this.defaults, t);
                    void 0 !== o && eU.assertOptions(o, {
                        silentJSONParsing: eD.transitional(eD.boolean),
                        forcedJSONParsing: eD.transitional(eD.boolean),
                        clarifyTimeoutError: eD.transitional(eD.boolean)
                    }, !1), null != i && (H.isFunction(i) ? t.paramsSerializer = {
                        serialize: i
                    } : eU.assertOptions(i, {
                        encode: eD.function,
                        serialize: eD.function
                    }, !0)), t.method = (t.method || this.defaults.method || "get").toLowerCase();
                    let s = a && H.merge(a.common, a[t.method]);
                    a && H.forEach(["delete", "get", "head", "post", "put", "patch", "common"], e => {
                        delete a[e]
                    }), t.headers = ey.concat(s, a);
                    let d = [],
                        c = !0;
                    this.interceptors.request.forEach(function(e) {
                        ("function" != typeof e.runWhen || !1 !== e.runWhen(t)) && (c = c && e.synchronous, d.unshift(e.fulfilled, e.rejected))
                    });
                    let l = [];
                    this.interceptors.response.forEach(function(e) {
                        l.push(e.fulfilled, e.rejected)
                    });
                    let u = 0;
                    if (!c) {
                        let e = [ew.bind(this), void 0];
                        for (e.unshift.apply(e, d), e.push.apply(e, l), n = e.length, r = Promise.resolve(t); u < n;) r = r.then(e[u++], e[u++]);
                        return r
                    }
                    n = d.length;
                    let p = t;
                    for (u = 0; u < n;) {
                        let e = d[u++],
                            t = d[u++];
                        try {
                            p = e(p)
                        } catch (e) {
                            t.call(this, e);
                            break
                        }
                    }
                    try {
                        r = ew.call(this, p)
                    } catch (e) {
                        return Promise.reject(e)
                    }
                    for (u = 0, n = l.length; u < n;) r = r.then(l[u++], l[u++]);
                    return r
                }
                getUri(e) {
                    return Z(ek((e = eN(this.defaults, e)).baseURL, e.url), e.params, e.paramsSerializer)
                }
            }
            H.forEach(["delete", "get", "head", "options"], function(e) {
                eM.prototype[e] = function(t, r) {
                    return this.request(eN(r || {}, {
                        method: e,
                        url: t,
                        data: (r || {}).data
                    }))
                }
            }), H.forEach(["post", "put", "patch"], function(e) {
                function t(t) {
                    return function(r, n, o) {
                        return this.request(eN(o || {}, {
                            method: e,
                            headers: t ? {
                                "Content-Type": "multipart/form-data"
                            } : {},
                            url: r,
                            data: n
                        }))
                    }
                }
                eM.prototype[e] = t(), eM.prototype[e + "Form"] = t(!0)
            });
            class eJ {
                constructor(e) {
                    let t;
                    if ("function" != typeof e) throw TypeError("executor must be a function.");
                    this.promise = new Promise(function(e) {
                        t = e
                    });
                    let r = this;
                    this.promise.then(e => {
                        if (!r._listeners) return;
                        let t = r._listeners.length;
                        for (; t-- > 0;) r._listeners[t](e);
                        r._listeners = null
                    }), this.promise.then = e => {
                        let t;
                        let n = new Promise(e => {
                            r.subscribe(e), t = e
                        }).then(e);
                        return n.cancel = function() {
                            r.unsubscribe(t)
                        }, n
                    }, e(function(e, n, o) {
                        r.reason || (r.reason = new eb(e, n, o), t(r.reason))
                    })
                }
                throwIfRequested() {
                    if (this.reason) throw this.reason
                }
                subscribe(e) {
                    if (this.reason) {
                        e(this.reason);
                        return
                    }
                    this._listeners ? this._listeners.push(e) : this._listeners = [e]
                }
                unsubscribe(e) {
                    if (!this._listeners) return;
                    let t = this._listeners.indexOf(e); - 1 !== t && this._listeners.splice(t, 1)
                }
                static source() {
                    let e;
                    return {
                        token: new eJ(function(t) {
                            e = t
                        }),
                        cancel: e
                    }
                }
            }
            let eH = {
                Continue: 100,
                SwitchingProtocols: 101,
                Processing: 102,
                EarlyHints: 103,
                Ok: 200,
                Created: 201,
                Accepted: 202,
                NonAuthoritativeInformation: 203,
                NoContent: 204,
                ResetContent: 205,
                PartialContent: 206,
                MultiStatus: 207,
                AlreadyReported: 208,
                ImUsed: 226,
                MultipleChoices: 300,
                MovedPermanently: 301,
                Found: 302,
                SeeOther: 303,
                NotModified: 304,
                UseProxy: 305,
                Unused: 306,
                TemporaryRedirect: 307,
                PermanentRedirect: 308,
                BadRequest: 400,
                Unauthorized: 401,
                PaymentRequired: 402,
                Forbidden: 403,
                NotFound: 404,
                MethodNotAllowed: 405,
                NotAcceptable: 406,
                ProxyAuthenticationRequired: 407,
                RequestTimeout: 408,
                Conflict: 409,
                Gone: 410,
                LengthRequired: 411,
                PreconditionFailed: 412,
                PayloadTooLarge: 413,
                UriTooLong: 414,
                UnsupportedMediaType: 415,
                RangeNotSatisfiable: 416,
                ExpectationFailed: 417,
                ImATeapot: 418,
                MisdirectedRequest: 421,
                UnprocessableEntity: 422,
                Locked: 423,
                FailedDependency: 424,
                TooEarly: 425,
                UpgradeRequired: 426,
                PreconditionRequired: 428,
                TooManyRequests: 429,
                RequestHeaderFieldsTooLarge: 431,
                UnavailableForLegalReasons: 451,
                InternalServerError: 500,
                NotImplemented: 501,
                BadGateway: 502,
                ServiceUnavailable: 503,
                GatewayTimeout: 504,
                HttpVersionNotSupported: 505,
                VariantAlsoNegotiates: 506,
                InsufficientStorage: 507,
                LoopDetected: 508,
                NotExtended: 510,
                NetworkAuthenticationRequired: 511
            };
            Object.entries(eH).forEach(([e, t]) => {
                eH[t] = e
            });
            let ej = function e(t) {
                let r = new eM(t),
                    n = s(eM.prototype.request, r);
                return H.extend(n, eM.prototype, r, {
                    allOwnKeys: !0
                }), H.extend(n, r, null, {
                    allOwnKeys: !0
                }), n.create = function(r) {
                    return e(eN(t, r))
                }, n
            }(ed);
            ej.Axios = eM, ej.CanceledError = eb, ej.CancelToken = eJ, ej.isCancel = ev, ej.VERSION = eC, ej.toFormData = L, ej.AxiosError = j, ej.Cancel = ej.CanceledError, ej.all = function(e) {
                return Promise.all(e)
            }, ej.spread = function(e) {
                return function(t) {
                    return e.apply(null, t)
                }
            }, ej.isAxiosError = function(e) {
                return H.isObject(e) && !0 === e.isAxiosError
            }, ej.mergeConfig = eN, ej.AxiosHeaders = ey, ej.formToJSON = e => es(H.isHTMLForm(e) ? new FormData(e) : e), ej.getAdapter = eA.getAdapter, ej.HttpStatusCode = eH, ej.default = ej, e.exports = ej
        },
        40607: function(e, t, r) {
            "use strict";
            r.d(t, {
                e: function() {
                    return d
                }
            });
            var n = r(6789),
                o = r(25432),
                i = r(16554),
                a = r(16914),
                s = r(85893),
                d = (0, i.G)(function(e, t) {
                    let {
                        className: r,
                        ...i
                    } = e, d = (0, n.v)();
                    return (0, s.jsx)(a.m.div, {
                        ref: t,
                        className: (0, o.cx)("chakra-card__body", r),
                        __css: d.body,
                        ...i
                    })
                })
        },
        6789: function(e, t, r) {
            "use strict";
            r.d(t, {
                Y: function() {
                    return n
                },
                v: function() {
                    return o
                }
            });
            var [n, o] = (0, r(85607).eC)("Card")
        },
        13990: function(e, t, r) {
            "use strict";
            r.d(t, {
                Z: function() {
                    return l
                }
            });
            var n = r(6789),
                o = r(25432),
                i = r(16554),
                a = r(33179),
                s = r(77030),
                d = r(16914),
                c = r(85893),
                l = (0, i.G)(function(e, t) {
                    let {
                        className: r,
                        children: i,
                        direction: l = "column",
                        justify: u,
                        align: p,
                        ...m
                    } = (0, a.Lr)(e), g = (0, s.jC)("Card", e);
                    return (0, c.jsx)(d.m.div, {
                        ref: t,
                        className: (0, o.cx)("chakra-card", r),
                        __css: {
                            display: "flex",
                            flexDirection: l,
                            justifyContent: u,
                            alignItems: p,
                            position: "relative",
                            minWidth: 0,
                            wordWrap: "break-word",
                            ...g.container
                        },
                        ...m,
                        children: (0, c.jsx)(n.Y, {
                            value: g,
                            children: i
                        })
                    })
                })
        },
        28912: function(e, t, r) {
            "use strict";
            r.d(t, {
                K: function() {
                    return a
                },
                Y: function() {
                    return i
                }
            });
            var n = r(85970),
                o = r(25432);

            function i(e) {
                let {
                    isDisabled: t,
                    isInvalid: r,
                    isReadOnly: n,
                    isRequired: i,
                    ...s
                } = a(e);
                return { ...s,
                    disabled: t,
                    readOnly: n,
                    required: i,
                    "aria-invalid": (0, o.Qm)(r),
                    "aria-required": (0, o.Qm)(i),
                    "aria-readonly": (0, o.Qm)(n)
                }
            }

            function a(e) {
                var t, r, i;
                let a = (0, n.NJ)(),
                    {
                        id: s,
                        disabled: d,
                        readOnly: c,
                        required: l,
                        isRequired: u,
                        isInvalid: p,
                        isReadOnly: m,
                        isDisabled: g,
                        onFocus: f,
                        onBlur: y,
                        ...h
                    } = e,
                    v = e["aria-describedby"] ? [e["aria-describedby"]] : [];
                return (null == a ? void 0 : a.hasFeedbackText) && (null == a ? void 0 : a.isInvalid) && v.push(a.feedbackId), (null == a ? void 0 : a.hasHelpText) && v.push(a.helpTextId), { ...h,
                    "aria-describedby": v.join(" ") || void 0,
                    id: null != s ? s : null == a ? void 0 : a.id,
                    isDisabled: null != (t = null != d ? d : g) ? t : null == a ? void 0 : a.isDisabled,
                    isReadOnly: null != (r = null != c ? c : m) ? r : null == a ? void 0 : a.isReadOnly,
                    isRequired: null != (i = null != l ? l : u) ? i : null == a ? void 0 : a.isRequired,
                    isInvalid: null != p ? p : null == a ? void 0 : a.isInvalid,
                    onFocus: (0, o.v0)(null == a ? void 0 : a.onFocus, f),
                    onBlur: (0, o.v0)(null == a ? void 0 : a.onBlur, y)
                }
            }
        },
        85970: function(e, t, r) {
            "use strict";
            r.d(t, {
                NI: function() {
                    return y
                },
                NJ: function() {
                    return f
                }
            });
            var n = r(55227),
                o = r(81103),
                i = r(16554),
                a = r(77030),
                s = r(33179),
                d = r(16914),
                c = r(25432),
                l = r(67294),
                u = r(85893),
                [p, m] = (0, n.k)({
                    name: "FormControlStylesContext",
                    errorMessage: "useFormControlStyles returned is 'undefined'. Seems you forgot to wrap the components in \"<FormControl />\" "
                }),
                [g, f] = (0, n.k)({
                    strict: !1,
                    name: "FormControlContext"
                }),
                y = (0, i.G)(function(e, t) {
                    let r = (0, a.jC)("Form", e),
                        {
                            getRootProps: n,
                            htmlProps: i,
                            ...m
                        } = function(e) {
                            let {
                                id: t,
                                isRequired: r,
                                isInvalid: n,
                                isDisabled: i,
                                isReadOnly: a,
                                ...s
                            } = e, d = (0, l.useId)(), u = t || `field-${d}`, p = `${u}-label`, m = `${u}-feedback`, g = `${u}-helptext`, [f, y] = (0, l.useState)(!1), [h, v] = (0, l.useState)(!1), [b, S] = (0, l.useState)(!1), k = (0, l.useCallback)((e = {}, t = null) => ({
                                id: g,
                                ...e,
                                ref: (0, o.lq)(t, e => {
                                    e && v(!0)
                                })
                            }), [g]), P = (0, l.useCallback)((e = {}, t = null) => ({ ...e,
                                ref: t,
                                "data-focus": (0, c.PB)(b),
                                "data-disabled": (0, c.PB)(i),
                                "data-invalid": (0, c.PB)(n),
                                "data-readonly": (0, c.PB)(a),
                                id: void 0 !== e.id ? e.id : p,
                                htmlFor: void 0 !== e.htmlFor ? e.htmlFor : u
                            }), [u, i, b, n, a, p]), _ = (0, l.useCallback)((e = {}, t = null) => ({
                                id: m,
                                ...e,
                                ref: (0, o.lq)(t, e => {
                                    e && y(!0)
                                }),
                                "aria-live": "polite"
                            }), [m]), B = (0, l.useCallback)((e = {}, t = null) => ({ ...e,
                                ...s,
                                ref: t,
                                role: "group",
                                "data-focus": (0, c.PB)(b),
                                "data-disabled": (0, c.PB)(i),
                                "data-invalid": (0, c.PB)(n),
                                "data-readonly": (0, c.PB)(a)
                            }), [s, i, b, n, a]);
                            return {
                                isRequired: !!r,
                                isInvalid: !!n,
                                isReadOnly: !!a,
                                isDisabled: !!i,
                                isFocused: !!b,
                                onFocus: () => S(!0),
                                onBlur: () => S(!1),
                                hasFeedbackText: f,
                                setHasFeedbackText: y,
                                hasHelpText: h,
                                setHasHelpText: v,
                                id: u,
                                labelId: p,
                                feedbackId: m,
                                helpTextId: g,
                                htmlProps: s,
                                getHelpTextProps: k,
                                getErrorMessageProps: _,
                                getRootProps: B,
                                getLabelProps: P,
                                getRequiredIndicatorProps: (0, l.useCallback)((e = {}, t = null) => ({ ...e,
                                    ref: t,
                                    role: "presentation",
                                    "aria-hidden": !0,
                                    children: e.children || "*"
                                }), [])
                            }
                        }((0, s.Lr)(e)),
                        f = (0, c.cx)("chakra-form-control", e.className);
                    return (0, u.jsx)(g, {
                        value: m,
                        children: (0, u.jsx)(p, {
                            value: r,
                            children: (0, u.jsx)(d.m.div, { ...n({}, t),
                                className: f,
                                __css: r.container
                            })
                        })
                    })
                });
            y.displayName = "FormControl", (0, i.G)(function(e, t) {
                let r = f(),
                    n = m(),
                    o = (0, c.cx)("chakra-form__helper-text", e.className);
                return (0, u.jsx)(d.m.div, { ...null == r ? void 0 : r.getHelpTextProps(e, t),
                    __css: n.helperText,
                    className: o
                })
            }).displayName = "FormHelperText"
        },
        33090: function(e, t, r) {
            "use strict";
            r.d(t, {
                I: function() {
                    return l
                }
            });
            var n = r(28912),
                o = r(16554),
                i = r(77030),
                a = r(33179),
                s = r(16914),
                d = r(25432),
                c = r(85893),
                l = (0, o.G)(function(e, t) {
                    let {
                        htmlSize: r,
                        ...o
                    } = e, l = (0, i.jC)("Input", o), u = (0, a.Lr)(o), p = (0, n.Y)(u), m = (0, d.cx)("chakra-input", e.className);
                    return (0, c.jsx)(s.m.input, {
                        size: r,
                        ...p,
                        __css: l.field,
                        ref: t,
                        className: m
                    })
                });
            l.displayName = "Input", l.id = "Input"
        },
        79078: function(e, t, r) {
            "use strict";
            r.d(t, {
                r: function() {
                    return a
                }
            });
            var n = r(16554),
                o = r(16914),
                i = r(85893),
                a = (0, n.G)(function(e, t) {
                    let {
                        templateAreas: r,
                        gap: n,
                        rowGap: a,
                        columnGap: s,
                        column: d,
                        row: c,
                        autoFlow: l,
                        autoRows: u,
                        templateRows: p,
                        autoColumns: m,
                        templateColumns: g,
                        ...f
                    } = e;
                    return (0, i.jsx)(o.m.div, {
                        ref: t,
                        __css: {
                            display: "grid",
                            gridTemplateAreas: r,
                            gridGap: n,
                            gridRowGap: a,
                            gridColumnGap: s,
                            gridAutoColumns: m,
                            gridColumn: d,
                            gridRow: c,
                            gridAutoFlow: l,
                            gridAutoRows: u,
                            gridTemplateRows: p,
                            gridTemplateColumns: g
                        },
                        ...f
                    })
                });
            a.displayName = "Grid"
        }
    }
]);